<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>网络编程部分汇总 | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="个人是比较喜欢研究网络问题的, 最初可能是为了玩更多高大上配置的服务器, 之后就是为了弄清楚编程中遇到的问题以及其原因.">
<meta name="keywords" content="网络">
<meta property="og:type" content="article">
<meta property="og:title" content="网络编程部分汇总">
<meta property="og:url" content="www.merlinblog.site/2017/10/13/network-base.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="个人是比较喜欢研究网络问题的, 最初可能是为了玩更多高大上配置的服务器, 之后就是为了弄清楚编程中遇到的问题以及其原因.">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/net.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-7.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-in.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-in1.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-linklayer.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-linklayer3.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-sub.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/net-work-route.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/ipheader.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-arp.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-nat.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-napt.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-dns.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/network-linklayer1.png">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/net-work-udp-mtu.png">
<meta property="og:updated_time" content="2017-10-15T02:53:50.168Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="网络编程部分汇总">
<meta name="twitter:description" content="个人是比较喜欢研究网络问题的, 最初可能是为了玩更多高大上配置的服务器, 之后就是为了弄清楚编程中遇到的问题以及其原因.">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/net.jpg">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                主页
            </a>
            
            <a class="nav-item" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item" href="/works">
                开源作品
            </a>
            
            <a class="nav-item" href="/about">
                关于博主
            </a>
            
            <a class="nav-item" href="/atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                主页
            </a>
            
            <a class="nav-item flex-1" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="/works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="/about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="/atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="/css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#分层模型"><span class="toc-number">1.</span> <span class="toc-text">分层模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#OSI模型"><span class="toc-number">1.1.</span> <span class="toc-text">OSI模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP四层模型"><span class="toc-number">1.2.</span> <span class="toc-text">TCP/IP四层模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#各层要点-重要"><span class="toc-number">1.3.</span> <span class="toc-text">各层要点(重要)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他问题"><span class="toc-number">2.</span> <span class="toc-text">其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MTU-相关问题"><span class="toc-number">2.1.</span> <span class="toc-text">MTU 相关问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MTU-路径发现"><span class="toc-number">2.1.1.</span> <span class="toc-text">MTU 路径发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MSS"><span class="toc-number">2.1.2.</span> <span class="toc-text">MSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#大小端问题"><span class="toc-number">2.2.</span> <span class="toc-text">大小端问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Ping原理"><span class="toc-number">2.3.</span> <span class="toc-text">Ping原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Traceroute原理"><span class="toc-number">2.4.</span> <span class="toc-text">Traceroute原理</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考："><span class="toc-number">3.</span> <span class="toc-text">参考：</span></a></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>网络编程部分汇总</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-10-13</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/网络/">网络</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <blockquote>
<p>本文主要记载一些网络基础知识, 但这些知识不是纯碎的理论研究, 而是为了后面<code>传输层</code>/<code>应用层</code>网络编程服务的.</p>
<blockquote>
<p>2017年10月更新了本文: <code>nagle算法</code> + <code>delayed ack算法</code> + <code>重新整理排版</code></p>
</blockquote>
</blockquote>
<p><strong>该文是我写的网络编程的第一篇文章</strong>, 改版了, 成为<code>最后一篇</code>, <strong>作为总结</strong>.</p>
<p>大致上已经整理了以下内容:(链接都是我站内的链接)</p>
<ul>
<li>网络理论基础部分 (本文)</li>
<li>基础套接字编程, <a href="http://www.merlinblog.site/2017/06/11/basic-socket-model.html">链接</a></li>
<li>本地套接字, <a href="http://www.merlinblog.site/2017/06/20/ipc-unix-domain-socket.html">链接</a></li>
<li>TCP 专题, <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">链接</a>, 以及 <a href="http://www.merlinblog.site/2017/06/19/sub-and-adhere-package.html">流解析(粘包问题)</a></li>
<li>UDP 专题, <a href="http://www.merlinblog.site/2017/06/19/udp-model.html">链接</a></li>
<li>IO 模型, <a href="http://www.merlinblog.site/2017/06/04/network-io.html">链接</a></li>
<li>Epoll专题, <a href="http://www.merlinblog.site/2017/06/13/why-not-epoll.html">链接</a></li>
<li>服务端模型演变, <a href="http://www.merlinblog.site/2017/06/19/server-side-model-again.html">链接</a></li>
<li>proto buffer 库, <a href="http://www.merlinblog.site/2017/08/21/protocol-buffer.html">链接</a></li>
<li>thrift 库, <a href="http://www.merlinblog.site/2017/08/22/thrift.html">链接</a></li>
<li>libevent 库, <a href="http://www.merlinblog.site/2017/07/29/libevent.html">链接</a></li>
<li>asio, <a href="http://www.merlinblog.site/2017/08/11/asio.html">链接</a></li>
<li>muduo, 陈硕大神的库, 值得研究学习, <a href="http://www.merlinblog.site/2017/07/29/deep-in-muduo-framework.html">链接</a></li>
<li>网络常用工具, nc, dd, tcpdump, ping, traceroute等, <a href="http://www.merlinblog.site/2017/08/23/net-work-tools.html">链接</a></li>
</ul>
<p>大部分知识来自于书籍(unp 1, unix高级编程, 以及 linux系统编程上下册), 腾讯后端的同学的交流, 我的一些个人思考, 最后靠谱网友的博客.</p>
<blockquote>
<p>这些整理记录了我的成长(完善知识体系), 也希望为看到的人带来帮助, 至少节约一些时间(<code>于我个人而言, 写作是一种乐趣</code>)</p>
</blockquote>
<p>补充上层协议: (2017/9月整理)</p>
<ul>
<li>http协议, <a href="http://www.merlinblog.site/2017/09/07/network-base-http.html">链接</a></li>
<li>https协议, <a href="http://www.merlinblog.site/2017/09/08/network-base-https.html">链接</a></li>
</ul>
<a id="more"></a>
<hr>
<p><img src="http://omotkhw3y.bkt.clouddn.com/net.jpg" alt="post-cover"></p>
<p><strong>由于网络理论比较多, 我只捡去编程或者面试中可能涉及的内容: 以 TCP/IP 协议簇为主，也会有应用层和数据链路层的简单介绍</strong></p>
<p>TCP/UDP/HTTP</p>
<h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><p>这里有两种模型, </p>
<ul>
<li>学术界的OSI模型</li>
<li>工业&amp;商业界的TCP/IP四层模型</li>
</ul>
<p>大致对比如下:</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/network-7.png" alt=""></p>
<p>协议本身并没有太多分别, 只是大家的认可度不一样罢了,<br>试想你自己发明一套, 比如IP_MY协议, 大家都不遵守, 这种约定有何意义?<br>所以即便是都用于互联网, TCP/IP四层模型协议更被开发者所接受, OSI 7层模型只是带过.</p>
<h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>OSI 模型中，网络被分为七层，由底层向高层依次是：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p>
<p><strong>物理层</strong> 处于 OSI 七层模型的最底端，它的主要任务是将比特流与电子信号进行转换。<br><strong>数据链路层</strong> 处于 OSI 七层模型的第二层，它定义了通过通信介质相互连接的设备之间，数据传输的规范。<br><strong>网络层</strong> 处于OSI参考模型的第三层网络层的主要作用是实现终端节点间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)<br><strong>传输层</strong> 处于 OSI 七层模型的第四层, 主要作用是实现应用程序之间的通信。<br><strong>会话层</strong> 处于 OSI 七层模型的第五层, 利用传输层提供的服务，使应用建立和维持会话，并能使会话获得同步。<br><strong>表示层</strong> 处于 OSI 七层模型的第六层, 表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。(字符集数据格式等处理)<br><strong>应用层</strong> 处于 OSI 七层模型的第七层, 这是最高层, 也是网络应用程序直接使用的协议, 它利用下层协议完成网络通信, 根据用途不同, 种类也不一样.</p>
<h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>为了实践编码方便, 理所应当采用了简化的四层模型, 即TCP/IP四层模型, 业界俗称为TCP/IP协议族.</p>
<p>下面也以规模性作为重点记录.</p>
<h2 id="各层要点-重要"><a href="#各层要点-重要" class="headerlink" title="各层要点(重要)"></a>各层要点(重要)</h2><p>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-in.png" alt=""></p>
<p>TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。(以太网帧协议是头尾, 注意1500字节, 后面还会出现)</p>
<p>完整的以 <strong>HTTP</strong>为例子:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-in1.png" alt=""></p>
<p><strong>网络接口层</strong> :<br>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer.png" alt=""></p>
<p>主要作为围绕 MAC 地址展开:</p>
<ul>
<li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</li>
<li>透明传输: 零比特填充、转义字符。</li>
<li>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</li>
<li>纠错处理: (CRC):接收者检测错误,如果发现差错，丢弃该帧。</li>
</ul>
<p>个人觉得, 一般谈到 网络接口层, 主要是2个概念再反复说:</p>
<ul>
<li>MAC 地址<br>MAC 地址是被烧录到网卡 ROM 中的一串数字，长度为 48 比特，它在世界范围内唯一(不考虑虚拟机自定义 MAC 地址)。由于 MAC 地址的唯一性，它可以被用来区分不同的节点，一旦指定了 MAC 地址，就不可能出现不知道往哪个设备传输数据的情况。</li>
<li><p>交换机仔细原理(转发表)<br>交换机是一种在数据链路层工作的网络设备，它有多个端口，可以连接不同的设备。交换机根据每个帧中的目标 MAC 地址决定向哪个端口发送数据，此时它需要参考“转发表”<br>转发表并非手动设置，而是交换机自动学习得到的。当某个设备向交换机发送帧时，交换机将帧的源 MAC 地址和接口对应起来，作为一条记录添加到转发表中。</p>
<p>当然交换机还有其他作用, 就不多说了.</p>
</li>
</ul>
<p>交换机自学过程的原理(端口MAC联系过程):<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer3.png" alt=""></p>
<blockquote>
<p>关于分组交换, 通常我们只是在IP网络层才会去谈分组交换(1480); 传输层谈报文交换; 物理层谈电路交换.</p>
</blockquote>
<p>实际山, 从涉及MTU问题这里, 分组交换就已经涉及到了.<br>分组交换是指将较大的数据分割为若干个较小的数据，然后依次发送。使用分组交换的原因是不同的数据链路有各自的最大传输单元(MTU: Maximum Transmission Unit)。</p>
<p><code>MTU</code>, 根据<code>协议性质</code>&amp;<code>网络性质</code>&amp;<code>操作系统(内核协议栈)实现</code>等因素的不同而不同, 通常认为这也是 TCP/IP分节传输或者设置buffer的依据.<br>关于 MTU 争议很多, 具体可以见下面 <strong>MTU问题</strong>部分.</p>
<p>最后补充, 数据链路层协议工作在物理介质相互连接的端点之间, 范围有限.</p>
<hr>
<p><strong>网络层</strong><br>数据链路层的作用在于实现同一种数据链路下的包传递，而网络层则可以实现跨越不同数据链路的包传递。(也就是说, 从这一层才涉及跨网络)</p>
<p>这一层内容比较多, 但是主要谈IP协议相关, 其他顺带谈一下.</p>
<p>IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议: TCP或UDP要做的事情(ICMP也起到了异常通知的作用)。</p>
<p><strong>IP协议</strong> : (主要说<code>ipv4</code>, 因为ipv6也就我们中国再说, 看看世界上其他国家, 根本不鸟的, 题外话)</p>
<ul>
<li>地址部分</li>
<li>路由部分</li>
<li>分包重组部分</li>
<li>ip协议头(首部)</li>
</ul>
<p>寻址部分:<br>IP地址是一种在网络层用于识别通信对端信息的地址。它有别于数据链路层中的MAC地址，后者用于标识同一链路下不同的计算机。<br>IP地址由32位正整数表示，为了直观的表示，我们把它分成4个部分，每个部分由8位整数组成，对应十进制的范围就是0-255。</p>
<p>比如<code>172.20.1.1</code>可以表示为：<code>10101100 00010100 00000001 00000001</code>。<br>转换规则很简单，就是分别把四个部分的十进制(0-255)与8位二进制数字进行转换。</p>
<p>IP地址由两部分组成：<code>网络标识</code>和<code>主机标识</code>。</p>
<ul>
<li>网络标识用于区分不同的网段，相同段内的主机必须拥有相同的网络表示，不同段内的主机不能拥有相同的网络标识</li>
<li>主机标识用于区分同一网段下不同的主机，它不能在同一网段内重复出现</li>
</ul>
<p>32位IP地址被分为两部分，<strong>到底前多少位是网络标识呢？</strong><br>一般有两种方法表示：<code>IP地址分类</code>、<code>子网掩码</code>。</p>
<p><strong>IP地址分类</strong> :<br>IP地址分为四个级别，分别为A类、B类、C类和D类。分类的依据是IP地址的前四位：</p>
<ul>
<li>A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个主机。</li>
<li>B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。</li>
<li>C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。</li>
<li>D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。</li>
</ul>
<p>简单记忆如下:<br>A类IP地址: 0.0.0.0~127.0.0.0<br>B类IP地址: 128.0.0.1~191.255.0.0<br>C类IP地址: 192.168.0.0~239.255.255.0</p>
<p>这类分类方法往往导致, 小网段不够, 大网段有余. 例如C类网段, 最多254台主机, 如果是255台怎么办? B类的上限是65534个, 明显浪费. 如果控制B类网址的上限数目? 因为B类网址, 说是以<code>10</code>开头, 前16位为网络号, 但是具体是多少真正在用就不一定了.</p>
<p>那么就<code>不对网络号规定位数?</code>, 但是这样就根本没有办法解析IP地址了, 因为不知道前多少位是网络号, 此时就演变出了<code>子网掩码</code>, 用子网掩码来解释子网占了多少位, 而剩余的主机号占了多少位.</p>
<p><strong>子网掩码</strong> :<br>IP地址分类的本质是区分网络标识和主机标识，另一种更加灵活、细粒度的区分方法是使用子网掩码。</p>
<p>它也是32位的, 只不过用其中 1 的数量表示子网, 即网络号的部分, 剩余的表示主机位.</p>
<p>子网掩码的方式, 涵盖并对应了 <code>IP</code>分类的方式, 但是又比<strong>规定死位数</strong>要灵活.</p>
<p>例如, B类网址, 即以10开头的网络号, 它本来网络号规定是16位, 可以容纳65534台, 现在通过子网掩码, 可以规定它的网络号是26位, 而不是规定死的16位, 可以容纳64台主机(出去主机号全0表示本子网, 全1表示广播外, 实际容纳62台)<br><img src="http://omotkhw3y.bkt.clouddn.com/network-sub.png" alt=""></p>
<p>但注意一下, 缺省情况下, 子网掩码和IP分类保持一致:<br>A类地址的缺省子网掩码为255.0.0.0,B类为255.255.0.0,C类为255.255.255.0。</p>
<p><strong>路由部分</strong></p>
<p>路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成。<br>路由器中保存着<code>路由控制表</code>(存储转发表)，它在路由控制表中查找目标IP地址对应的下一个路由器地址。下图描述了这一过程：<br><img src="http://omotkhw3y.bkt.clouddn.com/net-work-route.png" alt=""></p>
<p>由图中也可看出路由器连接着两个子网, 并且在路由表中进行范围或者最佳匹配.</p>
<p>路由控制表可以由管理员手动设置，称为静态路由控制，或者路由器可以和其他路由器互换信息比即使自动刷新路由表，这个信息交换的协议并没有在IP协议中定义，而是由一个叫做“路由协议”的协议管理。</p>
<p><strong>实际传输过程中, 数据包也会在路由器这里拆包并封包再转发, 因为要重新填写下一跳路由地址</strong></p>
<p>路由控制这有会有两个问题:</p>
<ul>
<li>转发成环问题(不存在相关的IP地址)<br>IP首部解决这个问题</li>
<li>分割与重组<br>IP受限于链路层的MTU, 过大的数据就要分组, 远端主机再重组(首部中的标志和偏移)</li>
</ul>
<p>分组和重组, 也会涉及 MTU, 请参考<code>其他部分</code>的<code>MTU路径发现</code>.</p>
<p>由于<code>环</code>和<code>分组</code>问题都依赖于<code>IP首部</code>结构, 下面就说说.</p>
<p><strong>IP首部</strong><br>即 ip协议头(20字节), 这里有很多设计讲究.<br><img src="http://omotkhw3y.bkt.clouddn.com/ipheader.png" alt=""></p>
<p>8位的TTL字段(解决环的问题, 不可能让你无限传下去)<br>这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p>
<p>其他部分介绍:(从上往下一层层看)</p>
<ul>
<li>总长度(Total Length)：表示IP首部与数据部分总的字节数，该段长16比特，所以IP包的最大长度为65535字节(2^16)。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。<br>(上层看不到下层的MTU限制)</li>
<li>16位标识（ID：Identification）：用于分片重组。属于同一个分片的帧的ID相同。但即使ID相同，如果目标地址、源地址、上层协议中有任何一个不同，都被认为不属于同一个分片。</li>
<li>标志（Flags）：由于分片重组，由3个比特构成。<br>第一个比特未使用，目前必须是0。<br>第二个比特表示是否进行分片，0表示可以分片，1表示不能分片。在路径MTU发现技术中就用到了这个位。<br>第三个比特表示在分片时，是否表示最后一个包。1表示不是最后一个包，0表示分配中最后一个包。<br>*片偏移（FO: Fragment Offset）：由13比特组成，表示被分片的段相对于原始数据的位置。它可以表示8192(2^13)个位置，单位为8字节，所以最大可以表示8 x 8192 = 65536字节的偏移量。</li>
<li>协议： 表示IP首部的下一个首部属于哪个协议。比如TCP协议的编号为6，UDP编号为17.</li>
<li>首部校验和：用于检查IP首部是否损坏</li>
<li>可选项：仅在试验或诊断时用，可以没有。如果有，需要配合填充（Padding）占满32比特。</li>
</ul>
<p><strong>ARP及RARP协议</strong> :<br>(非重点, 我以前电脑中过arp病毒, 所以印象深刻)<br>ARP (Address Resolution Protocol)是根据IP地址获取 MAC 地址的一种协议。(因为最终确定一台计算机的不是IP, 而是Mac地址, 硬件地址)<br>如果目标主机处在同一个数据链路上，那么可以直接得到目标主机的 MAC 地址，否则会得到下一条路由器的 MAC 地址。</p>
<p>ARP（地址解析）协议是一种解析协议，详细说明即: ARP 请求和 ARP 响应。<br>首先，源主机会通过广播发送一个 ARP 请求包：“我要与 IP 地址为 xxx 的主机通话，谁知道它的 MAC地址？”。<br>数据链路上的所有主机都会收到这条消息并检查自己的 IP 地址，如果与 ARP 请求包中的 IP 地址一致，主机就会发送 ARP 响应包：“我就是 IP 地址为 xxx 的主机，我的 MAC 地址是：xxxx”。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-arp.png" alt=""></p>
<p>但是反复查询效率很低, 也是不推荐的做法; 通常的做法是把获取到的 MAC 地址缓存一段时间。(一旦源主机向目标地址发送一个数据包，接下来继续发送多次的概率非常大，因此这种缓存非常容易命中)</p>
<p>当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个 IP-MAC 地址对应表缓存）。</p>
<p>如果查询的 IP－MAC 值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的 MAC 地址的ARP包传送给发送ARP广播的主机。而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p>
<p>当下一次发送 ARP 请求或超过一定时间后，缓存都会失效，这保证了即使 MAC 地址与 IP 地址的对应关系发生了变化，数据包依然能够被正确的发往目标地址。</p>
<p>RARP协议的工作与此相反，不做赘述。</p>
<blockquote>
<p>只用IP是不行的, 只用Mac是非常低效的.</p>
</blockquote>
<p>其中用意个人体会吧, arp和rarp协议有其存在的必要性.</p>
<p><strong>NAT 和 NAPT 技术</strong> :<br>NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。</p>
<p>在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。那不同网段中，IP 地址都是 192.168.1.1 的主机改如何通信呢？</p>
<p>下图描绘了 NAT 的工作原理：</p>
<p>局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 163.221.120.9 发送数据。NAT 路由器将数据包的源地址修改成自己的全局 IP 地址：202.244.174.37。同理，接收数据时，路由器把目标地址 202.244.174.37 翻译成内网地址：10.0.0.10</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/network-nat.png" alt=""><br>路由器只有一个对外的全局 IP 地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用 NAPT 技术，它和 NAT 从原理上类似，但它可以转换 TCP 和 UDP 端口号。</p>
<p>使用 NAPT 技术时，不同的内网 IP 被转换成同一个公共 IP 地址，也就是路由器对外显示的全局 IP 地址，但是被附加不同的端口号以示区分：</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/network-napt.png" alt=""><br>不管是 NAT 还是 NAPT，都需要路由器路由器内部维护一张自动生成的地址转换表。以 TCP 为例，建立 TCP 连接首次握手的 SYN 包发出时会生成这个表，关闭连接时会发出 FIN 包，收到这个包的应答时转换表被删除。</p>
<p><strong>ICMP协议</strong> :<br>这也是IP层的一个重要协议, 主要负责异常/错误通知.</p>
<p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。<br>其中一个重要的模块就是ICMP(网络控制报文)协议。</p>
<blockquote>
<p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。<br>给主机一个处理错误的机会，这也就是为什么说建立在 IP 层以上的协议是可能做到安全的原因。</p>
</blockquote>
<p>该协议有一个重要应用, <code>ping</code> 命令, 具体可以参考下面 <code>其他部分</code>.<br>哦, 还有一个TTL检测工具, <code>traceroute</code> 也需要借助它.</p>
<hr>
<p><strong>传输层</strong></p>
<p>这里已经不仅仅是理论了, 而且有大量的code实践, 可以单独参考我的其他文章:</p>
<ul>
<li>tcp: <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">how-about-tcp</a></li>
<li>udp: <a href="http://www.merlinblog.site/2017/06/19/udp-model.html">udp model</a></li>
</ul>
<hr>
<p><strong>应用层</strong></p>
<p>这里谈一些其他的协议, 比如常见的 HTTP, HTTPS, DNS等, 当然, 也有人专门花一本书的时间,去写一个应用协议, 呵呵呵.</p>
<p><strong>DNS</strong> : Domain Name System，域名解析系统<br>因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p>
<p>以解析域名： www.ietf.org为例：<br><img src="http://omotkhw3y.bkt.clouddn.com/network-dns.png" alt=""><br>根服务器其实并不知道 www.ietf.org 的 IP 地址，但是它知道 itef.org 域名服务器的地址，所以它把这条查询请求转发给 itef.org 域名服务器。DNS请求被逐层下发，直到找到对应的 IP 地址为止。</p>
<blockquote>
<p>DNS协议运行在UDP协议之上，使用端口号53</p>
</blockquote>
<p>应用层, 我接触的,最主要的还是 HTTP, HTTPS协议, 由于比较重要, 我还是单独成文了.</p>
<p><strong>HTTP</strong> :<br>详细可以参考: <a href="http://www.merlinblog.site/2017/09/07/network-base-http.html">HTTP相关</a></p>
<p><strong>HTTPS</strong> :<br>详细可以参考: <a href="http://www.merlinblog.site/2017/09/08/network-base-https.html">HTTPS相关</a></p>
<h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="MTU-相关问题"><a href="#MTU-相关问题" class="headerlink" title="MTU 相关问题"></a>MTU 相关问题</h2><p>其实这这个MTU指的是链路层的数据区, 并不包括链路层的首部和尾部的18个字节.<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer1.png" alt=""></p>
<p>上面已经说了</p>
<blockquote>
<p><code>MTU</code>, 根据<code>协议性质</code>&amp;<code>网络性质</code>&amp;<code>操作系统(内核协议栈)实现</code>等因素的不同而不同, 通常认为这也是 TCP/IP分节传输或者设置buffer的依据.</p>
</blockquote>
<p>也就是说, 这个东西(<code>链路层的MTU(最大传输单元)</code>)会和操作系统(Unix, Linux, windows), 和 TCP分节(MSL, max sgement length), 网络类型(以太网, ASDL)会扯上关系: </p>
<ul>
<li>如果只谈 以太网 最大传输单元, 那么就是 1500 字节</li>
<li>如果谈IP数据报的数据区长度, 最大为1480字节</li>
<li>如果说TCP packet 最大长度, 那么 window是, 1500-20-20=1460(减掉ip, tcp头部各20字节), linux/mac/unix则还要减去12字节 tcp time stamp, 即1448字节</li>
<li>如果说udp, UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节</li>
</ul>
<p>强调一下, 这里说的是<strong>最大</strong>, <code>最小为64字节</code> (以太网最大数据帧1500+14+4=1518字节, 头14字节, 尾CRC校验位4字节)<br>大于MTU, 这个时候发送方IP层就需要分片(fragmentation). 把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.</p>
<p>用于ping时, 一般就是1500-20-8 = 1472, ipv4中icmp协议头为8字节, 但是ipv6中可能是4也可能是8.</p>
<h3 id="MTU-路径发现"><a href="#MTU-路径发现" class="headerlink" title="MTU 路径发现"></a>MTU 路径发现</h3><p>但是 MTU 不是一成不变的, 它会根据网络的性质, 通信状态进行一些列的调整, 例如Internet上的标准MTU值为 576. 其实也有一部分原因是, IP一旦丢包整段都要舍弃, 所以分小包减少丢包的概率.</p>
<p>MTU路径发现, 就是解决办法:<br>主机会首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。<br>传输过程中的任何一个路由器都不用进行分片工作(但路由器有这个能力)。</p>
<blockquote>
<p>为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回给主机。<br>主机将ICMP通知中的MTU设置为当前MTU，根据整个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。</p>
</blockquote>
<p>还是以udp为例子:(1500-20-8=1472的理论值)<br><img src="http://omotkhw3y.bkt.clouddn.com/net-work-udp-mtu.png" alt=""></p>
<h3 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h3><p>TCP中谈论的更多的是, MSS (maximum segment size) 最大分节大小<br>一般为了避免分节, 也会进行相关的协商或者探测, 取网络的最小值.<br>撇开系统因素(比如linux/unix下可能会有tcp time stamp部分), 一般是:<br>ipv4 1500-20-20 = 1460 字节<br>ipv6 1500-20-40 = 1440 字节</p>
<h2 id="大小端问题"><a href="#大小端问题" class="headerlink" title="大小端问题"></a>大小端问题</h2><p>编写一个程序， 看一下主机字节序是<code>little-endian</code>还是<code>big-endian</code>.</p>
<p>下面给出一种简单的方案:</p>
<pre><code class="C++">#include &lt;stdio.h&gt;

int main()
{

    int a = 0x1122;
    char *b = (char*)&amp;a; //取低8位

    if(*b == 0x11){
        printf(&quot;BE\n&quot;);
    }else{
        printf(&quot;LE\n&quot;);
    }

    printf(&quot;%d\n&quot;, *b==0x22); //1

    return 0;
}
</code></pre>
<p>当然你用联合union也挺好：</p>
<pre><code class="C++">#include &lt;stdio.h&gt;

int main()
{
    typedef union {
        int num;
        char num_low8;
    } NUM;

    NUM number;
    number.num = 0x1122;
    if(number.num_low8 == 0x11){
        printf(&quot;BE\n&quot;);
    }else{
        printf(&quot;LE\n&quot;);
    }

    printf(&quot;%d\n&quot;, number.num_low8==0x22); //1

    return 0;
}
</code></pre>
<p>注意：操作系统读写内存都是从低地址到高地址。</p>
<blockquote>
<p>一般本地主机是小端，但是网络字节序就是大端了</p>
</blockquote>
<p>这个时候涉及到转换问题，一般是IP地址的转换(端口可能也需要)，有相应的函数htons()、ntohs()、htonl()、ntohl() ,<br>并且像protobuf库也有相关的API, asio库直接就封装好了, 什么都不用管.</p>
<h2 id="Ping原理"><a href="#Ping原理" class="headerlink" title="Ping原理"></a>Ping原理</h2><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p>
<p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站, 如果丢包研究就是网络问题, 如果其他连接不可达, 就会出现超时或者主机拒绝连接等信息。</p>
<p>它利用ICMP协议包来侦测另一个主机是否可达, 原理如下:</p>
<blockquote>
<p>用类型码为0的ICMP发请求, 收到请求的主机则用类型码为8的ICMP回应</p>
</blockquote>
<p>用于ping时, MTU一般是1500-20-8 = 1472, ipv4中icmp协议头为8字节, 但是ipv6中可能是4也可能是8.</p>
<h2 id="Traceroute原理"><a href="#Traceroute原理" class="headerlink" title="Traceroute原理"></a>Traceroute原理</h2><p>这个工具比较强大, 给的选项也比较多, 通常是来检查跳(hop)数.<br>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p>
<p>原理: (改变ttl数, 借助icmp反馈)</p>
<blockquote>
<p>它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。<br>主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。<br>如此往复直到到达目的主机</p>
</blockquote>
<p>这样，traceroute就拿到了所有的路由器IP.</p>
<hr>
<p>就写这么多吧.</p>
<h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol>
<li><a href="">《图解TCP/IP》</a></li>
<li><a href="http://www.cnblogs.com/hjslovewcl/archive/2011/07/18/2314316.html" target="_blank" rel="external">http://www.cnblogs.com/hjslovewcl/archive/2011/07/18/2314316.html</a></li>
<li><a href="http://www.choudan.net/2014/09/12/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4-%E4%B8%80.html" target="_blank" rel="external">http://www.choudan.net/2014/09/12/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4-%E4%B8%80.html</a></li>
<li><a href="https://juejin.im/post/598ba1d06fb9a03c4d6464ab" target="_blank" rel="external">https://juejin.im/post/598ba1d06fb9a03c4d6464ab</a></li>
<li><a href="https://www.zhihu.com/question/21064101" target="_blank" rel="external">https://www.zhihu.com/question/21064101</a></li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)                                                                                                  </p>
<p>Saturday, 11. March 2017 04:09PM </p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="/" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：网络编程部分汇总</span><br/>
	<span><b>本文链接</b>：www.merlinblog.site/2017/10/13/network-base.html</span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="/css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY SA 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>

