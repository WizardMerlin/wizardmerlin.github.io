<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>C++11 模板别名探究 | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="本文涉及到模板别名, 类型别名, 以及模板的模板参数问题">
<meta name="keywords" content="cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="C++11 模板别名探究">
<meta property="og:url" content="www.merlinblog.site/2017/05/18/template-alias-in-cpp.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="本文涉及到模板别名, 类型别名, 以及模板的模板参数问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/templates-alias.png">
<meta property="og:updated_time" content="2017-10-05T20:26:29.423Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++11 模板别名探究">
<meta name="twitter:description" content="本文涉及到模板别名, 类型别名, 以及模板的模板参数问题">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/templates-alias.png">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                主页
            </a>
            
            <a class="nav-item" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item" href="/works">
                开源作品
            </a>
            
            <a class="nav-item" href="/about">
                关于博主
            </a>
            
            <a class="nav-item" href="/atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                主页
            </a>
            
            <a class="nav-item flex-1" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="/works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="/about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="/atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="/css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#模板别名"><span class="toc-number">1.</span> <span class="toc-text">模板别名</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#模板出现在typedef中"><span class="toc-number">1.1.</span> <span class="toc-text">模板出现在typedef中</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#模板模板参数问题"><span class="toc-number">1.2.</span> <span class="toc-text">模板模板参数问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-number">1.3.</span> <span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点"><span class="toc-number">1.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#限制"><span class="toc-number">1.3.2.</span> <span class="toc-text">限制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#类型别名"><span class="toc-number">2.</span> <span class="toc-text">类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#默认模板参数"><span class="toc-number">3.</span> <span class="toc-text">默认模板参数</span></a></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>C++11 模板别名探究</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-05-18</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/cpp/">cpp</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <p>模板别名(template alias) 或者 template typedef, 以及 类型type alias</p>
<p>两者都是借助using关键字, 先花大力气理解<code>template typedef</code>, 之后再补充说下<code>type alias</code>以及默认模板参数问题</p>
<blockquote>
<p>可能会说一些元编程中比较晦涩的问题, 尽量说清楚</p>
</blockquote>
<p><img src="http://omotkhw3y.bkt.clouddn.com/templates-alias.png" alt="post-cover"></p>
<hr>
<h1 id="模板别名"><a href="#模板别名" class="headerlink" title="模板别名"></a>模板别名</h1><blockquote>
<p>这里面有些问题, 整的我一度有些奔溃; 因为涉及到模板, 一旦出问题, 调用深度大, 参数多也不好理解.</p>
<blockquote>
<p>比如模板模板参数问题, 比如说别名中还要使用模板类型问题</p>
</blockquote>
</blockquote>
<p>我尝试着说清楚, 一方面检验我的理解, 另外一方面说一些这里面的一些技巧或者已经可以舍弃了的C++03的技巧.</p>
<h2 id="模板出现在typedef中"><a href="#模板出现在typedef中" class="headerlink" title="模板出现在typedef中"></a>模板出现在typedef中</h2><p>就是模板参数和typedef混合了, 或者说,</p>
<blockquote>
<p>typedef的增强, 你可以在typedef的时候, 同时运用模板参数.</p>
</blockquote>
<p>重点其实是落在了<code>typedef</code>上, 加入模板参数的 typedef, <code>更加强大的typedef</code>.</p>
<p>C++03的时候, 我们是这么做的:</p>
<pre><code class="C++">typedef std::map&lt;std::string, int&gt; map_t;  
//...  
typedef std::map &lt; std::string, std::string &gt; map_str;
</code></pre>
<p>完全OK, 但是如果这样做:</p>
<pre><code class="C++">template &lt;typename T&gt;  
typedef std::map&lt;std::string, T&gt; map;  

map&lt;int&gt;  map_i;  
map&lt;std::string&gt;  map_str;
</code></pre>
<p>直接报错了, 在typedef的内容中, 使用模板参数, 03语法不支持, 所以<code>一般我们会借助模板类型定义, 函数模板或者类模板, 甚至 functor 模板</code><br>例如:</p>
<pre><code>template &lt;typename T&gt;  
struct alias_map  
{  
    typedef std::map&lt;std::string, T&gt; map;  
    //using map = std::map&lt;std::string, T&gt;; //具体参考下面的type alias
};  

alias_map&lt;int&gt;::map map_t;  //借助了 alias_map 类模板
alias_map&lt;int&gt;::map map_str;
</code></pre><p>也就是说, 此时能具体的指定typedef的类型, 还是要借助类(结构体)模板, 还不能直接和<code>typedef</code>结合.</p>
<blockquote>
<p>然后C++11, 就突破了, 直接可以使用别名是指定模板, 不需要间接的, 通过定义一个类型才能用模板机制.</p>
</blockquote>
<p>但是又不能破坏以前的规则, 所以干脆不用 typedef 了, 使用<code>using</code>吧, 即</p>
<pre><code class="C++">template &lt;typename T&gt;  
using alias_map = std::map &lt; std::string, T &gt; ;  

alias_map&lt;int&gt;  map_t;  
alias_map&lt;std::string&gt; map_str;
</code></pre>
<p>更多的例子, 比如:</p>
<pre><code class="C++">template&lt;typename T&gt;  
using func_using = void(*func)(T, T);
</code></pre>
<h2 id="模板模板参数问题"><a href="#模板模板参数问题" class="headerlink" title="模板模板参数问题"></a>模板模板参数问题</h2><p>想从模板参数中直接取出内部类型怎么办? 即模板参数特化时具体类型的参数(即<code>模板模板参数</code>).</p>
<blockquote>
<p>从函数模板中的模板参数中取出具体的参数内部的类型</p>
</blockquote>
<p>举个例子, 有一个函数模板, 例如:</p>
<pre><code>template&lt;typename T&gt;
void test(T t){
    //...具体实现, 实现中需要用到t中内部的类型, 可能是元素类型
}
</code></pre><p>而我具体调用的时候, 是这样的</p>
<pre><code class="C++">list&lt;string&gt; li;
void test (li);
</code></pre>
<p>我需要传递li对象, 是因为我想获取string类型</p>
<p>所以可以知道, 函数模板特化出来的模板函数是:</p>
<pre><code class="C++">void test(list&lt;string&gt; t);
</code></pre>
<p>那么问题来了, 如果我的最初的函数模板里面的实现代码中, 需要T中的具体模板参数怎么办? 此处<code>T</code>即<code>list&lt;string&gt;</code> 需要拿到T中的模板参数<code>string</code><br>例如:</p>
<pre><code class="C++">template&lt;typename T&gt;
void test(T t){
    //具体实现
    //抱歉拿不出来.
}
</code></pre>
<p>尝试这么写, 在声明模板参数的时候, 就声明模板为模板参数</p>
<blockquote>
<p>即模板套模板</p>
</blockquote>
<pre><code class="C++">template &lt;typename T, template&lt;class&gt; class P&gt;
class X
{
private:
    P&lt;T&gt; p; //注意这里用的是P模板, 下面分析时用到了.
};
</code></pre>
<p>相当于在外层模板里面又嵌套了一层内层模板, <strong>P</strong>作为外层模板, 相当于上面的<code>list&lt;string&gt;</code>类型,<br>而<strong>T</strong>则作为内层模板类型&amp;参数, 这个案例中相当于<code>string</code>.</p>
<p>等价于<code>template &lt;typename T, template&lt;class T&gt; class P&gt;</code>, 但 T 可以省略, 因为外层模板<code>P</code>没有使用内层模板参数<code>T</code>.</p>
<p>调用的时候, 也简单<code>X&lt;string, list&gt;</code>, 当然如果上面的内层模板我指定的话, 完整应该写成<code>X&lt;string, list&lt;string&gt;&gt;</code>.</p>
<p>直接就拿到了内层的模板参数<code>string</code>了. <strong>抱歉, 编译器报错了: (模板的二次编译问题)</strong></p>
<blockquote>
<p>第一次检查模板语法OK, 但是一旦根据你的调用逻辑进行二次编译的时候, 就报错了.</p>
</blockquote>
<p>第二个模板定义和实际调用不匹配, 需要<code>template&lt;class T&gt; class P</code>, 实际拿到的却是<code>template&lt;class _Tp, class _Alloc&gt; class std::vector</code>.<br>其实很奇怪, 因为<code>class _Alloc</code>有默认值, 翻看源码知道<code>class _Alloc=std::allocator&lt;_Tp&gt;</code>.</p>
<blockquote>
<p>只能说编译器不够智能吧, 根据我们的调用, 第二参数string, 完全是可以省略默认模板参数的.</p>
<blockquote>
<p>关键是调用时不对, 调用时如果能指定 allocator 就很好了</p>
</blockquote>
</blockquote>
<p>但是上面 class X里面成员, 我们是这么用的<code>P&lt;T&gt; p</code>, <code>对于模板模板参数而言, 编译器不知道第二个模板参数有默认值</code>, 尤其是第二个模板参数有默认值的情况.</p>
<blockquote>
<p>嵌套的嵌套来拿到模板参数的参数, 编译器确实没有办法了</p>
</blockquote>
<p>但是对于最开始的设计方式, 标准库的容器的话, 可以尝试这样拿出来: <code>容器--&gt; 迭代器 --&gt; value_type</code></p>
<pre><code class="C++">template&lt;typename T&gt;
void test(T t){
    //具体实现
    typedef typename iterator_traits&lt;typename T::iterator&gt;::value_type Valtype;
    //或者
    typedef typename T::iterator::value_type Valtype;
}
</code></pre>
<p>此时拿到了T内部元素的类型了, 即<code>typename iterator_traits&lt;typename T::iterator&gt;::value_type</code>别名为Valtype;</p>
<p>对应上面的例子, 就是<code>string</code>. 如果你不定义别名, 那么就要写很长的名字, 用于函数内部代码. 此处重点不在typedef , 在于拿到模板参数T内部的元素类型.</p>
<blockquote>
<p>这只是对于标准库可以这么<code>traits</code>萃取到类型特征.</p>
</blockquote>
<p>一般性情况如何解决?<br>我就想这么用, 在模板里面再套一个模板, 这个时候, 就用 template typedef 吧(还是using语法那个), 妙不可言.</p>
<p>我还是想这么用<code>X&lt;string, list&lt;string&gt;&gt;</code>, 定义的时候, 形式也不变, 即:(<code>内部模板的模板参数, 是以第一个模板参数为参数的</code>)</p>
<pre><code class="C++">template &lt;typename T, template&lt;class&gt; class P&gt;
//等价于template &lt;typename T, template&lt;class T&gt; class P&gt;, 但 T 可以省略.
class X
{
private:
    P&lt;T&gt; p; //注意这里用的是P模板, 下面分析时用到了.
};
</code></pre>
<p>关键是在调用时, 调用的时候借用一下<code>模板别名</code>:</p>
<pre><code class="C++">template&lt;typename T&gt;
using Lst=list&lt;T, allocator&lt;T&gt;&gt;;

X&lt;string, Lst&lt;string&gt;&gt; x; //注意没有指定第二个模板参数哦
</code></pre>
<p>超级难题, 一下子解决了… (), 苦笑不得啊. </p>
<p>展开<code>X&lt;string, lis&lt;string, allocator&lt;string&gt; &gt; &gt;</code>, 为什么是这种展开?<br>因为<code>对于模板模板参数而言, 编译器不知道第二个模板参数有默认值</code>. </p>
<blockquote>
<p>拿到内部类型干啥?</p>
</blockquote>
<p>你可能看到<code>typedef basic_string&lt;char&gt; string</code> 但是其实他默认是单字节字符, 直接拿有点儿困难.</p>
<p>当我要拿到string内部的类型用于函数&amp;类模板内部时(可能是单字节,双字节, 宽字符等), 我依旧只能:</p>
<pre><code class="C++">template&lt;class CharT&gt;
using common_string=std::basic_string&lt;CharT, std::char_traits&lt;charT&gt; &gt;;
</code></pre>
<p>此时调用如下:</p>
<pre><code class="C++">X&lt;wchar, common_string&lt;wchar&gt;&gt;
</code></pre>
<p>才能特化出我要的模板类&amp;函数版本.</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>简单说, 就是这样的东西:</p>
<pre><code class="C++">template &lt;typename T&gt;
using Vec = std::vector&lt;T&gt;;

//以后直接使用Vec即可.
Vec&lt;int&gt; v;
//相当于 std::vector&lt;int&gt; v;
</code></pre>
<p>方便了很多: </p>
<ul>
<li>代替了宏定义define, 只是宏定义不带有类型, 且是预处理的;<br>宏定义很多时候, 达不到效果的, 特别是在模板中</li>
<li>增强了typedef</li>
</ul>
<p>好比说, 你用<code>typedef</code>, 例如:</p>
<pre><code class="C++">typedef std::vector&lt;int&gt; Vec
</code></pre>
<p>那么后面使用的时候, 就直接<code>Vec v;</code>, 根本不必要, 也<strong>不能</strong>传递泛型参数了.</p>
<blockquote>
<p>其实我觉得最大的优点是解决了模板中嵌套模板的难题. (template template在使用的时候, 即编译器二次编译时, 对调用形式要求很高)</p>
</blockquote>
<h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>一旦你这样<code>using</code>了别名, 你就放弃了模板的特化(全特化或者偏特化), 也就是说, 你只能拿到<code>用</code>, 而不能拿来定义模板了.<br>(上面的例子, 也说明了这个问题, 我只是在<code>使用的场景</code>中才用到了模板别名)</p>
<blockquote>
<p>模板别名, 只用在<code>使用的场景</code>, 不用于定义的场景.</p>
</blockquote>
<p>下面补充说明一下<code>type alias</code>.</p>
<h1 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h1><p><code>type alias</code>这个只能算是个小小的方便, 例如:</p>
<pre><code class="C++">typedef void (*func)(int, int);
</code></pre>
<p>现在也可以用 using 来写, 而且更加简单, <code>更加突出类型的地位</code>.</p>
<pre><code class="C++">using func = void(*)(int, int);
</code></pre>
<p>使用起来完全当做<code>类型</code>去考虑即可:</p>
<pre><code class="C++">func fn = f1;
fn();
</code></pre>
<blockquote>
<p>也就是说, 彻底侧重于,<code>以类型为中心</code>, 我这么写是在定义类型, 而不是以对象&amp;变量为中心; </p>
</blockquote>
<p>其他用途:</p>
<pre><code class="C++">template &lt;typename T&gt;
struct X{
    using value_type = T; //给模板参数起别名
    //相当于
    //typedef T value_type;
};
</code></pre>
<h1 id="默认模板参数"><a href="#默认模板参数" class="headerlink" title="默认模板参数"></a>默认模板参数</h1><p>在 C++11 中, 支持默认模板参数, 例如:</p>
<pre><code class="C++">template&lt;class T, class U = int, U n= 0&gt;  
struct Foo  
{  
    //  
};
</code></pre>
<p>在函数模板中当所有模板参数都有默认参数时，函数的调用就如同普通的函数调用，</p>
<blockquote>
<p>但是对于类模板而言，哪怕所有模板参数都有默, 认构造函数在使用时还是必须在模板名后跟随&lt;&gt;来实例化</p>
</blockquote>
<p>C++11中函数的默认模板参数在使用规则上和其他的默认参数也有一些区别，普通函数的默认参数必须写在参数列表的最后，而函数的模板参数就没有这个限制.</p>
<p>因此当使用默认模板参数和模板参数自动推导时就显示十分灵活，可以指定函数中的一部分参数是默认参数，另一部分采用自动推导(其实是从左到右顺序, 优先匹配).</p>
<pre><code class="C++">template &lt;typename R = int, typename U&gt;  
R func(U val)  
{  
    //...  
}
</code></pre>
<blockquote>
<p>建议在使用的时候尽量还是价格默认模板参数写在模板参数的末尾</p>
</blockquote>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="/" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：C++11 模板别名探究</span><br/>
	<span><b>本文链接</b>：www.merlinblog.site/2017/05/18/template-alias-in-cpp.html</span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="/css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY SA 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>

