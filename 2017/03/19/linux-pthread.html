<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>linux-pthread | Merlin&#39;s Blog</title>
  <meta name="author" content="MerlinYu">
  
  <meta name="description" content="basic summary about posix pthread">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="linux-pthread"/>
  <meta property="og:site_name" content="Merlin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="ico">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Merlin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> linux-pthread</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> basic summary about posix pthread
		 </div> <!-- alert -->
	  		

	  <p>个人觉得对于线程的把控，难度要小于进程，进程的通信方式多到能写一本书，并且每种方式还有其各自的适用范围以及注意事项，真正玩起来还是有点儿多。甚至对于内核而言，它都不区分进程和线程。<br>但是线程就不一样，只是Linux下面的话，线程当前的模型就一种：<code>内核支持的NPTL</code>(Native POSIX Thread Library), 但是如果你读过<a href="http://www.merlinblog.site/2017/07/06/seven-concurrency-models.html" target="_blank" rel="external">《7周7并发模型》</a>的话就会知道并发问题远不止这么点儿东西。<br>本文从实战的角度展开主要涉及4个方面:</p>
<ul>
<li>Thread management - creating, joining threads etc.</li>
<li>Mutexes</li>
<li>Condition variables</li>
<li>Synchronization between threads using read/write locks and barriers</li>
</ul>
<p>The POSIX semaphore API works with POSIX threads but is not part of threads standard.</p>
<p>但是实际上就两大类: </p>
<ul>
<li>线程的控制原语(包括线程属性) </li>
<li>线程的同步原语(信号量(PV)，互斥量，竞争/冒险条件，文件锁，屏障)</li>
</ul>
<p>贴个图:<br><img src="http://omotkhw3y.bkt.clouddn.com/thread_model.png" alt="pthread"><br>API偏多, 注意一下常用的使用场景以及一些注意事项即可, <code>深入理解线程</code> 请参考专业书籍, 后续再写.<br>(本文是详细总结, 所以细节偏多)</p>
<a id="more"></a>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><blockquote>
<p>那么先问一个问题，一个Linux进程最多起多少个线程？</p>
</blockquote>
<p>本文涉及哪些内容, 见下图<br><img src="http://omotkhw3y.bkt.clouddn.com/pthread_control.jpg" alt="functions"></p>
<ol>
<li>线程控制函数<br>pthread_create(), pthread_exit(), pthread_join()</li>
<li>线程的同步(控制线程同时执行 &amp;&amp; 访问代码临界区)<br>信号量： sem_<em>()<br>互斥量： pthread<em>mutex</em></em>()<br>条件变量: pthread<em>cond</em>*()<br>(线程与信号配合的并不好，所以不要这样相互使用)</li>
<li>线程的属性(比较多，但是常用的不多，大概6个左右)<br>pthread<em>attr</em>*()<br>设置一些取消状态等</li>
<li>其他</li>
</ol>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="线程的控制"><a href="#线程的控制" class="headerlink" title="线程的控制"></a>线程的控制</h2><p>主要内容：(直接返回errno，而不是返回-1设置errno了)</p>
<ol>
<li>pthread_self()—–相当于getpid(); 但是注意pthread_t，虽然在linux下是%ul但是在别的系统下可能是结构体.(始终成功)</li>
<li>pthread_create()—–相当于fork()，但是这个函数的参数比较多；一定注意，如果失败了，传入的pthread就不要再使用了</li>
<li>pthread_exit()—–相当于exit(), 但是是退出单个线程, 并给出返回值</li>
<li>pthread_join()—-相当于waitpid(), 阻塞等待某一个线程退出, 并拿到其返回值(注意指针的传参)</li>
<li>pthread_detach()— 线程分离函数, 进程控制没有这个函数</li>
<li>pthread_cancel()—-相当于进程的kill(), 表示杀死某个子线程</li>
<li>pthread_equal()—-判断两个线程是否相同(主要是由于pthread_t定义在不同系统可能不一样, 所以用该函数判断)</li>
</ol>
<p>(return, exit, pthread_exit(), 推荐最后一个)</p>
<p>下面给出一些demo:</p>
<p>创建一个线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">my_func</span><span class="params">(<span class="keyword">void</span>*arg)</span></span>&#123;</div><div class="line">    <span class="comment">//子线程</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"in thread id = %lu\n"</span>, pthread_self());</div><div class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">pthread_t</span> tid;</div><div class="line">    <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"in main id = %lu\n"</span>, pthread_self());<span class="comment">//主控线程</span></div><div class="line"></div><div class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, my_func, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span>( ret )&#123;</div><div class="line">           <span class="comment">//fprintf(stderr, "pthread_create error: %s\n", strerror(ret));</span></div><div class="line">           <span class="built_in">printf</span>(<span class="string">"create thread failed, %s\n"</span>,strerror(ret));</div><div class="line">           <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sleep(<span class="number">1</span>); <span class="comment">//让子线程有机会打印</span></div><div class="line">    <span class="comment">//pthread_join(tid, NULL);</span></div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//退出进程地址空间</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是可以看到，使用<code>ps -Lf &lt;pid&gt;</code>看到的LWP号码，要比这里pthread_self()拿到的要小的多。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ps -Lf</div><div class="line">UID        PID  PPID   LWP  C NLWP STIME TTY          TIME CMD</div><div class="line">merlin   20185 19023 20185  0    1 17:53 pts/1    00:00:00 -bash</div></pre></td></tr></table></figure></p>
<p>(pthread_self()拿到的数字非常大, 而LWP是linux内核分配cpu时间片的依据)</p>
<p>循环创建多个线程</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(i =<span class="number">0</span>; i&lt; <span class="number">10</span>; ++i)&#123;</div><div class="line">  ret = pthread_create(&amp;tid[i], <span class="literal">NULL</span>, my_func, (<span class="keyword">void</span> *)i); </div><div class="line">  <span class="keyword">if</span>(ret != <span class="number">0</span> )&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create thread %d error: %s\n"</span>, i+<span class="number">1</span>, strerror(ret));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为什么传递值而不是传递地址, 因为当子线程真正解引用去拿值的时候main函数这个线程可能已经走到了别的位置，i的值已经在main中被改变了;所以这里只能用值传递。</p>
<p>加上pthread_join和pthread_exit之后, 完整的创建多个线程的例子如下：(既然创建了, 就要负责回收—如果它不是detach线程的话)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*不要让线程结束, 否则栈空间会被释放掉*/</span></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">    sleep(<span class="number">1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pthread_t</span> tid;</div><div class="line">  <span class="keyword">int</span> ret;</div><div class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">1</span>;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span><span class="comment">/*(void*)i*/</span>);</div><div class="line">    <span class="keyword">if</span>(ret) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error:%s\n"</span>, strerror(ret));</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"now thread sum number = %lu\n"</span>, i+<span class="number">1</span>); <span class="comment">//include main thread</span></div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    i++;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pthread_create error:Resource temporarily unavailable</div><div class="line">now thread sum number = 32756</div></pre></td></tr></table></figure></p>
<p>(大致可以看到, 一个进程能够创建多少个线程和线程栈空间大小, 以及物理内存多少有关)</p>
<p>拿到线程的返回值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span></div><div class="line">&#123;</div><div class="line"> <span class="keyword">int</span> a;</div><div class="line"> <span class="keyword">int</span> b;</div><div class="line">&#125;<span class="keyword">exit_t</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">exit_t</span> *ret;</div><div class="line">  ret = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">exit_t</span>));</div><div class="line"></div><div class="line">  ret-&gt;a = <span class="number">1</span>;</div><div class="line">  ret-&gt;b = <span class="number">2</span>;</div><div class="line"></div><div class="line">  pthread_exit((<span class="keyword">void</span>*)ret);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pthread_t</span> tid;</div><div class="line">  <span class="keyword">exit_t</span> *ret;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>( pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>) )&#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create  error"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pthread_join(tid, (<span class="keyword">void</span> **) &amp;ret);<span class="comment">//注意这里传入的不是&amp;tid</span></div><div class="line">  <span class="built_in">printf</span>(<span class="string">"return value %d, %d"</span>, ret-&gt;a, ret-&gt;b);</div><div class="line">  </div><div class="line">  <span class="built_in">free</span>(ret);</div><div class="line">  ret = <span class="literal">NULL</span>;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>(最好把ret作为传入参数传递给pthread_create, 之后申请和释放都在main函数中了)</p>
<p>线程分离<br>好处是, 不需要再由其他线程等待回收, 在状态上可以避免僵尸线程(结束时自动把自己的pcb在内存中的残留资源清理掉), 但是进程没有该机制, 所以当进程死亡如果没有回收, 总会在内存中残留一些资源, 导致内核始终认为该进程还存在.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</div></pre></td></tr></table></figure></p>
<p>(也可以使用线程属性进行设置分离状态)<br>创建完毕即可以分离<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span>);</div><div class="line">pthread_detach(tid); <span class="comment">//退出后自动释放资源</span></div></pre></td></tr></table></figure></p>
<p>设置分离之后, 再用join去回收, 则失败, 即会返回错误号22(无效的参数invalid argument).<br>(没有分离的时候, 是阻塞等待回收; 一旦设置线程的分离状态, 那么join直接反馈传递的tid无效)</p>
<p>杀死线程<br>kill发送信号, 杀死进程(相对实时); 而线程中, 不一定都能杀死, 要在一定的 “取消点” 才可以(非实时).</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pthread_cancel(tid);</div></pre></td></tr></table></figure>
<p>线程的取消并不是实时的，而有一定的延时。需要等待线程到达某个取消点(检查点).取消点：是线程检查是否被取消，并按请求进行动作的一个位置。通常是一些系统调用 creat， open， pause，close， read， write….. 执行命令 man 7 pthreads 可以查看具备这些取消点的系统调用列表。也可参阅 APUE.12.7 取消选项小节。</p>
<p>可以简单的认为, 陷入系统调用, 就进入了检查点; 如果没有检查点, 可以手动添加一个:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pthread_testcancel();</div></pre></td></tr></table></figure></p>
<p>被cancel杀死的线程, 如果在用join去回收, 则退出值是-1 (实际上是由 <code>PTHREAD_CANCELED</code> 宏决定的); 被取消的线程, 退出值定义在 Linux的 pthread 库中; 常数 PTHREAD_CANCELED 的值是-1. 可在头文件 pthread.h中找到它的定义: <code>#define PTHREAD_CANCELED ((void *) -1)</code>. 因此当我们对一个已经被取消的线程使用 pthread_join回收时, 得到的返回值为-1.</p>
<p>补充, 终止的清理函数<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//push and pop thread cancel-lation clean-up handlers</span></div><div class="line">pthread_cleanup_pop()</div><div class="line">pthread_cleanup_push()</div><div class="line">pthread_cleanup_pop_restore_np() </div><div class="line">pthread_cleanup_push_defer_np()</div></pre></td></tr></table></figure></p>
<p>可以读读 <a href="http://man.yolinux.com/cgi-bin/man2html?cgi_command=pthread_cleanup_pop" target="_blank" rel="external">man手册</a>, 写的非常详细的三种情况:</p>
<ul>
<li>When    a thread is canceled</li>
<li>When    a  thread  terminates by calling pthread_exit()</li>
<li>When a thread calls pthread_cleanup_pop()  with  a  nonzero  execute argument</li>
</ul>
<p>判断相等<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pthread_equal()</div></pre></td></tr></table></figure></p>
<p>为了防止, 将来pthread_t类型可能变成结构体类型, 所以最好还是用该函数进行判断.</p>
<h2 id="线程属性控制"><a href="#线程属性控制" class="headerlink" title="线程属性控制"></a>线程属性控制</h2><p>进行线程属性设置, 也是 <code>线程控制</code> 的一部分.</p>
<h3 id="修改线程属性的方法"><a href="#修改线程属性的方法" class="headerlink" title="修改线程属性的方法"></a>修改线程属性的方法</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_init</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; <span class="comment">//成功: 0; 失败:错误号</span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_attr_destroy</span><span class="params">(<span class="keyword">pthread_attr_t</span> *attr)</span></span>; <span class="comment">//成功: 0; 失败:错误号</span></div></pre></td></tr></table></figure>
<p>线程属性主要包括如下属性：作用域（scope）、栈尺寸（stack size）、栈地址（stack address）、优先级（priority）、分离的状态（detached state）、调度策略和参数（scheduling policy and parameters）。默认的属性为非绑定、非分离、缺省的堆栈、与父进程同样级别的优先级。</p>
<ul>
<li>detached state (joinable? Default: PTHREAD_CREATE_JOINABLE. Other option: PTHREAD_CREATE_DETACHED)</li>
<li>scheduling policy (real-time? PTHREAD_INHERIT_SCHED,PTHREAD_EXPLICIT_SCHED,SCHED_OTHER)</li>
<li>scheduling parameter</li>
<li>inheritsched attribute (Default: PTHREAD_EXPLICIT_SCHED Inherit from parent thread: PTHREAD_INHERIT_SCHED)</li>
<li>scope (Kernel threads: PTHREAD_SCOPE_SYSTEM User threads: PTHREAD_SCOPE_PROCESS Pick one or the other not both.)</li>
<li>guard size</li>
<li>stack address (See unistd.h and bits/posix_opt.h _POSIX_THREAD_ATTR_STACKADDR)</li>
<li>stack size (default minimum PTHREAD_STACK_SIZE set in pthread.h),</li>
</ul>
<p>一般修改: (可以参考APUE 12.3)</p>
<ul>
<li>线程的分离状态</li>
<li>线程栈的大小</li>
<li>线程栈末尾警戒区的大小</li>
<li>调度策略(这个属于高级内容)</li>
</ul>
<h3 id="设置分离状态"><a href="#设置分离状态" class="headerlink" title="设置分离状态"></a>设置分离状态</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_attr_t</span> attr;</div><div class="line">pthread_attr_init(&amp;attr);</div><div class="line">pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACH);</div><div class="line"></div><div class="line">pthread_create(&amp;tid, &amp;attr, func, <span class="literal">NULL</span>);</div></pre></td></tr></table></figure>
<p>用完attr记得销毁;<br>并且如果要创建的线程在pthread_create返回之前就运行完毕了, 这个时候pthread_create返回错误代码, 此时最好应该让子线程的运行逻辑里加上等待逻辑, 例如:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pthread_cond_timewait()</div></pre></td></tr></table></figure></p>
<h3 id="修改栈大小"><a href="#修改栈大小" class="headerlink" title="修改栈大小"></a>修改栈大小</h3><p>查看栈大小(线程均分进程栈空间)<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">ulimit</span> <span class="_">-a</span> | grep stack </div><div class="line"><span class="comment">#8192字节, 即8M; 一个进程栈大小8M</span></div></pre></td></tr></table></figure></p>
<p>可以从堆中手动申请, 然后设置<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pthread_attr_t</span> attr;</div><div class="line">pthread_attr_init(&amp;attr);</div><div class="line"></div><div class="line">pthread_attr_setstacksize(&amp;attr, <span class="number">1024</span>);</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize);</div><div class="line">int pthread_attr_getstacksize(pthread_attr_t *attr, size_t *stacksize);</div><div class="line">*/</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">//或者不让内核指定位置, 即位置, 大小都由我们手动指定</span></div><div class="line"><span class="comment">//可以把地址指定到堆空间上, 而不是栈空间上了</span></div><div class="line"><span class="comment">//char *buffer = (char*)malloc(1024*sizeof(char));</span></div><div class="line"><span class="comment">//pthread_attr_setstatck(&amp;attr, buffer, 1024);</span></div><div class="line"></div><div class="line"><span class="comment">/*int pthread_attr_setstack(pthread_attr_t *attr,</span></div><div class="line">                                 void *stackaddr, size_t stacksize);</div><div class="line">int pthread_attr_getstack(pthread_attr_t *attr,</div><div class="line">                                 void **stackaddr, size_t *stacksize); */</div></pre></td></tr></table></figure></p>
<p>(堆空间相对大一些, 再把stack size设置小一点, 那么每个进程可以创建的线程数量就会变多)</p>
<h3 id="设置警戒区"><a href="#设置警戒区" class="headerlink" title="设置警戒区"></a>设置警戒区</h3><p>每个线程栈的末尾有一段警戒区, 用来防止线程和线程之间干扰或者栈溢出.</p>
<p>用的不是太多, 略.</p>
<h3 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h3><p>察看当前 pthread 库版本 <code>getconf GNU_LIBPTHREAD_VERSION</code> .</p>
<p>(NPTL 实现机制(POSIX), Native POSIX Thread Library)</p>
<h2 id="线程控制总结"><a href="#线程控制总结" class="headerlink" title="线程控制总结"></a>线程控制总结</h2><ul>
<li>主线程退出其他线程不退出, 主线程应调用 pthread_exit</li>
<li>避免僵尸线程 <code>pthread_join</code> , <code>pthread_detach</code> , <code>pthread_create</code>指定分离属性</li>
<li>被 join 线程可能在 join 函数返回前就释放完自己的所有内存资源, 所以不应当返回被回收线程栈中的值(即临时变量);</li>
<li>malloc 和 mmap 申请的内存可以被其他线程释放</li>
<li>应避免在多线程模型中调用 fork ; 进程中只有调用 fork 的线程存在(该线程独占进程了), 其他线程在子进程中均 pthread_exit 自动退出.</li>
<li>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</li>
</ul>
<h2 id="线程的同步-重点"><a href="#线程的同步-重点" class="headerlink" title="线程的同步(重点)"></a>线程的同步(重点)</h2><p>(该部分内容非常多)<br>互斥是同步的工具<br>线程互斥和线程同步还有一定的距离</p>
<h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><p>访问某一个共享资源有先后的次序, 具体说, 某一个线程访问某一个资源, 得到结果之前, 该调用不返回, 并且其他线程不可访问.<br>(多个线程需要访问某一个共享资源时, 需要同步处理)</p>
<ul>
<li>多个独立对象</li>
<li>竞争访问</li>
<li>统一资源(共享资源)</li>
</ul>
<p>同步的手段(并发编程): 加锁(多线程); 任务队列(actor) </p>
<p>(锁是建议锁, 不具有强制性; 意思说, 你访问共享资源的时候, 线程不写拿锁逻辑, 直接访问也是可以的, 但这种方式就没有经过同步处理, 是不推荐的)</p>
<p>一把锁, 对应一个需要操作的共享数据.</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥锁, 也是一把建议锁&amp;协同锁, 不具有强制性; 涉及到的相关函数如下:<br>(apue上面称之为 <code>协同锁</code> )<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_init()</div><div class="line">pthread_mutex_destroy()</div><div class="line"></div><div class="line">pthread_mutex_lock() <span class="comment">//相当于把mutex实例减1</span></div><div class="line">pthread_trylock() <span class="comment">//如果能加锁成功, 则加锁成功;否则就返回</span></div><div class="line">pthread_mutex_unlock() <span class="comment">//相当于把mutex实例加1</span></div></pre></td></tr></table></figure></p>
<p>成功返回0, 失败返回错误码;</p>
<p><code>pthread_mutex_t</code>是结构体, 使用时忽略细节(不需要关注该结构体的细节)可以简单认为是整型, 有两种取值0,1; 相当于一个把锁.<br><code>pthread_mutexattr_t</code>是指互斥锁的属性.</p>
<p>下面给予一个简单的实例<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  srand(time(<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"small"</span>);</div><div class="line">    sleep(rand()%<span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line">    sleep(rand()%<span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pthread_t</span> tid;</div><div class="line">  <span class="keyword">int</span> ret;</div><div class="line"></div><div class="line">  srand(time(<span class="literal">NULL</span>));</div><div class="line"></div><div class="line">  <span class="keyword">if</span>(pthread_mutex_init(&amp;mutex, <span class="literal">NULL</span>)) &#123;<span class="comment">//mutex == 1</span></div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mutex init error"</span>);</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  ret = pthread_create(&amp;tid, <span class="literal">NULL</span>, func, <span class="literal">NULL</span><span class="comment">/*(void*)i*/</span>);</div><div class="line">  <span class="keyword">if</span>(ret) &#123;</div><div class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"pthread_create error:%s\n"</span>, strerror(ret));</div><div class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;    </div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"BIG"</span>);</div><div class="line">    sleep(rand()%<span class="number">2</span>);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line">    sleep(rand()%<span class="number">2</span>);</div><div class="line">    </div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pthread_mutex_destroy(&amp;mutex);</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>(注意保证另外一个线程也能抢到cpu, 所以保证锁的粒度越小越好, 共享的标准输出一旦使用完毕, 立即解锁)</p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>与互斥量类似, 但是读写锁运行 <code>更高的并发性</code> ; 写独占, 读共享; 共享独占锁, 适合读的情况比写的情况的场景. 拥有写锁的线程, 其他线程全部阻塞等待, 直到完成; 而读锁加锁成功时, 并且同时需要加锁的没有写锁(即之后的全是读锁), 那么其他线程仍可以加读锁, 但是一旦有写锁, 则大家一起等着(即读锁也不能加锁成功); 并且读写锁一起抢的时候, <code>写锁的优先级高</code>.<br>一把<code>rwlock</code>锁有3个状态:</p>
<ul>
<li>读模式下加锁(读锁)</li>
<li>写模式下加锁(写锁)</li>
<li>不加锁状态</li>
</ul>
<p>主要函数总结:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">pthread_rwlock_init()</div><div class="line">pthread_rwlock_destroy()</div><div class="line"></div><div class="line">pthread_rwlock_rdlock() <span class="comment">//读加锁</span></div><div class="line">pthread_rwlock_wrlock() <span class="comment">//写加锁</span></div><div class="line"></div><div class="line">pthread_rwlock_tryrdlock() <span class="comment">//尝试读加锁</span></div><div class="line">pthread_rwlock_trywrlock() <span class="comment">//尝试写加锁</span></div><div class="line"></div><div class="line">pthread_rwlock_unlock() <span class="comment">//解锁</span></div></pre></td></tr></table></figure></p>
<p>成功返回0, 失败返回错误码</p>
<p><code>pthread_rwlock_t</code>定义了读写锁的类型; <code>pthread_rwlockattr_t</code> 读写锁的属性.</p>
<p>写一个demo, 演示读写锁<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">int</span> counter = <span class="number">0</span>; <span class="comment">//shared resource</span></div><div class="line"><span class="keyword">pthread_rwlock_t</span> rwlock;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_write</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> t;</div><div class="line">  <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">    t = counter;</div><div class="line">    usleep(<span class="number">1000</span>);</div><div class="line"></div><div class="line">    pthread_rwlock_wrlock(&amp;rwlock); <span class="comment">//write lock</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"---write %d: %lu: counter=%d ++counter=%d\n"</span>, i, pthread_self(), t, ++counter);</div><div class="line">    pthread_rwlock_unlock(&amp;rwlock);</div><div class="line">    usleep(<span class="number">2000</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">thread_read</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i = (<span class="keyword">int</span>)arg;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">    </div><div class="line">    pthread_rwlock_rdlock(&amp;rwlock);</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"--------------------read %d: %lu: %d\n"</span>, i, pthread_self(), counter);</div><div class="line">    pthread_rwlock_unlock(&amp;rwlock);</div><div class="line">    </div><div class="line">    usleep(<span class="number">900</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  <span class="keyword">pthread_t</span> tid[<span class="number">8</span>]; <span class="comment">//3 write, 5 read</span></div><div class="line"></div><div class="line">  pthread_rwlock_init(&amp;rwlock, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</div><div class="line">    pthread_create(&amp;tid[i], <span class="literal">NULL</span>, thread_write, (<span class="keyword">void</span>*)i);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</div><div class="line">    pthread_create(&amp;tid[i+<span class="number">3</span>], <span class="literal">NULL</span>, thread_read, (<span class="keyword">void</span>*)i);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i&lt;<span class="number">8</span>; i++) &#123;</div><div class="line">    pthread_join(tid[i], <span class="literal">NULL</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  pthread_rwlock_destroy(&amp;rwlock);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>注意编译的时候加上 <code>-fpermissive</code> , 允许精度损失.</p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>(<code>sudo apt-get install manpages-posix-dev</code>)<br>条件变量本身 <code>不是锁</code> , 一般用于谓词判断(判断一下条件), 可造成线程阻塞.</p>
<p>通常要和互斥锁mutex配合在一起, 完成同步操作; </p>
<p>(满足某个条件才阻塞或者得到cpu)</p>
<p>主要函数有:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">pthread_cond_init()</div><div class="line">pthread_cond_destroy()</div><div class="line"></div><div class="line">pthread_cond_wait() <span class="comment">//核心</span></div><div class="line">pthread_cond_timedwait()<span class="comment">// 时间到, 自动返回(而非永久阻塞)</span></div><div class="line">pthread_cond_signal() <span class="comment">//唤醒其他线程, 至少一个(可以是具体的某个)</span></div><div class="line">pthread_cond_broadcast() <span class="comment">//唤醒其他所有阻塞线程(不指定具体的某个)</span></div></pre></td></tr></table></figure></p>
<p>其中 <code>pthread_cond_wait()</code> :<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span> *<span class="keyword">restrict</span> cond,</span></span></div><div class="line">              <span class="keyword">pthread_mutex_t</span> *<span class="keyword">restrict</span> mutex);</div></pre></td></tr></table></figure></p>
<ul>
<li>该函数调用时, 阻塞等待条件变量, 并解锁互斥量(相当于unlock), 且是原子操作(放开锁让别的线程操作)</li>
<li>阻塞等待一个条件变量(条件变量不满足则一直等待)—或者等其他线程唤醒本线程</li>
<li>该函数返回时(其他线程唤醒该线程时), 重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);//或者trylock; 本次拿不到就等下次, 不一定能拿到, 但是一旦拿到锁则阻塞解除, 可以开始操作数据了</li>
</ul>
<p>(什么时候条件变量满足? 别的线程调用signal, broadcast的时候自然会传入cond, 此时即表明条件变量已经满足, 有点儿像java的notify和notifyAll)</p>
<p>具体的例子, 可以参考一下下面的 <code>生产者消费者模型</code><br>(生产队列中有没有产品, 就依靠条件变量做判断; 加锁依靠mutex)<br>(也就是大家伙都cond_wait着, 就依靠别人signal或者broadcast通知, 即当条件变量满足时通知等待的众人, 然后大家抢锁成功的操作共享资源, 没有成功的继续循环调用wait阻塞等待下一次通知)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*static init*/</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> msg&#123;</div><div class="line">  <span class="keyword">int</span> num;</div><div class="line">  <span class="keyword">struct</span> msg *next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> msg *head = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">struct</span> msg *tmp = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">productor</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    tmp = (<span class="keyword">struct</span> msg*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</div><div class="line"></div><div class="line">    tmp-&gt;num = rand() % <span class="number">100</span> + <span class="number">1</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"---producer has produced %d \n"</span>, tmp-&gt;num);</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    tmp-&gt;next = head;</div><div class="line">    head = tmp;</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line">    pthread_cond_signal(&amp;has_product); <span class="comment">/*producer Vs consumer = 1:1*/</span></div><div class="line">    </div><div class="line">    usleep(rand()%<span class="number">1000</span>); <span class="comment">//给消费者机会</span></div><div class="line"></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line"></div><div class="line">    <span class="comment">/*开始操作Msg队列*/</span></div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(head==<span class="literal">NULL</span>) &#123; <span class="comment">//队列为空, 放弃锁, 阻塞, 等待下一波唤醒</span></div><div class="line">      pthread_cond_wait(&amp;has_product, &amp;mutex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//有产品, 取走一个队头</span></div><div class="line">    tmp = head;</div><div class="line">    head = head-&gt;next;</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"consumer  has consumed %d \n"</span>, tmp-&gt;num);</div><div class="line">    <span class="built_in">free</span>(tmp);</div><div class="line">    tmp = <span class="literal">NULL</span>;</div><div class="line">    usleep(rand()%<span class="number">1000</span>); <span class="comment">//给生产者机会    </span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pthread_t</span> ptid, ctid; <span class="comment">//processer and consumer</span></div><div class="line"></div><div class="line">  <span class="comment">/*remember checking return code*/</span></div><div class="line">  pthread_create(&amp;ptid, <span class="literal">NULL</span>, productor, <span class="literal">NULL</span>);</div><div class="line">  pthread_create(&amp;ctid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  pthread_join(ptid, <span class="literal">NULL</span>);</div><div class="line">  pthread_join(ctid, <span class="literal">NULL</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>至于 <code>pthread_cond_timewait</code> 注意一下时间的使用:<br>(指定阻塞时常, struct timespec具体定义可以参考 `man sem_timedwait)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">       int pthread_cond_timedwait(pthread_cond_t *restrict cond,</div><div class="line">              pthread_mutex_t *restrict mutex,</div><div class="line">              const struct timespec *restrict abstime);</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>); <span class="comment">//获取当前时间</span></div><div class="line"><span class="keyword">struct</span> timespec t = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">//绝对时间(可以直接在这里设置定时时间)</span></div><div class="line">t.tv_sec = cur + <span class="number">10</span>; <span class="comment">//当前时间往后, 定时10秒(作为绝对时间)</span></div><div class="line">pthread_cond_timewait(&amp;cond, &amp;mutex, &amp;t);</div></pre></td></tr></table></figure></p>
<p>该部分可以参考 APUE 11.6 章节.</p>
<p>总结: 条件变量在达到同步阻塞的目的是, 更多的减少了不必要的竞争(例如多个抢锁的进程, 原来是直接抢锁, 现在是等到条件满足的时候才去抢锁).</p>
<h3 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h3><p>信号量和信号完全两码事儿.<br>(semaphore可以用于线程, 进程间同步; mutex的增强版本)</p>
<p>主要函数如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span> *sem, <span class="keyword">int</span> pshared, <span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>; <span class="comment">//value为的1时, 相当于互斥量mutex</span></div><div class="line"></div><div class="line">sem_destroy()</div><div class="line">sem_wait() <span class="comment">//相当于加锁, 但不一定阻塞 value--, value减到0才会阻塞</span></div><div class="line">sem_trywait()</div><div class="line">sem_timedwait()</div><div class="line">sem_post()  <span class="comment">//相当于 value++ 并signal通知唤醒阻塞的线程</span></div></pre></td></tr></table></figure></p>
<p>具体可以查看man手册 <code>man sem_init</code> , 上述的加减操作对开发者隐藏; 并且可以看出, 上述初值value决定了同时占用的共享资源的个数.</p>
<p>具体案例, 见下面 <code>消费者生产者模型</code> (不同于条件变量的实现, 这个思路比较简单, 实现多生产者, 多消费者)<br><img src="http://omotkhw3y.bkt.clouddn.com/pthread_sem.jpg" alt="信号量实现"><br>(定义两个信号量, 其中一个表示实际生产出来的产品数量, 另外一个信号量表示总共的产品 <code>(线性)队列</code> 空余容量)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5</span></div><div class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[NUM]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//全局队列</span></div><div class="line"></div><div class="line"><span class="keyword">sem_t</span> blank_num, product_num; <span class="comment">//空余容量, 已生产容量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*本案例中, 队列用的数组代替, </span></div><div class="line"> 所以队列的移动等操作忽略(可能出现消费者消费产品为0的情况)*/</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">produce</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    sem_wait(&amp;blank_num); <span class="comment">//有空余才生产, 无空余则阻塞</span></div><div class="line">    <span class="built_in">queue</span>[i] = rand() % <span class="number">100</span> + <span class="number">1</span>; <span class="comment">//产生一个产品</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"----produced %d\n"</span>, <span class="built_in">queue</span>[i]);   </div><div class="line">    sem_post(&amp;product_num);</div><div class="line"></div><div class="line">    i = (i+<span class="number">1</span>) % NUM; <span class="comment">//逻辑环</span></div><div class="line">    sleep(rand()%<span class="number">1</span>); <span class="comment">//给消费者机会</span></div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consume</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    sem_wait(&amp;product_num); <span class="comment">//有产品才消费, 没有产品则等待</span></div><div class="line">    <span class="comment">//队列首部出队</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"consume %d\n"</span>, <span class="built_in">queue</span>[i]);</div><div class="line">    <span class="built_in">queue</span>[i] = <span class="number">0</span>;</div><div class="line">    sem_post(&amp;blank_num);</div><div class="line"></div><div class="line">    i = (i+<span class="number">1</span>) % NUM; <span class="comment">//逻辑环</span></div><div class="line">    sleep(rand()%<span class="number">3</span>); <span class="comment">//给生产者机会多生产</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*忽略rerurn code的检查*/</span></div><div class="line">  <span class="keyword">pthread_t</span> pid, cid;</div><div class="line">  sem_init(&amp;blank_num, <span class="number">0</span>, NUM);</div><div class="line">  sem_init(&amp;product_num, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">  pthread_create(&amp;pid, <span class="literal">NULL</span>, produce, <span class="literal">NULL</span>);</div><div class="line">  pthread_create(&amp;cid, <span class="literal">NULL</span>, consume, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  pthread_join(pid, <span class="literal">NULL</span>);</div><div class="line">  pthread_join(cid, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  sem_destroy(&amp;blank_num);</div><div class="line">  sem_destroy(&amp;product_num);</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>使用互斥量或者其他锁机制中出现的一种现象.<br>一般我遇到的情况:</p>
<ul>
<li>线程试图对互斥量A重复加锁</li>
<li>线程1拥有A锁, 线程2拥有B锁; 两者互相请求对方的锁.</li>
</ul>
<p>解决方案, 一般是找到问题, 对症下药.</p>
<ul>
<li>加锁之前, 一定先检查一下之前是否加过同样的锁(及时解锁)</li>
<li>(得不到资源的时候, 把已经占有的先释放)已经有一把锁, 再加锁另一把的时候可以使用try_lock逻辑(try_lock失败,就主动放弃已有的锁,让对方线程先运行)</li>
</ul>
<p>一个简单的demo, 看看下面这个死锁现象(注意执行步骤):</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line"></div><div class="line">pthread_mutex_t mutex_a;</div><div class="line">pthread_mutex_t mutex_b;</div><div class="line"></div><div class="line"></div><div class="line">void *func(void*)</div><div class="line">&#123;</div><div class="line">  pthread_mutex_lock(&amp;mutex_a);</div><div class="line">  printf("sub thread, i have a lock,</div><div class="line">   quest for b lock; once i get b lock, i will unlock a\n");  </div><div class="line"></div><div class="line">  pthread_mutex_lock(&amp;mutex_b);</div><div class="line">  pthread_mutex_unlock(&amp;mutex_a);</div><div class="line">  pthread_mutex_unlock(&amp;mutex_b);</div><div class="line">  </div><div class="line">  return NULL;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">int main(void) </div><div class="line">&#123;</div><div class="line">  pthread_t tid;</div><div class="line">  //int ret;</div><div class="line"></div><div class="line">  /*check return code plz*/</div><div class="line">  pthread_mutex_init(&amp;mutex_a, NULL);</div><div class="line">  pthread_mutex_init(&amp;mutex_b, NULL);</div><div class="line"></div><div class="line">  pthread_create(&amp;tid, NULL, func, NULL);</div><div class="line"></div><div class="line">  </div><div class="line">  pthread_mutex_lock(&amp;mutex_b);</div><div class="line">  printf("main thread, i have b lock, </div><div class="line">       quest for a lock; once i get a lock, i will unlock b\n");  </div><div class="line">  sleep(1);// let sub thread lock a</div><div class="line">  </div><div class="line">  pthread_mutex_lock(&amp;mutex_a);</div><div class="line">  pthread_mutex_unlock(&amp;mutex_b);</div><div class="line">  pthread_mutex_unlock(&amp;mutex_a);</div><div class="line"></div><div class="line">  pthread_mutex_destroy(&amp;mutex_a);</div><div class="line">  pthread_mutex_destroy(&amp;mutex_b);</div><div class="line">  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种类型解法上面已经说了, “牺牲自己, 成全别人”: 使用trylock逻辑, 如果我拿不到别人的锁, 我先放弃自己已经占有的锁, 将来再去占锁.</p>
<p>总结起来也就是这样:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">pthread_mutex_lock(&amp;mutex_1);</div><div class="line"><span class="keyword">while</span> ( pthread_mutex_trylock(&amp;mutex_2) )  <span class="comment">/* Test if already locked   */</span></div><div class="line">&#123;</div><div class="line">   pthread_mutex_unlock(&amp;mutex_1);  <span class="comment">/* Free resource to avoid deadlock */</span></div><div class="line">   ...</div><div class="line">   <span class="comment">/* stall here   */</span></div><div class="line">   ...</div><div class="line">   pthread_mutex_lock(&amp;mutex_1);</div><div class="line">&#125;</div><div class="line">count++;</div><div class="line">pthread_mutex_unlock(&amp;mutex_2);</div><div class="line">pthread_mutex_unlock(&amp;mutex_1);</div></pre></td></tr></table></figure></p>
<h3 id="常见模型"><a href="#常见模型" class="headerlink" title="常见模型"></a>常见模型</h3><ul>
<li>生产者-消费者模型</li>
</ul>
<p>这里使用的是, 采用互斥量+条件变量一起使用的案例, 具体代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">/*static init*/</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> mutex = PTHREAD_MUTEX_INITIALIZER;</div><div class="line"><span class="keyword">pthread_cond_t</span> has_product = PTHREAD_COND_INITIALIZER;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> msg&#123;</div><div class="line">  <span class="keyword">int</span> num;</div><div class="line">  <span class="keyword">struct</span> msg *next;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">struct</span> msg *head = <span class="literal">NULL</span>;</div><div class="line"><span class="keyword">struct</span> msg *tmp = <span class="literal">NULL</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">productor</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line">    tmp = (<span class="keyword">struct</span> msg*) <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> msg));</div><div class="line"></div><div class="line">    tmp-&gt;num = rand() % <span class="number">100</span> + <span class="number">1</span>;</div><div class="line">    <span class="built_in">printf</span>(<span class="string">"---producer has produced %d \n"</span>, tmp-&gt;num);</div><div class="line"></div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line">    tmp-&gt;next = head;</div><div class="line">    head = tmp;</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line">    pthread_cond_signal(&amp;has_product); <span class="comment">/*producer Vs consumer = 1:1*/</span></div><div class="line">    </div><div class="line">    usleep(rand()%<span class="number">1000</span>); <span class="comment">//给消费者机会(否则一直生产内存耗尽)</span></div><div class="line"></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consumer</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">for</span>(;;) &#123;</div><div class="line"></div><div class="line">    <span class="comment">/*开始操作Msg队列*/</span></div><div class="line">    pthread_mutex_lock(&amp;mutex);</div><div class="line"></div><div class="line">    <span class="keyword">while</span>(head==<span class="literal">NULL</span>) &#123; <span class="comment">//队列为空, 放弃锁, 阻塞, 等待下一波唤醒</span></div><div class="line">      pthread_cond_wait(&amp;has_product, &amp;mutex);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">//有产品, 取走一个队头</span></div><div class="line">    tmp = head;</div><div class="line">    head = head-&gt;next;</div><div class="line">    pthread_mutex_unlock(&amp;mutex);</div><div class="line"></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"consumer  has consumed %d \n"</span>, tmp-&gt;num);</div><div class="line">    <span class="built_in">free</span>(tmp);</div><div class="line">    tmp = <span class="literal">NULL</span>;</div><div class="line">    usleep(rand()%<span class="number">1000</span>); <span class="comment">//给生产者机会    </span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">pthread_t</span> ptid, ctid; <span class="comment">//processer and consumer</span></div><div class="line"></div><div class="line">  <span class="comment">/*remember checking return code*/</span></div><div class="line">  pthread_create(&amp;ptid, <span class="literal">NULL</span>, productor, <span class="literal">NULL</span>);</div><div class="line">  pthread_create(&amp;ctid, <span class="literal">NULL</span>, consumer, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  pthread_join(ptid, <span class="literal">NULL</span>);</div><div class="line">  pthread_join(ctid, <span class="literal">NULL</span>);</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>信号量实现起来更加简单, 实现多生产者, 多消费者<br><img src="http://omotkhw3y.bkt.clouddn.com/pthread_sem.jpg" alt="信号量实现"><br>(定义两个信号量, 其中一个表示实际生产出来的产品数量, 另外一个信号量表示总共的产品 <code>(线性)队列</code> 空余容量)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;semaphore.h&gt;</span></span></div><div class="line"></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM 5</span></div><div class="line"><span class="keyword">int</span> <span class="built_in">queue</span>[NUM]=&#123;<span class="number">0</span>&#125;;  <span class="comment">//全局队列</span></div><div class="line"></div><div class="line"><span class="keyword">sem_t</span> blank_num, product_num; <span class="comment">//空余容量, 已生产容量</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*本案例中, 队列用的数组代替, </span></div><div class="line"> 所以队列的移动等操作忽略(可能出现消费者消费产品为0的情况)*/</div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">produce</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    sem_wait(&amp;blank_num); <span class="comment">//有空余才生产, 无空余则阻塞</span></div><div class="line">    <span class="built_in">queue</span>[i] = rand() % <span class="number">100</span> + <span class="number">1</span>; <span class="comment">//产生一个产品</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"----produced %d\n"</span>, <span class="built_in">queue</span>[i]);   </div><div class="line">    sem_post(&amp;product_num);</div><div class="line"></div><div class="line">    i = (i+<span class="number">1</span>) % NUM; <span class="comment">//逻辑环</span></div><div class="line">    sleep(rand()%<span class="number">1</span>); <span class="comment">//给消费者机会</span></div><div class="line"></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">consume</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</div><div class="line">  </div><div class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    sem_wait(&amp;product_num); <span class="comment">//有产品才消费, 没有产品则等待</span></div><div class="line">    <span class="comment">//队列首部出队</span></div><div class="line">    <span class="built_in">printf</span>(<span class="string">"consume %d\n"</span>, <span class="built_in">queue</span>[i]);</div><div class="line">    <span class="built_in">queue</span>[i] = <span class="number">0</span>;</div><div class="line">    sem_post(&amp;blank_num);</div><div class="line"></div><div class="line">    i = (i+<span class="number">1</span>) % NUM; <span class="comment">//逻辑环</span></div><div class="line">    sleep(rand()%<span class="number">3</span>); <span class="comment">//给生产者机会多生产</span></div><div class="line">  &#125;</div><div class="line">  </div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="comment">/*忽略rerurn code的检查*/</span></div><div class="line">  <span class="keyword">pthread_t</span> pid, cid;</div><div class="line">  sem_init(&amp;blank_num, <span class="number">0</span>, NUM);</div><div class="line">  sem_init(&amp;product_num, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">  pthread_create(&amp;pid, <span class="literal">NULL</span>, produce, <span class="literal">NULL</span>);</div><div class="line">  pthread_create(&amp;cid, <span class="literal">NULL</span>, consume, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  pthread_join(pid, <span class="literal">NULL</span>);</div><div class="line">  pthread_join(cid, <span class="literal">NULL</span>);</div><div class="line"></div><div class="line">  sem_destroy(&amp;blank_num);</div><div class="line">  sem_destroy(&amp;product_num);</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>哲学家问题</li>
</ul>
<p>这里有个很经典的分析过程, 具体略, 主要思想是:  要么能拿到2把锁, 开始就餐; 要么拿不到释放已经占有的锁(或者就餐完毕释放已经占有的两把锁)</p>
<p>下面可以采用 <code>mutex数组</code> 或者 <code>信号量</code> 去实现(思想类似)5个哲学家就餐问题:<br><img src="http://omotkhw3y.bkt.clouddn.com/pthread_ph.jpg" alt=""></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (i == <span class="number">4</span>) &#123;</div><div class="line">  left = i;</div><div class="line">  right = <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">  left = i;</div><div class="line">  right = i+<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/*或者用取模也可以*/</span></div><div class="line">left = i;</div><div class="line">right = (i+<span class="number">1</span>)%<span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>之后可以进行加锁操作:<br>左手加锁成功则尝试加右锁, 如果右锁加锁成功则就餐, 完毕释放资源(先释放右锁); 如果失败, 则释放左锁, 阻塞等待(再从加左锁开始).</p>
<p>代码如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line">struct hands</div><div class="line">&#123;</div><div class="line">  int left;</div><div class="line">  int right</div><div class="line">&#125;;</div><div class="line">*/</div><div class="line"></div><div class="line"><span class="comment">//strut hands[5]; //假设已经初始化完毕</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> m[<span class="number">5</span>]; <span class="comment">//假设已经初始化完毕</span></div><div class="line"><span class="keyword">pthread_t</span> t[<span class="number">5</span>]; <span class="comment">//假设已经初始化完毕并已经创建</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> *<span class="title">run</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span></div><div class="line">&#123;</div><div class="line">  <span class="comment">//通过传入参数得知自己是几号线程(哲学家)</span></div><div class="line">  <span class="keyword">int</span> pthread_num = (<span class="keyword">int</span>) arg; </div><div class="line">  <span class="keyword">int</span> left;</div><div class="line">  <span class="keyword">int</span> right;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (pthread_num == <span class="number">4</span>) &#123;</div><div class="line">    left = pthread_num;</div><div class="line">    right = <span class="number">0</span>;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    left = pthread_num;</div><div class="line">    right = pthread_num+<span class="number">1</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">    pthread_mutex_lock(&amp;m[left]);</div><div class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(&amp;m[right])) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"thread[%d] lock right failed, relese left lock %d\n"</span>, pthread_num, left);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"thread[%d] start eating\n"</span>, pthread_num);</div><div class="line">      pthread_mutex_unlock(&amp;m[right]);</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;m[left]);</div><div class="line">    usleep(<span class="number">500</span>); <span class="comment">//休息500毫秒再抢</span></div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>完整的代码可以是:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> N 5</span></div><div class="line"></div><div class="line"><span class="keyword">struct</span> hands</div><div class="line">&#123;</div><div class="line">  <span class="comment">//按照顺序前面N-1个哲学家线程抢left, 最后一个抢right</span></div><div class="line">  <span class="keyword">int</span> left; </div><div class="line">  <span class="keyword">int</span> right;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">pthread_t</span> t[N]; <span class="comment">//5个哲学家线程</span></div><div class="line"><span class="keyword">pthread_mutex_t</span> m[N]; <span class="comment">//5把锁</span></div><div class="line"><span class="keyword">struct</span> hands h[N];<span class="comment">//5个线程左右手对应锁的编号</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> * <span class="title">func</span><span class="params">(<span class="keyword">void</span> *arg)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">int</span> pthread_num = (<span class="keyword">int</span>) arg;</div><div class="line">  <span class="keyword">int</span> left = h[pthread_num].left;</div><div class="line">  <span class="keyword">int</span> right = h[pthread_num].right;</div><div class="line"></div><div class="line">  <span class="keyword">while</span> (<span class="number">1</span>) &#123;</div><div class="line">    pthread_mutex_lock(&amp;m[left]);</div><div class="line">    <span class="keyword">if</span> (pthread_mutex_trylock(&amp;m[right])) &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"thread[%d] lock right failed, relese left lock %d\n"</span>, pthread_num, left);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="built_in">printf</span>(<span class="string">"thread[%d] start eating\n"</span>, pthread_num);</div><div class="line">      pthread_mutex_unlock(&amp;m[right]);</div><div class="line">    &#125;</div><div class="line">    pthread_mutex_unlock(&amp;m[left]);</div><div class="line">    <span class="comment">//休息20纳秒再抢(不给别人机会很可能自己一直在loop)</span></div><div class="line">    <span class="comment">//给别人机会越多, 大家不容易冲突; 睡的少, 容易不停放锁</span></div><div class="line">    usleep(<span class="number">20</span>); </div><div class="line">  &#125;</div><div class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line"></div><div class="line">  </div><div class="line">  <span class="keyword">int</span> i;</div><div class="line">  </div><div class="line">  <span class="comment">//初始化</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">    <span class="comment">//初始化锁</span></div><div class="line">    <span class="keyword">if</span> (pthread_mutex_init(&amp;m[i], <span class="literal">NULL</span>) ) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"mutex[%d] init error\n"</span>, i);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化哲学家线程应该抢的锁</span></div><div class="line">    h[i].left = i;</div><div class="line">    h[i].right = (i+<span class="number">1</span>)%N;</div><div class="line">    </div><div class="line">    <span class="comment">//初始化线程</span></div><div class="line">    <span class="keyword">if</span> ( pthread_create(&amp;t[i], <span class="literal">NULL</span>, func, (<span class="keyword">void</span>*)i) ) &#123;</div><div class="line">      <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"thread[%d] init error\n"</span>, i);</div><div class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">  &#125;<span class="comment">//end of for init</span></div><div class="line"></div><div class="line"></div><div class="line">  <span class="comment">//join and destroy</span></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">    pthread_join(t[i], <span class="literal">NULL</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;N; i++) &#123;</div><div class="line">    pthread_mutex_destroy(&amp;m[i]);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于锁的选择, 其实可以使用信号量semophore.</p>
<p>sem_t s[N]; //value 0或者1<br>然后使用sem_wait以及sem_trywait, sem_post进行主要逻辑, 其过程类似上面的mutex.</p>
<p>(注意, 此处用的是信号量 <code>semaphore.h</code> 不建议使用信号 <code>sys/sem.h</code>, <code>sys/shm.h</code>, 多线程和信号兼容不好, 多进程问题可以使用信号 )</p>
<p>总结: 让哲学家按一定顺序就餐, 得不到时即释放当前获得的锁. </p>
<p>另外一种高效的方式是:<br> 引入一个对各个线程(进程)的调度者, 当哲学家饥饿时向该调度者申请用餐, 而调度者根据哲学家面前是否同时有两只筷子空闲来判断哲学家此时能否就餐, 能则占用这两只筷子并且让哲学家就餐, 不能则让哲学家继续等待. 引入一个调度者能很有效地管理进程资源的分配.  </p>
<h2 id="线程的调试"><a href="#线程的调试" class="headerlink" title="线程的调试"></a>线程的调试</h2><p>详细信息可以参看 <a href="">多线程-进程的调试</a> .</p>
<h2 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h2><p>线程的诸多好处, 貌似总是相对于进程的, 比如通信, 共享等都比进程方便; 但是线程也有不方便的:</p>
<ol>
<li>gdb调试困难</li>
<li>线程对于信号的支持不好</li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文几乎通篇都在介绍pthread API及其含义，使用，从线程的控制，线程的属性，mutex函数，条件变量函数，线程私有存储，同步屏障函数，读写锁，以及最后其他的一些uitl函数，比如equal(), detach(), self(), once();</p>
<p>可以看到，玩下来，基本上操作&amp;弄懂API没有多大难度，难的是理解这么设计的理由是什么？以及设计并发流程，换句话说，到目前为了所有的练习全部是为了掌握并发编程的工具，真正的核心可能在于并发的模式或者算法上，而相关内容本文并没有深入设计，而这方面你只能参考业界相关领域的大牛，甚至是写相关库的本人的论述。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.ibm.com/developerworks/library/l-posix1/" target="_blank" rel="external"> POSIX threads explained</a>  –IBM的技术贴很有趣</li>
<li><a href="">《Programming With POSIX Theads》</a> 作者: David R.Butenhof (市面上已经绝版)—强烈推荐</li>
<li><a href="">《Unix Networking Programming Volume 1》</a> chapter 26–作者: W.Richard Stevens等</li>
<li><a href="">《APUE》</a></li>
</ol>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2017/03/20/what-kind-of-things-we-deal-with.html" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2017/03/18/linux-unix-posix.html" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2017-03-19 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/codings/">codings<span>45</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/linux/">linux<span>9</span></a></li> <li><a href="/tags/thread/">thread<span>6</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#引子"><span class="toc-article-text">引子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#正文"><span class="toc-article-text">正文</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#线程的控制"><span class="toc-article-text">线程的控制</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#线程属性控制"><span class="toc-article-text">线程属性控制</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#修改线程属性的方法"><span class="toc-article-text">修改线程属性的方法</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#设置分离状态"><span class="toc-article-text">设置分离状态</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#修改栈大小"><span class="toc-article-text">修改栈大小</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#设置警戒区"><span class="toc-article-text">设置警戒区</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#其他属性"><span class="toc-article-text">其他属性</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#线程控制总结"><span class="toc-article-text">线程控制总结</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#线程的同步-重点"><span class="toc-article-text">线程的同步(重点)</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#线程同步"><span class="toc-article-text">线程同步</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#互斥量"><span class="toc-article-text">互斥量</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#读写锁"><span class="toc-article-text">读写锁</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#条件变量"><span class="toc-article-text">条件变量</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#信号量"><span class="toc-article-text">信号量</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#死锁"><span class="toc-article-text">死锁</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#常见模型"><span class="toc-article-text">常见模型</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#线程的调试"><span class="toc-article-text">线程的调试</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#其他注意事项"><span class="toc-article-text">其他注意事项</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#总结"><span class="toc-article-text">总结</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#参考资料"><span class="toc-article-text">参考资料</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 MerlinYu
  
     
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
