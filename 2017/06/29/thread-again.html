<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>thread-again | Merlin&#39;s Blog</title>
  <meta name="author" content="MerlinYu">
  
  <meta name="description" content="techniques of thread in c++">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="thread-again"/>
  <meta property="og:site_name" content="Merlin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="ico">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Merlin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> thread-again</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> techniques of thread in c++
		 </div> <!-- alert -->
	  		

	  <p>如果不看 Futures 库, 整个 C++ 并发库, 就跟 pthread 没有啥区别. 如果加上Futures库, 整个和Boost又没有太多差别. 总之, 整个C++并发库貌似都是在炒冷饭的样子, 不是移植boost, 就是封装底层线程库(例如pthread), 没办法还是仔细说说吧.</p>
<p>关于Pthread, 可以参考我的博文:  <a href="http://www.merlinblog.site/2017/03/19/linux-pthread.html" target="_blank" rel="external">posix-thread</a><br>关于Boost, 可以参考我的博文: <a href="http://www.merlinblog.site/2017/06/21/boost.html" target="_blank" rel="external">Boost总结</a></p>
<blockquote>
<p>本文会花非常大的力气总结C++11并发库</p>
</blockquote>
<a id="more"></a>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>C+11中的实现基本和Boost一致, 只不过命名空间不一样以及涉及的头文件不一样:</p>
<ul>
<li>atomic</li>
<li>mutex</li>
<li>thread</li>
<li>condition_variable</li>
<li>future</li>
</ul>
<p>并且相关效率也不一样, 一般认为: lock, atomic, spinlock三者的效率相当, 但是mutex效率低. (这也是你看到为啥和libevent相比, 不管是asio还是多线程框架, 基本讨不到偏移, 可能就是因为mutex的关系).</p>
<p><code>《C++ Concurrency In Action》</code> 真本书非常推荐, 如果没有时间看完一本书, 那么直接看我说精华, 也不错.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先c++, 或者boost 为了我们方便的使用线程, 做了很多封装, 什么gud之类的, 反而影响了我们对于线程范畴内最本质内容的理解:</p>
<ul>
<li>线程的控制(创建，销毁/分离)</li>
<li>线程的同步(信号量(PV)，互斥量，竞争/冒险条件，文件锁，屏障)</li>
<li>线程的属性</li>
<li>线程的调试(多线程其实是不好调试的)</li>
</ul>
<hr>
<p>根据 <a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="external">Cppreference</a> 的说法, C++11并发库包含以下内容:</p>
<ul>
<li>atomic<br>该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数.<br>这个和boost是一致的, 不适用锁就能同步的原子操作</li>
<li>thread<br>该头文件主要声明了 std::thread 类, 另外 <code>std::this_thread</code> 命名空间也在该头文件中.</li>
<li>mutex<br>该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数</li>
<li>condition_variable<br>该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any</li>
<li>future<br>该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类<br>另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中</li>
</ul>
<p>其中最后一个future由于涉及到了异步任务, 相当于对于线程的封装. 异步任务可以参考我的文章 <a href="http://www.merlinblog.site/2017/08/11/Asio.html" target="_blank" rel="external">Asio</a></p>
<p>讲真, 从pthread切换过来, 没有感觉到幸福可能是因为pthread api用熟悉了, 但是不得不说c++并发库, 使得并发编程变得简单了.</p>
<p>直接上手一个demo:<br><img src="http://omotkhw3y.bkt.clouddn.com/cpp_thread.jpg" alt=""></p>
<p>可以看到老奸巨猾的c++11, 还是只给出了标准, 具体的实现, 要依赖系统平台的库.</p>
<p>也就是说, linux平台, 我们完全可以认为, c++ 并发库给出了统一的操作API, 实际上是封装了pthread操作(具体封装过程可以参考具体的头文件, 比如创建线程这个, 其实就是根据_type参数判断对应pthread_create()的哪种调用).</p>
<p>虽然只是封装, 但是, 确实精简了太多! 例如我要给线程执行函数传参, 看看下面是不是够简单的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> n1 = <span class="number">500</span>;</div><div class="line">    <span class="keyword">int</span> n2 = <span class="number">600</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([&amp;](<span class="keyword">int</span> addNum)</span></span>&#123;</div><div class="line">        n1 += addNum;</div><div class="line">        n2 += addNum;</div><div class="line">    &#125;,<span class="number">500</span>);</div><div class="line">    t.join();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">' '</span> &lt;&lt; n2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面开始细说</p>
<hr>
<h2 id="Threads库"><a href="#Threads库" class="headerlink" title="Threads库"></a>Threads库</h2><p>定义在 <code>thread</code> 头文件下, 该库就两大块儿</p>
<ul>
<li>thread类</li>
<li>this_thread命名空间</li>
</ul>
<h3 id="thread类"><a href="#thread类" class="headerlink" title="thread类"></a>thread类</h3><p>主要说说他的构造器, 赋值函数(移动函数)等成员函数的使用.</p>
<p>构造器:</p>
<ul>
<li><p>默认构造函数，创建一个空的 thread 执行对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread() <span class="keyword">noexcept</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> Fn, <span class="keyword">class</span>... Args&gt;</div><div class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">thread</span> <span class="params">(Fn&amp;&amp; fn, Args&amp;&amp;... args)</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread (<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread (thread&amp;&amp; x) <span class="keyword">noexcept</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>参考代码:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;functional&gt;</div><div class="line"> </div><div class="line">void f1(int n)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</div><div class="line">        std::cout &lt;&lt; "Thread " &lt;&lt; n &lt;&lt; " executing\n";</div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">void f2(int&amp; n)</div><div class="line">&#123;</div><div class="line">    for (int i = 0; i &lt; 5; ++i) &#123;</div><div class="line">        std::cout &lt;&lt; "Thread 2 executing\n";</div><div class="line">        ++n;</div><div class="line">        std::this_thread::sleep_for(std::chrono::milliseconds(10));</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    int n = 0;</div><div class="line">    std::thread t1; // t1 is not a thread</div><div class="line">    std::thread t2(f1, n + 1); // pass by value</div><div class="line">    std::thread t3(f2, std::ref(n)); // pass by reference</div><div class="line">    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread</div><div class="line">    t2.join();</div><div class="line">    t4.join();</div><div class="line">    std::cout &lt;&lt; "Final value of n is " &lt;&lt; n &lt;&lt; '\n';</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>移动赋值函数</p>
<ul>
<li><p>move 赋值操作，如果当前对象不可 joinable，传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则调用 terminate() .</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; rhs) <span class="keyword">noexcept</span>;</div></pre></td></tr></table></figure>
</li>
<li><p>拷贝赋值操作被禁用，thread 对象不可被拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">thread&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>其他成员函数:</p>
<ul>
<li><p>bool joinable() const noexcept; 检查某个线程是否可以被joinable (正在运行的可以被joinable)<br>代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread t;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before starting, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    t = <span class="built_in">std</span>::thread(foo);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after starting, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    t.join();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after joining, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">/* 运行结果:</span></div><div class="line">before starting, joinable: 0</div><div class="line">after starting, joinable: 1</div><div class="line">after joining, joinable: 0</div><div class="line">*/</div></pre></td></tr></table></figure>
<p><code>最好把joinable理解成正在运行</code> , 后面说成员数join的时候, 还会用到.</p>
</li>
<li>std::thread::id get_id() const noexcept; 获取线程id</li>
<li><p>native_handle_type native_handle(); 返回一个线程handler, 用于实时调度<br>由于系统对于实时调度的支持不同, 所以下面的代码不一定成功.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;chrono&gt;</div><div class="line">#include &lt;cstring&gt;</div><div class="line">#include &lt;pthread.h&gt;</div><div class="line"> </div><div class="line">std::mutex iomutex;</div><div class="line">void f(int num)</div><div class="line">&#123;</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div><div class="line"> </div><div class="line">    sched_param sch;</div><div class="line">    int policy; </div><div class="line">    pthread_getschedparam(pthread_self(), &amp;policy, &amp;sch);</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lk(iomutex);</div><div class="line">    std::cout &lt;&lt; "Thread " &lt;&lt; num &lt;&lt; " is executing at priority "</div><div class="line">              &lt;&lt; sch.sched_priority &lt;&lt; '\n';</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::thread t1(f, 1), t2(f, 2);</div><div class="line"> </div><div class="line">    sched_param sch;</div><div class="line">    int policy; </div><div class="line">    pthread_getschedparam(t1.native_handle(), &amp;policy, &amp;sch);</div><div class="line">    sch.sched_priority = 20;</div><div class="line">    if (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &amp;sch)) &#123;</div><div class="line">        std::cout &lt;&lt; "Failed to setschedparam: " &lt;&lt; std::strerror(errno) &lt;&lt; '\n';</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    t1.join(); t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>static unsigned int hardware_concurrency() noexcept; 返回并发数的参考</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="comment">//注意这是个静态方法</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="built_in">std</span>::thread::hardware_concurrency();</div><div class="line">     <span class="comment">//结果和你的逻辑处理器processor个数保持一致, cat /proc/cpuinfo </span></div><div class="line">      <span class="comment">//每个processor 启动一个硬件线程</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" concurrent threads are supported.\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>void join(); 阻塞等待回收其他线程; 只有本线程 <code>joinable is false</code> , 即当前不在运行, 才可以回收其他线程, 否则出现自己等待回收自己, 那就是死锁了.</p>
</li>
<li><p>void detach(); 主要是设置分离的线程自己调用detach方法, 必须当前线程在运行, 即joinable才可以.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">independentThread</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting concurrent thread.\n"</span>;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting concurrent thread.\n"</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCaller</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting thread caller.\n"</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(independentThread)</span></span>;</div><div class="line">    t.detach();</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting thread caller.\n"</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;</div><div class="line">    threadCaller();</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>void swap( thread&amp; other ) noexcept; 交换线程对象所绑定的具体线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(bar)</span></span>;</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::swap(t1, t2);</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after std::swap(t1, t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">    t1.swap(t2);</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after t1.swap(t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"> </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/*运行结果*/</span></div><div class="line">thread <span class="number">1</span> id: <span class="number">1892</span></div><div class="line">thread <span class="number">2</span> id: <span class="number">2584</span></div><div class="line">after <span class="built_in">std</span>::swap(t1, t2):</div><div class="line">thread <span class="number">1</span> id: <span class="number">2584</span></div><div class="line">thread <span class="number">2</span> id: <span class="number">1892</span></div><div class="line">after t1.swap(t2):</div><div class="line">thread <span class="number">1</span> id: <span class="number">1892</span></div><div class="line">thread <span class="number">2</span> id: <span class="number">2584</span></div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h3><p>这个命名空间下, 主要说几个函数:</p>
<ul>
<li><p>yield : void yield() noexcept; 让出cpu, 让其他线程执行.<br>是否阻塞让出cpu和操作系统的实现有关, 也就是说这只是个建议. For example, a first-in-first-out realtime scheduler (SCHED_FIFO in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, yield has no effect). 样例代码可以看下面:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"> </div><div class="line"><span class="comment">// "busy sleep" while suggesting that other threads run </span></div><div class="line"><span class="comment">// for a small amount of time</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">little_sleep</span><span class="params">(<span class="built_in">std</span>::chrono::microseconds us)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">    <span class="keyword">auto</span> end = start + us;</div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">       <span class="comment">//使用的时候注意加上命名空间</span></div><div class="line">        <span class="built_in">std</span>::this_thread::yield();</div><div class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">std</span>::chrono::high_resolution_clock::now() &lt; end);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line"> </div><div class="line">    little_sleep(<span class="built_in">std</span>::chrono::microseconds(<span class="number">100</span>));</div><div class="line"> </div><div class="line">    <span class="keyword">auto</span> elapsed = <span class="built_in">std</span>::chrono::high_resolution_clock::now() - start;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waited for "</span></div><div class="line">              &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::microseconds&gt;(elapsed).count()</div><div class="line">              &lt;&lt; <span class="string">" microseconds\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>get_id : std::thread::id get_id() noexcept; 获取当前线程的id, 类型为 std::thread::id</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"> </div><div class="line"><span class="built_in">std</span>::mutex g_display_mutex;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::thread::id this_id = <span class="built_in">std</span>::this_thread::get_id();</div><div class="line"> </div><div class="line">    g_display_mutex.lock();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread "</span> &lt;&lt; this_id &lt;&lt; <span class="string">" sleeping...\n"</span>;</div><div class="line">    g_display_mutex.unlock();</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(foo)</span></span>;</div><div class="line"> </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>sleep_for: 主动睡眠放弃cpu一定时间, 之后自动醒来.(由系统调度), 代码原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt; <span class="comment">//Rep数字计数单位, Period时间单位</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_for</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::chrono::duration&lt;Rep, Period&gt;&amp; sleep_duration )</span></span>;</div></pre></td></tr></table></figure>
<p>基本使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello waiter"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">    </div><div class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">2</span>s);</div><div class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</div><div class="line">    <span class="comment">// 注意持续的时间可以使用std::chrono::duration并提供单位</span></div><div class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt; elapsed = end-start;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waited "</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="string">" ms\n"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
<li><p>sleep_until 睡眠到某个时间点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration &gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">sleep_until</span><span class="params">( <span class="keyword">const</span> <span class="built_in">std</span>::chrono::time_point&lt;Clock,Duration&gt;&amp; sleep_time )</span></span>;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>std::this_thread下的这几个函数还是经常用到的:</p>
<ul>
<li>yield</li>
<li>get_id</li>
<li>sleep_for</li>
<li>sleep_until</li>
</ul>
<h2 id="Mutex库"><a href="#Mutex库" class="headerlink" title="Mutex库"></a>Mutex库</h2><p>On Linux, it uses pthreads underlying. So it can be thought of pthreads wrapped in C++ style objects. 但是讲到mutex锁, 它提供了一种全新的使用方式.<br>mutex库, 主要是围绕 mutex 以及 lock 展开 (当然也包括它们的变形和封装体). 此外把call_once相关的内容也放入了头文件 <code>mutex</code> 这里.</p>
<p>先看下, 以前再Boost是怎么用的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">int</span> globalVariable;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Reader</div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Reader(<span class="keyword">int</span> waitTime) &#123; _waitTime = waitTime;&#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reader Api: "</span> &lt;&lt; globalVariable &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">        usleep(_waitTime);</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _waitTime;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">class</span> Writer</div><div class="line">&#123;</div><div class="line">  <span class="keyword">public</span>:</div><div class="line">    Writer(<span class="keyword">int</span> variable, <span class="keyword">int</span> waitTime)</div><div class="line">    &#123;</div><div class="line">      _writerVariable = variable;</div><div class="line">      _waitTime = waitTime;</div><div class="line">    &#125;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</div><div class="line">        usleep(_waitTime);</div><div class="line">        <span class="comment">// Take lock and modify the global variable</span></div><div class="line">        boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(_writerMutex)</span></span>;</div><div class="line">        globalVariable = _writerVariable;</div><div class="line">        _writerVariable++;</div><div class="line">        <span class="comment">// since we have used scoped lock, </span></div><div class="line">        <span class="comment">// it automatically unlocks on going out of scope</span></div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <span class="keyword">int</span> _writerVariable;</div><div class="line">    <span class="keyword">int</span> _waitTime;</div><div class="line">    <span class="keyword">static</span> boost::mutex _writerMutex;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">boost::mutex</div><div class="line">Writer::_writerMutex;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="function">Reader <span class="title">reads</span><span class="params">(<span class="number">100</span>)</span></span>;</div><div class="line">  <span class="function">Writer <span class="title">writes1</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</div><div class="line">  <span class="function">Writer <span class="title">writes2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</div><div class="line"></div><div class="line">  boost::<span class="function">thread <span class="title">readerThread</span><span class="params">(reads)</span></span>;</div><div class="line">  boost::<span class="function">thread <span class="title">writerThread1</span><span class="params">(writes1)</span></span>;</div><div class="line">  usleep(<span class="number">100</span>);</div><div class="line">  boost::<span class="function">thread <span class="title">writerThread2</span><span class="params">(writes2)</span></span>;</div><div class="line"></div><div class="line">  readerThread.join();</div><div class="line">  writerThread1.join();</div><div class="line">  writerThread2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译运行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">$ g++ -o boost_mutex boost_mutex.cpp -lboost_thread -lboost_system</div><div class="line">$ ./boost_mutex</div><div class="line">Reader Api: <span class="number">100</span></div><div class="line">Reader Api: <span class="number">100</span></div><div class="line">Reader Api: <span class="number">200</span></div><div class="line">Reader Api: <span class="number">103</span></div><div class="line">Reader Api: <span class="number">104</span></div><div class="line">Reader Api: <span class="number">204</span></div><div class="line">Reader Api: <span class="number">205</span></div><div class="line">Reader Api: <span class="number">206</span></div><div class="line">Reader Api: <span class="number">207</span></div></pre></td></tr></table></figure></p>
<p>但是加锁和解锁的过程, 用了一个 <code>boost::mutex::scoped_lock lock(_writerMutex);</code> 相当简单.</p>
<p>boost thread就说这么多, 下面接着说c++的mutex库.</p>
<h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>首先要说的是, 在C++线程库, 很少有, 手动加锁然后解锁的这种传统流程(当然也可以这么做), 一般是使用手动加锁, 自动解锁的形式, 即 一般使用的是 <code>lock_guard</code>, <code>unique_lock</code> 等包装类, 但是包装类也需要Mutex作为锁的基本. 所以还是要介绍一下 mutex 锁: </p>
<ul>
<li>mutex 基本的排它锁(类)</li>
<li>timed_mutex  定时 Mutex (类)</li>
<li>recursive_mutex  递归锁(可以重复上锁)</li>
<li>recursive_timed_mutex 定时递归锁</li>
</ul>
<p>当然也有共享锁:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;mutex&gt;</div><div class="line">shared_timed_mutex :	provides shared mutual exclusion facility  (C++14)</div><div class="line">shared_mutex :          provides shared mutual exclusion facility  (C++17)</div></pre></td></tr></table></figure></p>
<p>基本锁 mutex 类, 仅提供了传统的流程方法:</p>
<ul>
<li>lock : locks the mutex, blocks if the mutex is not available </li>
<li>try_lock : tries to lock the mutex, returns if the mutex is not available </li>
<li>unlock : unlocks the mutex </li>
</ul>
<p>以try_lock为例, 案例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line">#include &lt;chrono&gt;</div><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;iostream&gt; // std::cout</div><div class="line"> </div><div class="line">std::chrono::milliseconds interval(100);</div><div class="line"> </div><div class="line">std::mutex mutex;</div><div class="line">int job_shared = 0; //两个线程要修改的(共享)量</div><div class="line"> </div><div class="line">int job_exclusive = 0; // 两个线程要修改的量, 但不提供mutex保护</div><div class="line"> </div><div class="line">// this thread can modify both &apos;job_shared&apos; and &apos;job_exclusive&apos;</div><div class="line">void job_1() </div><div class="line">&#123;</div><div class="line">    std::this_thread::sleep_for(interval); // let &apos;job_2&apos; take a lock</div><div class="line"> </div><div class="line">    while (true) &#123;  //使用 try_lock 离不开循环</div><div class="line">        // try to lock mutex to modify &apos;job_shared&apos;</div><div class="line">        if (mutex.try_lock()) &#123;</div><div class="line">            std::cout &lt;&lt; &quot;job shared (&quot; &lt;&lt; job_shared &lt;&lt; &quot;)\n&quot;;</div><div class="line">            mutex.unlock(); //能加上锁, 自然用完要解锁</div><div class="line">            return;</div><div class="line">        &#125; else &#123;</div><div class="line">            // can&apos;t get lock to modify &apos;job_shared&apos;</div><div class="line">            // but there is some other work to do</div><div class="line">            ++job_exclusive;</div><div class="line">            std::cout &lt;&lt; &quot;job exclusive (&quot; &lt;&lt; job_exclusive &lt;&lt; &quot;)\n&quot;;</div><div class="line">            std::this_thread::sleep_for(interval);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// this thread can modify only &apos;job_shared&apos;</div><div class="line">void job_2() </div><div class="line">&#123;</div><div class="line">    mutex.lock();</div><div class="line">    std::this_thread::sleep_for(5 * interval);</div><div class="line">    ++job_shared;</div><div class="line">    mutex.unlock();</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main() </div><div class="line">&#123;</div><div class="line">    std::thread thread_1(job_1);</div><div class="line">    std::thread thread_2(job_2);</div><div class="line"> </div><div class="line">    thread_1.join();</div><div class="line">    thread_2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他额锁, 定时锁和递归锁(重复锁), 主要方法和mutex类相似, 但是稍稍做了改进, 比如定时锁, 如果一直拿不到锁, 这个线程要不要这么傻等着? 要等多久? 要等到某个时刻? 而递归锁则是为同一个线程反复加锁提供了方便, 里三层外三层, 只要是同一个线程, 可以多次对同一个锁进行加锁(解锁次数也要匹配, 不然会报错std::system_error), 但是如果别的线程已经拿到了锁, 别说加三层, 一层也加不了, 所以递归锁方便的是本线程自己; 和其他线程的互斥性不变.</p>
<p>定时锁多了两个方法:</p>
<ul>
<li>try_lock_for (public member function)<br>tries to lock the mutex, returns if the mutex has been unavailable for the specified timeout duration </li>
<li>try_lock_until<br>tries to lock the mutex, returns if the mutex has been unavailable until specified time point has been reached </li>
</ul>
<p>(注意它们的返回值, 成功返回true, 失败返回false; 如果已经有所了, 还在try_lock, 那么其行为是未定义的, 看具体的平台具体怎么实现吧)<br>例如, try_lock_for: Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.</p>
<p>给一个写的不是太好的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></div><div class="line"></div><div class="line"><span class="comment">// control access to std::cout (非核心逻辑)</span></div><div class="line"><span class="built_in">std</span>::mutex cout_mutex; </div><div class="line"></div><div class="line"><span class="comment">//下面开辟的线程集合, 都在抢这个锁进行ostringstreams输出</span></div><div class="line"><span class="built_in">std</span>::timed_mutex mutex; </div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">job</span><span class="params">(<span class="keyword">int</span> id)</span> </span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> Ms = <span class="built_in">std</span>::chrono::milliseconds;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> stream;</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</div><div class="line">        <span class="keyword">if</span> (mutex.try_lock_for(Ms(<span class="number">100</span>))) &#123;</div><div class="line">            stream &lt;&lt; <span class="string">"success "</span>;</div><div class="line">            <span class="built_in">std</span>::this_thread::sleep_for(Ms(<span class="number">100</span>));</div><div class="line">            mutex.unlock();</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            stream &lt;&lt; <span class="string">"failed "</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">std</span>::this_thread::sleep_for(Ms(<span class="number">100</span>));</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; id &lt;&lt; <span class="string">"] "</span> &lt;&lt; stream.str() &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></div><div class="line">&#123;   <span class="comment">//线程集合</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</div><div class="line">        threads.emplace_back(job, i);</div><div class="line">    &#125;</div><div class="line"> </div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: threads) &#123;</div><div class="line">        i.join();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再次强调一下:</p>
<blockquote>
<p>一般很少会用一个Mutex自己去调用成员方法加锁的, 更多的使用全局加锁方法(针对多个锁, 同时或者顺序加锁) 或者 加锁的包装类比如lock_guard或者unique_lock等</p>
</blockquote>
<h3 id="全局加锁算法"><a href="#全局加锁算法" class="headerlink" title="全局加锁算法"></a>全局加锁算法</h3><p>本来上面的 mutex 类自身已经提供了lock 和 try_lock方法, 这里又针对不同锁(单个或者多个, 是否需要顺序加锁)提供了通用方法: (其实是对mutex.lock, unlock等的封装)</p>
<ul>
<li><p>std::lock 阻塞加锁<br>locks specified mutexes, blocks if any are unavailable </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Lockable1, <span class="keyword">class</span> Lockable2, <span class="keyword">class</span>... LockableN &gt;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">( Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn )</span></span>;</div></pre></td></tr></table></figure>
</li>
<li><p>std::try_lock 异步加锁<br>attempts to obtain ownership of mutexes via repeated calls to try_lock </p>
</li>
</ul>
<p>这些加锁方法其实是去调用每种lockable对象, 即mutex自身的方法, 然后加锁, 并且不会死锁, 原因如下:</p>
<blockquote>
<p>Locks the given Lockable objects lock1, lock2, …, lockn using a deadlock avoidance algorithm to avoid deadlock. The objects are locked by an unspecified series of calls to lock, try_lock, unlock. If a call to lock or unlock results in an exception, unlock is called for any locked objects before rethrowing.</p>
</blockquote>
<p>简单解释就是, 好比你要连续加两个锁, 现在加完第一个锁, 正要加第二锁的时候, 被强占了cpu, 导致了第二所没有获取, 之后造成了死锁; 如果想要连续一次性加几个锁, 就要这个方法就对了.</p>
<p>但是通用加锁算法, 只提供了加锁, 没有提供解锁方法, 所以, 一般要配合 <code>lock_guard</code> 或者 <code>unique_lock</code> 这类加锁封装类(其实就是把锁作为资源, 用raii手法封装起来)来使用, 下面给出一个案例:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;chrono&gt;</div><div class="line">#include &lt;string&gt;</div><div class="line"> </div><div class="line">struct Employee &#123;</div><div class="line">    Employee(std::string id) : id(id) &#123;&#125;</div><div class="line">    std::string id;</div><div class="line">    std::vector&lt;std::string&gt; lunch_partners;</div><div class="line">    std::mutex m;</div><div class="line">    std::string output() const</div><div class="line">    &#123;</div><div class="line">        std::string ret = "Employee " + id + " has lunch partners: ";</div><div class="line">        for( const auto&amp; partner : lunch_partners )</div><div class="line">            ret += partner + " ";</div><div class="line">        return ret;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">void send_mail(Employee &amp;, Employee &amp;)</div><div class="line">&#123;</div><div class="line">    // simulate a time-consuming messaging operation</div><div class="line">    std::this_thread::sleep_for(std::chrono::seconds(1));</div><div class="line">&#125;</div><div class="line"> </div><div class="line">// 线程执行方法</div><div class="line">// 某个Employee往自己的 lunch_partners 列表中添加人员的时候, 不允许其他线程同时操作.</div><div class="line">// assign_lunch_partners 把相关的双方互相添加联系, 所以两个Employee都要加锁</div><div class="line">void assign_lunch_partner(Employee &amp;e1, Employee &amp;e2)</div><div class="line">&#123;</div><div class="line">/* 非核心逻辑</div><div class="line">   static std::mutex io_mutex;</div><div class="line"></div><div class="line">   </div><div class="line">   // 确保cout过程不被其他线程打断, 可以连续输出</div><div class="line">    &#123;</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk(io_mutex);</div><div class="line">        std::cout &lt;&lt; e1.id &lt;&lt; " and " &lt;&lt; e2.id &lt;&lt; " are waiting for locks" &lt;&lt; std::endl;</div><div class="line">    &#125;</div><div class="line">*/</div><div class="line">    // use std::lock to acquire two locks without worrying about </div><div class="line">    // other calls to assign_lunch_partner deadlocking us</div><div class="line">    &#123;</div><div class="line">	//不用检查返回值, 因为加不上锁, 它就一直傻等</div><div class="line">        std::lock(e1.m, e2.m);</div><div class="line">			//adopt_lock表示已经加锁了, 调用lock_guard时不必再去加锁了</div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk1(e1.m, std::adopt_lock); </div><div class="line">        std::lock_guard&lt;std::mutex&gt; lk2(e2.m, std::adopt_lock);</div><div class="line">				    </div><div class="line"></div><div class="line">					</div><div class="line">// Equivalent code (if unique_locks are needed, e.g. for condition variables)</div><div class="line">//        std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</div><div class="line">//        std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</div><div class="line">//        std::lock(lk1, lk2);</div><div class="line"></div><div class="line"></div><div class="line">/*  非核心逻辑</div><div class="line">	//同样确保输出过程不被打断</div><div class="line">        &#123;</div><div class="line">            std::lock_guard&lt;std::mutex&gt; lk(io_mutex);</div><div class="line">            std::cout &lt;&lt; e1.id &lt;&lt; " and " &lt;&lt; e2.id &lt;&lt; " got locks" &lt;&lt; std::endl;</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">*/			</div><div class="line">        e1.lunch_partners.push_back(e2.id);</div><div class="line">        e2.lunch_partners.push_back(e1.id);</div><div class="line">    &#125;</div><div class="line">    send_mail(e1, e2);</div><div class="line">    send_mail(e2, e1);</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");</div><div class="line"> </div><div class="line">    // assign in parallel threads because mailing users about lunch assignments</div><div class="line">    // takes a long time</div><div class="line">    std::vector&lt;std::thread&gt; threads;</div><div class="line">    threads.emplace_back(assign_lunch_partner, std::ref(alice), std::ref(bob));</div><div class="line">    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(bob));</div><div class="line">    threads.emplace_back(assign_lunch_partner, std::ref(christina), std::ref(alice));</div><div class="line">    threads.emplace_back(assign_lunch_partner, std::ref(dave), std::ref(bob));</div><div class="line"> </div><div class="line">    for (auto &amp;thread : threads) thread.join();</div><div class="line">    std::cout &lt;&lt; alice.output() &lt;&lt; '\n'  &lt;&lt; bob.output() &lt;&lt; '\n'</div><div class="line">              &lt;&lt; christina.output() &lt;&lt; '\n' &lt;&lt; dave.output() &lt;&lt; '\n';</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是如果不用封装类, lock_guard或者unique_lock, 就应该让每个lockable对象分别自己解锁. </p>
<p>std::try_lock也是类似的, 只不过相当于std::lock, 它是非阻塞的, 所以注意检查它的 <code>返回值</code> :(拿不到锁, 它又不会傻等)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Lockable1, <span class="keyword">class</span> Lockable2, <span class="keyword">class</span>... LockableN&gt;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">try_lock</span><span class="params">( Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn)</span></span>;</div></pre></td></tr></table></figure></p>
<p>按你给定的顺序加锁, 全部成功, 返回-1; 如果哪一个失败就返回哪一个的索引(参数的索引从0开始, 即0-based). 通常仅当所有的加锁成功, 即返回-1的时候才停止try_lock尝试.</p>
<p>可以看下面的代码: (多个锁的 try_lock 实验)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div></pre></td><td class="code"><pre><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;functional&gt;</div><div class="line">#include &lt;chrono&gt;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    /*一个锁保护一个变量, 两个线程, 分别增加foo_count, bar_count*/</div><div class="line">    int foo_count = 0; std::mutex foo_count_mutex;</div><div class="line">    int bar_count = 0; std::mutex bar_count_mutex;</div><div class="line">    int overall_count = 0; //上面两个锁都拿到才修改总数</div><div class="line">    </div><div class="line">    //主线程, 即main函数所在线程控制是否结束 done 标志, 多余的锁, 见下面分析</div><div class="line">    bool done = false; //std::mutex done_mutex;</div><div class="line">    </div><div class="line"> </div><div class="line"> //线程执行函数(用来修改 foo_count, bar_count)</div><div class="line">    auto increment = [](int &amp;counter, std::mutex &amp;m,  const char *desc) &#123;</div><div class="line">        for (int i = 0; i &lt; 10; ++i) &#123;</div><div class="line">            std::unique_lock&lt;std::mutex&gt; lock(m);</div><div class="line">            ++counter;</div><div class="line">            std::cout &lt;&lt; desc &lt;&lt; ": " &lt;&lt; counter &lt;&lt; '\n';</div><div class="line">            lock.unlock();</div><div class="line">            std::this_thread::sleep_for(std::chrono::seconds(1));</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"> </div><div class="line">    std::thread increment_foo(increment, std::ref(foo_count), </div><div class="line">        std::ref(foo_count_mutex), "foo");</div><div class="line">    std::thread increment_bar(increment, std::ref(bar_count), </div><div class="line">        std::ref(bar_count_mutex), "bar");</div><div class="line"> </div><div class="line">    std::thread update_overall([&amp;]() &#123;</div><div class="line">    </div><div class="line">	//本线程和main线程共同受到done标志的相应, 只是本线程只是检查, 并不修改.</div><div class="line">						  // 所以下面弄什么 done_mutex其实是多余</div><div class="line">        //done_mutex.lock();</div><div class="line">		</div><div class="line">        while (!done) &#123;</div><div class="line">            //done_mutex.unlock();</div><div class="line">            int result = std::try_lock(foo_count_mutex, bar_count_mutex);</div><div class="line">            if (result == -1) &#123; //两个锁我都拿到才修改overall_count</div><div class="line">                overall_count += foo_count + bar_count;</div><div class="line">                foo_count = 0;</div><div class="line">                bar_count = 0;</div><div class="line">                std::cout &lt;&lt; "overall: " &lt;&lt; overall_count &lt;&lt; '\n';</div><div class="line">                foo_count_mutex.unlock();</div><div class="line">                bar_count_mutex.unlock();</div><div class="line">            &#125;</div><div class="line">            std::this_thread::sleep_for(std::chrono::seconds(2));</div><div class="line">            //done_mutex.lock();</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">        //done_mutex.unlock();</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    increment_foo.join(); //foo_count 增加到10完毕, 回收线程</div><div class="line">    increment_bar.join(); //bar_count 增加到10完毕, 回收线程</div><div class="line">    </div><div class="line">    //done_mutex.lock();</div><div class="line">    done = true;</div><div class="line">    //done_mutex.unlock();</div><div class="line">    </div><div class="line">    update_overall.join();</div><div class="line"> </div><div class="line">    std::cout &lt;&lt; "Done processing\n"</div><div class="line">              &lt;&lt; "foo: " &lt;&lt; foo_count &lt;&lt; '\n'</div><div class="line">              &lt;&lt; "bar: " &lt;&lt; bar_count &lt;&lt; '\n'</div><div class="line">              &lt;&lt; "overall: " &lt;&lt; overall_count &lt;&lt; '\n';</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="lock类结构"><a href="#lock类结构" class="headerlink" title="lock类结构"></a>lock类结构</h3><p>BasicLockable 类型的对象只需满足两种操作，lock 和 unlock，<br>Lockable 类型，在 BasicLockable 类型的基础上新增了 try_lock 操作，因此一个满足 Lockable 的对象应支持三种操作：lock，unlock 和 try_lock；<br>TimedLockable 类型，在 Lockable 类型的基础上又新增了 try_lock_for 和 try_lock_until 2种操作，因此一个满足 TimedLockable 的对象应支持五种操作：lock, unlock, try_lock, try_lock_for, try_lock_until</p>
<h3 id="lock包装类"><a href="#lock包装类" class="headerlink" title="lock包装类"></a>lock包装类</h3><p>C++11中单个锁的包装类, 构造的时候m.lock, 析构的时候自动m.unlock (其实就是把锁作为资源, 用raii手法封装起来):</p>
<ul>
<li><code>std::lock_guard</code> 方便线程对互斥量上锁(RAII 手法)的包装类<br>implements a strictly scope-based mutex ownership wrapper </li>
<li><code>std::unique_lock</code> 方便线程对互斥量上锁, 但提供了更好的上锁和解锁控制的包装类<br>implements movable mutex ownership wrapper </li>
</ul>
<p>(严格来说 std::unique_lock应该归类为BasicLockable类型, 即和mutex归为一类) </p>
<p>C++14和C++17中的包装类:</p>
<ul>
<li>shared_lock<br>implements movable shared mutex ownership wrapper </li>
<li>scoped_lock<br>deadlock-avoiding RAII wrapper for multiple mutexes </li>
</ul>
<p>(主要使用 <code>lock_guard</code> 和 <code>unique_lock</code>, 如果是boost, 那么几个就随便用了) </p>
<p>以lock_guard为例:</p>
<ul>
<li>explicit lock_guard( mutex_type&amp; m );</li>
<li>lock_guard( mutex_type&amp; m, std::adopt_lock_t t ); //adopt_lock_t类型表示加锁策略</li>
<li>lock_guard( const lock_guard&amp; ) = delete; //不允许lock_guard间相互赋值</li>
</ul>
<p>(移动构造/移动拷贝也没有)</p>
<p>如果这个线程还再运行, 并且拥有 mutx m, 那么调用<code>lock_guard()</code>就会尝试去拿锁(拿不到阻塞等待). 但是下面的情况是危险的:</p>
<ul>
<li>不是递归mutex, 却要用lock_guard取重复加锁</li>
<li>当前线程不存在了(停止或者被停止运行了), 还想调用lock_guard()</li>
<li>当前线程不拥有该mutex变量</li>
</ul>
<p>(该方法会抛出异常, 一般是m.lock()产生的)</p>
<p>简单的使用案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"> </div><div class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</div><div class="line"><span class="built_in">std</span>::mutex g_i_mutex;  <span class="comment">// protects g_i</span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(g_i_mutex);</div><div class="line">    ++g_i;</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    <span class="comment">// g_i_mutex is automatically released when lock</span></div><div class="line">    <span class="comment">// goes out of scope</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</div><div class="line"> </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>lock_guard 只是简单的包装, 它简化了mutex加锁和解锁的过程(但是不维护和管理锁的生命周期), 更加强大的是, std::unique_lock, shared_lock, scoped_lock; C++11中只支持到了unique_lock.</p>
<p>下面说说 unique_lock()</p>
<p>unique_lock 是对 mutex 集合的封装, 新创建的 unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作, 并且是独占方式. unique_lock支持:</p>
<ul>
<li>延迟加锁(先声明锁, 之后真正用的时候在加锁, 比如使用std::lock())</li>
<li>time-constrained attempts at locking (定义异步加锁)</li>
<li>recursive locking</li>
<li>transfer of lock ownership (但是不支持拷贝, 只支持移动)</li>
<li>use with condition variables</li>
</ul>
<p>和 lock_guard 一样, std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁(即使没有显式地调用 unlock 函数). 这也是一种简单而又安全的上锁和解锁方式, 尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作, 极大地简化了程序员编写与 Mutex 相关的异常处理代码. (unique_lock 对象同样也不负责管理 Mutex 对象的生命周期)</p>
<p>下面是延迟锁定的简单使用案例:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;chrono&gt;</div><div class="line"> </div><div class="line">struct Box &#123;</div><div class="line">    explicit Box(int num) : num_things&#123;num&#125; &#123;&#125;</div><div class="line"> </div><div class="line">    int num_things;</div><div class="line">    std::mutex m;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">void transfer(Box &amp;from, Box &amp;to, int num)</div><div class="line">&#123;</div><div class="line">    // don't actually take the locks yet</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);</div><div class="line">    std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);</div><div class="line"> </div><div class="line">    // lock both unique_locks without deadlock</div><div class="line">    std::lock(lock1, lock2);</div><div class="line"> </div><div class="line">    from.num_things -= num;</div><div class="line">    to.num_things += num;</div><div class="line"> </div><div class="line">    // 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    Box acc1(100);</div><div class="line">    Box acc2(50);</div><div class="line"> </div><div class="line">    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);</div><div class="line">    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);</div><div class="line"> </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但 unique_lock 给程序员提供了更多的自由, unique_lock 作为一个TimedLockable对象, 支持5种主要操作: lock, unlock, try_lock, try_lock_for, try_lock_until. 主要构造器, 大致上如下:</p>
<ul>
<li>unique_lock() noexcept; //默认构造器</li>
<li>explicit unique_lock(mutex_type&amp; m);  //对应basic mutex, 即含有lock和unlock操作</li>
<li>unique_lock(mutex_type&amp; m, try_to_lock_t tag);  //在上面的基础上增加了try_lock方法</li>
<li>unique_lock(mutex_type&amp; m, defer_lock_t tag) noexcept;  //延迟绑定mutex</li>
<li>unique_lock(mutex_type&amp; m, adopt_lock_t tag);  //中途收养已经加锁的mutex</li>
<li>template <class rep,="" class="" period=""><br>unique_lock(mutex_type&amp; m, const chrono::duration<rep,period>&amp; rel_time);  //带有计时器的mutex的封装, 相当于lock_for</rep,period></class></li>
<li>template <class clock,="" class="" duration=""><br>unique_lock(mutex_type&amp; m, const chrono::time_point<clock,duration>&amp; abs_time);  //相当于lock_until</clock,duration></class></li>
<li>unique_lock(const unique_lock&amp;) = delete;   //禁止拷贝</li>
<li>unique_lock(unique_lock&amp;&amp; x);   //移动转移所有权<br>如果被赋值的对象之前已经获得了它所管理的 Mutex 对象的锁(即已经上锁), 则在移动赋值(move assignment)之前会调用 unlock 函数释放它所占有的锁<br>主要是用在, 创建 unique_lock 的时候不指定 mutex 的情况.<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck;         <span class="comment">// default-constructed</span></div><div class="line">lck = <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;(mtx);  <span class="comment">// move-assigned</span></div></pre></td></tr></table></figure>
</li>
</ul>
<p>其他成员函数, 根据 <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" target="_blank" rel="external">参考手册</a> 的分类, 应该如下:</p>
<ul>
<li>锁操作类<ul>
<li>lock</li>
<li>try_lock, try_lock_for, try_lock_until</li>
<li>unlock</li>
</ul>
</li>
<li>所有权类<ul>
<li>swap 交换 unique_lock 所关联的 mutex</li>
<li>release 释放所有权(返回指向它所管理的 Mutex 对象的指针并释放所有权)</li>
</ul>
</li>
<li>判别类(只读)<ul>
<li>owns_lock(返回当前 std::unique_lock 对象是否获得了锁, 不仅仅是检查是否关联了 mutex ), 已经加锁则返回true</li>
<li>operator bool (和上面作用一样, 用于判断条件语句中直接使用对象进行判断)</li>
<li>mutex  直接返回相关联的 mutex 的指针</li>
</ul>
</li>
</ul>
<p>但是注意, 如果你要后面自己调用锁操作相关的成员方法, 主要是指加锁操作, (不手动调用unlock, 在作用域结束的时候也会自动调用), 那么初始化 unique_lock的时候, 必须制定为延迟绑定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">//std::unique_lock&lt;std::mutex&gt; lck (mtx,std::defer_lock);</div><div class="line"></div><div class="line">//线程执行方法</div><div class="line">void print_thread_id (int id) &#123;</div><div class="line">  std::unique_lock&lt;std::mutex&gt; lck (mtx,std::defer_lock);</div><div class="line">  // critical section (exclusive access to std::cout signaled by locking lck):</div><div class="line">  lck.lock();</div><div class="line">  std::cout &lt;&lt; &quot;thread #&quot; &lt;&lt; id &lt;&lt; &apos;\n&apos;;</div><div class="line">  lck.unlock(); //不手动调用也会自动调用</div><div class="line">&#125;</div><div class="line"></div><div class="line">//线程执行方法</div><div class="line">void print_star () &#123;</div><div class="line">  std::unique_lock&lt;std::mutex&gt; lck(mtx,std::defer_lock);</div><div class="line">  // print &apos;*&apos; if successfully locked, &apos;x&apos; otherwise: </div><div class="line">  if (lck.try_lock())</div><div class="line">    std::cout &lt;&lt; &apos;*&apos;;</div><div class="line">  else                    </div><div class="line">    std::cout &lt;&lt; &apos;x&apos;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"></div><div class="line">//线程执行方法</div><div class="line">void fireworks () &#123;</div><div class="line">  std::unique_lock&lt;std::timed_mutex&gt; lck(mtx, std::defer_lock);</div><div class="line">  // waiting to get a lock: each thread prints &quot;-&quot; every 200ms:</div><div class="line">  while (!lck.try_lock_for(std::chrono::milliseconds(200))) &#123;</div><div class="line">    std::cout &lt;&lt; &quot;-&quot;;</div><div class="line">  &#125;</div><div class="line">  // got a lock! - wait for 1s, then this thread prints &quot;*&quot;</div><div class="line">  std::this_thread::sleep_for(std::chrono::milliseconds(1000));</div><div class="line">  std::cout &lt;&lt; &quot;*\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当然, 如果你使用 <code>std::try_to_lock</code> 这种参数, 那么初始化的时候, 就会尝试加锁了:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;         // std::vector</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::unique_lock, std::try_to_lock</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_star</span> <span class="params">()</span> </span>&#123;</div><div class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(mtx,<span class="built_in">std</span>::try_to_lock);</div><div class="line">  <span class="comment">// print '*' if successfully locked, 'x' otherwise: </span></div><div class="line">  <span class="keyword">if</span> (lck.owns_lock()) <span class="comment">// 等价于 if(lck)</span></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span>;</div><div class="line">  <span class="keyword">else</span>                    </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'x'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</div><div class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</div><div class="line">    threads.emplace_back(<span class="built_in">std</span>::thread(print_star));</div><div class="line"></div><div class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: threads) x.join();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>仔细一看, unique_lock 比 lock_guard 灵活不少, 但是lock_guard设计目的明显而又简单.</p>
<h3 id="lock-t"><a href="#lock-t" class="headerlink" title="lock_t"></a>lock_t</h3><p>上面说 std::lock_guard, std::scoped_lock, std::unique_lock, and std::shared_lock 的时候, 已经涉及到这个结构体了, 代表上锁的策略( tag type used to specify locking strategy). </p>
<p>它们的用法不同:</p>
<ul>
<li>defer_lock_t    do not acquire ownership of the mutex (延后获取, 真正加锁的时候才获取所有权; 构造只是声明以后的联系)</li>
<li>try_to_lock_t    try to acquire ownership of the mutex without blocking</li>
<li>adopt_lock_t    assume the calling thread already has ownership of the mutex</li>
</ul>
<p>它们都可以作为参数传入给 unique_lock 或 lock_guard 的构造函数, 但是具体意义是不同的.</p>
<p>一个案例:<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line">#include &lt;mutex&gt;</div><div class="line">#include &lt;thread&gt;</div><div class="line"> </div><div class="line">struct bank_account &#123;</div><div class="line">    explicit bank_account(int balance) : balance(balance) &#123;&#125;</div><div class="line">    int balance;</div><div class="line">    std::mutex m;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">void transfer(bank_account &amp;from, bank_account &amp;to, int amount)</div><div class="line">&#123;</div><div class="line">    // lock both mutexes without deadlock</div><div class="line">    std::lock(from.m, to.m);</div><div class="line">    </div><div class="line">// make sure both already-locked mutexes are unlocked at the end of scope</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock1(from.m, std::adopt_lock);</div><div class="line">    std::lock_guard&lt;std::mutex&gt; lock2(to.m, std::adopt_lock);</div><div class="line"> </div><div class="line">//  上面的代码等价于(equivalent approach): //derfer_lock表明自己手动加锁</div><div class="line">//    std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);</div><div class="line">//    std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);</div><div class="line">//    std::lock(lock1, lock2);</div><div class="line"> </div><div class="line">    from.balance -= amount;</div><div class="line">    to.balance += amount;</div><div class="line">&#125;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    bank_account my_account(100);</div><div class="line">    bank_account your_account(50);</div><div class="line"> </div><div class="line">    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);</div><div class="line">    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);</div><div class="line"> </div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h3><p>在pthreads中是这样用的<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;pthread.h&gt;</div><div class="line"></div><div class="line">pthread_once_t once_control = PTHREAD_ONCE_INIT;</div><div class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));</div></pre></td></tr></table></figure></p>
<p>为了确保某些变量只在多线程环境中初始化一次, 要求 <code>once_control</code> 初始化指定的值, 而全部的这个flag是由库维护的保证了其互斥性. (c++中也可以用aotomic进行代替)</p>
<p>在C++这个并发库中, 类似的使用 <code>std::call_once</code> 来解决:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Function, <span class="keyword">class</span>... Args &gt;  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">call_once</span> <span class="params">( <span class="built_in">std</span>::once_flag&amp; flag, Function&amp;&amp; f, Args&amp;&amp; args... )</span></span>;</div></pre></td></tr></table></figure>
<p>注意这个函数时会抛出异常的(当f运行出错时): std::system_error if any condition prevents calls to call_once from executing as specified any exception thrown by f .<br>按照c++标准的介绍, 应该是如果第一次调用没有成功的话，那么第二次还会继续调用，一次类推直到调用成功为止。(实际上, 根据不同的实现, 表现结果也有一点儿差别)</p>
<p>简单的使用案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; staticData;  </div><div class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; initializeStaticData ()  </div><div class="line">&#123;  </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;  </div><div class="line">    vec.push_back (<span class="string">"initialize"</span>);  </div><div class="line">  </div><div class="line">    <span class="keyword">return</span> vec;  <span class="comment">//值拷贝</span></div><div class="line">&#125;  </div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></div><div class="line">&#123;  </div><div class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::once_flag oc;  </div><div class="line">    <span class="built_in">std</span>::call_once(oc, [] &#123; staticData = initializeStaticData ();&#125;);  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在本例中是系统自动初始化它(实际上onc_flag类的内部状态在调用call_once时采取设置, 不用担心), 并且注意std::once_flag is neither copyable nor movable.</p>
<p>但是上面的案例是不规范的, 说过的, 它是会抛出异常的, 下面看一个可能抛出异常的案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></div><div class="line"> </div><div class="line"><span class="built_in">std</span>::once_flag flag1, flag2;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::call_once(flag1, []()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple example: called once\n"</span>; &#125;);</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="keyword">if</span> (do_throw) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"throw: call_once will retry\n"</span>; <span class="comment">// this may appear more than once</span></div><div class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</div><div class="line">  &#125;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Didn't throw, call_once will not attempt again\n"</span>; <span class="comment">// guaranteed once</span></div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_once</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></div><div class="line">&#123;</div><div class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  <span class="keyword">try</span> &#123;</div><div class="line">    <span class="comment">//可能抛出异常</span></div><div class="line">    <span class="built_in">std</span>::call_once(flag2, may_throw_function, do_throw);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">catch</span> (...) &#123;</div><div class="line">    <span class="comment">//do nothing</span></div><div class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"unlock yes ?"</span>  &lt;&lt; <span class="string">"\n"</span>;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">//可惜只执行一次</span></div><div class="line">    <span class="comment">// std::thread st1(simple_do_once);</span></div><div class="line">    <span class="comment">// std::thread st2(simple_do_once);</span></div><div class="line">    <span class="comment">// std::thread st3(simple_do_once);</span></div><div class="line">    <span class="comment">// std::thread st4(simple_do_once);</span></div><div class="line">    <span class="comment">// st1.join();</span></div><div class="line">    <span class="comment">// st2.join();</span></div><div class="line">    <span class="comment">// st3.join();</span></div><div class="line">    <span class="comment">// st4.join();</span></div><div class="line"> </div><div class="line"> <span class="comment">//std::thread t1(do_once, true);</span></div><div class="line">    <span class="comment">//std::thread t2(do_once, true);	</span></div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>; <span class="comment">//直到不再抛出异常, 才算执行了一次</span></div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</div><div class="line">    t1.join();</div><div class="line">    t2.join();</div><div class="line">    t3.join();</div><div class="line">    t4.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>本质上来说, 异常和线程pthread的库在内核的futex同步机制上(内核互斥对象处理上), 貌似没有做的很好; 所以如果你不注释掉相应的行<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//std::thread t1(do_once, true);</span></div><div class="line">   <span class="comment">//std::thread t2(do_once, true);</span></div></pre></td></tr></table></figure></p>
<p>就可能产生死锁, 运行类似下面的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pid = pid = 140252808775424</div><div class="line">pid = 140252800382720</div><div class="line">throw: call_once will retry</div><div class="line">140252817168128</div><div class="line">unlock yes ?</div><div class="line">pid = 140252791990016</div></pre></td></tr></table></figure></p>
<p>查看线程堆栈, 发现3个线程在等待内核的互斥对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">Thread 4 (Thread 0x7fe23bfff700 (LWP 8588)):</div><div class="line">#0  0x00007fe2452006ef in futex_wait (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/unix/sysv/linux/futex-internal.h:61</div><div class="line">#1  futex_wait_simple (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/nptl/futex-internal.h:135</div><div class="line">#2  __pthread_once_slow (once_control=0xcb536311d8 &lt;flag2&gt;, init_routine=0x7fe244f293c0 &lt;__once_proxy&gt;) at pthread_once.c:105</div><div class="line">0x000000cb5342e3b1 in do_once (do_throw=true) at callonce.cpp:26</div><div class="line"></div><div class="line">Thread 3 (Thread 0x7fe243514700 (LWP 8587)):</div><div class="line">#0  0x00007fe2452006ef in futex_wait (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/unix/sysv/linux/futex-internal.h:61</div><div class="line">#1  futex_wait_simple (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/nptl/futex-internal.h:135</div><div class="line">#2  __pthread_once_slow (once_control=0xcb536311d8 &lt;flag2&gt;, init_routine=0x7fe244f293c0 &lt;__once_proxy&gt;) at pthread_once.c:105</div><div class="line">0x000000cb5342e3b1 in do_once (do_throw=false) at callonce.cpp:26</div><div class="line"></div><div class="line">Thread 2 (Thread 0x7fe243d65700 (LWP 8586)):</div><div class="line">#0  0x00007fe2452006ef in futex_wait (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/unix/sysv/linux/futex-internal.h:61</div><div class="line">#1  fusimple (private=0, expected=1, rnal.h:135</div><div class="line">#2  __nce_slow (once_control=0xcb5363thread_once.c:105</div><div class="line">0x342e3b1 in do_once (do_throw=true) at callonce.cpp:26</div><div class="line"></div><div class="line">//还有一个已经跑完的,但是没有释放锁的线程</div><div class="line">Threadd 0x7fe245605740 (LWP 8584)):</div><div class="line">#0  0x51fa67d in pthread_join (threadid=140609777456896, thread_return=0x0) at pthread_join.c:90</div><div class="line">#1  0x4f2a397 in std::thread::join() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</div><div class="line">#2  0x342e48b in main () at callonce.cpp:51</div></pre></td></tr></table></figure></p>
<p>但是如果 <code>t3</code> 最先执行, 那么最好不过了, 可以直接运行结束, 而不会产生死锁(你多运行几次)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">= pid = 139844931725056</div><div class="line">Didn&apos;t throw, call_once will not attempt again</div><div class="line">139844923332352</div><div class="line">pid = 139844940117760</div><div class="line">pid = 139844948510464</div></pre></td></tr></table></figure></p>
<p>如果你涉及到异常, call_once可以很好的用于初始化(拿到一个实例)一次, 例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> X &#123;  </div><div class="line"><span class="keyword">private</span>:  </div><div class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::once_flag initDataFlag;  </div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span> <span class="params">()</span>  </span></div><div class="line">    &#123;  </div><div class="line">        _data = <span class="string">"init"</span>;  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _data;  </div><div class="line"><span class="keyword">public</span>:  </div><div class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getData</span> <span class="params">()</span> </span>&#123;  </div><div class="line">        <span class="built_in">std</span>::call_once (initDataFlag, &amp;X::initData, <span class="keyword">this</span>);  </div><div class="line">        <span class="keyword">return</span> _data;  </div><div class="line">    &#125;  </div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p>如果返回相关实例的话, 这就是一个单例啊.</p>
<h2 id="Futures库"><a href="#Futures库" class="headerlink" title="Futures库"></a>Futures库</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当时学习 boost 的时候, 这一篇是直接一带而过的, 因为平常都没有怎么用到这个库.这个库和异步任务(简单理解成单独封装&amp;运行在独立线程中的任务)有关, 和线程间传递数据(当然包括共享数据–即同步)有关. Futures本身又是指期货, 未来交易的一种约定&amp;协议.  </p>
<p>怎么样理解这个库呢? Wiki上面给了很好的解释:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">In computer science, future, promise, delay, and deferred refer to constructs used <span class="keyword">for</span> synchronizing program execution in some concurrent programming languages. They describe an object that acts as a proxy <span class="keyword">for</span> a result that is initially unknown, usually because the computation of its value is yet incomplete.</div></pre></td></tr></table></figure></p>
<p>联系实际编程实体, 其实就很好理解了: 线程本身运行是互不干扰的, 虽然它们可以互相的共享一些资源. 那么两个独立运行的实体, 怎么通信交流呢? 就通过约定或者协议来了, 交流呢就通过promise对象来, 约定我这个线程的执行结果存储在一个叫做 futures的实体里, 另外的线程体执行体, 你们要结果先同步等待着(这个同步可能被封装起来, 你看不到它们显示的在wait或者被mutex挡住), 之后有了值就去取(而不是在那傻等) 所以这个过程是异步过程(可能有个线程在同步等待, 比如主线程).</p>
<p>并且这种约定, 通常是运行之前就要约定好, 我这个线程里面跑的是个什么任务(package_task), 我运行期来之后, 别的线程要交流就通过 promise (我给promise写值), 这个代理对象, 我没有给它值之前, 别的需要从这个对象获取值的其他线程就同步等待, 而且只能通过与promise关联的futures获取, 之后我这个线程运行的任务结束了, 有需要结果, 但是又在运行中不能傻等在那儿等结果的线程, 可以异步的从futures得到结果(当然我结束了给一个回调通知也是可以的?).</p>
<p>如何匹配future/promise对呢？ (建立相关的关联) 一个在我的线程, 另一个在别的啥线程中么？<br>既然 future 和 promise 可以被到处移动(不是拷贝), 那么可能性就挺多的.<br>最普遍的情况是父子线程配对形式, 父线程用future获取子线程promise返回的值. 在这种情况下, 使用async()是很优雅的方法.</p>
<p>如果还是没有听明白, 直接看代码吧, 这段代码是这么个意思:</p>
<blockquote>
<p>一个double数组求和的任务, 我(主线程) 分别交给两个子线程去求和(一个求前半个数组的和, 一个求后半个数组的和), 之后分别返回后, 我主线程在完成最后的求和工作.</p>
</blockquote>
<p>大致代码如下: (同步&amp;协作)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">double</span> <span class="title">accumulate_all</span><span class="params">(<span class="built_in">vector</span>&amp; v)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="comment">// package the tasks: </span></div><div class="line">	<span class="comment">//用accumulate算法计算 doubles 数据的和</span></div><div class="line">	<span class="comment">//注意 task 内部已经处理好了写入promise的操作</span></div><div class="line">	packaged_task pt0&#123;<span class="built_in">std</span>::accumulate&#125;;</div><div class="line">	packaged_task pt1&#123;<span class="built_in">std</span>::accumulate&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">auto</span> f0 = pt0.get_future(); <span class="comment">// get hold of the futures</span></div><div class="line">	<span class="keyword">auto</span> f1 = pt1.get_future();</div><div class="line"></div><div class="line">	<span class="comment">//把任务分解到两个线程; 分别完成后, 在主线程完成最终求和计算</span></div><div class="line">	pt0(&amp;v[<span class="number">0</span>],&amp;v[v.size()/<span class="number">2</span>],<span class="number">0</span>); <span class="comment">// start the threads</span></div><div class="line">	pt1(&amp;[v.size()/<span class="number">2</span>],&amp;v[size()],<span class="number">0</span>); <span class="comment">// packageed_task 封装了线程</span></div><div class="line"></div><div class="line">	<span class="keyword">return</span> f0.get()+f1.get(); <span class="comment">// get the results</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>packaged_task</code> 提供了启动任务线程的简单方法. 特别是它处理好了 future 和 promise 的关联关系, 同时提供了包装代码(就是put方法)以保证返回值/异常可以放到 promise 中</p>
<p>总结:<br>C++11并发库提供了 future 和 promise 来简化任务线程间的传值(返回值)操作; 同时为启动任务线程提供了packaged_task以方便的封装.<br>其中的关键点是允许2个任务间使用无(显式)锁的方式进行值传递(标准库帮你高效的封装好了). </p>
<p>async()基本实现思路: 当一个任务需要另外一个线程(启动它的线程)返回值时, 它把这个值放到promise中. 之后这个返回值会出现在和此 promise 关联的 future 中. 于是另外线程就能读到返回值, 从futures中读取. </p>
<h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p>该部分主要说:</p>
<ul>
<li>std::promise</li>
<li>std::package_task</li>
</ul>
<p>以及 provider 相关的函数 std::async() 和 std::launch.</p>
<p>下面先说 promise.</p>
<p>promise的主要目的是提供一个”put”(也能”get”)操作以和 future 的 get() 对应, 在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联, 并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值. promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值. 可以通过 get_future 来获取与该 promise 对象相关联的 future 对象, 并且用到其set方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::future&lt;T&gt; get_future();</div><div class="line"></div><div class="line"><span class="comment">//根据声明时promise的参数不同, 有不同的setter</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">( <span class="keyword">const</span> R&amp; value )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">( R&amp;&amp; value )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">( R&amp; value )</span></span>;</div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">()</span></span>;</div></pre></td></tr></table></figure></p>
<p>promise为future传递的结果类型有2种: (set_xxx)</p>
<ul>
<li>传一个普通值 (set_value, set_value_at_thread_exit)</li>
<li>抛出一个异常 (set_exception, set_exception_at_thread_exit)</li>
</ul>
<p>基本用法不同:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">  X res;</div><div class="line">  <span class="comment">// compute a value for res</span></div><div class="line">  p.set_value(res);</div><div class="line">&#125;</div><div class="line"><span class="keyword">catch</span> (...) &#123; <span class="comment">// oops: couldn't compute res</span></div><div class="line">  p.set_exception(<span class="built_in">std</span>::current_exception());</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>关于 get_future:<br>返回的 future 对象可以访问由 promise 对象设置在共享状态上的值或者某个异常对象。只能从 promise 共享状态获取一个 future 对象。如果关联了 future 的promise不设置值或者异常, 那么 promise对象在析构时会自动地设置一个 future_error 异常(broken_promise). 设置promise的值&amp;异常，此后 promise 的共享状态标志变为 ready.</p>
<p>下面有一个简单的例子: (主线程通过promise设置值, 让其他线程通过相关联的future去获取值)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;       // std::cout</div><div class="line">#include &lt;functional&gt;     // std::ref</div><div class="line">#include &lt;thread&gt;         // std::thread</div><div class="line">#include &lt;future&gt;         // std::promise, std::future</div><div class="line"></div><div class="line">void print_int(std::future&lt;int&gt;&amp; fut) &#123;</div><div class="line">    int x = fut.get(); // 获取共享状态的值.</div><div class="line">    std::cout &lt;&lt; "value: " &lt;&lt; x &lt;&lt; '\n'; // 打印 value: 10.</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">    std::promise&lt;int&gt; prom; // 生成一个 std::promise&lt;int&gt; 对象.</div><div class="line">    std::future&lt;int&gt; fut = prom.get_future(); // 和 future 关联.</div><div class="line">    std::thread t(print_int, std::ref(fut)); // 将 future 交给另外一个线程t.</div><div class="line">    prom.set_value(10); // 设置共享状态的值, 此处和线程t保持同步.</div><div class="line">    t.join();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>设置异常的具体例子: (线程1从终端接收一个整数, 线程2将该整数打印出来, 如果线程1接收一个非整数, 则为 promise 设置一个异常(failbit), 线程2 在std::future::get 是抛出该异常)<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">#include &lt;iostream&gt;       // std::cin, std::cout, std::ios</div><div class="line">#include &lt;functional&gt;     // std::ref</div><div class="line">#include &lt;thread&gt;         // std::thread</div><div class="line">#include &lt;future&gt;         // std::promise, std::future</div><div class="line">#include &lt;exception&gt;      // std::exception, std::current_exception</div><div class="line"></div><div class="line">void get_int(std::promise&lt;int&gt;&amp; prom) &#123;</div><div class="line">    int x;</div><div class="line">    std::cout &lt;&lt; "Please, enter an integer value: ";</div><div class="line">    std::cin.exceptions (std::ios::failbit);   // throw on failbit</div><div class="line">    try &#123;</div><div class="line">        std::cin &gt;&gt; x;                         // sets failbit if input is not int</div><div class="line">        prom.set_value(x);</div><div class="line">    &#125; catch (std::exception&amp;) &#123; //cin拿到的不是整数时</div><div class="line">        prom.set_exception(std::current_exception());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print_int(std::future&lt;int&gt;&amp; fut) &#123;</div><div class="line">    try &#123;</div><div class="line">        int x = fut.get();</div><div class="line">        std::cout &lt;&lt; "value: " &lt;&lt; x &lt;&lt; '\n';</div><div class="line">    &#125; catch (std::exception&amp; e) &#123;</div><div class="line">        std::cout &lt;&lt; "[exception caught: " &lt;&lt; e.what() &lt;&lt; "]\n";</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main ()</div><div class="line">&#123;</div><div class="line">    std::promise&lt;int&gt; prom;</div><div class="line">    std::future&lt;int&gt; fut = prom.get_future();</div><div class="line"></div><div class="line">    std::thread th1(get_int, std::ref(prom));</div><div class="line">    std::thread th2(print_int, std::ref(fut));</div><div class="line"></div><div class="line">    th1.join();</div><div class="line">    th2.join();</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>那么 <code>void set_value()</code>  是怎么回事?<br>如果不设置值的话(虽然还是会自动设置一个异常, 然后promise的状态还是ready状态), 那就起到通知(notify)等待从future拿到值的线程, 例如下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div></pre></td><td class="code"><pre><div class="line">#include &lt;thread&gt;</div><div class="line">#include &lt;future&gt;</div><div class="line">#include &lt;cctype&gt;</div><div class="line">#include &lt;vector&gt;</div><div class="line">#include &lt;algorithm&gt;</div><div class="line">#include &lt;iterator&gt;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;sstream&gt;</div><div class="line"> </div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">    std::istringstream iss_numbers&#123;&quot;3 4 1 42 23 -23 93 2 -289 93&quot;&#125;;</div><div class="line">    std::istringstream iss_letters&#123;&quot; a 23 b,e a2 k k?a;si,ksa c&quot;&#125;;</div><div class="line"></div><div class="line">    //其他线程把上面流的内容放入 这些容器中</div><div class="line">    std::vector&lt;int&gt; numbers;</div><div class="line">    std::vector&lt;char&gt; letters;</div><div class="line"></div><div class="line">    </div><div class="line">    std::promise&lt;void&gt; numbers_promise, letters_promise;</div><div class="line"> </div><div class="line">    //主线程纯碎只是要获取其他线程是否完成的状态</div><div class="line">    auto numbers_ready = numbers_promise.get_future();</div><div class="line">    auto letter_ready = letters_promise.get_future();</div><div class="line"></div><div class="line">    //子线程用xxx_promise只是传递ready状态</div><div class="line">    std::thread value_reader([&amp;]</div><div class="line">    &#123;</div><div class="line">        // I/O operations.</div><div class="line">        std::copy(std::istream_iterator&lt;int&gt;&#123;iss_numbers&#125;,</div><div class="line">                  std::istream_iterator&lt;int&gt;&#123;&#125;,</div><div class="line">                  std::back_inserter(numbers));</div><div class="line"> </div><div class="line">        //Notify for numbers.</div><div class="line">        numbers_promise.set_value(); //仅仅是只是传递ready状态</div><div class="line"> </div><div class="line">        std::copy_if(std::istreambuf_iterator&lt;char&gt;&#123;iss_letters&#125;,</div><div class="line">                     std::istreambuf_iterator&lt;char&gt;&#123;&#125;,</div><div class="line">                     std::back_inserter(letters),</div><div class="line">                     ::isalpha);</div><div class="line"> </div><div class="line">        //Notify for letters.</div><div class="line">        letters_promise.set_value();</div><div class="line">    &#125;);</div><div class="line"> </div><div class="line">    //主线程numbers future 阻塞wait</div><div class="line">    numbers_ready.wait();</div><div class="line">    //numbers容器被填充完毕了</div><div class="line">    std::sort(numbers.begin(), numbers.end());</div><div class="line"> </div><div class="line">/*  //非核心逻辑</div><div class="line">    if (letter_ready.wait_for(std::chrono::seconds(1)) ==</div><div class="line">            std::future_status::timeout)</div><div class="line">    &#123;</div><div class="line">        //output the numbers while letters are being obtained.</div><div class="line">        for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; &apos; &apos;;</div><div class="line">        numbers.clear(); //Numbers were already printed.</div><div class="line">    &#125;</div><div class="line">*/    </div><div class="line"></div><div class="line">    //阻塞等待</div><div class="line">    letter_ready.wait();</div><div class="line">    std::sort(letters.begin(), letters.end());</div><div class="line"> </div><div class="line">    //If numbers were already printed, it does nothing.</div><div class="line">    for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; &apos; &apos;;</div><div class="line">    std::cout &lt;&lt; &apos;\n&apos;;</div><div class="line"> </div><div class="line">    for (char let : letters) std::cout &lt;&lt; let &lt;&lt; &apos; &apos;;</div><div class="line">    std::cout &lt;&lt; &apos;\n&apos;;</div><div class="line"> </div><div class="line">    value_reader.join();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><code>set_xxx_at_thread_exit</code> 这类比较特殊, 拥有promise的线程, 真正set是在线程结束的时候才去set(延后设置), 可想而知, 对方等待的线程会一直等待结果.(但是重复调用set会报错). The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed. 下面有个简单的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></div><div class="line"> </div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</div><div class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</div><div class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f = p.get_future();</div><div class="line">    <span class="built_in">std</span>::thread([&amp;p] &#123;</div><div class="line">          <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</div><div class="line">          p.set_value_at_thread_exit(<span class="number">9</span>);</div><div class="line">    &#125;).detach();</div><div class="line"> </div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waiting..."</span> &lt;&lt; <span class="built_in">std</span>::flush;</div><div class="line">    f.wait();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done!\nResult is: "</span> &lt;&lt; f.get() &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>补充说明一下其构造方法中也是禁用了拷贝构造函数的, 只保留了移动构造:</p>
<ul>
<li>promise();  //默认构造函数，初始化一个空的共享状态。</li>
<li>template <class alloc=""> promise<br>(allocator_arg_t aa, const Alloc&amp; alloc); //和默认类似, 但是可以自定指定分配器</class></li>
<li>promise (const promise&amp;) = delete; //禁止拷贝构造</li>
<li>promise (promise&amp;&amp; x) noexcept; //移动构造</li>
</ul>
<p>移动构造就是为了转移所有权, 例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;         // std::promise, std::future</span></span></div><div class="line"></div><div class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; prom; <span class="comment">//下面接收不同的promise实例的所有权</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_global_promise</span> <span class="params">()</span> </span>&#123;</div><div class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future();</div><div class="line">    <span class="keyword">int</span> x = fut.get();</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span><span class="params">(print_global_promise)</span></span>;</div><div class="line">    prom.set_value(<span class="number">10</span>);</div><div class="line">    th1.join();</div><div class="line"></div><div class="line">    prom = <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt;();    <span class="comment">// prom 被move赋值为一个新的 promise 对象.</span></div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(print_global_promise)</span></span>;</div><div class="line">    prom.set_value (<span class="number">20</span>);</div><div class="line">    th2.join();</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<hr>
<p>整理&amp;上传 ING.</p>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="">《C++并发编程实战》</a></li>
<li><a href="http://www.merlinblog.site/2017/06/21/boost.html" target="_blank" rel="external">boost总结</a></li>
<li><a href="http://www.boost.org/doc/libs/1_49_0/doc/html/thread.html" target="_blank" rel="external">boost线程库</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="external">cppreference</a></li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2017/06/30/try-stock-trading-system.html" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2017/06/24/three-major-tools-of-linux.html" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2017-06-29 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/codings/">codings<span>63</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/boost/">boost<span>7</span></a></li> <li><a href="/tags/cpp/">cpp<span>22</span></a></li> <li><a href="/tags/thread/">thread<span>7</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#引子"><span class="toc-article-text">引子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#正文"><span class="toc-article-text">正文</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#简介"><span class="toc-article-text">简介</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Threads库"><span class="toc-article-text">Threads库</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#thread类"><span class="toc-article-text">thread类</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#this-thread"><span class="toc-article-text">this_thread</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Mutex库"><span class="toc-article-text">Mutex库</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#mutex"><span class="toc-article-text">mutex</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#全局加锁算法"><span class="toc-article-text">全局加锁算法</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#lock类结构"><span class="toc-article-text">lock类结构</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#lock包装类"><span class="toc-article-text">lock包装类</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#lock-t"><span class="toc-article-text">lock_t</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#call-once"><span class="toc-article-text">call_once</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Futures库"><span class="toc-article-text">Futures库</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#概述"><span class="toc-article-text">概述</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#provider"><span class="toc-article-text">provider</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#尾巴"><span class="toc-article-text">尾巴</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#参考资料"><span class="toc-article-text">参考资料</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 MerlinYu
  
     
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
