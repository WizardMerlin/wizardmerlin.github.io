<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>stl | Merlin&#39;s Blog</title>
  <meta name="author" content="MerlinYu">
  
  <meta name="description" content="熟练使用stl并对其有深刻的了解">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="stl"/>
  <meta property="og:site_name" content="Merlin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="ico">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Merlin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> stl</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> 熟练使用stl并对其有深刻的了解
		 </div> <!-- alert -->
	  		

	  <p>STL模板中, 唯一比较难得熟悉的是算法部分; 容器, 迭代器部分则相对好一些.<br>(本文是当年我学习stl时的一些体会和总结)<br>如果你是初学者, 不妨参考一下我上传的 <a href="https://github.com/WizardMerlin/stl_life" target="_blank" rel="external">学习记录</a><br><a id="more"></a></p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>标准库的学习不需要认认真真地读书, 需要的是在了解概貌的情况下, 在实践中深入.<br>(需要泛型基础)<br> “通过使用算法和容器, 简化编程任务” 这才是重点.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>STL主要涉及: 容器, 迭代器, 算法, 仿函数, 适配器, 分配器.</p>
<p>在 C++标准中， STL 被组织为下面的 13 个头文件: (不用记忆, 用的久了就知道了)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;algorithm&gt;,  &lt;deque&gt;, &lt;functional&gt;, &lt;iterator&gt;, &lt;vector&gt;, &lt;list&gt;, </div><div class="line">&lt;map&gt;, &lt;memory&gt;, &lt;numeric&gt;, &lt;queue&gt;, &lt;set&gt;, &lt;stack&gt;, &lt;utility&gt;</div></pre></td></tr></table></figure></p>
<p>除了 <code>分配器</code> 不常用, 其他5个组件都非常常用, 而且是配合使用.</p>
<ul>
<li>STL是c++的一部分, 编译器支持.</li>
<li>STL在设计时就是算法和数据结构分离的(其实是得益于泛型).</li>
<li>程序员可以不用思考 STL 具体的实现过程, 只要能够熟练使用 STL 就 OK 了, 这样他们就可以把精力放在程序开发的别的方面.</li>
<li>STL的实现也比较高效: 如 map 可以高效地从十万条记录里面查找出指定的记录, 因为 map 是采用红黑树的变体实现的(红黑树是平横二叉树的一种)</li>
<li>什么情况下使用什么容器和算法, 这个很重要.</li>
</ul>
<p>C++中10类标准库, 用的时候再去看吧.</p>
<blockquote>
<p>我们更多的关注的是, 各种容器&amp;算法的使用场景, 具体的用法; </p>
</blockquote>
<p>具体的容器和算法的讲解, 可以参考一下我的github记录(string, vector, deque, stack, queue, list, priority_queue, set, map等)</p>
<p>但是有些容器是需要了解底层实现的数据结构的, 比如说 “为什么不可以修改set元素的值?” (因为set底层是用红黑树实现的, 因为该类容器是自动排序的(改变节点的值会打乱原有的顺序). 如果希望修改一个set元素值, 必须先删除原有的元素, 再插入新的元素)</p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>数据结构一般不会让你去实现, 但是会让你根据合适的场景选择和包装数据结构.<br>(必须知道每种容器的特点)<br>常用的容器如下 (注意下容器适配器)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;vector&gt;, &lt;list&gt;, &lt;deque&gt;, &lt;set&gt;, &lt;map&gt;, &lt;stack&gt; 和 &lt;queue&gt;.</div></pre></td></tr></table></figure></p>
<p>必须非常熟悉的容器有:</p>
<ul>
<li>序列式容器<br>(有固定位置, 和插入时间和地点有关, 和元素本身无关)<ul>
<li>vector: 向量  (顺序存储) </li>
<li>list: 双向链表 (链式存储)</li>
<li>deque: 双端队列  (顺序存储)</li>
</ul>
</li>
<li>关联式容器<br>(元素位置取决于特定的排序准则, 和插入顺序无关)<ul>
<li>set/multiset: 集合 (多重集合, 允许存在两个次序相等的元素的集合)由节点组成的红黑树, 每个节点都包含着一个元素</li>
<li>map/multimap: 键值对(映射)–多重映射允许键对有相等的次序(key可以不唯一); map默认按照key升序<br>(这两种容器遍历的时候可能用到pair结构: 函数返回两个迭代器, 而这两个迭代器被封装在 “pair” 中, <code>pair.first</code> , <code>pair.second</code>)</li>
</ul>
</li>
</ul>
<p>其他不常用容器:<br>(操作受限的容器, 又可以称作序列容器适配器)</p>
<ul>
<li>stack: 栈 (简单装饰deque而形成的一种容器)</li>
<li>queue: 队列(简单装饰deque而形成的一种容器)</li>
<li><p>priority_queue: 优先队列(最大值优先级队列, 最小值优先级队列)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt; &gt; p1; //默认是 最大值优先级队列</span></div><div class="line">priority_queue&lt;<span class="keyword">int</span>&gt; p1; <span class="comment">//简化的写法</span></div><div class="line"></div><div class="line">priority_queue&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; p2; <span class="comment">//最小值优先级队列</span></div></pre></td></tr></table></figure>
<p>这个元素没有iterator迭代器成员, 注意其遍历方式</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">priority_queue&lt;<span class="keyword">int</span>&gt; p1; </div><div class="line">p1.push(<span class="number">11</span>);<span class="comment">//...</span></div><div class="line"><span class="keyword">while</span> (p2.size() &gt; <span class="number">0</span>)</div><div class="line">&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; p2.top() &lt;&lt; <span class="string">" "</span>;</div><div class="line">    p2.pop();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>(当然各个容器还有各自的注意事项, 说起来比较多, 就没有必要详细展开了)</p>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器部分主要由头文件 <code>utility</code> , <code>iterator</code> 和 <code>memory</code> 组成。 </p>
<ul>
<li>utility是一个很小的头文件, 它包括了贯穿使用在 STL 中的几个模板的声明</li>
<li>iterator提供了迭代器使用的许多方法</li>
<li>memory的描述则十分的困难, 它以不同寻常的方式为容器中的元素分配存储空间, 同时也为某些算法执行期间产生的临时对象提供机制. memory中的主要部分是模板类 allocator, 它负责产生所有容器中的默认分配器.</li>
</ul>
<p>5种迭代器: 输入迭代器, 输出迭代器, 正向迭代器, 双向迭代器, 随机访问迭代器.<br>(后两种用的比较多)</p>
<p>双向迭代器支持: ++, –, *, =, !=, ==操作 (list,set,multiset,map,multimap)<br>随机迭代器在此基础上支 +=n, &gt;, &gt;=, &lt;, &lt;=操作  (一般是顺序存储的序列容器支持, vector, deque)</p>
<p>注意end()总是指向容器最后的下一个位置, rend()指向开头的前一个位置;</p>
<p>下面是迭代器的简单使用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it=vecInt.begin(); it!=vecInt.end(); ++it)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">int</span> iItem = *it;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; iItem; <span class="comment">//或直接使用 cout &lt;&lt; *it;</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//或者反向</span></div><div class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::reverse_iterator rit=vecInt.rbegin(); rit!=vecInt.rend(); ++rit)&#123;</div><div class="line">    <span class="built_in">cout</span> &lt;&lt; *it;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其他迭代器<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//不修改元素的值</span></div><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator 与 <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_reverse_iterator</div></pre></td></tr></table></figure></p>
<p>建议: </p>
<pre><code>《Effective STL 》 建议我们尽量使用 iterator 取 代 const_iterator , reverse_iterator 和 const_reverse_iterator.
</code></pre><p>(迭代器的使用也有一些技巧, 用好了也是事半功倍, 本文就不再展开讨论了)</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>怎么样让模板参数支持不同类型的呢? (模板特化, 延迟类型选择)<br>只需要通过调用一两个算法模板, 就可以完成所需要的功能, 并大大地提升效率.</p>
<p>算法部分主要由头文件 <code>algorithm</code> ,  <code>numeric</code> 和 <code>functional</code> 组成. </p>
<ul>
<li>algorithm是所有STL头文件中最大的一个(尽管它很好理解), 它是由一大堆模版函数组成的, 可以认为每个函数在很大程度上都是独立的, 其中常用到的功能范围涉及到比较、 交换、 查找、 遍历操作、 复制、 修改、 移除、 反转、 排序、 合并等等 (最常用的算法: 置换, 排序, 合并, 搜索)</li>
<li>numeric体积很小, 只包括几个在序列上面进行简单数学运算的模板函数, 包括加法和乘法在序列上的一些操作</li>
<li>functional中则定义了一些模板类, 用以声明函数对象(functor)</li>
</ul>
<p>这个部分内容比较多(非常多, 差不多将近80个常用算法).</p>
<p>比如for_each()函数和 transform函数 的区别?</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v(<span class="number">5</span>,<span class="number">2</span>); <span class="comment">//2, 2, 2, 2, 2</span></div><div class="line">for_each(v.begin(), v.end(), mycompare);</div><div class="line">transform(v.begin(), v.end(), v.begin(), mycompare2);</div></pre></td></tr></table></figure>
<p>一般情况下:<br>for_each所使用的的函数对象, 参数是引用, 没有返回值;<br>transform所使用的函数对象, 参数不使用引用, 而且有返回值.</p>
<h2 id="函数对象和谓词"><a href="#函数对象和谓词" class="headerlink" title="函数对象和谓词"></a>函数对象和谓词</h2><p>函数对象和谓词函数时比较重要的概念, 取代之前C中的回调或者函数指针.</p>
<ul>
<li><p>函数对象(functor)<br>重载 <code>函数调用操作符</code> 的类, 其对象常称为函数对象(function object), 即它们是行为类似函数的对象. 一个类对象, 表现出一个函数的特征, 就是通过”对象名+(参数列表)”的方式使用一个类对象. 如果没有上下文, 完全可以把它看作一个函数对待. 这是通过重载类或者struct的 operator()来实现的. “在标准库中, 函数对象被广泛地使用以获得弹性”, 标准库中的很多算法都可以使用函数对象或者函数来作为自定的回调行为(就相当于函数指针).<br>下面举出 greater<int>的简易实现原理:</int></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> greater</div><div class="line">&#123;</div><div class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; iLeft, <span class="keyword">const</span> <span class="keyword">int</span>&amp; iRight)</span></span></div><div class="line">    &#123;</div><div class="line">        <span class="comment">//如果是实现 less&lt;int&gt;的话， 这边是写 return (iLeft&lt;iRight);</span></div><div class="line">        <span class="keyword">return</span> (iLeft&gt;iRight);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>容器就是调用函数对象的 operator()方法去比较两个值的大小.<br>并且关联容器如果想使用sort, merge, less, greater等算法, 那么放入其中的元素就要提供operator&lt;()或者operator&gt;()运算重载.</p>
</li>
<li><p>谓词</p>
<ul>
<li>n元函数对象: 函数参数 n 个</li>
<li>n元谓词函数: 函数参数 n 个, 函数返回值是 bool 类型, 可以作为一个判断表达式</li>
</ul>
</li>
<li>算数函数对象<br>主要有 <code>plus</code> , <code>minus</code> , <code>multiplies</code> , <code>divides</code> 等.</li>
<li>特殊函数对象<br>主要是指 <code>约束器</code>, <code>适配器</code>, <code>否定器</code> (绑定适配器, 组合适配器, 指针函数适配器, 成员函数适配器)<ul>
<li>bind1st(x), bind2nd(y)</li>
<li>not1(), not2()</li>
<li>ptr_fun()等</li>
</ul>
</li>
</ul>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li>《C++标准库(自学教程与参考手册) 2e》 上下两册  (经过改版的加入了很多C++11的特性)</li>
<li>《大道至简C++STL精解》 机械工业出版社</li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2017/06/21/boost.html" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2017/06/21/c-plus-plus-more.html" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2017-06-21 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/codings/">codings<span>52</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/cpp/">cpp<span>13</span></a></li> <li><a href="/tags/stl/">stl<span>3</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#引子"><span class="toc-article-text">引子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#正文"><span class="toc-article-text">正文</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#容器"><span class="toc-article-text">容器</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#迭代器"><span class="toc-article-text">迭代器</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#算法"><span class="toc-article-text">算法</span></a></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#函数对象和谓词"><span class="toc-article-text">函数对象和谓词</span></a></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#尾巴"><span class="toc-article-text">尾巴</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#参考资料"><span class="toc-article-text">参考资料</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 MerlinYu
  
     
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
