<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>bind-in-cpp | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="主要讲讲 std::bind, 也会说bind1st和bind2nd">
<meta name="keywords" content="cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="bind-in-cpp">
<meta property="og:url" content="www.merlinblog.site/2017/07/01/bind-in-cpp.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="主要讲讲 std::bind, 也会说bind1st和bind2nd">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/stsbind1.jpg">
<meta property="og:updated_time" content="2017-09-24T05:06:06.703Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="bind-in-cpp">
<meta name="twitter:description" content="主要讲讲 std::bind, 也会说bind1st和bind2nd">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/stsbind1.jpg">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                主页
            </a>
            
            <a class="nav-item" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item" href="/works">
                开源作品
            </a>
            
            <a class="nav-item" href="/about">
                关于博主
            </a>
            
            <a class="nav-item" href="/atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                主页
            </a>
            
            <a class="nav-item flex-1" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="/works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="/about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="/atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="/css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引子"><span class="toc-number">1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#bind1st和bind2nd"><span class="toc-number">2.1.</span> <span class="toc-text">bind1st和bind2nd</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现bind1st"><span class="toc-number">2.2.</span> <span class="toc-text">实现bind1st</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#std-bind"><span class="toc-number">2.3.</span> <span class="toc-text">std::bind</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾巴"><span class="toc-number">3.</span> <span class="toc-text">尾巴</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>bind-in-cpp</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-07-01</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/cpp/">cpp</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <p>以前常用的是 <code>std::bind1st</code> 和 <code>std::bind2nd</code> 函数适配器, 现在主推 <code>std::bind</code><br> 并且常常和 <code>std::function</code> 一起使用的就是 <code>std::bind</code> , 用于绑定类成员函数.<br>(std::function 可以直接绑定全局函数, 静态函数; 但成员函数就要借助 bind )</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/stsbind1.jpg" alt="post-cover"></p>
<a id="more"></a>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文主要说说 std::bind1st 和 std::bind2nd 这类函数适配器, 以及其基本的实现方式.</p>
<p>其次讲解本文主推的 <code>std::bind</code> , 但是注意, 编译标准: <code>-std=c++11</code> .</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="bind1st和bind2nd"><a href="#bind1st和bind2nd" class="headerlink" title="bind1st和bind2nd"></a>bind1st和bind2nd</h2><p>绑定函数适配器, 将二元函数对象变成一元函数对象(也就是说, 原来二元函数对象中的一个参数是被绑定了的), 之后使用函数适配器即可, 使用起来比较简单.<br>bind1st绑定的是左边儿的参数(第一个参数), bind2nd是绑定的第二个参数(右边儿的参数).</p>
<p>直接看代码比较清楚:</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;
#include &lt;vector&gt;

using namespace std;


int main(void)
{
  binder1st&lt;plus&lt;int&gt; &gt; plusObj = bind1st(plus&lt;int&gt;(), 1);

  cout &lt;&lt; plusObj(2) &lt;&lt; endl; //3

  cout &lt;&lt; &quot;---------------&quot; &lt;&lt; endl;

  vector&lt;int&gt; v;
  for (int i = 0; i&lt;10; i++) {
    v.push_back(i+1);
  }

  //less or equal than 4
  int n = count_if(v.begin(), v.end(), bind2nd(less_equal&lt;int&gt;(),4));
  cout &lt;&lt; &quot;less or equal than 4: &quot; &lt;&lt; n &lt;&lt; endl;


  return 0;
}
</code></pre>
<p>注意编译的时候, 不要用 <code>-std=c++11</code> 这个标准, 会出现警告</p>
<pre><code>warning: ‘template&lt;class _Operation&gt; class std::binder1st’ 
   is deprecated [-Wdeprecated-declarations]
   binder1st&lt;plus&lt;int&gt;&gt; plusObj = bind1st(plus&lt;int&gt;(), 1);
   ^~~~~~~~~
In file included from /usr/include/c++/6/bits/stl_function.h:1127:0,
                 from /usr/include/c++/6/string:48,
                 from /usr/include/c++/6/bits/locale_classes.h:40,
                 from /usr/include/c++/6/bits/ios_base.h:41,
                 from /usr/include/c++/6/ios:42,
                 from /usr/include/c++/6/ostream:38,
                 from /usr/include/c++/6/iostream:39,
                 from tmp.cpp:1:
/usr/include/c++/6/backward/binders.h:108:11: note: declared here
     class binder1st
           ^~~~~~~~~
</code></pre><p>说明, bind1st和bind2nd 在新的标准中已经不提倡了. 应该用03的标准, 例如: <code>g++ -g -Wall -std=c++03 tmp.cpp -o main</code> .</p>
<p>并且<code>binder1st&lt;plus&lt;int&gt;&gt;</code> 也会报错:</p>
<pre><code>error: ‘&gt;&gt;’ should be ‘&gt; &gt;’ within a nested template argument list
</code></pre><p>应该写成 <code>binder1st&lt;plus&lt;int&gt; &gt;</code> .</p>
<h2 id="实现bind1st"><a href="#实现bind1st" class="headerlink" title="实现bind1st"></a>实现bind1st</h2><p>实现这样的一个 函数适配器, 形式上是在玩 函数模板 (调用函数模板my_bind1st返回一个函数对象my_binder1st), 实质上是把原来的二元操作, 转换为一元了.</p>
<p>首先需要一个类my_binder1st实现 <code>operator()(param)</code> 一元调用, 该类即作为函数对象类, 如下:</p>
<pre><code class="c++">template &lt;class Op, Class Pa&gt;
class my_binder1st
{
public:
    //外部调用者提供 secondParam
    Pa operator() (Pa secondParam)
    {
    //返回调用 Op操作的结果
    }
};
</code></pre>
<p>那么此时, 至少需要两个成员变量, 保存 <code>第一个参数</code>, 以及 <code>原始二元函数对象</code> , 并且要在构造器里初始化(因为你可能需要该函数对象的实例, 而不仅仅是调用operator()(Param)), 代码就变成了这样:</p>
<pre><code class="c++">template &lt;class Op, class Pa&gt;
class my_binder1st
{
private:
    Op binary_functor;
    Pa first_param;

public:
    my_binder1st(Op op, Pa pa)
    {
    binary_functor = op;
    first_param = pa;
    }

    Pa operator() (Pa secondParam)
    {
    //返回调用 Op操作的结果
    return binary_functor(first_param, secondParam);

    }
};
</code></pre>
<p>然而根据std提供的方式, 我们还不应该直接调用其构造函数, 得到my_binder1st的对象, 应该有相关的模板方法(或者使工厂方法), 就简单些一个函数模板吧:</p>
<pre><code>template&lt;class Op, class Pa&gt;
my_binder1st&lt;Op, Pa&gt; my_bind1st(Op functor, Pa first)
{
    return my_binder1st&lt;Op, Pa&gt;(functor, first);
} //注意返回值是值传递
</code></pre><p>之后直接使用my_bind1st调用, 或者去得到my_binder1st对象, 再进行调用, 都可以.</p>
<p>完整的代码可以是, 如下:</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;functional&gt;


using namespace std;

template &lt;class Op, class Pa&gt;
class my_binder1st
{
private:
  Op binary_functor;
  Pa first_param;

public:
  my_binder1st(Op op, Pa pa)
  {
    binary_functor = op;
    first_param = pa;
  }

  Pa operator() (Pa secondParam)
  {
    return binary_functor(first_param, secondParam);

  }
};

template&lt;class Op, class Pa&gt;
my_binder1st&lt;Op, Pa&gt; my_bind1st(Op functor, Pa first)
{
  return my_binder1st&lt;Op, Pa&gt;(functor, first);
} 



int main(void)
{
  my_binder1st&lt;plus&lt;int&gt;, int&gt; plusObj = my_bind1st(plus&lt;int&gt;(), 1);

  cout &lt;&lt; plusObj(2) &lt;&lt;endl; //1+2=3

  return 0;
}

//编译 g++ -g -Wall -std=c++03 tmp.cpp -o main
</code></pre>
<p>其实还是蛮简单的, 实际上我们总是在用适配之后的函数对象 my_binder1st, 所以, 就看你怎么去包装了(其实还可以写的更好, 关键在模板类的封装上).</p>
<h2 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h2><p>bind1st 和 bind2nd 不提倡了, 现在推荐使用的是 <code>std::bind</code> , 不仅仅包含了原来的两个功能, 还提供了全局性的绑定, 具体可以查看 cppreference.com , 我下面就详细说说看.</p>
<p>毫不夸张的说, 现在的各种绑定的, 都可以直接使用 std::bind, 无论是指针, 参数, 函数, 包括lambda表达式 等等, 当然可能和 <code>std::function</code> 结合的比较紧(std::function绑定成员函数不借助std::bind也是可以完成的，只需要传一个 <code>*this</code> 变量进去就好了). </p>
<p>例如你要绑定一个二元函数的参数, 可以这么做:</p>
<pre><code class="c++">auto fun = bind(&amp;func, std::placeholders::_2, std::placeholders::_1);
</code></pre>
<p>调用的时候通过 fun(1,2) 实现调用 func(2,1) , 其中func可以是指针, 函数对象, 函数, 包括lambda表达式 等等. 这种调用的时候使用占位符的叫做延迟计算绑定( <code>后绑定</code> ), 而调用 bind 时直接传入参数的叫做 <code>预先绑定</code> , 例如:</p>
<pre><code class="c++">auto fun = bind(&amp;func, xxxx, yyy);
</code></pre>
<p>区别:</p>
<ul>
<li>bind预先绑定的参数需要传具体的变量或值进去, 对于预先绑定的参数, 是pass-by-value的</li>
<li>对于不事先绑定的参数，需要传 std::placeholders 进去, 从 _1 开始, 依次递增, placeholder是pass-by-reference的<br>(记得占位符绑定的时候传参是引用即可; 或者你预先绑定的时候就传入引用参数)<br>注意: 对于绑定的指针&amp;引用类型的 “参数” , 使用者需要保证在可调用实体调用之前, 这些指针所指是可用的(绑定本身不对安全性做担保).</li>
</ul>
<p>占位符的讲解<br>std::placeholders是一个占位符. 当使用 bind 生成一个 <code>新的可调用对象</code> 时, std::placeholders表示新的可调用对象的参数位置. </p>
<pre><code class="c++">bind(&amp;func, std::placeholders::_2, std::placeholders::_1)
</code></pre>
<p>解释:</p>
<ul>
<li>你调用 新的函数对象fun 时第2个参数(即占位符_2代表的参数)和原来函数对象 func 的第1个参数匹配, 而fun的第1个占位符参数和原来函数对象func的第2个参数匹配. 也就是placeholder是代表你使用新的函数对象的顺序.</li>
<li>该语句中传入参数是给原来的func用的, 所以是按照顺序传参的, 即新的函数对象被调用时传入的参数<code>_2</code>是给原来函数对象的第1个参数用的(因为语句中是写在前面的). 也就是你在bind语句的书写顺序就是原函数的参数顺序;  参数的绑定可以由你自己指定, 但是建议按照顺序来, 以免出错.</li>
</ul>
<p>总结: 你就记得你总是在用绑定后生成的新对象在进行调用, 那么新对象的参数位置是用 placeholders 进行标记的, 例如 <code>fun(2,1);</code> 这里实参<code>2</code>就是第一个placeholder, 实参<code>1</code>是第二个placeholder; 然后根据你定义的bind规则填充原函数func(placeholder::_2, placeholder::_1);//这样进行调用</p>
<p>std::bind 绑定的参数的个数不受限制, 绑定的具体哪些参数也不受限制, 由用户指定, 这个bind才是真正意义上的绑定.</p>
<p>绑定类型</p>
<ul>
<li><p>普通函数(直接在bind语句写函数的名字,但是为了避免重载函数的干扰, 最好转换成函数指针, 用函数指针进行)<br>见下面代码:</p>
<pre><code class="c++">//有两个重载函数参数不同, 但是名字都叫做f
typedef int (*f_int_int)(int, int);
typedef int (*f_double_double)(double, double);

f_int_int pf1 = f;
f_double_double pf2= f;

cout &lt;&lt; bind(pf1, 1, 1) &lt;&lt;endl; //相当于直接&amp;f
cout &lt;&lt; bidn(pf2, 1.0, 1.0) &lt;&lt; endl;
</code></pre>
</li>
<li><p>函数对象(直接在bind语句写函数对象的实例)<br>例如:</p>
<pre><code class="c++">std::bind(std::greater&lt;int&gt;(), _1, 10);
//这样就生成了一个funtion对象, 可以直接在此基础上进行实例调用
std::bind(std::greater&lt;int&gt;(), _1, 10)(11);(11&lt;10, 该表达式是false)
</code></pre>
<p>稍微注意一下, 标准库中的函数对象都是有定义 <code>result_type</code> 的, 如果你自定义的函数对象, 那么绑定的时候要定义一下.</p>
<pre><code class="c++">class add : public std::binary_function&lt;int, int, void&gt; //这里void就定义了result_type是void
{
 public:
    //或者遵循规范, 内部定义result_type
    typedef void result_type;

    void operator()(int i, int j) const
    {
        std::cout &lt;&lt; i + j &lt;&lt; std::endl;
    }
};

int main(void)
{
   std:: vector&lt;int&gt; v;
   v.push_back(1);
   v.push_back(3);

   std::for_each(v.begin(), v.end(), std::bind(add,10,_1);
   //相当于
   //std::for_each(v.begin(), v.end(), std::bind&lt;void&gt;(add,10,_1);
}
</code></pre>
<p>即 <code>bind&lt;result_type&gt;(functor, ...);</code></p>
</li>
<li>绑定成员函数或者对象<br>一定要传入this指针, 即对象的地址, 下面给一个简单的案例:<br>```c++<br>#include <random><br>#include <iostream><br>#include <memory><br>#include <functional></functional></memory></iostream></random></li>
</ul>
<p>struct Foo {<br>  void print_sum(int n1, int n2)<br>  {<br>    std::cout &lt;&lt; n1+n2 &lt;&lt; ‘\n’;<br>  }<br>  int data = 10;<br>};</p>
<p>int main()<br>{<br>  using namespace std::placeholders;  // for _1, _2, _3…</p>
<p>  // bind to a pointer to member function<br>  Foo foo;<br>  auto f3 = std::bind(&amp;Foo::print_sum, &amp;foo, 95, _1);<br>  f3(5);//5作为foo.print_sum的第二个参数</p>
<p>  // bind to a pointer to data member<br>  //绑定的时候, 没有传入this指针, 则调用时要传入(指针或者引用)<br>  auto f4 = std::bind(&amp;Foo::data, _1);<br>  std::cout &lt;&lt; f4(foo) &lt;&lt; ‘\n’;//实际上传入的是引用</p>
<p>  //上面f4还可以写成如下形式(绑定时就传入this指针)<br>  auto f5 = std::bind(&amp;Foo::data, &amp;foo); //这里传入引用也是可以的<br>  std::cout &lt;&lt; f5() &lt;&lt; std::endl;</p>
<p>  //当然也可以拿着去绑定pair对象的first和second成员<br>  //pair<int, string=""> p(1, “1”);<br>  //cout &lt;&lt; bind(&amp;pair<int, string="">::fist, p)() &lt;&lt; endl;<br>}</int,></int,></p>
<pre><code>
而且用于STL算法时, std::bind 降低了算法函数绑定对象的要求:
```c++
vector&lt;point&gt; v(10);
vector&lt;x&gt; v2(10); //专门记录point的横坐标

//初始化 容器v
...

transform(v.begin(), v.end(), v2.begin(), bind(&amp;point::x, _1));
for(auto x: v2){
  cout &lt;&lt; x &lt;&lt; &quot;,&quot;;
}
</code></pre><p>更加复杂的, 嵌套式绑定, 运算符重载式绑定, 最好不要用, 绑定标准C库的函数等, 太过复杂, 容易出错.(或者选用lambda表达式)</p>
<p>(注意: 绑定标准C库函数的时候, 可能还会扯上调用方式 <code>_stdcall</code>, <code>_fastcall</code>, 以及修饰 <code>extern &quot;C&quot;</code>, 具体可以参考相关的宏控制)</p>
<p>补充: </p>
<ul>
<li>bind的返回值是可调用实体, 可以直接赋给std::function对象; </li>
<li>山寨一个<a href="http://www.cnblogs.com/xusd-null/p/3693817.html" target="_blank" rel="external">bind</a></li>
<li>绑定虚函数的时候和绑定成员函数没有区别, 但是虚函数的行为还是根据调用时的实例确定</li>
<li>绑定成员函数还可以直接使用 std::mem_fn</li>
<li>如果你还是不能理解绑定过程, 那么我推荐你看一篇 <a href="http://blog.think-async.com/2010/04/bind-illustrated.html" target="_blank" rel="external">图</a> 该图大致画出了相关意思, 并且给出了bind的大致实现思路.</li>
</ul>
<hr>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>在使用 <code>std::bind</code> 的时候注意一下, 绑定的参数的安全性, 顺序, 以及绑定成员成分(函数, 数据)时, 一定要在后面传入this指针或者本对象的地址, 如果你不绑定, 那么实际调用的时候就要传入.</p>
<p>绑定实际上是, 统一了多种调用形式, 并且用 function 对象接收, 从而实现完全的面向对象操作方法.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="http://blog.think-async.com/2010/04/bind-illustrated.html" target="_blank" rel="external">http://blog.think-async.com/2010/04/bind-illustrated.html</a><br>(图解了std::bind的绑定和延迟计算过程)</li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="/" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：bind-in-cpp</span><br/>
	<span><b>本文链接</b>：www.merlinblog.site/2017/07/01/bind-in-cpp.html</span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="/css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>

