<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="pragma" content="no-cache">
  <meta http-equiv="cache-control" content="no-cache">
  <meta http-equiv="expires" content="0">
  
  <title>smart-pointers | Merlin&#39;s Blog</title>
  <meta name="author" content="MerlinYu">
  
  <meta name="description" content="集中说说Boost和标准库中的智能指针">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <meta property="og:title" content="smart-pointers"/>
  <meta property="og:site_name" content="Merlin&#39;s Blog"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="ico">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">Merlin&#39;s Blog</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		  <li>
			<a href="/atom.xml" title="Subscribe me.">
			  <i class=""></i>RSS
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 


	
		<div class="page-header">
			<h1> smart-pointers</h1>
		</div>
	



<div class="row post">
	<!-- cols -->
	
	<div id="top_meta"></div>
	<div class="col-md-9">
	

	<!-- content -->
	<div class="mypage">		
	  
		 <div class="alert alert-success description">
			<i class="fa fa-info-circle"></i> 集中说说Boost和标准库中的智能指针
		 </div> <!-- alert -->
	  		

	  <p>智能指针的引入并没有完全解决资源自动回收的问题, 或者你不能做刷手掌柜, 但是也很大程度上简化了相关问题的处理.本文集中讲讲Boost或者标准库中的几种智能指针, 以 <code>用好</code> 为宗旨.<br>期间可能会遇到 <code>Noncopyable</code> 的智能指针 装入容器 问题(比如 unique_ptr ).<br><a id="more"></a></p>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>C++(包括C语言中已存的一些关于内存的问题):</p>
<ul>
<li>空指针异常</li>
<li>越界访问</li>
<li>野指针</li>
<li>内存泄露</li>
</ul>
<p>本质上都是因为编程能力造成，但是如果有自动回收，智能管理之类的(就像Java的垃圾回收机制)策略是不是更方便呢？</p>
<p>Boost给出了相关的方案，智能指针smart pointers.<br>(当然STL野给出了auto_ptr，但是受到了限制比较多，而且存在一些问题，例如不支持拷贝构造函数以及赋值等，一般不推荐使用了)</p>
<p>后来C++11也从Boost引入了3个智能指针:(本质上就是Boost的那一套)</p>
<ul>
<li>unique_ptr<br>smart pointer with unique object ownership semantics </li>
<li>shared_ptr<br>smart pointer with shared object ownership semantics </li>
<li>weak_ptr<br>weak reference to an object managed by std::shared_ptr </li>
</ul>
<p>现在用起来更加方便了.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="Boost智能指针"><a href="#Boost智能指针" class="headerlink" title="Boost智能指针"></a>Boost智能指针</h2><p>官方文档时这么说的:</p>
<blockquote>
<p>Smart pointers are objects which store pointers to dynamically allocated (heap) objects. They behave much like built-in C++ pointers except that they automatically delete the object pointed to at the appropriate time.<br>(到底是什么时候回收呢？ appropriate time)</p>
<p>Smart pointers are particularly useful in the face of exceptions as they ensure proper destruction of dynamically allocated objects. They can also be used to keep track of dynamically allocated objects shared by multiple owners.</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></div><div class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> boost;</div></pre></td></tr></table></figure>
<p>大致上给了6种：</p>
<ol>
<li>scoped_ptr    <boost scoped_ptr.hpp="">           Simple sole ownership of single objects. Noncopyable.</boost></li>
<li>scoped_array    <boost scoped_array.hpp="">       Simple sole ownership of arrays. Noncopyable.</boost></li>
<li>shared_ptr    <boost shared_ptr.hpp="">           Object ownership shared among multiple pointers.</boost></li>
<li>shared_array    <boost shared_array.hpp="">       Array ownership shared among multiple pointers.</boost></li>
<li>weak_ptr    <boost weak_ptr.hpp="">           Non-owning observers of an object owned by shared_ptr.</boost></li>
<li>intrusive_ptr                   <boost intrusive_ptr.hpp="">  Shared ownership of objects with an embedded reference count.</boost></li>
</ol>
<p>scope_ptr, Noncopyable也就是说不可以拷贝和赋值; 相比而言 shared_ptr则要好很多.<br>(array和普通指针的区别在于负责new还是new [])</p>
<p>Additionally, the smart pointer library provides efficient factory functions for creating smart pointer objects:<br>(直接new创建智能指针消耗比较大, 这里可以用一下工厂方法)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">make_shared,  allocate_shared <span class="keyword">for</span> objects	&lt;boost/make_shared.hpp&gt;	Efficient creation of <span class="built_in">shared_ptr</span> objects.</div><div class="line">make_shared,  allocate_shared <span class="keyword">for</span> arrays	&lt;boost/make_shared.hpp&gt;	Efficient creation of <span class="built_in">shared_ptr</span> arrays.</div><div class="line">make_unique    &lt;boost/make_unique.hpp&gt;		 Creation of <span class="built_in">unique_ptr</span> objects and arrays.</div></pre></td></tr></table></figure></p>
<p>即 <code>&lt;boost/make_shared.hpp&gt;</code> 和 <code>&lt;boost/make_unique.hpp&gt;</code> , 大致像下面这样的用法:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strp = make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"make_test"</span>);</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vecp = make_shared&lt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(<span class="number">10</span>, <span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>挨个说一下(重点放在 <code>shared_ptr</code> 和 <code>weak_ptr</code>, 其他不常用的不说)</p>
<h3 id="scoped-ptr"><a href="#scoped-ptr" class="headerlink" title="scoped_ptr"></a>scoped_ptr</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Smart_Ptr.cpp : 定义控制台应用程序的入口点*/</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/smart_ptr.hpp&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></div><div class="line"></div><div class="line"><span class="keyword">class</span> Test </div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">	Test(<span class="keyword">int</span> x = <span class="number">0</span>);</div><div class="line">	<span class="keyword">virtual</span> ~Test();</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getX</span><span class="params">()</span> <span class="keyword">const</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="keyword">int</span> x;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line">Test::Test(<span class="keyword">int</span> x) </div><div class="line">&#123;</div><div class="line">	<span class="keyword">this</span>-&gt;x = x;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"constructor called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Test::~Test()</div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deconstructor called"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">int</span> Test::getX() <span class="keyword">const</span></div><div class="line">&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>-&gt;x;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main Function start"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//basic type: int</span></div><div class="line">	boost::scoped_ptr&lt;<span class="keyword">int</span>&gt; int_ptr(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>));</div><div class="line">	++*int_ptr;</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *int_ptr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">//class type: Test</span></div><div class="line">	boost::scoped_ptr&lt;Test&gt; class_ptr(<span class="keyword">new</span> Test(<span class="number">1</span>));</div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; class_ptr-&gt;getX() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	class_ptr.reset();</div><div class="line"></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main Function end"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行结果如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Main Function start</div><div class="line"><span class="number">101</span></div><div class="line">constructor called</div><div class="line"><span class="number">1</span></div><div class="line">deconstructor called</div><div class="line">Main Function end</div></pre></td></tr></table></figure>
<p>不用手动调用<code>delete ptr</code>确实不错，但是也有限制：</p>
<ul>
<li>scoped_ptr 只限于作用域内使用(出了定义智能指针的范围,管不了)</li>
<li>指针管理权不可转移，不支持拷贝构造函数与赋值操作</li>
</ul>
<p>总结一下：</p>
<pre><code>scoped_ptr&lt;T&gt; ptr_t(new T); //创建了一个智能指针维护空间
ptr_t.reset(); //调用delete指针所指向空间
ptr_t-&gt;get(); //返回内部管理的指针, 但禁止在get()出来的指针上执行delete
</code></pre><h3 id="shared-ptr"><a href="#shared-ptr" class="headerlink" title="shared_ptr"></a>shared_ptr</h3><p>这个是重点, 可以看做auto_ptr的替代品, 内置引用计数, 支持拷贝和赋值, 支持 <code>*</code> 和 <code>-&gt;</code> 运算</p>
<p>在 <code>scoped_ptr</code> 的基础上还要注意:</p>
<ul>
<li>不要循环引用(这个 <code>weak_ptr</code> 出面解决)</li>
<li>不要用于函数的匿名参数(特别注意)</li>
<li><code>ptr.use_count()</code> 可以查看当前引用计数</li>
<li><code>ptr.unique()</code> 查看引用是否唯一</li>
</ul>
<p>例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">bad</span><span class="params">()</span> </span></div><div class="line">&#123; </div><div class="line">    f( <span class="built_in">shared_ptr</span>(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">2</span>)), g() ); </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>应该写成:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">void ok() </div><div class="line">&#123; </div><div class="line">    shared_ptr p(new int(2)); </div><div class="line">    f(p, g()); </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>详细看一下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p0;</div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1(<span class="keyword">new</span> <span class="keyword">int</span>);</div><div class="line">*p1=<span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;p2(p1); <span class="comment">//p1引用计数+1; p1和p2同时管理一个内部指针</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="string">" value: "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">*p2 = <span class="number">13</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="string">" value: "</span> &lt;&lt; *p2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">p2.reset();</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"p1 count: "</span> &lt;&lt; p1.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;  <span class="comment">//p2解除之后引用计数-1</span></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line">    Main Function start</div><div class="line">    p1 count: 2 value: 1</div><div class="line">    p1 count: 2 value: 13</div><div class="line">    p1 count: 1</div><div class="line">    Main Function end</div><div class="line">*/</div><div class="line"><span class="comment">/*---------------------------------------------------------------------------*/</span></div><div class="line"></div><div class="line"><span class="comment">// shared_ptr(std::auto_ptr&lt;Y&gt; &amp; r) 从 auto_ptr 获得指针管理权; 同时 auto_ptr 失去管理权</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; p;</div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p3(p);</div><div class="line"></div><div class="line"><span class="comment">// 从另外一个 shared_ptr 或 auto_ptr 获得指针管理权(拷贝构造函数)</span></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p4 = p1;</div><div class="line"></div><div class="line"><span class="comment">//shared_ptr&lt;Y&gt;(Y * p, D d) 类似于 shared_ptr&lt;Y&gt;(Y * p)</span></div><div class="line"><span class="comment">// 第一个参数是要被管理的指针; </span></div><div class="line"><span class="comment">// 第二个删除参数 d 告诉 shared_ptr 在析构时不使用 delete 来操作指针 p, 而使用 d 来操作;</span></div><div class="line"><span class="comment">// 把 delete p 换成调用 d(p) 函数对象.</span></div></pre></td></tr></table></figure>
<p>其他的方法，可以利用 <code>&lt;boost/make_shared.hpp&gt;</code> 提供的工厂方法:<br>(创建效率高)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// include &lt;boost/make_shared.hpp&gt;</span></div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; strp = make_shared&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(<span class="string">"make_test"</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *strp &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vec_ptr = make_shared&lt; <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;(<span class="number">10</span>, <span class="number">3</span>);</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; vecp_ptr-&gt;size() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure></p>
<p>把智能指针放到容器中:(因为其实现了拷贝构造和赋值操作)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;boost::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt;&gt; ptr_vector;</div><div class="line"></div><div class="line"><span class="function">ptr_vector <span class="title">vector</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line"></div><div class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</div><div class="line"><span class="keyword">for</span> (ptr_vector::iterator it = <span class="built_in">vector</span>.begin(); it != <span class="built_in">vector</span>.end(); ++it) &#123;</div><div class="line">    *it = boost::make_shared&lt;<span class="keyword">int</span>&gt;(i++);</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *(*it) &lt;&lt; <span class="string">" "</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Main Function end"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line"></div><div class="line">   <span class="comment">/*result</span></div><div class="line">       Main Function start</div><div class="line">       0 1 2 3 4 5 6 7 8 9</div><div class="line">       Main Function end</div><div class="line">   */</div></pre></td></tr></table></figure>
<p>如果想修改其中一个成员, 比如说vector中最后一个成员:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptest = <span class="built_in">vector</span>[<span class="number">9</span>];</div><div class="line">*ptest = <span class="number">100</span>;</div><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *<span class="built_in">vector</span>[<span class="number">9</span>] &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div></pre></td></tr></table></figure>
<p>用于自定义类型时候:</p>
<p>如果一个类, 有成员是需要手动的分配空间的, 例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> Test</div><div class="line">&#123;</div><div class="line">    <span class="keyword">private</span>:</div><div class="line">        <span class="keyword">int</span> *data;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时Test就要手动处理 <code>拷贝构造</code> 和 <code>赋值</code>还有<code>析构</code>; 避免由于浅拷贝导致的重复析构.比如说分配独立的Heap(构造函数重新分配成员空间；赋值函数先删除本对象原来的，再重新分配，或者使用临时对象)，即深拷贝来解决问题(说了太多遍，就不写例子了)</p>
<p>然而自从有了shared_ptr, 不用手动提供拷贝构造和赋值方法了, 因为编译器帮你实现了默认的方法解决智能指针拷贝，引用计数等问题, 例子如下:<br>(前提是你使用的是智能指针作为成员)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">class</span> ClassInt</div><div class="line">&#123;</div><div class="line"><span class="keyword">private</span>:</div><div class="line">	<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; ptr_data;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">	ClassInt(<span class="keyword">int</span> data_param) :ptr_data(<span class="keyword">new</span> <span class="keyword">int</span>)</div><div class="line">	&#123;</div><div class="line">	    init(data_param);</div><div class="line">	    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"construct"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">			</div><div class="line">	<span class="keyword">virtual</span> ~ClassInt()</div><div class="line">	&#123;</div><div class="line">	    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"destructor, count = "</span> &lt;&lt; ptr_data.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get_data</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">	&#123;</div><div class="line">	    <span class="keyword">return</span> *ptr_data;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">				  </div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">ptr_count</span><span class="params">()</span> <span class="keyword">const</span> </span></div><div class="line">	&#123;</div><div class="line">	    <span class="keyword">return</span> ptr_data.use_count();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">					 </div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> data_param)</span></span></div><div class="line">	&#123;</div><div class="line">	    *ptr_data = data_param;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">	<span class="function">ClassInt <span class="title">c1</span><span class="params">(<span class="number">10</span>)</span></span>;</div><div class="line">	<span class="function">ClassInt <span class="title">c2</span><span class="params">(c1)</span></span>;</div><div class="line">	ClassInt c3 = c2;</div><div class="line"></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c1.ptr_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//3</span></div><div class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; c2.get_data() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//10</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ptr_count 的数量可以看出他们指向了同样的地址, 而使用了 shared_ptr, 所以销毁的时候, 不会重复析构(先对引用计数操作).</p>
<h3 id="weak-ptr"><a href="#weak-ptr" class="headerlink" title="weak_ptr"></a>weak_ptr</h3><p>weak_ptr 被设计为与 shared_ptr 共同工作，可以从一个 shared_ptr 或者另一个 weak_ptr 对象构造，获得资源的观测权.<br>值得强调的是weak_ptr一定从shared_ptr初始化而来, 它就是shared_ptr的助手(不能像普通指针那样使用 <code>-&gt;</code> 和 <code>*</code> 操作), 用于解决循环引用问题.<br>但是 weak_ptr 没有共享资源，它的构造不会引起指针引用计数的增加，同时，在析构的时候也不会引起引用计数的减少.(但是却可以从weak_ptr还原得到一个shared_ptr)</p>
<p>主要用于打破循环引用, 不能两方都是用强引用, 要有一方使用weak_ptr，才能在相互引用的情况下, 保证引用计数可以减为1, 从未正确释放.</p>
<p>例子：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div></pre></td><td class="code"><pre><div class="line">class parent;</div><div class="line">class children;</div><div class="line"></div><div class="line">typedef boost::shared_ptr&lt;parent&gt; parent_ptr;</div><div class="line">typedef boost::shared_ptr&lt;children&gt; children_ptr;</div><div class="line"></div><div class="line">class parent</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	~parent() </div><div class="line">	&#123; </div><div class="line">	  std::cout &lt;&lt; "destroying parent" &lt;&lt; std::endl;;</div><div class="line">	  &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">	children_ptr children;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">class children</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">	~children() </div><div class="line">	&#123; </div><div class="line">	  std::cout &lt;&lt; "destroying children\n"; </div><div class="line">	  &#125;</div><div class="line"></div><div class="line">public:</div><div class="line">	parent_ptr parent;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">int main()</div><div class="line">&#123;</div><div class="line">	parent_ptr father(new parent()); //father.use_count 1</div><div class="line">	children_ptr son(new children);  //son.use_count 1</div><div class="line"></div><div class="line">	std::cout &lt;&lt; "parent_ptr count " &lt;&lt; father.use_count() &lt;&lt; std::endl;</div><div class="line">	std::cout &lt;&lt; "child_ptr count " &lt;&lt; son.use_count() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">	std::cout &lt;&lt; "------------------" &lt;&lt; std::endl;</div><div class="line"></div><div class="line">	/*相互赋值, 导致循环引用*/</div><div class="line">	father-&gt;children = son;</div><div class="line">	son-&gt;parent = father;</div><div class="line"></div><div class="line">	std::cout &lt;&lt; "parent_ptr count " &lt;&lt; father.use_count() &lt;&lt; std::endl;</div><div class="line">	std::cout &lt;&lt; "child_ptr count " &lt;&lt; son.use_count() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">	/*</div><div class="line">	parent_ptr count 1</div><div class="line">	child_ptr count 1</div><div class="line">	------------------</div><div class="line">	parent_ptr count 2</div><div class="line">	child_ptr count 2</div><div class="line">	Main Function end</div><div class="line">	*/</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当你析构father的时候, father引用计数减少1；但是由于son还引用着呢, 所以引用计数没有减少到0; 所以father指针所指向的parent的析构函数调用失败(引用计数还剩1); son指针销毁children的情况类似.</p>
<p>解决方法，引入weak_ptr:</p>
<ul>
<li>expired()用于检测所管理的对象是否已经释放</li>
<li>lock()用于获取所管理的对象的强引用指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//parent 代码不变;</span></div><div class="line"><span class="keyword">class</span> children</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    ~children() &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt;<span class="string">"destroying children\n"</span>; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    boost::weak_ptr&lt;parent&gt; parent; <span class="comment">//弱引用</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>运行结果就变成了:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">int main(void)</div><div class="line">&#123;</div><div class="line">	parent_ptr father(new parent()); //father.use_count 1</div><div class="line">	children_ptr son(new children);  //son.use_count 1</div><div class="line"></div><div class="line">	std::cout &lt;&lt; "parent_ptr count " &lt;&lt; father.use_count() &lt;&lt; std::endl;</div><div class="line">	std::cout &lt;&lt; "child_ptr count " &lt;&lt; son.use_count() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">	std::cout &lt;&lt; "------------------" &lt;&lt; std::endl;</div><div class="line"></div><div class="line">	father-&gt;children = son; //son.use_count 2</div><div class="line">	son-&gt;parent = father; //father.use_count 1</div><div class="line"></div><div class="line">	std::cout &lt;&lt; "parent_ptr count " &lt;&lt; father.use_count() &lt;&lt; std::endl;</div><div class="line">	std::cout &lt;&lt; "child_ptr count " &lt;&lt; son.use_count() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">	/*</div><div class="line">	Main Function start</div><div class="line">	parent_ptr count 1</div><div class="line">	child_ptr count 1</div><div class="line">	------------------</div><div class="line">	parent_ptr count 1</div><div class="line">	child_ptr count 2</div><div class="line">	destroying parent</div><div class="line">	destroying children</div><div class="line">	Main Function end</div><div class="line">	*/</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上面看到，赋值给weak_ptr的仍旧是 <code>boost::shared_ptr&lt;parent&gt;</code>,即 <code>shared_ptr</code>.</p>
<h2 id="标准库智能指针"><a href="#标准库智能指针" class="headerlink" title="标准库智能指针"></a>标准库智能指针</h2><p>C++11引入的3个智能指针全部都在 <code>&lt;memory&gt;</code> 头文件中, <code>shared_ptr</code>和<code>weak_ptr</code>大致和Boost一样.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> pShared = <span class="built_in">std</span>::make_shared&lt;T&gt;(<span class="keyword">new</span> T)</div><div class="line"><span class="keyword">auto</span> pWeak = <span class="built_in">std</span>::make_shared&lt;T&gt;(pShared);</div><div class="line"></div><div class="line"><span class="keyword">if</span>(pWeak.expired()) &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The Obj is no longer exists"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; pNew(pWeak.lock()); <span class="comment">//如果对象已经销毁则返回的是nullptr</span></div><div class="line"><span class="keyword">if</span>(pNew)&#123;</div><div class="line">    <span class="comment">//doing sth.</span></div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The Obj is no longer exists"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意 <code>shared_ptr</code> 没有权限转移行为, 因为他是基于引用计数的, 所以这样的代码是错误的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">auto</span> old_ptr = <span class="built_in">std</span>::make_unique&lt;T&gt;(<span class="keyword">new</span> T);</div><div class="line"></div><div class="line"><span class="comment">//shared_ptr没有release()方法</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;T&gt; new_ptr(old_ptr.release());</div></pre></td></tr></table></figure></p>
<p>下面主要说说 <code>unique_ptr</code></p>
<h3 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h3><p>这个本质上和 <code>scoped_ptr</code> 有点儿像, 不能拷贝, 不能赋值, 所以你想把外部具名的 unique_ptr 实例放入容器是不能的了.<br>作为函数参数, 返回值, 值传递也是不可能的了, 但是下面的案例除外:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; f(<span class="keyword">int</span> i)&#123;</div><div class="line">    <span class="keyword">if</span> (i == <span class="number">0</span>)</div><div class="line">        <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">0</span>));</div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">auto</span> p = f(<span class="number">2</span>);</div><div class="line">    <span class="comment">/*std::unique_ptr&lt;int&gt;  p;</span></div><div class="line">      p = f(2); //wrong</div><div class="line">    */</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里采用了匿名对象(临时对象), 直接初始化到容器内(相当于有人接收, 所以小三直接上位, 临时变量也不用销毁了), 但是注释起来的则产生的中间对象没有人接收, 行为不确定, 要看具体的编译器处理.(但是这样返回的临时对象的unique_ptr实在没有意义)</p>
<p>补充知识: 具名返回值优化<br>C++ 11确实可以用move构造编译通过, 即便没有move构造, 还有一种潜规则即 <code>Named Return Value Optimization</code> (具名返回值优化). 这种情况下由于返回的时一个临时对象，所以编译器会将接受返回值的对象的引用传进去直接进行构造.</p>
<p>下面的代码也是 ok 的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Runtime polymorphism demo\n"</span>;</div><div class="line">&#123;</div><div class="line">    <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;B&gt; p = <span class="built_in">std</span>::make_unique&lt;D&gt;(); <span class="comment">// p is a unique_ptr that owns a D</span></div><div class="line">    </div><div class="line">    <span class="comment">// as a pointer to base</span></div><div class="line">    p-&gt;bar(); <span class="comment">// virtual dispatch</span></div><div class="line"></div><div class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;B&gt;&gt; v;  <span class="comment">// unique_ptr can be stored in a container</span></div><div class="line"></div><div class="line">    v.push_back(<span class="built_in">std</span>::make_unique&lt;D&gt;());</div><div class="line">    v.push_back(<span class="built_in">std</span>::move(p));<span class="comment">//</span></div><div class="line">    v.push_back(p);           <span class="comment">//</span></div><div class="line">    v.emplace_back(<span class="keyword">new</span> D);</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : v) &#123;</div><div class="line">    	p-&gt;bar(); <span class="comment">// virtual dispatch</span></div><div class="line">    &#125;</div><div class="line">&#125;   <span class="comment">// ~D called 3 times</span></div></pre></td></tr></table></figure>
<p>因为存入容器的, 全部是没有调用拷贝构造的(直接新生成的或者采用移动构造转移所有权的), 保证了 <code>unique</code> 的不共享特性. </p>
<p><code>v.push_back(std::make_unique&lt;D&gt;());</code> 临时的右值, 编译器允许. (就相当于一个中间对象)</p>
<p>其他使用(reset, release等不说了)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">size_t</span> len[<span class="number">10</span>];</div><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; pnumbers(<span class="keyword">new</span> <span class="keyword">int</span>[len]);</div><div class="line"><span class="comment">//or</span></div><div class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>[]&gt; pnums = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>[]&gt;(len);</div></pre></td></tr></table></figure></p>
<p>控制权的转移:</p>
<ul>
<li>std::move</li>
<li>reset(release())<br>(前一种方式其实是利用临时右值, 进行权限转移)</li>
</ul>
<p><code>unique_ptr</code> 不支持拷贝和复制, 所以只能唯一引用, 这和它的(回收机制)实现可能有关.<br>(后面有时间再说)</p>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>几种智能指针的使用还是比较简单的, 中间也会有一些坑, 稍微注意一下就好了.</p>
<p>但是智能指针的引入, 并没有完全解决相关回收泄露问题, 只是一定程度上缓解了, 简化了操作, 也就是说, 还是需要人为注意.</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://www.boost.org/doc/libs/1_60_0/libs/smart_ptr/smart_ptr.htm" target="_blank" rel="external">http://www.boost.org/doc/libs/1_60_0/libs/smart_ptr/smart_ptr.htm</a></li>
<li>《Boost程序库完全开发指南》</li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>
	  
	</div>

	<div>
  	<center>
	<div class="pagination">

    
    
    <a href="/2017/07/01/effective-cpp.html" type="button" class="btn btn-default"><i
                class="fa fa-arrow-circle-o-left"></i> Prev</a>
    

    <a href="/" type="button" class="btn btn-default"><i class="fa fa-home"></i>Home</a>
    
    <a href="/2017/06/30/cpp-library-in-linux.html" type="button" class="btn btn-default ">Next<i
                class="fa fa-arrow-circle-o-right"></i></a>
    

    
</div>

    </center>
	</div>
	
	<!-- comment -->
	

	</div> <!-- col-md-9/col-md-12 -->
		
	
	<div id="side_meta">
		<div class="col-md-3" id="post_meta"> 

	<!-- date -->
	
	<div class="meta-widget">
	<i class="fa fa-clock-o"></i>
	2017-07-01 
	</div>
	

	<!-- categories -->
    
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#categorys"><i class="fa fa-folder"></i></a>	
    <ul id="categorys" class="tag_box list-unstyled collapse in">
          
  <li>
    <li><a href="/categories/codings/">codings<span>53</span></a></li>
  </li>

    </ul>
	</div>
	

	<!-- tags -->
	
	<div class="meta-widget">
	<a data-toggle="collapse" data-target="#tags"><i class="fa fa-tags"></i></a>		  
    <ul id="tags" class="tag_box list-unstyled collapse in">	  
	    
  <li><a href="/tags/boost/">boost<span>7</span></a></li> <li><a href="/tags/c/">c++<span>12</span></a></li>
    </ul>
	</div>
		

	<!-- toc -->
	<div class="meta-widget">
	
	   <a data-toggle="collapse" data-target="#toc"><i class="fa fa-bars"></i></a>
	   <div id="toc" class="toc collapse in">
		   <span class="toc-title">Contents</span>
			<ol class="toc-article"><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#引子"><span class="toc-article-text">引子</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#正文"><span class="toc-article-text">正文</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#Boost智能指针"><span class="toc-article-text">Boost智能指针</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#scoped-ptr"><span class="toc-article-text">scoped_ptr</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#shared-ptr"><span class="toc-article-text">shared_ptr</span></a></li><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#weak-ptr"><span class="toc-article-text">weak_ptr</span></a></li></ol></li><li class="toc-article-item toc-article-level-2"><a class="toc-article-link" href="#标准库智能指针"><span class="toc-article-text">标准库智能指针</span></a><ol class="toc-article-child"><li class="toc-article-item toc-article-level-3"><a class="toc-article-link" href="#unique-ptr"><span class="toc-article-text">unique_ptr</span></a></li></ol></li></ol></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#尾巴"><span class="toc-article-text">尾巴</span></a></li><li class="toc-article-item toc-article-level-1"><a class="toc-article-link" href="#参考"><span class="toc-article-text">参考</span></a></li></ol>
		</div>
	
	</div>
	
    <hr>
	
</div><!-- col-md-3 -->

	</div>
		

</div><!-- row -->



	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 MerlinYu
  
     
     <br> Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind.386</a>.    
</p>
 </footer>
</div> <!-- container-narrow -->
  


  
<a id="gotop" href="#">   
  <span>⬆︎TOP</span>
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



</body>
   </html>
