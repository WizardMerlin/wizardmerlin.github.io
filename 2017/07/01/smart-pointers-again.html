<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>再说说智能指针 | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="说完了Boost和std中的智能指针, 也尝试实现看看">
<meta name="keywords" content="cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="再说说智能指针">
<meta property="og:url" content="www.merlinblog.site/2017/07/01/smart-pointers-again.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="说完了Boost和std中的智能指针, 也尝试实现看看">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.jpg">
<meta property="og:updated_time" content="2017-09-24T05:12:31.411Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="再说说智能指针">
<meta name="twitter:description" content="说完了Boost和std中的智能指针, 也尝试实现看看">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.jpg">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="../../../css/common.css">
<link rel="stylesheet" href="../../../css/nav.css">
<link rel="stylesheet" href="../../../css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="../../../index.html">
                主页
            </a>
            
            <a class="nav-item" href="../../../tags">
                标签集合
            </a>
            
            <a class="nav-item" href="../../../works">
                开源作品
            </a>
            
            <a class="nav-item" href="../../../about">
                关于博主
            </a>
            
            <a class="nav-item" href="../../../atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="../../../index.html">
                主页
            </a>
            
            <a class="nav-item flex-1" href="../../../tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="../../../works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="../../../about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="../../../atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="../../../css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引子"><span class="toc-number">1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#智能指针实现机制"><span class="toc-number">2.1.</span> <span class="toc-text">智能指针实现机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#引用计数简单实现"><span class="toc-number">2.2.</span> <span class="toc-text">引用计数简单实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#auto-ptr"><span class="toc-number">2.3.</span> <span class="toc-text">auto_ptr</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#unique-ptr"><span class="toc-number">2.4.</span> <span class="toc-text">unique_ptr</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾巴"><span class="toc-number">3.</span> <span class="toc-text">尾巴</span></a></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>再说说智能指针</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-07-01</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/cpp/">cpp</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <p>引用计数, 标记擦除, 智能指针还有其他实现方式么?</p>
<p>本篇主要涉及: </p>
<ul>
<li>尝试自己实现 引用计数类型的智能指针</li>
<li>仔细说说 <code>auto_ptr</code> 和 <code>unique_ptr</code></li>
</ul>
<p><img src="http://omotkhw3y.bkt.clouddn.com/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88.jpg" alt="post-cover"></p>
<a id="more"></a>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>如果明白了RAII手法, 引用计数原理, 标记擦除原理, 那么实现一个scoped_ptr, shared_ptr, 或者unique_ptr都不是难事儿. 难得的是实现的时候, 对于下面两个函数的处理:</p>
<ul>
<li>赋值函数</li>
<li>拷贝构造函数</li>
</ul>
<p>当然也包括右值问题. </p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="智能指针实现机制"><a href="#智能指针实现机制" class="headerlink" title="智能指针实现机制"></a>智能指针实现机制</h2><p>按照其实现机制, 大致可以把智能指针分为如下几类:</p>
<ul>
<li>引用计数机制<br>解释: 引用计数主要是使用系统记录对象被引用的次数。当对象被引用的次数变为0时，该对象即可被视为“垃圾”，从而可以被回收。使用引用计数做垃圾回收的算法的一个优点是实现很简单，与其它垃圾回收算法相比，该方法不会造成程序暂停，因为计数的增减与对象的使用时紧密结合的。 </li>
<li>跟踪处理的垃圾回收机制 根据不同算法又可以重新划分<ul>
<li>标记-清除(Mark-Sweep)<br>首先该算法将程序中正在使用的对象视为“根对象”，从根对象开始查找它们所引用的堆空间，并在这些堆空间上做标记。当标记结束后，所有被标记的对象就是可达对象或活对象，而没有被标记的对象就被认为是垃圾，在第二步的清扫阶段会被回收掉; 这种方法的特点是活的对象不会被移动，但是其存在会出现大量的内存碎片问题。</li>
<li>标记-整理(Mark-Compact)<br>这个算法标记的方法和标记-清除方法一样，但是标记完之后，不再遍历所有对象清扫垃圾了，而是将活跃的对象向“左”靠齐，这就解决了内存碎片的问题。<br>标记-整理算法有个特点就是移动活的对象，因此相应的，程序中所有对堆内存的引用都要更新。</li>
<li>标记-拷贝(Mark-Copy)<br>这种算法的一大特点就是将堆空间分为两部分：From，To。开始的时候我们只在From里分配，当From分配满的时候出发垃圾收集，这个时候会找出From空间里所有的存活对象，然后将这些存活的对象拷贝到To空间里。这样From空间里剩下的就都全是垃圾，而且对象拷贝到To里，在To里是紧凑排列的。这个事儿做完了之后From和To的角色就转变了一下。原来的From变成了To，原来的To变成了现在的From。现在又可以在这个完全是空的From里分配了。这个算法实现起来也很简单，高效（Sun JVM的新生代的垃圾回收就使用了这种算法）。不过这个算法有一个问题，堆的利用率只有一半了，这对那些内存占用率比较低的对象还算好，如果随着应用的内存占用率的增高，问题就出现了，第一个要拷贝的对象太多了，还有可能无法回收内存了。程序失败了。</li>
</ul>
</li>
<li>RAII机制(资源和对象绑定, 局部对象自动销毁)<br>这种机制把资源的声明周期和对象的声明周期绑定, 存在的问题就是资源的当前使用者是唯一的, 出现赋值则情况需要特殊处理.</li>
</ul>
<h2 id="引用计数简单实现"><a href="#引用计数简单实现" class="headerlink" title="引用计数简单实现"></a>引用计数简单实现</h2><p>如果把引用计数器也当做一种(共享)资源, 那么很容易可以给出一种实现:</p>
<pre><code class="c++">template&lt;class _T&gt;  
class SmartPtr  
{  
private:  
    _T *key;  
    size_t *counter;  
    void decrease() {  
        if (--*counter == 0)  
            delete key;  
    }  

public:  
    SmartPtr (_T *t = NULL) : key(t), counter(new size_t(1)) {  
    }  

    SmartPtr(const SmartPtr &amp; sp) {  
        key = sp.key;  
        counter = sp.counter;  
        (*counter)++;  
    }  

    SmartPtr &amp; operator = (const SmartPtr &amp; sp) {  
        decrease();  
        key = sp.key;  
        counter = sp.counter;  
        (*counter)++;  
    }  

    virtual ~SmartPtr() {  
        decrease();  
    }  
};
</code></pre>
<p>核心实现代码非常简单:</p>
<ul>
<li>拷贝构造是共同拥有, 指向统一资源(因为拷贝构造时, 原来是没有指向的); </li>
<li>赋值是转移所有权(赋值是原来指向的内容要判断一下是否减少引用计数, 然后再接收之后的指向).</li>
</ul>
<h2 id="auto-ptr"><a href="#auto-ptr" class="headerlink" title="auto_ptr"></a>auto_ptr</h2><p>说先要说这个智能指针当前已经废弃了, 平常大概也就会这么用:</p>
<pre><code class="c++">auto_ptr&lt;T&gt; pt( new T );//只有new, 没有delete调用
</code></pre>
<p>代替原来的:</p>
<pre><code class="c++">T* pt( new T );  
//...
delete pt;
</code></pre>
<p>当然和其他职能指针一样, 也包含其他方法:<br>reset()函数</p>
<pre><code class="c++">&lt;memeory&gt;
auto_ptr&lt;T&gt; pt( new T(1) );  
pt.reset( new T(2) );         // 删除由&quot;new T(1)&quot;分配出来的第一个T, 改变指向
</code></pre>
<p>以及成员函数:</p>
<pre><code class="c++">X* get() const throw();       //返回保存的指针, 原指针中仍保留指向空间
X* release() const throw();     //返回保存的指针, 原指针已经不再指向原来空间
</code></pre>
<p>这个智能指针实现的时候, 在唯一所有权的问题上没有处理好, 或者说赋值函数没有处理好. 例如下面一段代码:</p>
<pre><code class="c++">void TestFunc(auto_ptr&lt;A&gt; Obj)
{
    Obj-&gt;SetA(20);
    cout &lt;&lt; Obj-&gt;GetA() &lt;&lt; endl;
}

int main()
{
    auto_ptr&lt;A&gt; pAObj(new A(10));
    TestFunc(pAObj); //注意这里发生值拷贝
    cout &lt;&lt; pAObj-&gt;GetA() &lt;&lt; endl; //pAObj 智能指针此时已经不再指向先关数据了.
}
</code></pre>
<p>然后最后一句报错了, 也就是说, auto_ptr不能共享内存, 在同一时间, 只有一个auto_ptr指向一个指定的内存(托管转移).  为什么不能? 因为他的实现机制是, 一个对象绑定它的成员资源. </p>
<ul>
<li>利用特点”栈上对象在离开作用范围时会自动析构”</li>
<li>对于动态分配的内存，其作用范围是程序员手动控制的，这给程序员带来了方便但也不可避免疏忽造成的内存泄漏，毕竟只有编译器是最可靠的</li>
<li>auto_ptr通过在栈上构建一个对象a，对象a中wrap了动态分配内存的指针p，所有对指针p的操作都转为对对象a的操作</li>
</ul>
<p>或者你从他的源码也可以看到:</p>
<pre><code class="c++">    // 赋值构造函数
    auto_ptr&amp; operator=(auto_ptr&amp; __a) __STL_NOTHROW {
        if (&amp;__a != this) {
            delete _M_ptr;
            _M_ptr = __a.release();//放弃__a保留的原指针, 转让给当前接受者
        }
        return *this;
    }
</code></pre>
<p>既然不能共享所有权, 那么凡是调用 operator=()的操作都是危险的, 比如吧auto_ptr放入容器内, 即</p>
<pre><code class="c++">vector&lt;auto_ptr&lt;MyClass&gt;&gt;m_example;
</code></pre>
<p>(当然你可以使用std:ref智能引用进行包装, 不过一拷贝, 原对象就失效, 总的来说还是不能放入容器).</p>
<p>正是auto_ptr实现机制上的问题(<code>原件一拷贝就失效, 你受得了?</code>), 所以后来引入标准库的 std::unique_ptr用静态检验的方式去确认用户是否需要在赋值后转移所有权, 并且采用引用计数的shared_ptr可以共享所有权(除了一个相互引用比较烦人以外). 唯一可惜的是, shared_ptr(配合weaked_ptr使用)效率会有微小损失, 而auto_ptr则没有. 哦, scoped_ptr 这又是一个对所有权的几种做法: 不允许转移, 也就是说保证资源从一而终(此时也保障了唯一所有者).</p>
<p>补充: auto_ptr还不能存储数组, 即auto_ptr<t[]> 原因可能是因为析构的时候, 没有调用delete[]处理, 而只有delete.</t[]></p>
<h2 id="unique-ptr"><a href="#unique-ptr" class="headerlink" title="unique_ptr"></a>unique_ptr</h2><p>std::unique_ptr 它也是通过指针的方式来管理对象资源, 并且在 unique_ptr 的生命期结束后释放该资源. unique_ptr 持有对对象的独有权, 即两个 unique_ptr 不能指向一个对象, 不能进行复制操作只能进行移动操作(某种意义上禁止了拷贝语义, 只保留move语义, 查看函数原型就能发现), 即右值(临时变量)转移给某个具名值(左值)或者函数返回. 那么它为什么就比 auto_ptr好呢?</p>
<blockquote>
<p>即unique_ptr赋值拷贝构造有多个重载, 但是都不具备拷贝语义, 而只有移动语义. (从其原型看出, 它其实是强制你在需要转义的时候使用move语句, 因为根本找不到T&amp;, 只有T&amp;&amp;)</p>
</blockquote>
<p>转移仅仅发生在:</p>
<ul>
<li>unique_ptr 所要接收的对象即将销毁(右值)</li>
<li>unique_ptr 所要接收的对象显示的放弃了所有权, 比如release(), 即左值或者非const引用电泳move语句.</li>
</ul>
<p>通俗的说:<br>auto_ptr是可以说你随便赋值,但赋值完了之后原来的对象就不知不觉的报废.搞得你莫名其妙.而unique就干脆不让你可以随便去复制,赋值.如果实在想传个值就哪里,显式的说明内存转移std:move一下.然后这样传值完了之后,之前的对象也同样报废了.只不过整个move你让明显的知道这样操作后会导致之前的unique_ptr对象失效.</p>
<p>对比一下就知道:</p>
<pre><code class="c++">
auto_ptr&lt;int&gt; ap(new int(88));
auto_ptr&lt;int&gt; one (ap) ; // ok
auto_ptr&lt;int&gt; two = one; //ok

//但unique_ptr不支持上述操作
unique_ptr&lt;int&gt; ap(new int(88));
unique_ptr&lt;int&gt; one (ap) ; // 会出错
unique_ptr&lt;int&gt; two = one; //会出错

//uniuqe_ptr 可以进行移动操作
//例如作为函数的返回值
unique_ptr&lt;int&gt; GetVal()
{
  unique_ptr&lt;int&gt; up(new int(88));
  return up;
}

unique_ptr&lt;int&gt; uPtr = GetVal();   //ok

//或者直接move
unique_ptr&lt;int&gt; up(new int(88 );
//这里是显式的所有权转移, 把up所指的内存转给uPtr2了
unique_ptr&lt;int&gt; uPtr2 = std:move( up) ;
</code></pre>
<p>cppreference上的例子:</p>
<pre><code class="c++">#include &lt;iostream&gt;
#include &lt;memory&gt;

struct Foo { // object to manage
    Foo() { std::cout &lt;&lt; &quot;Foo ctor\n&quot;; }
    Foo(const Foo&amp;) { std::cout &lt;&lt; &quot;Foo copy ctor\n&quot;; }//真正拷贝
    Foo(Foo&amp;&amp;) { std::cout &lt;&lt; &quot;Foo move ctor\n&quot;; } //真正转移
    ~Foo() { std::cout &lt;&lt; &quot;~Foo dtor\n&quot;; }
};



struct D { // deleter
    D() {};
    D(const D&amp;) { std::cout &lt;&lt; &quot;D copy ctor\n&quot;; }
    D(D&amp;) { std::cout &lt;&lt; &quot;D non-const copy ctor\n&quot;;}
    D(D&amp;&amp;) { std::cout &lt;&lt; &quot;D move ctor \n&quot;; }
    void operator()(Foo* p) const {
        std::cout &lt;&lt; &quot;D is deleting a Foo\n&quot;;
        delete p;
    };
};

int main()
{
    std::cout &lt;&lt; &quot;Example constructor(1)...\n&quot;;
    std::unique_ptr&lt;Foo&gt; up1;  // up1 is empty
    std::unique_ptr&lt;Foo&gt; up1b(nullptr);  // up1b is empty

    std::cout &lt;&lt; &quot;\nExample constructor(2)...\n&quot;;
    {
        std::unique_ptr&lt;Foo&gt; up2(new Foo); //up2 now owns a Foo
    } // Foo deleted

    std::cout &lt;&lt; &quot;\nExample constructor(3)...\n&quot;;
    D d;
    {  // deleter type is not a reference
       std::unique_ptr&lt;Foo, D&gt; up3(new Foo, d); // deleter copied
    }
    {  // deleter type is a reference 
       std::unique_ptr&lt;Foo, D&amp;&gt; up3b(new Foo, d); // up3b holds a reference to d
    }

    std::cout &lt;&lt; &quot;\nExample constructor(4)...\n&quot;;
    {  // deleter is not a reference 
       std::unique_ptr&lt;Foo, D&gt; up4(new Foo, D()); // deleter moved
    }

    std::cout &lt;&lt; &quot;\nExample constructor(5)...\n&quot;;
    {
       std::unique_ptr&lt;Foo&gt; up5a(new Foo);
       std::unique_ptr&lt;Foo&gt; up5b(std::move(up5a)); // ownership transfer
    }

    std::cout &lt;&lt; &quot;\nExample constructor(6)...\n&quot;;
    {
        std::unique_ptr&lt;Foo, D&gt; up6a(new Foo, d); // D is copied
        std::unique_ptr&lt;Foo, D&gt; up6b(std::move(up6a)); // D is moved

        std::unique_ptr&lt;Foo, D&amp;&gt; up6c(new Foo, d); // D is a reference
        std::unique_ptr&lt;Foo, D&gt; up6d(std::move(up6c)); // D is copied
    }

    std::cout &lt;&lt; &quot;\nExample constructor(7)...\n&quot;;
    {
        std::auto_ptr&lt;Foo&gt; up7a(new Foo);
        std::unique_ptr&lt;Foo&gt; up7b(std::move(up7a)); // ownership transfer
    }
}
</code></pre>
<p>可以看到凡是涉及到左值的, 全部都用了move(). </p>
<p>个人觉得,  unique支持容器, 并且支持数组类型,  <code>unique_ptr&lt;T[]&gt;</code>, 这才是重点. </p>
<p>最初我也怀疑, unique不支持拷贝, 怎么能放入输入: auto_ptr不可做为容器元素, 而unique_ptr也同样不能直接做为容器元素.</p>
<p>实际上, 发现用右值, 或者移动语义是可以实现的:</p>
<pre><code class="c++">unique_ptr&lt;int&gt; sp(new int(88) );
vector&lt;unique_ptr&lt;int&gt; &gt; vec;
vec.push_back(std::move(sp));
//vec.push_back( sp ); 这样不行,会报错的.
//cout&lt;&lt;*sp&lt;&lt;endl;但这个也同样出错,说明sp添加到容器中之后,它自身报废了.
</code></pre>
<p>上面的学习, 也可以看到, unique_ptr和auto_ptr真的太像了, 只不过unique_ptr支持移动语义, 被c++11所推崇(并且其转移是可控的, 用户的显示行为).</p>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>不算太详细的说明了一下 auot_ptr, unique_ptr; 顺带说了下引用计数的原理.</p>
<p>先这样吧.</p>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="../../../index.html" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：<a href="2017/07/01/smart-pointers-again.html" target="_blank" title="再说说智能指针">再说说智能指针</a></span><br/>
	<span><b>本文链接</b>：<a href="2017/07/01/smart-pointers-again.html" target="_blank" title="再说说智能指针">www.merlinblog.site/2017/07/01/smart-pointers-again.html</a></span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="../../../css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="../../../js/search_core.js"></script>
<script src="../../../js/script.js"></script>

</body>
</html>

