<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>里程碑1(Linux后台开发经验分享) | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一些列工作经验的分享,干货">
<meta name="keywords" content="里程碑">
<meta property="og:type" content="article">
<meta property="og:title" content="里程碑1(Linux后台开发经验分享)">
<meta property="og:url" content="www.merlinblog.site/2017/08/30/milestone1.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="一些列工作经验的分享,干货">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/new_era_1.png">
<meta property="og:updated_time" content="2017-10-15T02:55:46.216Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="里程碑1(Linux后台开发经验分享)">
<meta name="twitter:description" content="一些列工作经验的分享,干货">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/new_era_1.png">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                主页
            </a>
            
            <a class="nav-item" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item" href="/works">
                开源作品
            </a>
            
            <a class="nav-item" href="/about">
                关于博主
            </a>
            
            <a class="nav-item" href="/atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                主页
            </a>
            
            <a class="nav-item flex-1" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="/works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="/about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="/atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="/css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#版本记录"><span class="toc-number">1.</span> <span class="toc-text">版本记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#milestone1-大巨变"><span class="toc-number">1.1.</span> <span class="toc-text">milestone1: 大巨变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#milestone2-领域专家"><span class="toc-number">1.2.</span> <span class="toc-text">milestone2 : 领域专家</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#核心内容"><span class="toc-number">2.</span> <span class="toc-text">核心内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端"><span class="toc-number">2.1.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程语言"><span class="toc-number">2.1.1.</span> <span class="toc-text">编程语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库"><span class="toc-number">2.1.2.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息件"><span class="toc-number">2.1.3.</span> <span class="toc-text">消息件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协议"><span class="toc-number">2.1.4.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络框架"><span class="toc-number">2.1.5.</span> <span class="toc-text">网络框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关架构"><span class="toc-number">2.1.6.</span> <span class="toc-text">相关架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他技术"><span class="toc-number">2.1.7.</span> <span class="toc-text">其他技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux系统"><span class="toc-number">2.2.</span> <span class="toc-text">Linux系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#core文件"><span class="toc-number">2.2.1.</span> <span class="toc-text">core文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESTful相关"><span class="toc-number">2.3.</span> <span class="toc-text">RESTful相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#restful简介"><span class="toc-number">2.3.1.</span> <span class="toc-text">restful简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#api返回值经验"><span class="toc-number">2.3.2.</span> <span class="toc-text">api返回值经验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-语言"><span class="toc-number">2.4.</span> <span class="toc-text">C++语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#window移植"><span class="toc-number">2.4.1.</span> <span class="toc-text">window移植</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宽字符问题"><span class="toc-number">2.4.2.</span> <span class="toc-text">宽字符问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作大文件"><span class="toc-number">2.4.3.</span> <span class="toc-text">操作大文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-标准库"><span class="toc-number">2.5.</span> <span class="toc-text">C++标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量初始化"><span class="toc-number">2.5.1.</span> <span class="toc-text">变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind"><span class="toc-number">2.5.2.</span> <span class="toc-text">std::bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#智能指针-多线程-问题"><span class="toc-number">2.5.3.</span> <span class="toc-text">智能指针(多线程)问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost-Asio"><span class="toc-number">2.6.</span> <span class="toc-text">Boost.Asio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read-util相关"><span class="toc-number">2.6.1.</span> <span class="toc-text">read_util相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求队列积压问题"><span class="toc-number">2.6.2.</span> <span class="toc-text">请求队列积压问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#长连接"><span class="toc-number">2.7.</span> <span class="toc-text">长连接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾巴"><span class="toc-number">3.</span> <span class="toc-text">尾巴</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>里程碑1(Linux后台开发经验分享)</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-08-30</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/里程碑/">里程碑</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <blockquote>
<p>本文只在每一次 milestone 记录点更新, 记录我开发中遇到的经验,体会; 有的单独总结了, 所以只给出链接</p>
</blockquote>
<p>当前文章(以后会更新), 总结了我的个人经验, 包括我自己亲身经历的, 后台同学一起讨论的, 网络曾经看到的等等. </p>
<p><strong>如果你把你学到的知识, 而不是思考问题的方式, 细心&amp;耐心的品质, 健康的身体, 银行的存款, 结交的人缘作为核心竞争力;</strong><br><strong>那么分享自己所学可能对你有点儿困难.(虽然最初的时候我写博客也只是完全为了记录我成长的过程, 不过渐渐目的已经转变了)</strong></p>
<a id="more"></a>
<h1 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h1><h2 id="milestone1-大巨变"><a href="#milestone1-大巨变" class="headerlink" title="milestone1: 大巨变"></a>milestone1: 大巨变</h2><blockquote>
<p><code>大巨变100天(100 days from New Era)</code></p>
</blockquote>
<p><img src="http://omotkhw3y.bkt.clouddn.com/new_era_1.png" alt="里程碑"></p>
<p>当前里程碑记录<strong>Linux后台开发经验</strong>.</p>
<p>下面是一些<code>基于当前工作经验&amp;年限</code>的认识:</p>
<ul>
<li>对于c++, go这类稍微偏底层, 并且常用的语言, 一定要了解细节, 深知见底.</li>
<li>对于python, shell这类脚本或者模型语言, 用好为主</li>
<li>对于数据结构和算法: 数据结构深入, 算法了解.</li>
<li>对于操作系统, 如果决心做高级工程师, 业内技术专家linux一定要深入到内核(具体的是内核哪个模块?所有.)</li>
<li>对于网络编程, 根据工作的不同, 有人工作在应用层,有人工作在传输层和网络层, 甚至是链路层(但是不管这么说, 应用层和网络层是要知道的)</li>
<li>对于项目管理和人员管理等管理问题, 请入行的第3年再去涉及.(也就是工作的第5-7年)</li>
<li>对于金钱, 抱歉我看到的身边的人30W一大把, 50W是一个坎大多人突破不过去. (自己实力稍弱的时候, <code>不要太看重钱</code>)</li>
<li></li>
</ul>
<p><code>表面上看我成长不少, 但是从一个高手的要求上看, 我所做的其实远远不够; 希望慢慢会快, 后期抓紧时间!</code></p>
<h2 id="milestone2-领域专家"><a href="#milestone2-领域专家" class="headerlink" title="milestone2 : 领域专家"></a>milestone2 : 领域专家</h2><p>期待 <strong>2019.9</strong>, 一个全新&amp;加强版的我.</p>
<blockquote>
<p>TODO, 等待下一次更新; 深入行业!</p>
</blockquote>
<hr>
<h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>游戏业内主要的是c/c++ + Python/lua模式做游戏服务器。<br>c/c++做网络通讯数据传输，python/lua做业务逻辑。这样既保持了网络传输的效率(c++)，又提升开发效率(Python/lua)，同时也支持热更新。</p>
<p>其他用 erlang, go, C#, 甚至java, node.js也有, 只是没有接触过.</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>我看到同学中, 一般小公司的, 用mysql, mongodb足以; 如果要访问提升效率(减轻数据库压力), 选择内存数据库redis, memcached都不错.<br>(存盘可以即使存盘, 但一般都不这么做, 一般采用固定存盘减少服务器压力; 个别效率苛刻的场景除外)</p>
<h3 id="消息件"><a href="#消息件" class="headerlink" title="消息件"></a>消息件</h3><p>一般用于服务器或者多进程之间通信, 比如zeromq等.<br>网络通信方面可以自己处理粘包问题, 直接传输字节流, 也可以传输xml, json; 常见的可能是采用框架, 比如protobuffer, 二进制传输.</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议部分的, 一般会涉及三个协议: http, tcp, udp<br><strong>http</strong>: 如果是那种弱联网单机玩法，用http足够了，像天天酷跑之类，只在需要的时候处理一条http请求响应。<br><strong>tcp</strong>: 现在的网络游戏大多数都是tcp<br><strong>udp</strong>: 其实游戏是有udp的，在一些高效率(即时性, 实时性要求高)的场景下比如pvp即时战斗,tcp的拥塞控制和超时重传并不适合，有些就用的udp,然后自己做丢包重发</p>
<p>现在参与开发的游戏就同时使用了http协议和tcp协议，在游戏服是单机玩法用http协议,战斗服需要长连接保存协议状态，用的tcp。</p>
<h3 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h3><p>libevent, boost.asio等网络库， 网上有很多开源网络库，与其自己造轮子，不如就用开源网络库作为自己服务器的通讯库, 例如:<br>libevent和boost.asio:</p>
<ul>
<li>Boost的ASIO是一个异步IO库，封装了对Socket的常用操作，简化了基于socket程序的开发。支持跨平台。</li>
<li>Libevent是一个C语言写的事件驱动的开源网络库, 应用和异步IO逻辑思想类似的 reactor反应堆模型.</li>
</ul>
<p>这两个库我都有详细介绍过, 这里就不再多说了, 具体可以参考我的文章: <a href="http://www.merlinblog.site/2017/10/13/network-base.html">网络部分汇总</a></p>
<h3 id="相关架构"><a href="#相关架构" class="headerlink" title="相关架构"></a>相关架构</h3><p>后端服务器架构应该说有很多种, 我熟悉的:</p>
<ul>
<li>Gate: 首先要有一个Gate(网关)服务器，负责客户端连接及消息转发到Game(游戏服),保持客户端到服务端的连接<br>没有任何逻辑，只做消息加密和解密，以及客户端和服务器消息的转发(相当于两者之间的桥梁).</li>
<li>GameServer: GameServer是游戏进程,提供游戏逻辑功能(采用单进程(或者单线程)模型,游戏服务器的瓶颈从来不在CPU,所以只做逻辑功能的话单线程足够了,在这里没必要用多线程或多进程)。</li>
<li>DBManager:实现数据库的读写，方便Game服务器异步读写数据库的数据(有些把数据库读写放在游戏服务器，没有单独的服务器，那恐怕游戏服单进程就不够用了)。</li>
<li>GameManager: 负责管理所有的GameServer，GameServer之间消息转发，提供广播到所有Game的功能。</li>
</ul>
<p>分布式架构我就不太熟悉了, 一般需要到专门的大公司学习.</p>
<h3 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h3><p>一般用的都是开源的, 比如gtest, glog/zlog, tcmalloc(内存性能分析), distcc, repo等</p>
<blockquote>
<p>其他技术, 请参考我的博客其他文章.</p>
</blockquote>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="core文件"><a href="#core文件" class="headerlink" title="core文件"></a>core文件</h3><p>产生 core 文件, 命令 <code>ulimit -c</code> 如果显示 1024 那么说明 coredump 已经被开启, 0 则表示没有开启.</p>
<blockquote>
<p>一般临时修改: ulimit -c unlimited  或者 <code>ulimit -c 1024</code>;关闭的话<code>ulimit -c 0</code>.</p>
</blockquote>
<p>1024 限制产生的 core 文件的大小不能超过 1024kb，可以使用参数unlimited，取消该限制</p>
<p>也可以修改文件配置<code>/etc/security/limits.conf</code>, 添加一行<code>* soft core unilimited</code><br>其实这个是由pam来完成的，pam里有个模块叫pam_limits，它默认的会读取/etc/security/limits.conf文件来进行资源限制。而用户登录时会调用/etc/pam.d/login文件来进行检查，这个文件里标明了使用哪些模块。其中它include了一个叫system_auth的配置文件，在这个文件里有对pam_limits.so的调用。</p>
<p>如果上面没有生效, 可能是其他登陆模块强制修改了, 典型的需要查看一下<code>/etc/profile</code>, <code>/etc/init.d/functions</code>.<br>这些文件在用户登录时会执行，因此即使pam修改了还是会被它改回去, 可以把那几行注释掉, 不过我一直截止很简单的:</p>
<pre><code>echo &quot;ulimit -c 1024&quot; &gt;&gt; /etc/profile
</code></pre><blockquote>
<p>将不该清空的内存清空了，导致执行的时候会进入不可状态; 此时每次看到的core dump信息都不一样.</p>
</blockquote>
<h2 id="RESTful相关"><a href="#RESTful相关" class="headerlink" title="RESTful相关"></a>RESTful相关</h2><p>本段属于上层协议内容, 感谢土哥的经验交流.</p>
<h3 id="restful简介"><a href="#restful简介" class="headerlink" title="restful简介"></a>restful简介</h3><p>RESTful 架构, 由于其以资源中心, 依赖http协议和uri, 虽然也会涉及c-s模型, 不过其更多的是强调对于相关资源的crud操作, 并且提供了统一的API形式:</p>
<ul>
<li>看Url就知道要什么</li>
<li>看http method就知道干什么</li>
<li>看http status  code就知道结果如何</li>
</ul>
<p>举几个例子就会发现它非常规范:</p>
<pre><code>https://api.qzone.com/user/getUserFeedList?from=web 
https://api.qzone.com?m=user&amp;c=getUserFeedList?from=web 
https://qzone.com/api/user/getUserFeedList?from=web 
https://qzone.com?m=api&amp;c=user&amp;a=getUserFeedList?from=web
</code></pre><p>HTTP协议形式例如:</p>
<pre><code>GET /posts HTTP/1.1
Accept: application/atom+xml

响应：
HTTP/1.1 200 OK
Content-Type: application/atom+xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;
    &lt;title&gt;Posts&lt;/title&gt;
    &lt;link href=&quot;http://example.org/posts&quot; rel=&quot;self&quot; /&gt;
    &lt;link href=&quot;http://example.org/posts?pn=2&quot; rel=&quot;next&quot; /&gt;

    &lt;id&gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6&lt;/id&gt;
    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;
    &lt;entry&gt;
        &lt;title&gt;Post XXX&lt;/title&gt;
        &lt;link href=&quot;http://example.org/post-xxx&quot; /&gt;
        &lt;id&gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id&gt;
        &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;
        &lt;content type=&quot;xhtml&quot;&gt;
            &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
                &lt;p&gt;This is the post content.&lt;/p&gt;
            &lt;/div&gt;
        &lt;/content&gt;
    &lt;/entry&gt;
    &lt;entry&gt;...&lt;/entry&gt;
&lt;/feed&gt;
</code></pre><h3 id="api返回值经验"><a href="#api返回值经验" class="headerlink" title="api返回值经验"></a>api返回值经验</h3><blockquote>
<p>针对JSON型API的返回结果设计, 总结下自己的经验</p>
</blockquote>
<p>一般的返回结果是怎么样的?</p>
<pre><code>{
    data : { // 请求数据
        user_id: 123,
        user_name: &quot;tutuge&quot;,
        ...
    },
    msg : &quot;done&quot;, // 请求状态描述，调试用
    code: 1001, // 业务自定义状态码
    extra : { // 全局附加数据(optional字段)
        type: 1,
        desc: &quot;秒数信息&quot;
    }
}
</code></pre><p>下面详细解释:</p>
<ul>
<li>data字段<br>本次请求结果的数据 data 字段, 其值为对象(字典)或数组(列表)均可以, 根据业务而定. 例如:<pre><code>data: [
  {user_id: 123, user_name: &quot;tutuge&quot;},
  {user_id: 321, user_name: &quot;zekunyan&quot;},
  ...
]
</code></pre>当然数组, 对象还可以嵌套, 怎么灵活怎么用.(不用担心现有库对于字段的解析问题)</li>
<li>msg字段<br>该字段是本次请求的业务&amp;状态描述信息, 主要用于调试、测试等, 例如 “done”, “测试缺少参数”. 根据相关开发人员协商即可. </li>
<li>code字段<br>这是比较有争议的一个字段, 因为Http请求本身已经有了完备的状态码，再定义一套状态码直观上感受却是不对劲。但是实际开发中，确实发现 <code>自定义业务状态码</code> 的必要性，如一次成功的Http status 200的请求，可能由于用户未登录、登录过期而有不同的返回结果和处理方式，所以还是保留了; 权当http协议的详细说明.<br>定义规范根据业务来, 例如按照用户相关、授权相关、各种业务，做简单的分类:<pre><code>// Code 业务自定义状态码定义示例
// 授权相关
1001: 无权限访问
1002: access_token过期
1003: unique_token无效
...
// 用户相关
2001: 未登录
2002: 用户信息错误
2003: 用户不存在
// 业务1
3001: 业务1XXX
3002: 业务1XXX
// ...
</code></pre>最好定义为常量, 当然能够动态解析最好.</li>
<li><p>extra字段<br>这个纯粹是附加字段(全局的附加数据), 为的是灵活扩展, 比如升级啊, 需求变化等. 由服务端的规则决定并且客户端要及时向用户展示变化, 所以加上了extra字段. 例如:</p>
<pre><code>// 升级
type: 1,
show_msg: &quot;恭喜您升级到XXX&quot;

// 完成任务
type: 2,
task_desc: &quot;达成XXX成就&quot;
</code></pre></li>
</ul>
<p>其实最终还是要看客户端和服务端人员的协商; 服务端人员切不可以为添加一个字段简单没有什么, 就随口答应, 一切都要走流程, 并且避免乱用. 这不仅仅是为了规范, 而是为了让项目不会再将来出现意想不到的 <code>惊喜</code> .</p>
<p>补充经验:</p>
<ul>
<li>命名, 和C语言保持一致就可以了(字段统一小写加下划线)<br>例如:<pre><code>// 字符串
user_name, task_desc, date_str, article_title, feed_content 等
// 数字
user_id, users_count, task_num, xxx_offset 等
// 日期
login_at, create_date, logout_time 等
// 布尔
is_done, is_vip, protected, can_read 等
// URL
user_avatar_url, thumb_url 等
// 数组
users, profiles, thumb_imgs 等
</code></pre></li>
<li>设置默认值(空值)<ul>
<li>数字就是 <code>0</code></li>
<li>字符串就是空字符串<code>&quot;&quot;</code></li>
<li>数组就是空数组<code>[]</code></li>
<li>对象就是空对象{}</li>
</ul>
</li>
<li>bool值, 统一成0和1.<br>由于多种语言不统一, 所以一开始就要做好限定, 而不是<code>true</code>, <code>True</code>, <code>1</code>漫天乱飞.. 在客户端和服务端统一设置常量、宏定义，定义布尔的类型，所有的参数、结果的布尔字段全部做强制约束</li>
<li>时间处理, 统一使用Unix时间戳, 即GMT/UTC时间戳, 可以用<code>date +%s</code>命令查看, 然后各自客户端根据自己的时区, 显示做转换.<br>例如:<pre><code>// 从服务器接收的时间数据
login_at: 1462068610
// 根据时区、显示要求转换，如北京时间
显示：2016年5月1日下午1点、1天前等
</code></pre>(如果用字符串,可以参考<code>YYYY-MM-DDThh:mm:ssTZD</code>格式,保留了时区)</li>
<li>字符串常量 请用常量文档约束.<pre><code>// 如登录类型，QQ、微信、微博等
login_type: &quot;qq&quot;,
login_type: &quot;wechat&quot;,
login_type: &quot;sina_weibo&quot;,
</code></pre></li>
<li>使用完整的url, 指明网络协议(scheme).</li>
</ul>
<h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><h3 id="window移植"><a href="#window移植" class="headerlink" title="window移植"></a>window移植</h3><p>windows迁移问题, 自己遇到的, 记录一下:</p>
<ul>
<li>缺少最后一行空行, 多余的\r回车符<br><code>dos2unix &lt;file&gt; fromdos &lt;file&gt;</code></li>
<li>中文注释乱码<br><code>iconv –f gbk –t utf8</code> (utf8也可以写成utf-8)</li>
<li>不能忍的头文件<br><code>windows.h</code></li>
<li>不兼容的宏, 库函数<br><code>snprintf()</code>,<code>__FUNCTION__</code>, <code>__FILE__</code>, <code>__LINE__</code></li>
<li>特殊的宏<br><code>#ifdef WIN_32  #define …  #endif</code></li>
</ul>
<h3 id="宽字符问题"><a href="#宽字符问题" class="headerlink" title="宽字符问题"></a>宽字符问题</h3><p>本质上是ascii码和unicode的存储问题.(单字节不够用, 采用多字节)<br>先注意一下文件编码, windows下默认是gbk编码:</p>
<pre><code>iconv -f GBK -t UTF-8 main.cc &gt; mainu.cc
</code></pre><p>之后注意一下多字节字符问题, 基本情况如下:(实际上wchar_t同样没有标准限定)</p>
<ul>
<li>Windows 下的 char 是 ANSI，WCHAR 是 UTF-16（UCS-2），跟 locale设置有关系</li>
<li>Linux   下的 char 是 UTF-8，WCHAR 是 UTF-32（UCS-4），都是 Unicode，与 locale 无关</li>
</ul>
<p>我建议你 Windows 下调用<code>MultiByteToWideChar</code>和<code>WideCharToMultiByte</code>，<br>而 Linux 直接自己写一个转换函数(UTF-8 和 UTF-32 转换规律很简单), 大致如下:</p>
<pre><code class="C++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int UTF8ToUnicode(const char *pmbs, wchar_t *pwcs, int size)
{
    int cnt = 0;
    // 这里 size-- 是预先除去尾零所需位置
    if (pmbs != NULL &amp;&amp; pwcs != NULL &amp;&amp; size-- &gt; 0) {
        while (*pmbs != 0 &amp;&amp; size &gt; 0) {
            unsigned char ch = *pmbs;
            if (ch &gt; 0x7FU) {
                int cwch = 0;
                while (ch &amp; 0x80U) {
                    ch &lt;&lt;= 1;
                    cwch++;
                }
                *pwcs = *pmbs++ &amp; (0xFFU &gt;&gt; cwch);
                while (--cwch &gt; 0) {
                    *pwcs &lt;&lt;= 6;
                    *pwcs |= (*pmbs++ &amp; 0x3FU);
                }
            } else {
                *pwcs = *pmbs++;
            }
            pwcs++;
            size--;
            cnt++;
        }
        *pwcs = 0;
        cnt++;
    }
    return cnt;
}

int UnicodeToUTF8(const wchar_t *pwcs, char *pmbs, int size)
{
    int cnt = 0;
    // 这里 size-- 是预先除去尾零所需位置
    if (pwcs != NULL &amp;&amp; pmbs != NULL &amp;&amp; size-- &gt; 0) {
        while (*pwcs != 0 &amp;&amp; size &gt; 0) {
            if (*pwcs &lt; 0x00000080U) {
                *pmbs++ = (char)*pwcs;
                size -= 1;
                cnt += 1;
            } else if (*pwcs &lt; 0x00000800U) {
                // 剩余空间不够存放该字符
                if (size &lt; 2) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 6) | (*pwcs &gt;&gt; 6);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 2;
                cnt += 2;
            } else if (*pwcs &lt; 0x00010000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 3) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 5) | (*pwcs &gt;&gt; 12);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 3;
                cnt += 3;
            } else if (*pwcs &lt; 0x00200000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 4) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 4) | (*pwcs &gt;&gt; 18);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 4;
                cnt += 4;
            } else if (*pwcs &lt; 0x04000000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 5) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 3) | (*pwcs &gt;&gt; 24);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 5;
                cnt += 5;
            } else if (*pwcs &lt; 0x80000000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 6) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 2) | (*pwcs &gt;&gt; 30);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 24) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 6;
                cnt += 6;
            } else {
                // 无法识别的 Unicode 字符
                break;
            }
            pwcs++;
        }
        *pmbs = 0;
        cnt++;
    }
    return cnt;
}

int main(void)
{
    // 这部分代码请在 Linux 上测试，Windows 命令行无法打印 UTF-8 字符串。
    char mbs1[256] = { 0 };
    wchar_t wcs1[] = L&quot;测试文字&quot;; //单个中文, utf8存储3字节
    int ret1 = UnicodeToUTF8(wcs1, mbs1, sizeof(mbs1)/sizeof(char));
    printf(&quot;%d\n&quot;, ret1); //13

    // 这部分代码请在 Linux 上测试，Windows 的 char 类型非 UTF-8 编码。
    char mbs2[] = &quot;测试文字&quot;;
    wchar_t wcs2[256] = { 0 };
    int ret2 = UTF8ToUnicode(mbs2, wcs2, sizeof(wcs2)/sizeof(wchar_t));
    printf(&quot;%d\n&quot;, ret2); //5

    return 0;
}
</code></pre>
<p>参数作用简单说明如下：</p>
<ul>
<li>第一个参数为待转换的字符串</li>
<li>第二个参数为接收结果的缓冲区</li>
<li>第三个参数为结果缓冲区大小(包含尾零)<br>返回值为所写入缓冲区的大小(包含尾零)</li>
</ul>
<p>最好不要使用<code>wchar_t</code>, 而直接使用<code>std::wstring</code>, 例如下面的代码:(windows环境)</p>
<pre><code class="C++">//const wchar_t* ws = L&quot;世界你好！&quot;;
std::wstring wstr = L&quot;世界你好！&quot;;
std::wcout.imbue( std::locale(&quot;chs&quot;) );
std::wcout &lt;&lt; wstr &lt;&lt; std::endl;
</code></pre>
<p><code>std::locale( std::locale(),&quot;&quot;,std::locale::ctype )</code>会创建当前系统环境下locale，这个locale中会保存这个系统 ansi 使用 code page.<br>(wofstream，wcout 在处理 unicode字符 时，必须进行内部编码转换（unicode -&gt; ansi ）)</p>
<p>具体参考以下链接:</p>
<ol>
<li><a href="http://blog.csdn.net/xujiezhige/article/details/17843831" target="_blank" rel="external">http://blog.csdn.net/xujiezhige/article/details/17843831</a></li>
<li><a href="http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html" target="_blank" rel="external">http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html</a></li>
<li><a href="http://bbs.csdn.net/topics/391079600?page=1" target="_blank" rel="external">http://bbs.csdn.net/topics/391079600?page=1</a></li>
</ol>
<h3 id="操作大文件"><a href="#操作大文件" class="headerlink" title="操作大文件"></a>操作大文件</h3><p>1.包含所有头文件以前，先定义这些宏：</p>
<pre><code class="C++">#ifndef __USE_FILE_OFFSET64
#define __USE_FILE_OFFSET64
#endif

#ifndef __USE_LARGEFILE64
#define __USE_LARGEFILE64
#endif

#ifndef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE
#endif
</code></pre>
<p>一般用 /usr/include/features.h 重定义的:</p>
<p>32位LINUX使用超过2G的大文件，需要定义很多宏，与文件操作API相关的宏都有这样一些：</p>
<pre><code>_FILE_OFFSET_BITS
_LARGEFILE_SOURCE
_LARGEFILE64_SOURCE
__USE_FILE_OFFSET64
__USE_LARGEFILE
__USE_LARGEFILE64
</code></pre><p>那么，它们之间的关系究竟是怎么样的呢？<br>终于在linux的头文件<code>/usr/include/features.h</code>中找到了定义。</p>
<pre><code class="C++">//原来这个文件就是专门让用户定义各种特性的：
/*These are defined by the user (or the compiler)
to specify the desired environment

其中几个供用户配置的宏的注释为：
_LARGEFILE_SOURCE    Some more functions for correct standard I/O.
_LARGEFILE64_SOURCE    Additional functionality from LFS for large files.
_FILE_OFFSET_BITS=N    Select default filesystem interface.
_GNU_SOURCE        All of the above, plus GNU extensions.
__USE_LARGEFILE    Define correct standard I/O things.
__USE_LARGEFILE64    Define LFS things with separate names.
__USE_FILE_OFFSET64    Define 64bit interface as default.
*/

// use前缀的宏定义都先取消掉，说明这些宏不是直接供用户使用的，而是由其他宏的定义衍生这些宏
#undef    __USE_LARGEFILE
#undef    __USE_LARGEFILE64
#undef    __USE_FILE_OFFSET64

//   _GNU_SOURCE是一张很大的通行证，定义了这个，很多相关的开关都会打开
/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
#ifdef _GNU_SOURCE
# undef     _LARGEFILE64_SOURCE
# define _LARGEFILE64_SOURCE    1
#endif

// 下面是打开各个USE宏的位置
#ifdef _LARGEFILE_SOURCE
# define __USE_LARGEFILE    1
#endif

#ifdef _LARGEFILE64_SOURCE
# define __USE_LARGEFILE64    1
#endif

#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64
# define __USE_FILE_OFFSET64    1
#endif
</code></pre>
<p>总结： <strong>使用64位大文件，定义_LARGEFILE64_SOURCE和_FILE_OFFSET_BITS=64这两个宏即可</strong></p>
<p><strong>2.</strong>使用open打开文件的时候，加上O_LARGEFILE标志：<br>int fd = open(“test.dat”, O_RDWR|O_APPEND|O_CREAT|O_LARGEFILE, 0666);<br>read(), write()等与一般的用法一致，无变化。</p>
<p><strong>3.</strong>注意lseek()函数，文件未超过2G的时候，一切工作良好；<br>文件超过2G后，调用返回-1，errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>需要使用lseek64()代替lseek()。很奇怪，定义了宏以后，并未自动将lseek变成lseek64。（知道原因的朋友可以教教我）</p>
<p><strong>4.</strong>注意stat()函数，传入的文件如果在2G内，工作良好；<br>传入的文件如果超过2G，返回-1, errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>应该这样使用：struct stat64 st; stat64(“file”, &amp;st);</p>
<p><strong>5.</strong>为了保险，建议所有操作文件的函数都是用支持64位大文件的。否则当文件超过2G后，难免会出现什么未知的异常</p>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>具体可以参考一下我的文章, <a href="">C++11一致性初始化</a>, 提倡&amp;建议使用一致性初始化.</p>
<p>其他还有需要注意的就是, <strong>在线程编码中,尽量不要使用匿名对象</strong></p>
<blockquote>
<p>尽量不使用匿名对象，如果想要用完立即释放，可以使用单独的代码块包裹。</p>
</blockquote>
<h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><p>标准库的 bind 和 boost::bind 使用起来类似</p>
<p>举个例子</p>
<pre><code class="C++">void test(int a, int b, int c)
boost::bind(test, 1, _1, _2);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(1,3,4)
boost::bind(test, _2, 3, _1);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(4,3,3)
</code></pre>
<p>而在标准库中一般是这么用的:</p>
<pre><code class="C++">auto handler = std::bind(test, 1, std::placeholders::_1, std::placeholders::_2);
handler(3,4);// 相当于 test(1,3,4);
</code></pre>
<p>其他的可以参考文章<a href="http://www.merlinblog.site/2017/07/01/bind-in-cpp.html">C++11 std:bind探究</a></p>
<h3 id="智能指针-多线程-问题"><a href="#智能指针-多线程-问题" class="headerlink" title="智能指针(多线程)问题"></a>智能指针(多线程)问题</h3><p>其实是异步代码问题.<br>具体现象描述:<br>一旦压力达到一定程度，程序立即就会崩溃，报的错误几乎都在new的时候没有内存了，一开始以为确实是因为内存分配的问题，后来在<strong>程序运行过程中</strong>用top观察，发现内存使用很低，因此可以确认不应该是瞬间内存使用完造成的。</p>
<p>因此认真看了一下 core dump 的地方，发现几乎都是在自己写的一个智能指针分配内存那里出的问题。<br>于是仔细思考了一下，发现是因为<strong>智能指针的引用计数没有加锁</strong>导致的, 或者说<strong>同一时间, 可能有多个线程持有该指针</strong>, 导致引用计数不能减为0。</p>
<p>例如下面的代码:</p>
<pre><code class="C++">void func()
{
    shared_ptr a;
    async_call(a);
}
</code></pre>
<p>解释:首先有一个智能指针，接下来，这个智能指针被丢给了异步程序，因此这个时候其实已经有两个线程同时持有这个智能指针了，因为这个函数还未退出，当前线程还拥有这个指针a. 一般低压情况下，这两句很快就执行完了，不会出问题，但是高压情况下，这个函数先执行完，还是异步程序先执行完就不一定了（或者说是因为高压情况样本变多了）, 也就造成了资源没有释放.</p>
<h2 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost.Asio"></a>Boost.Asio</h2><h3 id="read-util相关"><a href="#read-util相关" class="headerlink" title="read_util相关"></a>read_util相关</h3><p>在使用boost的read_util库的时候遇到一个很诡异的问题，如果用read_util(““)这样的调用，第一个请求可以得到，但是第二个请求会卡住，永远也拿不到。从服务器端看到的情况是，第二个响应已经完整的发送出去，但是read_util就是不返回。比较奇怪的是如果用read_util(‘&gt;’)这样调用，那是没有任何问题的。</p>
<blockquote>
<p>read_util(string)这样的函数，它所用的肯定是string.find这样的函数，而这样的函数它是用字符串查找的，这表示它一旦遇到<code>\0</code>就不再往后查找了。</p>
</blockquote>
<p>每个响应最后会有一个/0字符。因此在第一个包读完之后，接下来读到的第一个字符就是<code>\0</code>，那么第二个包读的时候，不论读到多少数据，这个字符串的内容是<code>\0xxxxxxxx</code>，在这个一个长度为0的字符串上进行查找<code>&quot;&lt;/data&gt;&quot;</code>，必然找不到任何有用的信息。</p>
<p>结论：<strong>在处理网络流的时候，即使协议是文本协议，最好还是把它当作二进制来处理或者用一些自己写的字符串匹配函数.</strong></p>
<h3 id="请求队列积压问题"><a href="#请求队列积压问题" class="headerlink" title="请求队列积压问题"></a>请求队列积压问题</h3><p>测试用asio写的模块时发现，在高压力情况下，内存使用很大，而且涨上去之后在低压力情况下内存依然没降下来。一开始以为是内存泄露，后来用valgrind查了半天，发现根本没有内存泄露的代码。</p>
<p>通过post方法将多个其他线程的日志内容推到这个日志线程的中去。于是这个时候就比较容易理解了，<strong>多线程来喂一个单线程，单线程必然响应不过来，这样子导致整个task队列比较一直在增长</strong>，并且当压力降下来之后，整个队列已经很大了，并不会再降回去。</p>
<blockquote>
<p>在所有异步系统中普遍存在的，当响应很慢时，会导致请求队列积压，造成内存的大量占用。</p>
</blockquote>
<p>解决办法: </p>
<ul>
<li>给队列一个上限，当走出这个队列长度之后，拒绝新的请求。这种方法很暴力，但是不会造成系统崩溃。<br>检查了io_service的构造函数之后发现，没有提供任何关于队列长度限制的函数，因此这个方法可以直接忽略了</li>
</ul>
<p>一般就是这么做, 但是这里由于环境限制, 所以只能提高日志的级别, 解决队列积压问题.</p>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>首先一般不会用c/c++去写业务代码, 维护和开发成本太高, 一般都是通过服务器转发给前端其他模块&amp;语言处理, 比如php,<br>此时转发请求的服务器就要能保存状态&amp;维护长连接, 例如可以采用<code>boost/asio + fastcgi + php</code>.</p>
<p>当前端将请求发上来之后，长连接服务器通过 <code>fastcgi协议</code> 将请求发给 php，由php处理完成后再返回给长连接服务器，由长连接服务器返回给用户。<br>好处如下:</p>
<ul>
<li>web服务器是基于http协议的(架构显然协议不一定是http的，可以任意自己想要的协议)</li>
<li>http协议是无状态的</li>
</ul>
<p>那么第二个问题，如何解决无状态，通常web服务器是通过session，这个显然有性能问题，而且session是没有保证的。<br>于是我们反过来，长连接服务器同时作为session服务器，在把请求发给php时，同时将存储在长连接服务器的session也发给php，<br>php对session的任何更改也在响应中回传给服务器，由<strong>服务器保存(session)</strong>，下一次调用时再传回去。</p>
<p>这样一来，从 php 服务器端看到的是一个有状态的请求序列。 </p>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>这篇文章会一直更新, 直到哪一天我不再在一线编码了, 希望能给看到的人提供一些帮助.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="external">知乎大神们对restful的看法</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">http状态码大全</a></li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="/" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：里程碑1(Linux后台开发经验分享)</span><br/>
	<span><b>本文链接</b>：www.merlinblog.site/2017/08/30/milestone1.html</span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="/css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY SA 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>

