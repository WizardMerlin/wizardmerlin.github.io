<!DOCTYPE html>
<html>
<head>

  <meta charset="utf-8">
  <link rel="stylesheet" type="text/css" href="/css/fonts.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/bulma/0.4.1/css/bulma.min.css"> 
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  <script src="//cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></script>
  
  <title>里程碑1(Linux后台开发经验分享) | Merlin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="一些列工作经验的分享,干货">
<meta name="keywords" content="里程碑">
<meta property="og:type" content="article">
<meta property="og:title" content="里程碑1(Linux后台开发经验分享)">
<meta property="og:url" content="www.merlinblog.site/2017/08/30/milestone1.html">
<meta property="og:site_name" content="Merlin&#39;s Blog">
<meta property="og:description" content="一些列工作经验的分享,干货">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/new_era_1.png">
<meta property="og:updated_time" content="2017-10-27T03:37:11.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="里程碑1(Linux后台开发经验分享)">
<meta name="twitter:description" content="一些列工作经验的分享,干货">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/new_era_1.png">
  
  
    <link href="/favicon.ico" rel="ico" />
  
  
  <link rel="stylesheet" href="/css/common.css">
<link rel="stylesheet" href="/css/nav.css">
<link rel="stylesheet" href="/css/layout.css">
  

</head>

<body>

  <div class="preloader">
    <div class="preloader-inner">
      <ul><li></li><li></li><li></li><li></li><li></li><li></li></ul>
    </div>
  </div>
  <div>
	<header id="navbar" class="overflow-hidden">
  <div class="container">

    <nav class="nav">

         <div class="nav-left">
            <a href="/" class="nav-item" style="font-size: 20px;">
              <span class="logo">Merlin</span>'s Blog
            </a>
           <span style="margin-top:20px; font-size:0.85em; color:grey;">
		      version: 2.0
		   </span>
         </div>




        <div class="nav-right nav-menu">
            <a class="nav-item" id="search" onclick="tmpfobid()">
                <i class="fa fa-search" aria-hidden="true"></i>
            </a>
            
            <a class="nav-item" href="/">
                主页
            </a>
            
            <a class="nav-item" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item" href="/works">
                开源作品
            </a>
            
            <a class="nav-item" href="/about">
                关于博主
            </a>
            
            <a class="nav-item" href="/atom.xml">
                Rss
            </a>
            
        </div>

        <span class="nav-toggle" id="navMenuDropdown">
            <span></span>
            <span></span>
            <span></span>
        </span>

        <div class="navbar-menu position-absolute full-width content-box is-hidden-desktop is-flex flex-column center" style="top: 100%;">
            
            <a class="nav-item flex-1" href="/">
                主页
            </a>
            
            <a class="nav-item flex-1" href="/tags">
                标签集合
            </a>
            
            <a class="nav-item flex-1" href="/works">
                开源作品
            </a>
            
            <a class="nav-item flex-1" href="/about">
                关于博主
            </a>
            
            <a class="nav-item flex-1" href="/atom.xml">
                Rss
            </a>
            
        </div>

    </nav>
  </div>
</header>

<script>
function tmpfobid()
{
	alert("搜索效果太差, 暂时禁用 Local Search.");
}
</script>

  </div>
  <div id="main-wrap" class="position-relative" style="margin-top: 55px;">
      <div class="main-inner-content">
          <!--博文页面-->

<style>
    .header-box {
        height: 170px;
        filter: blur(10px);
        background-size: cover;
        background-color: darkgrey;
    }

    .post-box {
        padding: 15px;
        padding-top: 60px;
        min-height: 80vh;
        margin-top: -200px;
        border-radius: 4px;
        background-color: rgba(255,255,255,0.7);
    }

    .post-avatar {
        height: 30px;
        width: 30px;
        border-radius: 50%;
    }

    .flow-chart {
        text-align: center;
    }

    img[alt="post-cover"] {
        display: none;
    }
</style>





<header>
    <div id="header_box" class="header-box"></div>
</header>


<section>
<!--这里添加toc内容, 一定是在article entry之前-->
<link rel="stylesheet" href="/css/toc.css">


       <p class="show-toc-btn" id="show-toc-btn"  style="display:none" onclick="showToc()">
       <span class="btn-bg"></span>
       <span class="btn-text">文章导航</span></p>

	<div id="toc-article" class="toc-article">
	    <div id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">
		×
		</div>
		<strong class="toc-title"> 目录</strong>
           	<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#版本记录"><span class="toc-number">1.</span> <span class="toc-text">版本记录</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#milestone1-大巨变"><span class="toc-number">1.1.</span> <span class="toc-text">milestone1: 大巨变</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#milestone2-领域专家"><span class="toc-number">1.2.</span> <span class="toc-text">milestone2 : 领域专家</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#核心内容"><span class="toc-number">2.</span> <span class="toc-text">核心内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#服务端"><span class="toc-number">2.1.</span> <span class="toc-text">服务端</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#编程语言"><span class="toc-number">2.1.1.</span> <span class="toc-text">编程语言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库"><span class="toc-number">2.1.2.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#消息件"><span class="toc-number">2.1.3.</span> <span class="toc-text">消息件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#协议"><span class="toc-number">2.1.4.</span> <span class="toc-text">协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络框架"><span class="toc-number">2.1.5.</span> <span class="toc-text">网络框架</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#相关架构"><span class="toc-number">2.1.6.</span> <span class="toc-text">相关架构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其他技术"><span class="toc-number">2.1.7.</span> <span class="toc-text">其他技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Linux系统"><span class="toc-number">2.2.</span> <span class="toc-text">Linux系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#core文件"><span class="toc-number">2.2.1.</span> <span class="toc-text">core文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RESTful相关"><span class="toc-number">2.3.</span> <span class="toc-text">RESTful相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#restful简介"><span class="toc-number">2.3.1.</span> <span class="toc-text">restful简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#api返回值经验"><span class="toc-number">2.3.2.</span> <span class="toc-text">api返回值经验</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-语言"><span class="toc-number">2.4.</span> <span class="toc-text">C++语言</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#window移植"><span class="toc-number">2.4.1.</span> <span class="toc-text">window移植</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#宽字符问题"><span class="toc-number">2.4.2.</span> <span class="toc-text">宽字符问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作大文件"><span class="toc-number">2.4.3.</span> <span class="toc-text">操作大文件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C-标准库"><span class="toc-number">2.5.</span> <span class="toc-text">C++标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#变量初始化"><span class="toc-number">2.5.1.</span> <span class="toc-text">变量初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#std-bind"><span class="toc-number">2.5.2.</span> <span class="toc-text">std::bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#智能指针-多线程-问题"><span class="toc-number">2.5.3.</span> <span class="toc-text">智能指针(多线程)问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Boost-Asio"><span class="toc-number">2.6.</span> <span class="toc-text">Boost.Asio</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#read-util相关"><span class="toc-number">2.6.1.</span> <span class="toc-text">read_util相关</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#请求队列积压问题"><span class="toc-number">2.6.2.</span> <span class="toc-text">请求队列积压问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#linux-网络部分"><span class="toc-number">3.</span> <span class="toc-text">linux 网络部分</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#长连接"><span class="toc-number">3.1.</span> <span class="toc-text">长连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#禁用Nagle算法"><span class="toc-number">3.2.</span> <span class="toc-text">禁用Nagle算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用-tcp-选项"><span class="toc-number">3.3.</span> <span class="toc-text">常用 tcp 选项</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket-编程问题"><span class="toc-number">3.4.</span> <span class="toc-text">socket 编程问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket-选项"><span class="toc-number">3.4.1.</span> <span class="toc-text">socket 选项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#心跳保活"><span class="toc-number">3.5.</span> <span class="toc-text">心跳保活</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP保活"><span class="toc-number">3.5.1.</span> <span class="toc-text">TCP保活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP保活"><span class="toc-number">3.5.2.</span> <span class="toc-text">HTTP保活</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用保活"><span class="toc-number">3.5.3.</span> <span class="toc-text">应用保活</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾巴"><span class="toc-number">4.</span> <span class="toc-text">尾巴</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">5.</span> <span class="toc-text">参考资料</span></a></li></ol>
    	</div>
	




<script  language="javascript">


</script>


    <div class="container post-box">
        <div class="content post-title is-flex center flex-column" style="margin-bottom: 2px; overflow: auto;">
            <div class="has-text-centered" style="font-size:36px; padding-bottom: 7px; border-bottom: 2px solid #000">
                <strong>里程碑1(Linux后台开发经验分享)</strong>
            </div>
 
            <div class="is-flex align-center" style="margin-top:10px;">
                <span style="padding:0 10px;">post time:</span>
				
                <span class="post-date">2017-08-30</span>
            </div>
			
            
                <div>
                    
                         <a style="margin-right:5px" class="tag is-post-tag" href="/tags/里程碑/">里程碑</a>
                    
                </div>
            
        </div>
        <hr/>           


        <div class="content" style="overflow: auto; align:center;">
            <blockquote>
<p>本文只在每一次 milestone 记录点更新, 记录我开发中遇到的经验,体会; 有的单独总结了, 所以只给出链接</p>
</blockquote>
<p>当前文章(以后会更新), 总结了我的个人经验, 包括我自己亲身经历的, 后台同学一起讨论的, 网络曾经看到的等等. </p>
<p><strong>如果你把你学到的知识, 而不是思考问题的方式, 细心&amp;耐心的品质, 健康的身体, 银行的存款, 结交的人缘作为核心竞争力;</strong><br><strong>那么分享自己所学可能对你有点儿困难.(虽然最初的时候我写博客也只是完全为了记录我成长的过程, 不过渐渐目的已经转变了)</strong></p>
<a id="more"></a>
<h1 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h1><h2 id="milestone1-大巨变"><a href="#milestone1-大巨变" class="headerlink" title="milestone1: 大巨变"></a>milestone1: 大巨变</h2><blockquote>
<p><code>大巨变100天(100 days from New Era)</code></p>
</blockquote>
<p><img src="http://omotkhw3y.bkt.clouddn.com/new_era_1.png" alt="里程碑"></p>
<p>当前里程碑记录<strong>Linux后台开发经验</strong>.</p>
<p>下面是一些<code>基于当前工作经验&amp;年限</code>的认识:</p>
<ul>
<li>对于c++, go这类稍微偏底层, 并且常用的语言, 一定要了解细节, 深知见底.</li>
<li>对于python, shell这类脚本或者模型语言, 用好为主</li>
<li>对于数据结构和算法: 数据结构深入, 算法了解.</li>
<li>对于操作系统, 如果决心做高级工程师, 业内技术专家linux一定要深入到内核(具体的是内核哪个模块?所有.)</li>
<li>对于网络编程, 根据工作的不同, 有人工作在应用层,有人工作在传输层和网络层, 甚至是链路层(但是不管这么说, 应用层和网络层是要知道的)</li>
<li>对于项目管理和人员管理等管理问题, 请入行的第3年再去涉及.(也就是工作的第5-7年)</li>
<li>对于金钱, 抱歉我看到的身边的人30W一大把, 50W是一个坎大多人突破不过去. (自己实力稍弱的时候, <code>不要太看重钱</code>)</li>
<li></li>
</ul>
<p><code>表面上看我成长不少, 但是从一个高手的要求上看, 我所做的其实远远不够; 希望慢慢会快, 后期抓紧时间!</code></p>
<h2 id="milestone2-领域专家"><a href="#milestone2-领域专家" class="headerlink" title="milestone2 : 领域专家"></a>milestone2 : 领域专家</h2><p>期待 <strong>2019.9</strong>, 一个全新&amp;加强版的我.</p>
<blockquote>
<p>TODO, 等待下一次更新; 深入行业!</p>
</blockquote>
<hr>
<h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>游戏业内主要的是c/c++ + Python/lua模式做游戏服务器。<br>c/c++做网络通讯数据传输，python/lua做业务逻辑。这样既保持了网络传输的效率(c++)，又提升开发效率(Python/lua)，同时也支持热更新。</p>
<p>其他用 erlang, go, C#, 甚至java, node.js也有, 只是没有接触过.</p>
<h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>我看到同学中, 一般小公司的, 用mysql, mongodb足以; 如果要访问提升效率(减轻数据库压力), 选择内存数据库redis, memcached都不错.<br>(存盘可以即使存盘, 但一般都不这么做, 一般采用固定存盘减少服务器压力; 个别效率苛刻的场景除外)</p>
<h3 id="消息件"><a href="#消息件" class="headerlink" title="消息件"></a>消息件</h3><p>一般用于服务器或者多进程之间通信, 比如zeromq等.<br>网络通信方面可以自己处理粘包问题, 直接传输字节流, 也可以传输xml, json; 常见的可能是采用框架, 比如protobuffer, 二进制传输.</p>
<h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议部分的, 一般会涉及三个协议: http, tcp, udp<br><strong>http</strong>: 如果是那种弱联网单机玩法，用http足够了，像天天酷跑之类，只在需要的时候处理一条http请求响应。<br><strong>tcp</strong>: 现在的网络游戏大多数都是tcp<br><strong>udp</strong>: 其实游戏是有udp的，在一些高效率(即时性, 实时性要求高)的场景下比如pvp即时战斗,tcp的拥塞控制和超时重传并不适合，有些就用的udp,然后自己做丢包重发</p>
<p>现在参与开发的游戏就同时使用了http协议和tcp协议，在游戏服是单机玩法用http协议,战斗服需要长连接保存协议状态，用的tcp。</p>
<h3 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h3><p>libevent, boost.asio等网络库， 网上有很多开源网络库，与其自己造轮子，不如就用开源网络库作为自己服务器的通讯库, 例如:<br>libevent和boost.asio:</p>
<ul>
<li>Boost的ASIO是一个异步IO库，封装了对Socket的常用操作，简化了基于socket程序的开发。支持跨平台。</li>
<li>Libevent是一个C语言写的事件驱动的开源网络库, 应用和异步IO逻辑思想类似的 reactor反应堆模型.</li>
</ul>
<p>这两个库我都有详细介绍过, 这里就不再多说了, 具体可以参考我的文章: <a href="http://www.merlinblog.site/2017/10/13/network-base.html">网络部分汇总</a></p>
<h3 id="相关架构"><a href="#相关架构" class="headerlink" title="相关架构"></a>相关架构</h3><p>后端服务器架构应该说有很多种, 我熟悉的:</p>
<ul>
<li>Gate: 首先要有一个Gate(网关)服务器，负责客户端连接及消息转发到Game(游戏服),保持客户端到服务端的连接<br>没有任何逻辑，只做消息加密和解密，以及客户端和服务器消息的转发(相当于两者之间的桥梁).</li>
<li>GameServer: GameServer是游戏进程,提供游戏逻辑功能(采用单进程(或者单线程)模型,游戏服务器的瓶颈从来不在CPU,所以只做逻辑功能的话单线程足够了,在这里没必要用多线程或多进程)。</li>
<li>DBManager:实现数据库的读写，方便Game服务器异步读写数据库的数据(有些把数据库读写放在游戏服务器，没有单独的服务器，那恐怕游戏服单进程就不够用了)。</li>
<li>GameManager: 负责管理所有的GameServer，GameServer之间消息转发，提供广播到所有Game的功能。</li>
</ul>
<p>分布式架构我就不太熟悉了, 一般需要到专门的大公司学习.</p>
<h3 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h3><p>一般用的都是开源的, 比如gtest, glog/zlog, tcmalloc(内存性能分析), distcc, repo等</p>
<blockquote>
<p>其他技术, 请参考我的博客其他文章.</p>
</blockquote>
<h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="core文件"><a href="#core文件" class="headerlink" title="core文件"></a>core文件</h3><p>产生 core 文件, 命令 <code>ulimit -c</code> 如果显示 1024 那么说明 coredump 已经被开启, 0 则表示没有开启.</p>
<blockquote>
<p>一般临时修改: ulimit -c unlimited  或者 <code>ulimit -c 1024</code>;关闭的话<code>ulimit -c 0</code>.</p>
</blockquote>
<p>1024 限制产生的 core 文件的大小不能超过 1024kb，可以使用参数unlimited，取消该限制</p>
<p>也可以修改文件配置<code>/etc/security/limits.conf</code>, 添加一行<code>* soft core unilimited</code><br>其实这个是由pam来完成的，pam里有个模块叫pam_limits，它默认的会读取/etc/security/limits.conf文件来进行资源限制。而用户登录时会调用/etc/pam.d/login文件来进行检查，这个文件里标明了使用哪些模块。其中它include了一个叫system_auth的配置文件，在这个文件里有对pam_limits.so的调用。</p>
<p>如果上面没有生效, 可能是其他登陆模块强制修改了, 典型的需要查看一下<code>/etc/profile</code>, <code>/etc/init.d/functions</code>.<br>这些文件在用户登录时会执行，因此即使pam修改了还是会被它改回去, 可以把那几行注释掉, 不过我一直截止很简单的:</p>
<pre><code>echo &quot;ulimit -c 1024&quot; &gt;&gt; /etc/profile
</code></pre><blockquote>
<p>将不该清空的内存清空了，导致执行的时候会进入不可状态; 此时每次看到的core dump信息都不一样.</p>
</blockquote>
<h2 id="RESTful相关"><a href="#RESTful相关" class="headerlink" title="RESTful相关"></a>RESTful相关</h2><p>本段属于上层协议内容, 感谢土哥的经验交流.</p>
<h3 id="restful简介"><a href="#restful简介" class="headerlink" title="restful简介"></a>restful简介</h3><p>RESTful 架构, 由于其以资源中心, 依赖http协议和uri, 虽然也会涉及c-s模型, 不过其更多的是强调对于相关资源的crud操作, 并且提供了统一的API形式:</p>
<ul>
<li>看Url就知道要什么</li>
<li>看http method就知道干什么</li>
<li>看http status  code就知道结果如何</li>
</ul>
<p>举几个例子就会发现它非常规范:</p>
<pre><code>https://api.qzone.com/user/getUserFeedList?from=web 
https://api.qzone.com?m=user&amp;c=getUserFeedList?from=web 
https://qzone.com/api/user/getUserFeedList?from=web 
https://qzone.com?m=api&amp;c=user&amp;a=getUserFeedList?from=web
</code></pre><p>HTTP协议形式例如:</p>
<pre><code>GET /posts HTTP/1.1
Accept: application/atom+xml

响应：
HTTP/1.1 200 OK
Content-Type: application/atom+xml

&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;
    &lt;title&gt;Posts&lt;/title&gt;
    &lt;link href=&quot;http://example.org/posts&quot; rel=&quot;self&quot; /&gt;
    &lt;link href=&quot;http://example.org/posts?pn=2&quot; rel=&quot;next&quot; /&gt;

    &lt;id&gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6&lt;/id&gt;
    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;
    &lt;entry&gt;
        &lt;title&gt;Post XXX&lt;/title&gt;
        &lt;link href=&quot;http://example.org/post-xxx&quot; /&gt;
        &lt;id&gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id&gt;
        &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;
        &lt;content type=&quot;xhtml&quot;&gt;
            &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;
                &lt;p&gt;This is the post content.&lt;/p&gt;
            &lt;/div&gt;
        &lt;/content&gt;
    &lt;/entry&gt;
    &lt;entry&gt;...&lt;/entry&gt;
&lt;/feed&gt;
</code></pre><h3 id="api返回值经验"><a href="#api返回值经验" class="headerlink" title="api返回值经验"></a>api返回值经验</h3><blockquote>
<p>针对JSON型API的返回结果设计, 总结下自己的经验</p>
</blockquote>
<p>一般的返回结果是怎么样的?</p>
<pre><code>{
    data : { // 请求数据
        user_id: 123,
        user_name: &quot;tutuge&quot;,
        ...
    },
    msg : &quot;done&quot;, // 请求状态描述，调试用
    code: 1001, // 业务自定义状态码
    extra : { // 全局附加数据(optional字段)
        type: 1,
        desc: &quot;秒数信息&quot;
    }
}
</code></pre><p>下面详细解释:</p>
<ul>
<li>data字段<br>本次请求结果的数据 data 字段, 其值为对象(字典)或数组(列表)均可以, 根据业务而定. 例如:<pre><code>data: [
  {user_id: 123, user_name: &quot;tutuge&quot;},
  {user_id: 321, user_name: &quot;zekunyan&quot;},
  ...
]
</code></pre>当然数组, 对象还可以嵌套, 怎么灵活怎么用.(不用担心现有库对于字段的解析问题)</li>
<li>msg字段<br>该字段是本次请求的业务&amp;状态描述信息, 主要用于调试、测试等, 例如 “done”, “测试缺少参数”. 根据相关开发人员协商即可. </li>
<li>code字段<br>这是比较有争议的一个字段, 因为Http请求本身已经有了完备的状态码，再定义一套状态码直观上感受却是不对劲。但是实际开发中，确实发现 <code>自定义业务状态码</code> 的必要性，如一次成功的Http status 200的请求，可能由于用户未登录、登录过期而有不同的返回结果和处理方式，所以还是保留了; 权当http协议的详细说明.<br>定义规范根据业务来, 例如按照用户相关、授权相关、各种业务，做简单的分类:<pre><code>// Code 业务自定义状态码定义示例
// 授权相关
1001: 无权限访问
1002: access_token过期
1003: unique_token无效
...
// 用户相关
2001: 未登录
2002: 用户信息错误
2003: 用户不存在
// 业务1
3001: 业务1XXX
3002: 业务1XXX
// ...
</code></pre>最好定义为常量, 当然能够动态解析最好.</li>
<li><p>extra字段<br>这个纯粹是附加字段(全局的附加数据), 为的是灵活扩展, 比如升级啊, 需求变化等. 由服务端的规则决定并且客户端要及时向用户展示变化, 所以加上了extra字段. 例如:</p>
<pre><code>// 升级
type: 1,
show_msg: &quot;恭喜您升级到XXX&quot;

// 完成任务
type: 2,
task_desc: &quot;达成XXX成就&quot;
</code></pre></li>
</ul>
<p>其实最终还是要看客户端和服务端人员的协商; 服务端人员切不可以为添加一个字段简单没有什么, 就随口答应, 一切都要走流程, 并且避免乱用. 这不仅仅是为了规范, 而是为了让项目不会再将来出现意想不到的 <code>惊喜</code> .</p>
<p>补充经验:</p>
<ul>
<li>命名, 和C语言保持一致就可以了(字段统一小写加下划线)<br>例如:<pre><code>// 字符串
user_name, task_desc, date_str, article_title, feed_content 等
// 数字
user_id, users_count, task_num, xxx_offset 等
// 日期
login_at, create_date, logout_time 等
// 布尔
is_done, is_vip, protected, can_read 等
// URL
user_avatar_url, thumb_url 等
// 数组
users, profiles, thumb_imgs 等
</code></pre></li>
<li>设置默认值(空值)<ul>
<li>数字就是 <code>0</code></li>
<li>字符串就是空字符串<code>&quot;&quot;</code></li>
<li>数组就是空数组<code>[]</code></li>
<li>对象就是空对象{}</li>
</ul>
</li>
<li>bool值, 统一成0和1.<br>由于多种语言不统一, 所以一开始就要做好限定, 而不是<code>true</code>, <code>True</code>, <code>1</code>漫天乱飞.. 在客户端和服务端统一设置常量、宏定义，定义布尔的类型，所有的参数、结果的布尔字段全部做强制约束</li>
<li>时间处理, 统一使用Unix时间戳, 即GMT/UTC时间戳, 可以用<code>date +%s</code>命令查看, 然后各自客户端根据自己的时区, 显示做转换.<br>例如:<pre><code>// 从服务器接收的时间数据
login_at: 1462068610
// 根据时区、显示要求转换，如北京时间
显示：2016年5月1日下午1点、1天前等
</code></pre>(如果用字符串,可以参考<code>YYYY-MM-DDThh:mm:ssTZD</code>格式,保留了时区)</li>
<li>字符串常量 请用常量文档约束.<pre><code>// 如登录类型，QQ、微信、微博等
login_type: &quot;qq&quot;,
login_type: &quot;wechat&quot;,
login_type: &quot;sina_weibo&quot;,
</code></pre></li>
<li>使用完整的url, 指明网络协议(scheme).</li>
</ul>
<h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><h3 id="window移植"><a href="#window移植" class="headerlink" title="window移植"></a>window移植</h3><p>windows迁移问题, 自己遇到的, 记录一下:</p>
<ul>
<li>缺少最后一行空行, 多余的\r回车符<br><code>dos2unix &lt;file&gt; fromdos &lt;file&gt;</code></li>
<li>中文注释乱码<br><code>iconv –f gbk –t utf8</code> (utf8也可以写成utf-8)</li>
<li>不能忍的头文件<br><code>windows.h</code></li>
<li>不兼容的宏, 库函数<br><code>snprintf()</code>,<code>__FUNCTION__</code>, <code>__FILE__</code>, <code>__LINE__</code></li>
<li>特殊的宏<br><code>#ifdef WIN_32  #define …  #endif</code></li>
</ul>
<h3 id="宽字符问题"><a href="#宽字符问题" class="headerlink" title="宽字符问题"></a>宽字符问题</h3><p>本质上是ascii码和unicode的存储问题.(单字节不够用, 采用多字节)<br>先注意一下文件编码, windows下默认是gbk编码:</p>
<pre><code>iconv -f GBK -t UTF-8 main.cc &gt; mainu.cc
</code></pre><p>之后注意一下多字节字符问题, 基本情况如下:(实际上wchar_t同样没有标准限定)</p>
<ul>
<li>Windows 下的 char 是 ANSI，WCHAR 是 UTF-16（UCS-2），跟 locale设置有关系</li>
<li>Linux   下的 char 是 UTF-8，WCHAR 是 UTF-32（UCS-4），都是 Unicode，与 locale 无关</li>
</ul>
<p>我建议你 Windows 下调用<code>MultiByteToWideChar</code>和<code>WideCharToMultiByte</code>，<br>而 Linux 直接自己写一个转换函数(UTF-8 和 UTF-32 转换规律很简单), 大致如下:</p>
<pre><code class="C++">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int UTF8ToUnicode(const char *pmbs, wchar_t *pwcs, int size)
{
    int cnt = 0;
    // 这里 size-- 是预先除去尾零所需位置
    if (pmbs != NULL &amp;&amp; pwcs != NULL &amp;&amp; size-- &gt; 0) {
        while (*pmbs != 0 &amp;&amp; size &gt; 0) {
            unsigned char ch = *pmbs;
            if (ch &gt; 0x7FU) {
                int cwch = 0;
                while (ch &amp; 0x80U) {
                    ch &lt;&lt;= 1;
                    cwch++;
                }
                *pwcs = *pmbs++ &amp; (0xFFU &gt;&gt; cwch);
                while (--cwch &gt; 0) {
                    *pwcs &lt;&lt;= 6;
                    *pwcs |= (*pmbs++ &amp; 0x3FU);
                }
            } else {
                *pwcs = *pmbs++;
            }
            pwcs++;
            size--;
            cnt++;
        }
        *pwcs = 0;
        cnt++;
    }
    return cnt;
}

int UnicodeToUTF8(const wchar_t *pwcs, char *pmbs, int size)
{
    int cnt = 0;
    // 这里 size-- 是预先除去尾零所需位置
    if (pwcs != NULL &amp;&amp; pmbs != NULL &amp;&amp; size-- &gt; 0) {
        while (*pwcs != 0 &amp;&amp; size &gt; 0) {
            if (*pwcs &lt; 0x00000080U) {
                *pmbs++ = (char)*pwcs;
                size -= 1;
                cnt += 1;
            } else if (*pwcs &lt; 0x00000800U) {
                // 剩余空间不够存放该字符
                if (size &lt; 2) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 6) | (*pwcs &gt;&gt; 6);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 2;
                cnt += 2;
            } else if (*pwcs &lt; 0x00010000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 3) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 5) | (*pwcs &gt;&gt; 12);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 3;
                cnt += 3;
            } else if (*pwcs &lt; 0x00200000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 4) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 4) | (*pwcs &gt;&gt; 18);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 4;
                cnt += 4;
            } else if (*pwcs &lt; 0x04000000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 5) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 3) | (*pwcs &gt;&gt; 24);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 5;
                cnt += 5;
            } else if (*pwcs &lt; 0x80000000U) {
                // 剩余空间不够存放该字符
                if (size &lt; 6) {
                    break;
                }
                *pmbs++ = (0xFFU &lt;&lt; 2) | (*pwcs &gt;&gt; 30);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 24) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);
                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);
                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);
                size -= 6;
                cnt += 6;
            } else {
                // 无法识别的 Unicode 字符
                break;
            }
            pwcs++;
        }
        *pmbs = 0;
        cnt++;
    }
    return cnt;
}

int main(void)
{
    // 这部分代码请在 Linux 上测试，Windows 命令行无法打印 UTF-8 字符串。
    char mbs1[256] = { 0 };
    wchar_t wcs1[] = L&quot;测试文字&quot;; //单个中文, utf8存储3字节
    int ret1 = UnicodeToUTF8(wcs1, mbs1, sizeof(mbs1)/sizeof(char));
    printf(&quot;%d\n&quot;, ret1); //13

    // 这部分代码请在 Linux 上测试，Windows 的 char 类型非 UTF-8 编码。
    char mbs2[] = &quot;测试文字&quot;;
    wchar_t wcs2[256] = { 0 };
    int ret2 = UTF8ToUnicode(mbs2, wcs2, sizeof(wcs2)/sizeof(wchar_t));
    printf(&quot;%d\n&quot;, ret2); //5

    return 0;
}
</code></pre>
<p>参数作用简单说明如下：</p>
<ul>
<li>第一个参数为待转换的字符串</li>
<li>第二个参数为接收结果的缓冲区</li>
<li>第三个参数为结果缓冲区大小(包含尾零)<br>返回值为所写入缓冲区的大小(包含尾零)</li>
</ul>
<p>最好不要使用<code>wchar_t</code>, 而直接使用<code>std::wstring</code>, 例如下面的代码:(windows环境)</p>
<pre><code class="C++">//const wchar_t* ws = L&quot;世界你好！&quot;;
std::wstring wstr = L&quot;世界你好！&quot;;
std::wcout.imbue( std::locale(&quot;chs&quot;) );
std::wcout &lt;&lt; wstr &lt;&lt; std::endl;
</code></pre>
<p><code>std::locale( std::locale(),&quot;&quot;,std::locale::ctype )</code>会创建当前系统环境下locale，这个locale中会保存这个系统 ansi 使用 code page.<br>(wofstream，wcout 在处理 unicode字符 时，必须进行内部编码转换（unicode -&gt; ansi ）)</p>
<p>具体参考以下链接:</p>
<ol>
<li><a href="http://blog.csdn.net/xujiezhige/article/details/17843831" target="_blank" rel="external">http://blog.csdn.net/xujiezhige/article/details/17843831</a></li>
<li><a href="http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html" target="_blank" rel="external">http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html</a></li>
<li><a href="http://bbs.csdn.net/topics/391079600?page=1" target="_blank" rel="external">http://bbs.csdn.net/topics/391079600?page=1</a></li>
</ol>
<h3 id="操作大文件"><a href="#操作大文件" class="headerlink" title="操作大文件"></a>操作大文件</h3><p>1.包含所有头文件以前，先定义这些宏：</p>
<pre><code class="C++">#ifndef __USE_FILE_OFFSET64
#define __USE_FILE_OFFSET64
#endif

#ifndef __USE_LARGEFILE64
#define __USE_LARGEFILE64
#endif

#ifndef _LARGEFILE64_SOURCE
#define _LARGEFILE64_SOURCE
#endif
</code></pre>
<p>一般用 /usr/include/features.h 重定义的:</p>
<p>32位LINUX使用超过2G的大文件，需要定义很多宏，与文件操作API相关的宏都有这样一些：</p>
<pre><code>_FILE_OFFSET_BITS
_LARGEFILE_SOURCE
_LARGEFILE64_SOURCE
__USE_FILE_OFFSET64
__USE_LARGEFILE
__USE_LARGEFILE64
</code></pre><p>那么，它们之间的关系究竟是怎么样的呢？<br>终于在linux的头文件<code>/usr/include/features.h</code>中找到了定义。</p>
<pre><code class="C++">//原来这个文件就是专门让用户定义各种特性的：
/*These are defined by the user (or the compiler)
to specify the desired environment

其中几个供用户配置的宏的注释为：
_LARGEFILE_SOURCE    Some more functions for correct standard I/O.
_LARGEFILE64_SOURCE    Additional functionality from LFS for large files.
_FILE_OFFSET_BITS=N    Select default filesystem interface.
_GNU_SOURCE        All of the above, plus GNU extensions.
__USE_LARGEFILE    Define correct standard I/O things.
__USE_LARGEFILE64    Define LFS things with separate names.
__USE_FILE_OFFSET64    Define 64bit interface as default.
*/

// use前缀的宏定义都先取消掉，说明这些宏不是直接供用户使用的，而是由其他宏的定义衍生这些宏
#undef    __USE_LARGEFILE
#undef    __USE_LARGEFILE64
#undef    __USE_FILE_OFFSET64

//   _GNU_SOURCE是一张很大的通行证，定义了这个，很多相关的开关都会打开
/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */
#ifdef _GNU_SOURCE
# undef     _LARGEFILE64_SOURCE
# define _LARGEFILE64_SOURCE    1
#endif

// 下面是打开各个USE宏的位置
#ifdef _LARGEFILE_SOURCE
# define __USE_LARGEFILE    1
#endif

#ifdef _LARGEFILE64_SOURCE
# define __USE_LARGEFILE64    1
#endif

#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64
# define __USE_FILE_OFFSET64    1
#endif
</code></pre>
<p>总结： <strong>使用64位大文件，定义_LARGEFILE64_SOURCE和_FILE_OFFSET_BITS=64这两个宏即可</strong></p>
<p><strong>2.</strong>使用open打开文件的时候，加上O_LARGEFILE标志：<br>int fd = open(“test.dat”, O_RDWR|O_APPEND|O_CREAT|O_LARGEFILE, 0666);<br>read(), write()等与一般的用法一致，无变化。</p>
<p><strong>3.</strong>注意lseek()函数，文件未超过2G的时候，一切工作良好；<br>文件超过2G后，调用返回-1，errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>需要使用lseek64()代替lseek()。很奇怪，定义了宏以后，并未自动将lseek变成lseek64。（知道原因的朋友可以教教我）</p>
<p><strong>4.</strong>注意stat()函数，传入的文件如果在2G内，工作良好；<br>传入的文件如果超过2G，返回-1, errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>应该这样使用：struct stat64 st; stat64(“file”, &amp;st);</p>
<p><strong>5.</strong>为了保险，建议所有操作文件的函数都是用支持64位大文件的。否则当文件超过2G后，难免会出现什么未知的异常</p>
<h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>具体可以参考一下我的文章, <a href="">C++11一致性初始化</a>, 提倡&amp;建议使用一致性初始化.</p>
<p>其他还有需要注意的就是, <strong>在线程编码中,尽量不要使用匿名对象</strong></p>
<blockquote>
<p>尽量不使用匿名对象，如果想要用完立即释放，可以使用单独的代码块包裹。</p>
</blockquote>
<h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><p>标准库的 bind 和 boost::bind 使用起来类似</p>
<p>举个例子</p>
<pre><code class="C++">void test(int a, int b, int c)
boost::bind(test, 1, _1, _2);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(1,3,4)
boost::bind(test, _2, 3, _1);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(4,3,3)
</code></pre>
<p>而在标准库中一般是这么用的:</p>
<pre><code class="C++">auto handler = std::bind(test, 1, std::placeholders::_1, std::placeholders::_2);
handler(3,4);// 相当于 test(1,3,4);
</code></pre>
<p>其他的可以参考文章<a href="http://www.merlinblog.site/2017/07/01/bind-in-cpp.html">C++11 std:bind探究</a></p>
<h3 id="智能指针-多线程-问题"><a href="#智能指针-多线程-问题" class="headerlink" title="智能指针(多线程)问题"></a>智能指针(多线程)问题</h3><p>其实是异步代码问题.<br>具体现象描述:<br>一旦压力达到一定程度，程序立即就会崩溃，报的错误几乎都在new的时候没有内存了，一开始以为确实是因为内存分配的问题，后来在<strong>程序运行过程中</strong>用top观察，发现内存使用很低，因此可以确认不应该是瞬间内存使用完造成的。</p>
<p>因此认真看了一下 core dump 的地方，发现几乎都是在自己写的一个智能指针分配内存那里出的问题。<br>于是仔细思考了一下，发现是因为<strong>智能指针的引用计数没有加锁</strong>导致的, 或者说<strong>同一时间, 可能有多个线程持有该指针</strong>, 导致引用计数不能减为0。</p>
<p>例如下面的代码:</p>
<pre><code class="C++">void func()
{
    shared_ptr a;
    async_call(a);
}
</code></pre>
<p>解释:首先有一个智能指针，接下来，这个智能指针被丢给了异步程序，因此这个时候其实已经有两个线程同时持有这个智能指针了，因为这个函数还未退出，当前线程还拥有这个指针a. 一般低压情况下，这两句很快就执行完了，不会出问题，但是高压情况下，这个函数先执行完，还是异步程序先执行完就不一定了（或者说是因为高压情况样本变多了）, 也就造成了资源没有释放.</p>
<h2 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost.Asio"></a>Boost.Asio</h2><h3 id="read-util相关"><a href="#read-util相关" class="headerlink" title="read_util相关"></a>read_util相关</h3><p>在使用boost的read_util库的时候遇到一个很诡异的问题，如果用read_util(““)这样的调用，第一个请求可以得到，但是第二个请求会卡住，永远也拿不到。从服务器端看到的情况是，第二个响应已经完整的发送出去，但是read_util就是不返回。比较奇怪的是如果用read_util(‘&gt;’)这样调用，那是没有任何问题的。</p>
<blockquote>
<p>read_util(string)这样的函数，它所用的肯定是string.find这样的函数，而这样的函数它是用字符串查找的，这表示它一旦遇到<code>\0</code>就不再往后查找了。</p>
</blockquote>
<p>每个响应最后会有一个/0字符。因此在第一个包读完之后，接下来读到的第一个字符就是<code>\0</code>，那么第二个包读的时候，不论读到多少数据，这个字符串的内容是<code>\0xxxxxxxx</code>，在这个一个长度为0的字符串上进行查找<code>&quot;&lt;/data&gt;&quot;</code>，必然找不到任何有用的信息。</p>
<p>结论：<strong>在处理网络流的时候，即使协议是文本协议，最好还是把它当作二进制来处理或者用一些自己写的字符串匹配函数.</strong></p>
<h3 id="请求队列积压问题"><a href="#请求队列积压问题" class="headerlink" title="请求队列积压问题"></a>请求队列积压问题</h3><p>测试用asio写的模块时发现，在高压力情况下，内存使用很大，而且涨上去之后在低压力情况下内存依然没降下来。一开始以为是内存泄露，后来用valgrind查了半天，发现根本没有内存泄露的代码。</p>
<p>通过post方法将多个其他线程的日志内容推到这个日志线程的中去。于是这个时候就比较容易理解了，<strong>多线程来喂一个单线程，单线程必然响应不过来，这样子导致整个task队列比较一直在增长</strong>，并且当压力降下来之后，整个队列已经很大了，并不会再降回去。</p>
<blockquote>
<p>在所有异步系统中普遍存在的，当响应很慢时，会导致请求队列积压，造成内存的大量占用。</p>
</blockquote>
<p>解决办法: </p>
<ul>
<li>给队列一个上限，当走出这个队列长度之后，拒绝新的请求。这种方法很暴力，但是不会造成系统崩溃。<br>检查了io_service的构造函数之后发现，没有提供任何关于队列长度限制的函数，因此这个方法可以直接忽略了</li>
</ul>
<p>一般就是这么做, 但是这里由于环境限制, 所以只能提高日志的级别, 解决队列积压问题.</p>
<h1 id="linux-网络部分"><a href="#linux-网络部分" class="headerlink" title="linux 网络部分"></a>linux 网络部分</h1><p>写网络的博文已经够多了, 请参考我的<strong>标签</strong>: <code>网络</code>, 大部分问题网络问题已经探讨过了.</p>
<h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>这个是相对于短连接而言的, 比如可能会遇到的<code>TIME_WAIT</code>过多, 就是由于大量的短连接造成的. 这里的长短都是指的的连接时间.</p>
<p>首先一般不会用c/c++去写业务代码, 维护和开发成本太高, 一般都是通过服务器转发给前端其他模块&amp;语言处理, 比如php,<br>此时转发请求的服务器就要能保存状态&amp;维护长连接, 例如可以采用<code>boost/asio + fastcgi + php</code>.</p>
<p>当前端将请求发上来之后，长连接服务器通过 <code>fastcgi协议</code> 将请求发给 php，由php处理完成后再返回给长连接服务器，由长连接服务器返回给用户。<br>好处如下:</p>
<ul>
<li>web服务器是基于http协议的(架构显然协议不一定是http的，可以任意自己想要的协议)</li>
<li>http协议是无状态的</li>
</ul>
<p>那么第二个问题，如何解决无状态，通常web服务器是通过session，这个显然有性能问题，而且session是没有保证的。<br>于是我们反过来，长连接服务器同时作为session服务器，在把请求发给php时，同时将存储在长连接服务器的session也发给php，<br>php对session的任何更改也在响应中回传给服务器，由<strong>服务器保存(session)</strong>，下一次调用时再传回去。</p>
<p>这样一来，从 php 服务器端看到的是一个有状态的请求序列。 </p>
<h2 id="禁用Nagle算法"><a href="#禁用Nagle算法" class="headerlink" title="禁用Nagle算法"></a>禁用Nagle算法</h2><p>这个问题也差不多也是由大量小数据包引起的问题, 它影响了IO性能, 或者吞吐量. 核心思想就是, 延迟应答.</p>
<p>和<code>TCP_NODELAY</code>选项有关, 简单地说，这个(启动)选项的作用就是禁用 Nagle 算法，禁止后当然就不会有它引起的一系列问题了。<br>使用setsockopt可以做到：</p>
<pre><code class="C++">static void _set_tcp_nodelay(int fd) {  
    int enable = 1;  
    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void*)&amp;enable, sizeof(enable));  
}
</code></pre>
<p>具体可以参考我的这篇文章 <a href="http://merlinblog.site/2017/06/19/how-about-tcp.html#Nagle算法" target="_blank" rel="external">how about tcp</a></p>
<h2 id="常用-tcp-选项"><a href="#常用-tcp-选项" class="headerlink" title="常用 tcp 选项"></a>常用 tcp 选项</h2><p>关于这一点, 可以查看 <code>man 7 tcp</code>, 或者看一下<code>man 7 socket</code>, 里面详细列举了相关的参数.</p>
<p>具体可以参考一下 我的文章 <strong>how-about-tcp</strong>.</p>
<h2 id="socket-编程问题"><a href="#socket-编程问题" class="headerlink" title="socket 编程问题"></a>socket 编程问题</h2><h3 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h3><p>常用的有:</p>
<ul>
<li>SO_REUSEADDR</li>
<li>SO_RECVBUF/SO_SNDBUF</li>
<li>SO_KEEPALIVE</li>
<li>SO_LINGER</li>
</ul>
<p>下面详细说一下:<br><strong>SO_REUSEADDR选项</strong> :<br>在服务器程序中，SO_REUSEADDR socket 选项通常在调用bind()之前被设置。<br>SO_REUSEADDR可以用在以下四种情况下： (摘自《Unix网络编程》卷一，即UNPv1)</p>
<ul>
<li>当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项</li>
<li>SO_REUSEADDR允许同一端口上启动同一服务器的多个实例(多个进程), 但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。 </li>
<li>SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。 </li>
<li>SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li>
</ul>
<p><strong>SO_LINGER选项</strong> :<br>linger，顾名思义是延迟延缓的意思，这里是延缓面向连接的socket的close操作。<br>默认，close立即返回，但是当发送缓冲区中还有一部分数据的时候， 系统将会尝试将数据发送给对端, SO_LINGER可以改变close的行为.<br>控制SO_LINGER通过下面一个结构：</p>
<pre><code class="C++">struct linger
{
      int l_onoff; /*0=off, nonzero=on*/
      int l_linger; /*linger time, POSIX specifies units as seconds*/
};
</code></pre>
<p>通过结构体中成员的不同赋值，可以表现为下面几种情况：</p>
<ol>
<li>l_onoff设置为0，选项被关闭。l_linger值被忽略，就是上面的默认情形，close立即返回。</li>
<li>l_onoff设置为非0，l_linger被设置为0，则close()不被阻塞立即执行，丢弃socket发送缓冲区中的数据，并向对端发送一个RST报文。<br> 这种关闭方式称为“强制”或“失效”关闭。</li>
<li>l_onoff设置为非0，l_linger被设置为非0，则close()调用阻塞进程，直到所剩数据发送完毕或超时。<br> 这种关闭称为“优雅的”关闭。</li>
</ol>
<p>注意： 这个选项需要谨慎使用，尤其是强制式关闭，会丢失服务器发给客户端的最后一部分数据。UNP中:</p>
<blockquote>
<p>The TIME_WAIT state is our friend and is there to help us(i.e., to let the old duplicate segments expire in the network).</p>
</blockquote>
<p><strong>SO_KEEPALIVE选项</strong> :<br>通常这个选型关联: SO_KEEPALIVE, TCP_KEEPCNT, TCP_KEEPIDLE, TCP_KEEPINTVL</p>
<p>如果一方已经关闭或异常终止连接，而另一方却不知道，我们将这样的TCP连接称为半打开的, TCP通过保活定时器(KeepAlive)来检测半打开连接.</p>
<p>在高并发的网络服务器中，经常会出现漏掉socket的情况，对应的结果有一种情况就是出现大量的CLOSE_WAIT状态的连接(确认对端已经关闭了).<br>这个时候，可以通过设置 KEEPALIVE 选项来解决这个问题，当然还有其他的方法可以解决这个问题.</p>
<p>使用方法如下：</p>
<pre><code class="C++">//Setting For KeepAlive
int keepalive = 1;
setsockopt(incomingsock,SOL_SOCKET,SO_KEEPALIVE,(void*)(&amp;keepalive),(socklen_t)sizeof(keepalive));
int keepalive_time = 30;
setsockopt(incomingsock, IPPROTO_TCP, TCP_KEEPIDLE,(void*)(&amp;keepalive_time),(socklen_t)sizeof(keepalive_time));
int keepalive_intvl = 3;
setsockopt(incomingsock, IPPROTO_TCP, TCP_KEEPINTVL,(void*)(&amp;keepalive_intvl),(socklen_t)sizeof(keepalive_intvl));
int keepalive_probes= 3;
setsockopt(incomingsock, IPPROTO_TCP, TCP_KEEPCNT,(void*)(&amp;keepalive_probes),(socklen_t)sizeof(keepalive_probes));
</code></pre>
<p>设置<code>SO_KEEPALIVE</code>选项来开启KEEPALIVE，然后通过<code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code>和<code>TCP_KEEPCNT</code>设置keepalive的开始时间、间隔、次数等参数。</p>
<p>当然，也可以通过设置 <code>/proc/sys/net/ipv4/tcp_keepalive_time</code>、<code>tcp_keepalive_intvl</code>和<code>tcp_keepalive_probes</code>等内核参数来达到目的，<br>但是这样的话，会影响所有的socket，因此建议使用setsockopt设置。</p>
<h2 id="心跳保活"><a href="#心跳保活" class="headerlink" title="心跳保活"></a>心跳保活</h2><p>有TCP侧的保活机制, 又有应用侧的保活机制, 但是他们的侧重不同.</p>
<h3 id="TCP保活"><a href="#TCP保活" class="headerlink" title="TCP保活"></a>TCP保活</h3><p>检测连接是否可用, 是否还有数据继续发送.</p>
<p>tcp的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方断掉的时候，没有断掉的定时发送几次心跳包，<br>如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。<br>设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。<br>那么这对服务器资源的影响是很大的。</p>
<p>tcp的keepalive就是为了检测链接的可用性。主要调节的参数有三个：</p>
<pre><code>tcp_keepalive_time // 距离上次传送数据多少时间未收到判断为开始检测
tcp_keepalive_intvl // 检测开始每多少时间发送心跳包
tcp_keepalive_probes // 发送几次心跳包对方未响应则close连接
</code></pre><p>默认设定是:<br>当tcp发现有<code>tcp_keepalive_time</code>(7200)秒未收到对端数据后，开始以间隔<code>tcp_keepalive_intvl</code>(75)秒的频率发送的空心跳包，<br>如果连续<code>tcp_keepalive_probes</code>(9)次以上(实际上是10次)未响应代码对端已经down了，close连接.</p>
<p>运行流程：<br>在客户端和服务端进行完三次握手之后，客户端和服务端都处在ESTABLISH状态，这个时候进行正常的PSH和ACK交互，但是一旦一方服务中断了，<br>另一方在距离上次PSH时间tcp_keepalive_time发现对方未发送数据，则开始心跳检测。<br>心跳检测实际就是发送一个PSH的空心跳包，这里说的空心跳包就是包的数据为空，但是TCP包的头部的数据和标识和正常包一样。<br>如果这个包获取到的是RST返回的话，下面就会继续每隔tcp_keepalive_intval的时长发送一个空心跳包，如果tcp_keepalive_probes次心跳包对方都是返回RST而不是ACK，<br>则心跳发起方就判断这个连接已经失效，主动CLOST这个连接。</p>
<p>如果是对方服务器进行重启的时候，我们<strong>不能根据一次的tcp返回重置信号就判定这个连接失效</strong>:</p>
<ul>
<li>连接一方服务中止</li>
<li>网络不好导致的服务长时间无响应</li>
<li>连接一方服务重启中</li>
</ul>
<p>相反的，重启之后，这个心跳包一旦正常，这个连接仍然可以继续使用。</p>
<p>如果要单独设定每个TCP连接的参数, 可以使用<code>setsockopt</code>函数:</p>
<pre><code class="C++">int setsockopt(int s, int level, int optname,  
                 const void *optval, socklen_t optlen);
</code></pre>
<p>具体代码控制如下:</p>
<pre><code class="C++">opt = 1;  
setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;opt, sizeof(opt));
opt = 1000;  
setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;opt, sizeof(opt));  //tcp_keepalive_time  
opt = 10;  
setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;opt, sizeof(opt));  //tcp_keepalive_intvl  
opt = 10;  
setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;opt, sizeof(opt));  //tcp_keepalive_probes
</code></pre>
<p><strong>代码中如何判断TCP连接是否断开?</strong><br>当tcp检测到对端socket不再可用时(不能发出探测包,或探测包没有收到ACK的响应包),select会返回socket可读(不可写),并且在recv时返回-1,同时置上errno为ETIMEDOUT。</p>
<h3 id="HTTP保活"><a href="#HTTP保活" class="headerlink" title="HTTP保活"></a>HTTP保活</h3><p>HTTP的保活主要是重用连接, 而不用反复三次握手, 四次分手. (可以简单的认为HTTP保活, 就是要利用长连接)</p>
<p>普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。<br>下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。<br>但是一旦客户端发送<code>connection:keep-alive</code>头给服务端，且服务端也接受这个<code>keep-alive</code>的话，两边对上暗号，这个连接就可以复用了，<br>一个http处理完之后，另外一个http数据直接从这个连接走了。</p>
<p><strong>http层的keep-alive, 它主要是用于客户端告诉服务端，这个连接我还会继续使用，在使用完之后不要关闭</strong></p>
<p>区分一下长短连接:</p>
<ul>
<li>短连接， 就是每次请求一个资源就建立连接，请求完成后连接立马关闭。每次请求都经过“创建tcp连接-&gt;请求资源-&gt;响应资源-&gt;释放连接”这样的过程</li>
<li>长连接， 就是只建立一次连接，多次资源请求都复用该连接，完成后关闭。要请求一个页面上的十张图，只需要建立一次tcp连接，然后依次请求十张图，等待资源响应，释放连接。</li>
</ul>
<p>具体client和server要从短连接到长连接最简单演变需要做如下改进:</p>
<ul>
<li>client发出的HTTP请求头需要增加Connection:keep-alive字段</li>
<li>Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且”应允”client我暂时不会关闭socket连接</li>
</ul>
<p>在HTTP/1.0里，为了实现client到web-server能支持长连接，必须在HTTP请求头里显示指定Connection:keep-alive<br>在HTTP/1.1里，就默认是开启了keep-alive，要关闭keep-alive需要在HTTP请求头里显示指定Connection:close<br>现在大多数浏览器都默认是使用HTTP/1.1，所以keep-alive都是默认打开的。一旦client和server达成协议，那么长连接就建立好了。</p>
<p>少了TCP的三次握手和四次挥手，第二次传递数据就可以通过前一个连接直接进行数据交互了。</p>
<p><strong>联系TIME_WAIT</strong></p>
<p>由于HTTP服务的发起方一般都是浏览器，即客户端。但是先执行完逻辑，传输完数据的一定是服务端。那么一旦没有keep-alive机制，服务端在传送完数据之后会率先发起连接断开的操作。由于TCP的四次挥手机制，先发起连接断开的一方会在连接断开之后进入到TIME_WAIT的状态达到2MSL之久。设想，如果没有开启HTTP的keep-alive，那么这个TIME_WAIT就会留在服务端，由于服务端资源是非常有限的，我们当然倾向于服务端不会同一时间hold住过多的连接，这种TIME_WAIT的状态应该尽量在客户端保持。那么这个http的keep-alive机制就起到非常重要的作用了。</p>
<p>基于重用,性能和TIME_WAIT等原因, 现在浏览器发起web请求, 一般都会带上connection:keep-alive的头.</p>
<h3 id="应用保活"><a href="#应用保活" class="headerlink" title="应用保活"></a>应用保活</h3><p>KeepAlive仅用于检测连接的死活，而应用层心跳机制还有一个目的是检测简练的存活状态。<br>考虑一个场景：当某台服务器处理负载过高，CPU利用率100%，无法处理任何业务请求，在这种情况下，TCP探针仍然确认对方可用，<br>而实际上，服务器已经不能处理任何请求了，这种情况下应该断开当前连接，重新建立连接，而不是认为服务器仍然可用。</p>
<p>因此，从这个角度出发，应用层心跳机制也是必然需要的。</p>
<p>另外, 应用层的心跳机制, 基本和HTTPS一致的要求需要<code>长连接</code>.</p>
<p>对于客户端而言，保持长连接的长连接的有效性可以使得每次请求都只是简单的数据发送和接受，而不必要每次重新建立一个连接，重新解析DNS，<br>省去连接建立的时间，加快了于服务器之间的通信速度，有利于接收服务器的实时消息，前提都是连接必须可用。</p>
<p>对于服务器而言，保持连接的有效性可以让服务器降低负载，及时清除无效的连接。</p>
<p><strong>最简单的实现</strong></p>
<p>定时心跳.</p>
<p>例如:<br>由登录端每隔5秒向消息服务器发送心跳信息，如果30秒内没有收到消息服务器的相应，则关闭当前连接；<br>服务器每隔60s向移动端或者PC端发送定时心跳，60s没收到对端相应，则关闭当前连接。<br>(重发心跳保活指令，心跳超时时间为5S; 最长尝试时间为30秒和60s; 服务器还是客户端发送并不重要)</p>
<p>其实需要应用层检测, 更主要的原因是可以更好的判断服务器状态, 以此给出是否保持或者断开连接.</p>
<blockquote>
<p>现在的很多框架, 系统都已经提供了相关的API, 定时器等, 实现起来也比较容易.</p>
</blockquote>
<p>实际上很多时候, 往往是UDP协议的应用才需要专门这么做.<br>虽然TCP本身的包头要比UDP多，但是<strong>UDP在实际应用中往往需要维护双向通道</strong>，就必须要通过大量的心跳包数据来维护端口资源。<br>总的比较起来，UDP的实际流量要比TCP还要大。很多使用者在初期的时候并不了解UDP需要大量心跳包来维持端口资源这个问题，往往都认为UDP要比TCP更节省流量，实际上这里存在着一个误区。<br>在某些特定的应用场合，例如一些银行的时时交互系统，对响应速度要求很高，此时数据传输频率较快，不需要大量心跳包维持UDP端口资源，采用UDP就比较有利了。</p>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>这篇文章会一直更新, 直到哪一天我不再在一线编码了, 希望能给看到的人提供一些帮助.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="external">知乎大神们对restful的看法</a></li>
<li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">http状态码大全</a></li>
</ol>
<hr>
<p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>

        </div>

<!-下面是评论模块 ->
        <div class="post-reply">
            
            
        </div>

		<!-- 下面是版权声明模块-->
        
<div id="copyright" class="content blockquote">
  <blockquote>
	<span><b>版权声明</b>：本文采用<b>署名(BY)</b>-<b>非商业性使用(NC)</b>-<b>相同方式共享(SA)</b>许可协议授权,转载请注明作者及出处</span><br/>
	<span><b>本文作者</b>：<a href="/" target="_blank" title="Merlin Yu">Merlin Yu</a></span><br/>
	<span><b>本文标题</b>：里程碑1(Linux后台开发经验分享)</span><br/>
	<span><b>本文链接</b>：www.merlinblog.site/2017/08/30/milestone1.html</span>

  </blockquote>
</div>


    </div>
</section>

 



<script type="text/javascript">
    // 获取第一张图, 用以当封面背景图
    var img = document.querySelectorAll('img')[1]

    if (img) {
        var header_box = document.querySelector('#header_box')
        header_box.style.backgroundImage = 'url('+ img.src +')'
    }
</script>


<!-- for code block highlight --> 
<!-- theme.block_highlight -->
<!-- we do not guarantee the char sequences spell right, usr himself do it -->
<link rel="stylesheet" href="/css/highlight_rainbow.css">
<script src="/js/highlight.min.js"></script>
<script type="text/javascript"> hljs.initHighlightingOnLoad();</script>
  

<!--设置内部长度 -->                
<script type="text/javascript"> 

 $('code').attr('style', 'overflow:auto; font-size:18px; margin-left:2px; margin-right:2px;');

 
</script>






      </div>
  </div>

  <style>
  #footer {
    min-height: 10vh;
    background: black;
    color: #fff;
  }

  #footer a {
    color: #e1e1e1;
  }
</style>
<footer id="footer" class="has-text-centered is-flex center">
  <div class="container has-padding">
    <div>
      <div>
        <!--请您保留作者署名, 主题制作来之不易-->
        Copyright © <b><a href="#">Merlin Yu</a></b> 2017
        <br>
        Themed by <a href="http://haojen.github.io/">Haojen Ma</a>
		<br>
		Articles of this site licensed under <b>CC BY SA 4.0<b>
        
      </div>
    </div>
  </div>
</footer>

<script src="/js/search_core.js"></script>
<script src="/js/script.js"></script>

</body>
</html>

