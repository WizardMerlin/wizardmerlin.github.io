<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Merlin&#39;s Blog</title>
  
  <subtitle>Alfred, I did find someone..</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.merlinblog.site/"/>
  <updated>2017-11-05T15:07:51.000Z</updated>
  <id>www.merlinblog.site/</id>
  
  <author>
    <name>Merlin Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>思考算法系列汇总</title>
    <link href="www.merlinblog.site/2017/11/05/mastering-algorithm-all.html"/>
    <id>www.merlinblog.site/2017/11/05/mastering-algorithm-all.html</id>
    <published>2017-11-05T06:47:32.000Z</published>
    <updated>2017-11-05T15:07:51.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://omotkhw3y.bkt.clouddn.com/algorithm0.jpg" alt="post-cover"></p><blockquote><p>老板, 小炒一盘算法, 不要放葱呀</p></blockquote><p><strong>应该说是非常偶然的机会吧, 我发现了算法的乐趣.</strong> </p><p>我其实是<code>非常享受和面试官交流的过程</code>, 首先</p><ul><li>短时间内(时间限制)</li><li>没有计算机给你跑一下结果看看(材料限制)</li></ul><p>你的大脑要飞速运转, 把<code>以往学过的知识</code>, 以及当前脑子里汇聚和生产出来的(<code>反应和思维能力</code>), 拿来解决碰到的问题, 是不是很刺激, 很有趣.<br>(就像打游戏一样, 不仅需要想着赢的策略, 还要手速操作)</p><p>但是我通常不跟别人在面试的时候扯太多的东西, 而尽可能谈工作需要的技能和态度(然而面试官貌似喜欢开拓) :</p><ol><li>一方面我工作经验有限, 有些东西我知道, 但是不够深入, 说出来没有太多可说的(说不透, 也说不出太多思考).</li><li>其次, 有些东西, 我熟悉的, 说的太深&amp;太多, 我技术面试官可能很满意, 但是HR的薪资恐怕上限都兜不住.</li></ol><p>真的, 这绝对不是开玩笑, 已经有三次案例了.<br>(如果一件事儿, 做了没有收入, 而且没有<strong>意义</strong>, 那么去做就是非常愚蠢的, 不管出于什么目的)</p><p><code>爱好当然属于意义</code>啦. 我也希望, 如果有同样爱好者, 或者前辈看到这篇文章, 能够邮件我, 指导一下我. 感谢.</p><hr><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>为什么会有这么一篇文章?</p><p>最近在面试的时候, 多次有前辈&amp;主管面试的时候, 都会考验我的分析和思维能力, 当然我个人也是欢迎的.<br>一方面我对自己的分析和思维能力有信心, <strong>其次这也是一种锻炼</strong>, 我来面试不仅仅是来找一份工作, 我同时也是来长见识的.</p><p><em>不同的公司&amp;环境, 人员的水平, 也是考量的范围; 毕竟水平相差太远的人, 在一起共事, 也非常尴尬.</em></p><p>面试官最喜欢问题的问题是:</p><blockquote><p><code>还有更好的方法么?</code></p></blockquote><p>当然有的面试官的观点是, 有时候能实现了再说, 至于优化, 以后再说. (happen before perfect) 我个人是赞同这种观点的.</p><p>但是, 现在毕竟是在面试, 我会尝试着, 尽自己最大的智力水平去思考改良和替代方案.<br>因为这其实是一个很好的自我测试手段:</p><ul><li>测试思维的开拓程度 &amp; 思维能力 &amp; 甚至是创新能力</li><li>脑子里有多少知识储备, 有没有完善的知识组织架构</li><li>手里有多少可用的工具(有多少已有积累)</li></ul><p>其次, 不光面试, <strong>因为研究算法, 对于人的思维的训练是非常好的</strong>. 再者, 我们毕竟都是程序员, 保持高水准的思维能力不是什么坏事情.</p><p>后期(工作稳定之后), 我打算做两件事儿:</p><ul><li>成立算法&amp;策略研究小分队 (如果已经存在这样的开源组织, 我就加入)</li><li>每周一个leecode题解 (多个人给出不同的优化方法, 然后周六晚上讨论一下, 或者当场profile对比一下)</li></ul><p>我希望营造一个健康的, 没有利益纠纷的开源小组. 目的纯碎, 当然也是为了能找到更多志同道合的朋友.</p><hr><h1 id="基础算法思考"><a href="#基础算法思考" class="headerlink" title="基础算法思考"></a>基础算法思考</h1><p>这里是我对于基础算法的思考和整理, 当然, 我们已经不是学生了, 有很多问题, 比如0-1背包问题, 8皇后问题等, 已经不再是研究范围了,<br>当然也能说, <code>当前集中说的是算法思维</code>, 以及日常工作中遇到的一些应用.</p><p>主要就是基础算法, 详细内容, 已经单独成篇, 请参考, 下面的列表: btw: 暂且只提供<code>c/c++实现</code>, java或者python, 后期再补上.</p><blockquote><p>因为都是很<code>基础的东西</code>, 我写的很快, 并且思考也很快; </p></blockquote><p>1.<a href="">基础算法之思考排序</a>       2017/11/5 晚上<br>2.<a href="">基础算法之思考查找</a>       2017/11/5 晚上<br>3.<a href="">基础算法之思考贪心</a>       2017/11/5 晚上<br>4.<a href="">基础算法之思考动态规划</a>   2017/11/5 晚上</p><p>好; 先停一下, 要去写一写数据结构了, 就像一部好车, 它的性能极限还是<code>受限于物理结构</code>(这么说其实是不准确的, 但是80%的情况是这样的)<br>比如, 底盘, 变速箱, 发动机; 而算法走到一定程度, 也取决于所采用的物理存储结构.</p><p>那就是<code>数据结构</code>, 先停一下, 我去把数据结构, 给搞一波. (<code>写代码, 思考不是很有趣么?</code>) 具体参考: <a href="">思考数据结构汇总</a></p><p>最后, <strong>如果你的工作是主搞算法, 那么没有任何一个人会原谅你写出来的算法复杂是O(n^2)的.</strong>因为研究算法</p><p>所以啊, <code>来一盘算法啊</code>!</p><hr><h1 id="特殊领域算法"><a href="#特殊领域算法" class="headerlink" title="特殊领域算法"></a>特殊领域算法</h1><p>其实有些专业的科学和研究领域的算法, 我估计还没有这个能力;<br><strong>可能需要顶级或者至少是科学家级别的人, 才能去发明的.</strong></p><p>根据各自所在的领域不同, 再来完善和补充: </p><ul><li>大数据算法</li><li>随机算法</li><li>哈希算法</li><li>压缩算法</li><li>加密算法</li><li>策略算法</li><li>模式识别算法</li><li>神经网络算法</li></ul><p>等等</p><p>(当然有些算法是要钱的, 只在线下讨论, 不公开; 比如一些交易的策略算法)</p><hr><h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><ol><li>《啊哈算法》 啊哈磊, 入门书, 有趣, 简单.</li><li>《编程之法, 面试和算法心得》 July</li><li>《算法最优解》 左程云</li><li>《算法神探》 啊哈磊 李嘉浩 译</li><li>《算法精解-C语言描述》 机械工业出版社</li></ol><p>在算法方法, <code>July</code>, <code>左程云</code>, <code>啊哈磊</code>, 真的不愧为大神, 或者领跑者.<br>多的不说, 你可以参考他的博客或者网站(虽然他博客有些东西没有说清楚, 但是你看他写的书, 还是有水平的)</p><p>第5本也是我经常参考的, 不过我以前用它太过关注于具体的语言实现, 而忘记了去思考算法本身的思想以及运用.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      只是因为在人群中多看了你一眼. 其实是, 思考算法汇总篇.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="算法" scheme="www.merlinblog.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>你说红黑树?</title>
    <link href="www.merlinblog.site/2017/11/04/ur-tree.html"/>
    <id>www.merlinblog.site/2017/11/04/ur-tree.html</id>
    <published>2017-11-04T15:25:36.000Z</published>
    <updated>2017-11-04T13:35:48.555Z</updated>
    
    <content type="html"><![CDATA[<p>本文初稿 2017-07-28, 再面试过程中进行了更新:</p><blockquote><p>真的是没有想到, 社招的时候也会问到这些最基本的东西…那, <code>客户的需求永远是第一位的</code>.</p><p>STL中set, map, 网络中 epoll 等好多地方都会使用 RB tree, 以前校招也曾经手写红黑树. 毫无压力.<br>但是工作久了(工作中基本都是直接用STL了), 该忘记的差不多都忘记了.</p></blockquote><p>本文就一口气把<strong>所有的树</strong>说一遍, 权做复习面试了.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/rbtree.jpg" alt="post-cover"></p><p>但是我已经不是刚毕业了, 我对数据结构也有一些简单的自己的思考, 先写在前面</p><ul><li><strong>上学的时候</strong>, 我们学习数据结构, 会去思考它的逻辑结构, 构成, 物理结构存储, 比如说树中如何存储他的父节点, 它的子节点</li><li><strong>工作之后</strong>, 基本不会让你去实现, 一来一个库需要经历大量的检测和实践才可以放到生产环境中商用; 其次现在轮子已经很多了.<br>更重要的是, 我们现在关注的点是, 该数据结构的<code>物理结构带来了哪些特性和适用性</code>,<br>比如物理内存受限的环境, 或者对查询效率要求非常高, 需要用哪写结构<br>至于它是怎么保证它为何有如此高效的效率, 能说明白和指出来就够了(一般不会让你去实现, 职业搞算法的同学例外)</li></ul><h1 id="强调"><a href="#强调" class="headerlink" title="强调"></a>强调</h1><p><strong>这些东西比较严禁, 最好是去找本专业的参考书</strong> (但是参考书理论偏多, 实际应用方面则论述不足) </p><ul><li>比如说<code>算法导论</code></li><li>比如说 清华大学老师实现的<code>C++版的数据结构与算法</code>, 具体可以见参考部分.</li></ul><p>如果网友的博客, 算法或者数据结构部分没有写明参考资料或者书籍, 最好不要去看他写的, 因为印刷出来的, 一般都比网络上的博文可靠.<br>(当然, 本文的目的, 帮助我记录成长, 也是给你一个参考, 帮助你理解, 但是不能代替你思考)</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>我是不太知道面试的时候, 不同的公司会考什么样的树的, 但是我知道大公司是一定要的, 小公司未必, 但是<strong>如果招聘的是核心开发者, 应该也会问到的</strong>.</p><p>本文主要涉及:</p><ul><li>AVL tree</li><li>RB tree</li><li>B+ tree</li><li>trie tree</li></ul><blockquote><p>本文一般简单说完概念之后, 解析其设计精妙之处, 然后给予C++实现. (不会扯太多理论)</p></blockquote><h1 id="详述"><a href="#详述" class="headerlink" title="详述"></a>详述</h1><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1.《算法导论》第三版 机械工业出版社 (晦涩, 深入, 完美)<br>2.《数据结构与算法分析新视角》 中国工信出版集团 &amp; 电子工业出版社  (清晰, 简单, 方便理解)<br>3.《数据结构(C++语言版)带习题解析第三版》邓俊辉 清华大学出版社 (主要参考, 写的比较完善)<br>4.《数据结构,算法与应用 C++语言描述》 Sartaj Sahni 美 (这是我上学时代用的书, 简单易懂; 罗里吧嗦)</p><p>我<strong>个人推荐</strong>, 专业搞算法的同学参考1, 其他码农参考3.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      二叉树, 平衡二叉树, 二叉查找树; 我赶时间, 你们一起都上吧(笑)
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="算法" scheme="www.merlinblog.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>全面经</title>
    <link href="www.merlinblog.site/2017/11/04/all-interview.html"/>
    <id>www.merlinblog.site/2017/11/04/all-interview.html</id>
    <published>2017-11-04T13:40:19.000Z</published>
    <updated>2017-11-04T14:34:44.051Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>正好周末, 我对于一些过去的心态啊准备啊, 以及未来真正的想做的事儿, 做了全面而深入的思考.</p></blockquote><hr><h1 id="我的反思"><a href="#我的反思" class="headerlink" title="我的反思"></a>我的反思</h1><p>我问了自己这样几个问题?</p><ul><li>是否随便一家公司给钱你就愿意过去干? 你是这样的人么?</li><li>你明白自己的价值和定位么?</li><li>你是不是一个可以讨价还价的人?</li><li>你自己觉得自己实力和别人觉得你实力究竟相差多少?</li></ul><p>答案是显而易见的, 虽然现在不是招聘旺季(11月初), 但是并不意味着我需要或者可以违背自己的原则做事情. 正确评估自己的市场价值的同时, 也要据理力争.</p><blockquote><p>别人什么情况下不会跟你讨价还价, 你想清楚了么?</p></blockquote><p>笑. 被拒绝不可怕, 因为有些环境就是不适合你的, 他们挑选你的时候, 其实你也在挑选他.<br>(除非你是真的水平很差, 别人用你也是将就着用, 你也是将就这去工作; 两边儿不欢快, 何必呢?)</p><blockquote><p><code>It&#39;s just that nobody likes people who stay where they don&#39;t belong</code>.</p></blockquote><p>顺其自然(let it be), 但不违背原则: do one thing, do it well.</p><p>其实<code>关键还是看, 你到底是个认真&amp;较真的人还是个稀里糊涂就能过的人</code>.<br> <strong>每个人都应该为自己的人生负责</strong>, 你说呢?</p><hr><h1 id="给HR或招聘主管"><a href="#给HR或招聘主管" class="headerlink" title="给HR或招聘主管"></a>给HR或招聘主管</h1><p>To <strong>之后看到本文的</strong> <code>招聘主管</code>, <code>HR姐姐</code> : (首先感谢你们严谨的态度, 来调查我)</p><ul><li>首先, 请相信我对于应聘过的公司的评价是很客观的, 至少我实地考察和交流过了 (当然出于道德和保护等原因, 不会透露公司的名字)</li><li>其次, 我去面试都是带着足够的诚意和尊重的 (不要认为我敷衍啥的…汗~)</li><li>最后, 无论最后有没有一起共事, 我都希望有一个愉快的碰面或者交流, 顺便在业界可以多认识一个朋友.</li><li>最后的最后, 如果您给了我offer, 但是我没有回应, 那一定是在仔细考虑(我不喜欢换工作, 慎重地选择好的就一定会坚持到底, 同事资源也会特别珍惜), 请给予我一些时间考虑(感激)</li></ul><p>当然技术方面, 如果您不放心, <strong>plz test me as u like</strong>. (当然, 知之为知之不知为不知; 瞎说就是打脸, 没有必要, 我也不会那么<strong>没趣</strong>)<br>(请不要问一些隐私的问题, 我想我会拒绝回答您; <strong>如果我有言语上的措辞不当, 也请您一定一定一定, 给我一些反馈, 感激</strong>)</p><p>补充:</p><blockquote><p>I do not wanna a job or occupation, I choice a way of life and I chose my own career or furture.</p></blockquote><p><strong>翻译</strong>: 我的<code>每次投递都是精心调研过的单位</code>, 不会乱投递; 其次, 我想找一家有潜力的, 接下来能工作5-7年的单位, 和能长期共事的战友.</p><p><strong>别误会, 我只是对我的人生负责.(笑)</strong></p><p>当然, <strong>如果您(技术前辈, 大佬)认为我是个可以培养的人才, 请务必给我这个机会, 感谢.(伏地, 叩首)</strong></p><p>btw: 以前面试过的技术同行, 如果有啥需要交流的, 可以发邮件给我.</p><ul><li>技术交流 : <code>wizardmerlin945@gmail.com</code> </li><li>招聘专用 : <code>yuyankai945@hotmail.com</code></li></ul><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><p>我<code>先把内容记录在本子上</code>, 后期整理之后, 上传.</p><blockquote><p>并且, 我是想找一家, 可以待上&amp;为之<code>效力5-7年的单位</code>, 所以过程可能有点儿长, 但一定会完整上传的</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/interview1.jpg" alt=""></p><p>这一本大概有300多页 (妹子送我的速写本&amp;绘画本), 正反加起来大概可以写600多页, 足够了.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      面试经验呀
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="面试" scheme="www.merlinblog.site/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>第一次被拒</title>
    <link href="www.merlinblog.site/2017/11/02/interview-experience.html"/>
    <id>www.merlinblog.site/2017/11/02/interview-experience.html</id>
    <published>2017-11-02T15:45:23.000Z</published>
    <updated>2017-11-04T13:46:03.699Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文只记录第一次面试被拒, 以及一些粗浅的心得体会和记录.</p></blockquote><p>如果想看面经, 请参考另外一篇文章 <a href="http://www.merlinblog.site/2017/11/04/all-interview.html">全面经</a></p><hr><h1 id="写作原因"><a href="#写作原因" class="headerlink" title="写作原因"></a>写作原因</h1><p><strong>为什么会写这篇文章?</strong>.</p><p>说实话, 关于面试, 我没有想到, 我需要去写这篇文章, 真的. 主要是昨天的<code>碰壁</code>, 招聘第一次被拒了…是的, <strong>被拒</strong>了!!!(见下面反馈表)<br>OMG! (突然感觉, 现在同学叫我大神, 我都不好意思了…)<br><img src="http://omotkhw3y.bkt.clouddn.com/code-laughter1.jpg" alt=""></p><p>可能看到的人, 会有一些不解, 为什么面试碰壁了会惊讶, <code>这人就知道装逼, 可以让我打死他么?</code></p><p>首先, 我朋友圈里还是有一些人(研发经理&amp;主管&amp;架构师)可以给我内推的, 当然也有主管直接说了, “要过来的话, 和我打声招呼就行了”.<br>(但是我个人讨厌欠别人人情, 所以坚决不做这种事情, 就好像我讨厌在家的时候那些裙带关系一样; 其次和我选择的领域有关, 最好不要让他们插手)<br>好不容易, 爸妈死心了, 让我自己自己证明自己了, 回上海工作(第一天回上海, 第二天就受到面试邀请了), 第一次就碰壁了.  </p><p><strong>我就在想, 原来我这么差劲啊?</strong>… (其实不是, 见后文的分析)<br>以前呢, 有些公司和我的选择或者方向不太一致或者我个人嫌弃给的太少了, 不乐意去.</p><p>真没有想到, 我挑剔别人的时候, 别人也在挑剔我. <strong>但这些都不是重点</strong>, 重点是:</p><blockquote><p><strong>这些宝贵的反馈和建议, 对于我的个人成长, 意义重大!</strong></p></blockquote><p>所以呢, 我也从心底里非常<code>感谢</code>他们. (这些都是人生宝贵的经验)</p><hr><h1 id="第一次被拒"><a href="#第一次被拒" class="headerlink" title="第一次被拒"></a>第一次被拒</h1><blockquote><p>没有一次吧? 那好, 这就是第一次. 笑.</p></blockquote><p>永远的第一次啊: </p><ul><li>时间: 2017年11月1号, 礼拜三, 1:25~3:40 PM </li><li>地点: 上海市浦东新区金桥</li><li>人物: 我以及两位主管 </li></ul><p><code>反馈表</code>如下: (是按照我发给对方的反馈自评价表, 反馈给我的)</p><blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/review.jpg" alt="纪念"></p></blockquote><p>(<strong>一会儿,我在说这张表的评价问题, 心态? 心态当然没有崩呀, 笑</strong>)</p><p>首先我先没有自己总结, 而是把相关情况反馈给了我的老师(部门经理级别的人), 他的原话:</p><blockquote><p>“人家上面不是说了么? teamwork的问题.” (但是我当场聊的挺投机的呀?) </p></blockquote><p>当然认真的说, 老师是这么说的:</p><blockquote><p>“你工作年限不够, 如果是我招聘你这个工作年限的人, 都是希望去培养你的, 放低姿态吧.”<br>“对方也不是真的在说团队协作问题, 这个面试看不出来, 对方还是想压低你的薪水, 别在意”</p></blockquote><h2 id="老师的忠告"><a href="#老师的忠告" class="headerlink" title="老师的忠告"></a>老师的忠告</h2><p>之后老师是这样解释的:<br><strong>“技术能力只是一方面, 技术能力满足了, 我们还要考虑为人和性价比的问题;”</strong><br><strong>“我面试过的人, 有的甚至比我资格都老, 但是要价很高, 性价比就很一般;</strong><br><strong>“交流能力, 我老早就提醒你, 不要心高气傲的; 我建议你还是放低姿态, 这样的话, 你肯定很抢手的”</strong><br><strong>“小公司相比大公司的技术储备, 环境, 平台都没法比, 你可以适当的要要价, 我给你一个参考标准”</strong></p><p>其实<strong>沟通能力啥的, 我是不同意他们的评价</strong>的, 但是我态度和准备, 明显是不够的; 这个我虚心承认问题.<br><em>在学校里面我就带队, 后来到了公司, 我也时不时的有些技术分享, 交流能力有问题? 不存在的.</em></p><p>我是当事人, 我总结, 可能是<code>印象</code>或者<code>态度</code>丢了分(见下面总结).</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>鞋子合不合脚, 亲自试穿的人最清楚了呀</code> :</p><ul><li>印象部分<ul><li>技术团队的面试, 请一定一定一定, <code>不要穿正装</code>, 千万记住!!! 随和最好了. 为啥?<br>(因为我一进去, (公司也比较小, 还是租赁的办公室), 里面大家都是格子衬啥的, <strong>那时我就知道, 糟了!</strong>我装着笔直…)</li><li>注意说话音量, <code>不要影响到别人</code> (他们单位很小, 会议室就一个, 同事就在不远地方办公)</li><li>等待的时候, 不要东张西望, 玩手机啊啥的, 耐心一点 (我当时在吃巧克力…天哪~!好想去跳海)</li><li>出门, 记得<code>鞠躬或者握手</code>, 表示对占用别人时间的感谢和尊重</li><li>笔试, 要认真; (最好先问一下, 有没有笔试;<strong>我当时拿到面试题的时候, 我就知道我可能来错地方了, 完全是给应届生准备的</strong>)<br>如果有笔试部分, 先不要不屑, 先问一下能不能直接进入面试环节, 哪怕面试官当场让你写呢; 不行的话, 微笑接受就好了, 没啥.</li></ul></li><li>技术部分<ul><li>谦虚一点儿 (不管你有没有觉得自己很厉害, 很牛啥的, 请你记住, 你是来被测试的), 放低姿态就对了<br>“xxx部分, 那一块儿, <code>你随便问</code>“, <strong>这种话千万不要再说</strong>, 你可以说, <strong>“xxx部分, 我可能有一些心得, 您可以在这写方面测试我”</strong></li><li>技术大不过为人 (也就是你技术不行, 为人处世比较OK, 技术主管也会适当加分的)</li><li>不管你回答的如何好, 技术把关的人, 不会给你完美的评价的<br>基于两点来佐证这个论述:<ul><li>他们招聘是针对目前岗位而来, 所问的问题基本和岗位相关, 匹配; 不会故意刁难你或者把你问倒为目的</li><li>工作不满5年的人, 再强也强不到哪里去(天才除外啊, 可惜我不是)</li><li>技术的追求, 没有止境, 你知道的他未必知道, 也就是说, 他单方面的评价不能做到完全客观的(2/8原则嘛, 够了)</li></ul></li></ul></li></ul><p>其次, 我<strong>对公司的评价</strong>: (面试官面试我完毕, 我会有一张单独的表, 里面列了很专业的选项询问他们岗位和公司相关事宜)</p><ul><li>小公司<strong>人</strong>比较实在, 随性 (这一点其实就足够啦, 我目前就是瞅准小公司呀)</li><li>小公司<strong>基础设施</strong>以及环境一般(换句话说, 缺少极客氛围), 其他薪资制度不明(但是我肯定, HR和财务还没有独立)—这样是招不到胆子小的人的</li><li>小公司, <strong>薪水</strong>有限制;  (如果最后薪资实在不让我满意, 我还是考虑一线互联网公司算了)<br>绿豆对王八, 关键还是看对眼, 充分匹配; <code>为啥技术经理都对我技术过关的情况下, 还是毙了我?</code>(先不考虑人性因素)<br>可能像我老师说的, 他们是小团队, 生存问题是首要的, 给不了太多. 其次, <code>我还是没有足够强</code>, 至少强到他们无话可说.</li><li>小公司<strong>技术积累</strong>不行, 可能当前只是为了生存, 而不是真正的care带来的价值, <code>只想找个人填补岗位空缺</code> (私以为是这样)<br>我这么说不是没有根据的:<br>1.虽然我没有时间为面试做相关准备, 但是我基础是很扎实的, 换句话说, 我技术还是可以的, 但他们可能只是需要能干活(再培养)就好的<br>2.其次, 面试官问的问题, 专业度&amp;深度都不够(我有维护相关的群, 我知道群里大佬面试的时候, 会问怎么样深度的问题)</li><li>小公司<strong>招聘流程</strong>不规范<br>先不谈阿里的那些繁琐的步骤, 但是我以前社招面试的单位, 只要认可了我的简历, 直接进行面试环节(差不多2个小时左右, 可能还不到), 没有笔试的<br>(我的老东家, 招聘实习生的时候, 是先笔试一下的)—不过, 习惯就好了, 也没啥.</li></ul><p>当然这家公司, 整体的印象还是非常不错的, 我给予7分评价(10分满分), 典型的起步型公司.</p><p>最后, <strong>给那些和我一样, 想进小公司的同学一个警告</strong>:</p><ul><li>如果你只是因为大公司门槛高, 面试周期长, 流程复杂而选择小公司, 那么我建议你还是选择大公司, 因为有很多points, 你还没有想清楚.</li><li>如果你进入的是不知名互联网公司, 而是创业公司, 小公司, 那么你再跳到大公司是不容易的(不要跟我谈技术多牛啥的), <code>这个代价你想好</code>.<br>我太多同学在一线互联网公司了; 而且我的其中一个老师就在惠普做HR, 大公司的HR对学历, 工作经验的挑剔, 是存在的(可能还是普遍现象哦)</li><li>小公司不见得给的多的了多少, 你相信我, 小公司需要人不假, 但是薪资能力也是非常有限的. (给的少的, 真的没必要去了;你是在拿你的前途开玩笑)</li></ul><p>(我个人是考虑的非常清楚的, 家里父母也没有给我太多压力; 所以看到这里的同学, 最好衡量一下<code>机会成本</code>)</p><hr><h1 id="起航"><a href="#起航" class="headerlink" title="起航"></a>起航</h1><p> <strong>跌倒了, 不可怕; 可怕的是你因此而放弃了自己的原则, that’s really matters.</strong><br><strong>It’s just that nobody likes people who stay where they don’t belong. 所以, 心态平和, 顺气自然.</strong><br>(我当时问面试官的问题中, 其中有一个很关键的, 我是非常不满意的, 我先不说是啥问题; 但是从这个问题, 你就能明确发现, 你到底属不属于这个环境, 这个环境是不是适合你)</p><blockquote><p>群里大部分人和我交流的时候, 是问学这个有没有用, 那个有没有用, 很少有人深入询问某个领域的具体问题<br>所以如果你想做<code>Top 10%</code>, 那么你的经历一定会有一些不同寻常, 简单说, 你可能需要<code>经历更多, 付出更多, 还需要天分</code></p></blockquote><p>—当然这也是自我勉励的话.</p><p><strong>Never Mind</strong>, 修改修改简历, 仔细准备面试, 注意一下形象和态度.  希望5年后, 我也可以是一名 细分领域专家 .</p><p><em>(当然老师说的话也很对, 放低姿态, 技术只是一方面)</em></p><blockquote><p>起航, 再出发. 我还是那句话: <code>积极的人, 运气往往不会太差</code>.</p></blockquote><p>btw: 先调研, 实地考察一下公司, 毕竟我是想待5-7年的, <code>为事业, 而不仅仅是为了一份工作</code>.</p><h1 id="全面经"><a href="#全面经" class="headerlink" title="全面经"></a>全面经</h1><p>截稿的现在, 我已经准备和复习了哪些内容呢?<br>(不要觉得好low, 据我的体会, 就算我老师这样专业出身(工作10多年的人), 面试别人, 也会问一些很简单的问题)</p><p><img src="http://omotkhw3y.bkt.clouddn.com/test2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/test_1.jpg" alt=""><br>后面先不拍照.</p><p>(<code>后期会全部补齐</code>, <strong>希望能给看到本文的人, 带来些许帮助</strong>; 当然写作是我的爱好, 而已; 并不是为了为别人服务或者要打赏之类的, 太无聊了)</p><p>后面补齐, 专门有一篇文章, <a href="http://www.merlinblog.site/2017/11/04/all-interview.html">全面经</a></p><p>Merlin<br>2017/11/2 5:30 PM</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;本文只记录第一次面试被拒, 以及一些粗浅的心得体会和记录.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果想看面经, 请参考另外一篇文章 &lt;a href=&quot;http://www.merlinblog.site/2017/11/04/all-inte
      
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="面试" scheme="www.merlinblog.site/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>网络编程部分汇总</title>
    <link href="www.merlinblog.site/2017/10/13/network-base.html"/>
    <id>www.merlinblog.site/2017/10/13/network-base.html</id>
    <published>2017-10-13T04:18:43.000Z</published>
    <updated>2017-10-26T03:38:54.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记载一些网络基础知识, 但这些知识不是纯碎的理论研究, 而是为了后面<code>传输层</code>/<code>应用层</code>网络编程服务的.</p><blockquote><p>2017年10月更新了本文: <code>nagle算法</code> + <code>delayed ack算法</code> + <code>重新整理排版</code></p></blockquote></blockquote><p>该文是我写的<strong>网络编程</strong>的第一篇文章, 更新成为<code>网络最后一篇</code>, <strong>权当总结</strong>.</p><p>大致上已经整理了以下内容:(链接都是我站内的链接)</p><ul><li>网络理论基础部分 (本文)</li><li>基础套接字编程, <a href="http://www.merlinblog.site/2017/06/11/basic-socket-model.html">链接</a></li><li>本地套接字, <a href="http://www.merlinblog.site/2017/06/20/ipc-unix-domain-socket.html">链接</a></li><li>TCP 专题, <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">链接</a>, 以及 <a href="http://www.merlinblog.site/2017/06/19/sub-and-adhere-package.html">流解析(粘包问题)</a></li><li>UDP 专题, <a href="http://www.merlinblog.site/2017/06/19/udp-model.html">链接</a></li><li>IO 模型, <a href="http://www.merlinblog.site/2017/06/04/network-io.html">链接</a></li><li>Epoll专题, <a href="http://www.merlinblog.site/2017/06/13/why-not-epoll.html">链接</a></li><li>服务端模型演变, <a href="http://www.merlinblog.site/2017/06/19/server-side-model-again.html">链接</a></li><li>proto buffer 库, <a href="http://www.merlinblog.site/2017/08/21/protocol-buffer.html">链接</a></li><li>thrift 库, <a href="http://www.merlinblog.site/2017/08/22/thrift.html">链接</a></li><li>libevent 库, <a href="http://www.merlinblog.site/2017/07/29/libevent.html">链接</a></li><li>asio, <a href="http://www.merlinblog.site/2017/08/11/asio.html">链接</a></li><li>muduo, 陈硕大神的库, 值得研究学习, <a href="http://www.merlinblog.site/2017/07/29/deep-in-muduo-framework.html">链接</a></li><li>网络常用工具: nc, dd, tcpdump, ping, traceroute等, <a href="http://www.merlinblog.site/2017/08/23/net-work-tools.html">链接</a></li></ul><p>大部分知识来自于书籍(unp 1, unix高级编程, TCP/IP详解 以及 linux系统编程上下册), 腾讯后端的同学的交流, 我的一些个人思考, 最后靠谱网友的博客.</p><blockquote><p>这些整理记录了我的成长(完善知识体系), 也希望为看到的人带来帮助, 至少节约一些时间(<code>于我个人而言, 写作是一种乐趣</code>)</p></blockquote><p>补充上层协议: (2017/9月整理)</p><ul><li>http协议, <a href="http://www.merlinblog.site/2017/09/07/network-base-http.html">链接</a></li><li>https协议, <a href="http://www.merlinblog.site/2017/09/08/network-base-https.html">链接</a></li></ul><a id="more"></a><hr><p><img src="http://omotkhw3y.bkt.clouddn.com/net.jpg" alt="post-cover"></p><h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><p>分层: 只暴露应该关注的细节, 方便重用和解耦, 降低软件的复杂度. 例如一个应用层开发人员不需要关心底层也可以做好开发.<br>这里有两种模型, </p><ul><li>学术界的OSI模型</li><li>工业&amp;商业界的TCP/IP四层模型</li></ul><p>大致对比如下:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-7.png" alt=""></p><p>协议本身并没有太多分别, 只是大家的认可度不一样罢了,<br>试想你自己发明一套, 比如IP_MY协议, 大家都不遵守, 这种约定有何意义?<br>所以即便是都用于互联网, TCP/IP四层模型协议更被开发者所接受, OSI 7层模型只是带过.</p><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>OSI 模型中，网络被分为七层，由底层向高层依次是：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p><p><strong>物理层</strong> 处于 OSI 七层模型的最底端，它的主要任务是将比特流与电子信号进行转换。<br><strong>数据链路层</strong> 处于 OSI 七层模型的第二层，它定义了通过通信介质相互连接的设备之间，数据传输的规范。<br><strong>网络层</strong> 处于OSI参考模型的第三层网络层的主要作用是实现终端节点间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)<br><strong>传输层</strong> 处于 OSI 七层模型的第四层, 主要作用是实现应用程序之间的通信。<br><strong>会话层</strong> 处于 OSI 七层模型的第五层, 利用传输层提供的服务，使应用建立和维持会话，并能使会话获得同步。<br><strong>表示层</strong> 处于 OSI 七层模型的第六层, 表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。(字符集数据格式等处理)<br><strong>应用层</strong> 处于 OSI 七层模型的第七层, 这是最高层, 也是网络应用程序直接使用的协议, 它利用下层协议完成网络通信, 根据用途不同, 种类也不一样.</p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>为了实践编码方便, 理所应当采用了简化的四层模型, 即TCP/IP四层模型, 业界俗称为TCP/IP协议族.</p><p>下面也以规模性作为重点记录.</p><h2 id="各层要点-重要"><a href="#各层要点-重要" class="headerlink" title="各层要点(重要)"></a>各层要点(重要)</h2><p>TCP/IP协议族按照层次由上到下，层层包装:<br>最上面的是应用层，这里面有http，ftp, smtp, pop3, telnet等等我们熟悉的协议。<br>第二层则是传输层，著名的TCP和UDP协议就在这个层次。<br>第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。<br>第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-in.png" alt=""></p><p>TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。<br>出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。(以太网帧协议是加装头尾, 注意46-1500字节, 后面还会出现)</p><p>完整的以 <strong>HTTP</strong>为例子:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-in1.png" alt=""></p><p>各层主要涉及的协议:<br><img src="http://omotkhw3y.bkt.clouddn.com/networkbase11.png" alt=""></p><hr><h3 id="网络接口层"><a href="#网络接口层" class="headerlink" title="网络接口层"></a>网络接口层</h3><p>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。<br>数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer.png" alt=""></p><p>主要作为围绕 MAC 地址展开:</p><ul><li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</li><li>透明传输: 零比特填充、转义字符。</li><li>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</li><li>纠错处理: (CRC):接收者检测错误,如果发现差错，丢弃该帧。</li></ul><p>个人觉得, 一般谈到 网络接口层, 主要是2个概念再反复说:</p><ul><li>MAC 地址<br>MAC 地址是被烧录到网卡 ROM 中的一串数字，长度为 48 比特，它在世界范围内唯一(不考虑虚拟机自定义 MAC 地址)。由于 MAC 地址的唯一性，它可以被用来区分不同的节点，一旦指定了 MAC 地址，就不可能出现不知道往哪个设备传输数据的情况。</li><li><p>交换机转发原理(转发表)<br>交换机是一种在数据链路层工作的网络设备，它有多个端口，可以连接不同的设备。交换机根据每个帧中的目标 MAC 地址决定向哪个端口发送数据，此时它需要参考“转发表”<br>转发表并非手动设置，而是交换机自动学习得到的。当某个设备向交换机发送帧时，交换机将帧的源 MAC 地址和接口对应起来，作为一条记录添加到转发表中。</p><p><em>当然交换机还有其他作用, 就不多说了.</em></p></li></ul><p>交换机自学过程的原理(端口MAC联系过程):<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer3.png" alt=""></p><p>链路层一般就是用的<code>以太网帧</code>结构, 当前的intel就是基于以太网标准的.<br>当然以前还有<code>IEEE802标准</code>(简称802.3), 只不过现在很少能抓的到他的包(普通网络, 以及路由器之间的等等, 都是以太网帧). </p><p><strong>区别在哪里?</strong><br>帧的结构不同(源地址后面是类型字段的就是以太网帧结构, 表示帧的类型, 比如0800表示后面是ip(如果是封装IP的帧, 这里链路层的号码就是后面协议类型字段的值), 0806是arp;<br>如果是长度字段的就是802帧结构, 类型字段在别的地方), 换句话说, 标准不一样. 以太网标准要简单一些.</p><p>实际山, 从涉及MTU问题这里, 分组交换就已经涉及到了.<br>分组交换是指将较大的数据分割为若干个较小的数据，然后依次发送。使用分组交换的原因是不同的数据链路有各自的最大传输单元(MTU: Maximum Transmission Unit)。</p><p><strong>ARP及RARP协议</strong> :<br>(非重点, 我以前电脑中过arp病毒, 所以印象深刻)arp和rarp都是链路层的协议.<br>ARP (Address Resolution Protocol)是根据IP地址获取 MAC 地址的一种协议。(因为最终确定一台计算机的不是IP, 而是Mac地址, 硬件地址)<br>如果目标主机处在同一个数据链路上(本地网络)，那么可以直接得到目标主机的 MAC 地址，否则会得到下一条路由器的 MAC 地址。</p><p>ARP（地址解析）协议是一种解析协议，详细说明即: ARP 请求和 ARP 响应。<br>首先，源主机会通过广播发送一个 ARP 请求包：“我要与 IP 地址为 xxx 的主机通话，谁知道它的 MAC地址？”。<br>数据链路上的所有主机都会收到这条消息并检查自己的 IP 地址，如果与 ARP 请求包中的 IP 地址一致，主机就会发送 ARP 响应包：<br>“我就是 IP 地址为 xxx 的主机，我的 MAC 地址是：xxxx”。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-arp.png" alt=""></p><p>但是反复查询效率很低, 也是不推荐的做法; 通常的做法是把获取到的 MAC 地址缓存一段时间。<br>(一旦源主机向目标地址发送一个数据包，接下来继续发送多次的概率非常大，因此这种缓存非常容易命中)</p><p>当主机要发送一个IP包的时候，会首先查一下自己的<code>ARP高速缓存</code>（就是一个 IP-MAC 地址对应表缓存）。</p><blockquote><p>查看arp缓存(arp映射) : <code>arp -a</code>; 清理: <code>arp -d</code>. (路由器上你要清理的话, 它基本上马上就会去再解析, 除非把接口, 即端重新断开接上)</p></blockquote><p>如果查询的 IP－MAC 值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址.<br>如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的 MAC 地址的ARP包传送给发送ARP广播的主机。(即arp响应)<br>而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>当下一次发送 ARP 请求或超过一定时间后，缓存都会失效，这保证了即使 MAC 地址与 IP 地址的对应关系发生了变化，数据包依然能够被正确的发往目标地址。</p><p>总结:<br>表面上发送的时候, 看逻辑地址, 实际上发送的时候就会去确定该逻辑地址对应的物理地址(如果不是直连网络, 即不是同一数据链路, 会先进行IP的不断查找, 找到下一跳, 直到最终找到相应IP的地址, 再获取到物理地址(技术上是arp全子网广播, 然后相应IP的主机发送arp回应给最开始的发送者)); (arp缓存表是补充手段, 本质还是靠物理地址进行发送的), 确定物理地址之后, 才开始真正发包. 只知道IP并不能发送任何数据(看不到任何IP, TCP流量).</p><p><strong>代理arp</strong>:<br>一般路由器是默认就开启了代理arp功能的, 特别是对外进行<code>NAT转换的路由器</code>.<br>比如说你请求的一个互联网地址, 找到了相应的路由, 如果他没有开启代理arp功能, 那么你的arp广播就会被忽略.<br>因为只有你请求该路由的IP时才会返回给你mac地址, 而不会对一些对该路由控制的子网主机的arp请求的回应.<br><strong>其实是对子网的mac查询的支持</strong>, 不必具体找到子网内的具体主机再进行arp回应(外部看来, 找到该路由器或者防火墙就找了主机, 他们认为该路由的mac和该子网内的具体主机就是同一个).<br>(该机制也有弱点, 可以参考《路由交换 卷1》)</p><p><strong>自由(free)arp</strong>:<br>开机的时候, 自己给自己发送一个arp请求, 一般情况下不希望有人回应, 那么我就可以用这个ip地址, 但是如果有人回应, 那就坏了, 说明我当前正在使用的ip地址, 有人使用了.<br>这个时候往往就会报错, <code>duplicate addresss x.x.x.x</code>.<br>(其他主机收到这个包的时候, 也会尝试去更新本地的mac缓存信息, <code>arp -a</code>可以查看; 小心free arp攻击, 冲掉合法mac地址)</p><p>RARP协议的工作与此相反，不做赘述。</p><blockquote><p>只用IP是不行的, 只用Mac是非常低效的.</p></blockquote><p>其中用意个人体会吧, arp和rarp协议有其存在的必要性.</p><p><strong>MTU</strong><br>关于 MTU 争议很多, 具体可以见下面 <strong>MTU问题</strong>部分.</p><p>最后补充, 数据链路层协议工作在物理介质相互连接的端点之间, 范围有限, 所以需要IP, 逻辑地址来夸不同链路.</p><hr><h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>数据链路层的作用在于实现同一种数据链路下的包传递，而网络层则可以实现跨越不同数据链路的包传递。(也就是说, 从这一层才涉及跨网络)</p><p>这一层内容比较多, 但是主要谈IP协议相关, 其他顺带谈一下.</p><p>IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议: TCP或UDP要做的事情(ICMP也起到了异常通知的作用)。</p><p><strong>IP协议</strong> : (主要说<code>ipv4</code>, 因为ipv6也就我们中国再说, 看看世界上其他国家, 根本不鸟的, 题外话)</p><ul><li>地址部分</li><li>路由部分</li><li>分包重组部分</li><li>ip协议头(首部)</li></ul><p>IP协议的特点:</p><ul><li>不可靠: 比如路由器缓存满了, 它会丢掉包, 然后ICMP通知给源, 之后交由TCP保证重传之类的动作.</li><li>无连接: 不用建立会话连接才开始发送, 也不按照顺序发, 走的IP路径也不确定. (组装由TCP排序, 顺序不对的包一直被缓存, 它把数据捋顺)</li></ul><p>IP 查看就用 <code>ipcofig -all</code> 或者 <code>ifconfig</code>, 或者<code>netstat -ano</code>, 或者你要改ip地址:(linux下)</p><pre><code>ifconfig eth0 1.2.3.4 netmask 255.255.255.0</code></pre><p><strong>寻址部分</strong> :<br>IP地址是一种在网络层用于识别通信对端信息的地址。它有别于数据链路层中的MAC地址，后者用于标识同一链路下不同的计算机。<br>IP地址由32位正整数表示，为了直观的表示，我们把它分成4个部分，每个部分由8位整数组成，对应十进制的范围就是0-255。</p><p>比如<code>172.20.1.1</code>可以表示为：<code>10101100 00010100 00000001 00000001</code>。<br>转换规则很简单，就是分别把四个部分的十进制(0-255)与8位二进制数字进行转换。</p><p>IP地址由两部分组成：<code>网络标识</code>和<code>主机标识</code>。</p><ul><li>网络标识用于区分不同的网段，相同段内的主机必须拥有相同的网络表示，不同段内的主机不能拥有相同的网络标识</li><li>主机标识用于区分同一网段下不同的主机，它不能在同一网段内重复出现</li></ul><p>32位IP地址被分为两部分，<strong>到底前多少位是网络标识呢？</strong><br>一般有两种方法表示：<code>IP地址分类</code>、<code>子网掩码</code>(无类IP)。</p><p><strong>IP地址分类</strong> :<br>IP地址分为四个级别，分别为A类、B类、C类和D类。分类的依据是IP地址的前四位：</p><ul><li>A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个主机。</li><li>B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。</li><li>C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。</li><li>D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。</li></ul><p>简单记忆如下:<br>A类IP地址: 0.0.0.0~127.0.0.0<br>B类IP地址: 128.0.0.1~191.255.0.0<br>C类IP地址: 192.168.0.0~239.255.255.0</p><p>这类分类方法往往导致, 小网段不够, 大网段有余. 例如C类网段, 最多254台主机, 如果是255台怎么办? B类的上限是65534个, 明显浪费.<br>如果控制B类网址的上限数目? 因为B类网址, 说是以<code>10</code>开头, 前16位为网络号, 但是具体是多少真正在用就不一定了.</p><p>那么就<code>不对网络号规定位数?</code>, 但是这样就根本没有办法解析IP地址了, 因为不知道前多少位是网络号, 此时就演变出了<code>子网掩码</code>, 用子网掩码来解释子网占了多少位, 而剩余的主机号占了多少位.</p><p><strong>子网掩码</strong> :<br>IP地址分类的本质是区分网络标识和主机标识，另一种更加灵活、细粒度的区分方法是使用子网掩码。<br>A类, B类型, C类, 这类规定了网络号位数的IP划分方式, 浪费了大量的IP, 现在的无类路由(CIDR), 即mask可以更改网络号的位数的划分方式更有利于充分利用IP地址,<br>也是对于IPV4的扩充 (单独的mask也可以用于解决子网主机限制的).<br>它也是32位的, 只不过用其中 1 的数量表示子网, 即网络号的部分, 剩余的表示主机位.</p><p>子网掩码的方式, 涵盖并对应了 <code>IP</code>分类的方式, 但是又比<strong>规定死位数</strong>要灵活.</p><p>例如, B类网址, 即以10开头的网络号, 它本来网络号规定是16位, 可以容纳65534台.<br>现在通过子网掩码, 可以规定它的网络号是26位, 而不是规定死的16位, 可以容纳64台主机(除去主机号全0表示本子网, 全1表示广播外, 实际容纳62台)<br><img src="http://omotkhw3y.bkt.clouddn.com/network-sub.png" alt=""></p><p>但注意一下, 缺省情况下, 子网掩码和IP分类保持一致: 例如A类地址的缺省子网掩码为255.0.0.0,B类为255.255.0.0,C类为255.255.255.0。</p><p>全0的IP, 即表示本子网的IP, 只能是源IP, 不可能是目的IP; (DHCP 动态地址获取协议有用到, DHCP其实是封装了UDP包, 再没有获取真实IP地址前, 源IP地址就是0)</p><p>关于子网广播的内容部分, IP划分的子网, 比如8位, 24位等只能作为目的地址, 不能作为源地址. (常见的广播地址就是目的地址啦)<br>但是全1的, 比如255.255.255.255或者<em>.</em>.*.255的有些操作系统, 比如window, 你如果Ping的话就不行.<br>另外一些则可以支持, 比如linux, 它会让所有子网内的主机都返回信息.(你可以认为它是被保留的, 不能作为主机去ping)</p><p>微软的很多东西就是不按照标准来, 它自己去实现了一套, 从子网广播这里就能看出来.</p><p>其他扩充手段:</p><ul><li>IPV4, 最多划分42亿个IP.</li><li>IPV6不仅是长度(128位)的扩充, 而且, 它对于字段的规划&amp;划分&amp;长度要求等更加规范,标准.</li></ul><p><strong>回环IP</strong> :<br>loop ip: <code>127打头</code>的IP地址, 简单理解: 去了还能回来的接口. (IP输入(in 收), IP输出(out 出))</p><p>比如广播/多播, 还是ping自己, 都是通过本地回环接口(回环驱动程序), 直接进行IP输出输入的. 如果目标地址不是本地/本机网络机制, 那么才去走arp那条路, 之后返回给IP输入端口.<br><img src="http://omotkhw3y.bkt.clouddn.com/loop.png" alt=""><br>还有在配置nat的时候, 本机的某个地址如果配置成 IP_A – ANY, 所以所有本地访问出去的都要进行公网转换; 那么本地的 IP_B 也是会进行转换的(本地网络应该直连不用转换).<br>这个时候, 就可以利用一下回环IP, 配置策略路由, 即把源是 IP_A , 目的是 IP_B 的, 送到环回口.<br>因为NAT配置要满足3个条件:</p><ul><li>内部接口入</li><li>外部接口出</li><li>满足配置的列表</li></ul><p>我们破坏了第二个条件, out条件, 直接输出到IP回环地址上, 再从改地址配置列表到IP_B. 从路由的角度, 它看到是环回口进来的, 就不走NAT了, 而是直接匹配它的目的地址.</p><p><strong>路由部分</strong></p><p>路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成。<br>路由器中保存着<code>路由控制表</code>(存储转发表)，它在路由控制表中查找目标IP地址对应的下一个路由器地址。</p><p>下图描述了这一过程：<br><img src="http://omotkhw3y.bkt.clouddn.com/net-work-route.png" alt=""></p><p>由图中也可看出路由器连接着两个子网, 并且在路由表中进行范围或者最佳匹配. 同一个数据链路网络(本地网络)直接传送, 没有太多要说的是.<br>但是如果经过路由的, 即不同网络: 目的IP地址不变, 但是源mask地址, 即子网地址是在不断的变化的, 其实是路由器的网关地址.</p><p>源站路由(严格, 宽松)指定跳的路径(一次性指定多个中间目的地址, 普通的IP包的目的地址是不变的, 但是这样情况IP包地址是可变的).<br>(防火墙一般会对tcp, ip设置选项部分的, 一概不予通过; 源站路由也是被防火墙封杀的)</p><p>路由控制表可以由管理员手动设置，称为静态路由控制，或者路由器可以和其他路由器互换信息比即使自动刷新路由表，<br>这个信息交换的协议并没有在IP协议中定义，而是由一个叫做“路由协议”的协议管理. <code>netstat -r</code> 查看路由表(网关或者静态路由).</p><p>总结:<br>IP选路和路由表相关, 一般就是udp, tcp包来了, 借用它来查询下一跳(然后往后传递); 或者从网络接口层拿到数据处理IP选项然后上发.<br><code>netstat -rn</code> 可以查看路由表(但不能更新路由表, 更新路由表,一般是route命令).</p><p><strong>实际传输过程中, 数据包也会在路由器这里拆包并封包再转发, 因为要重新填写下一跳路由地址</strong></p><p>路由控制这有会有两个问题:</p><ul><li>转发成环问题(不存在相关的IP地址)<br>IP首部解决这个问题</li><li>分割与重组<br>IP受限于链路层的MTU, 过大的数据就要分组, 远端主机再重组(首部中的标志和偏移)</li></ul><p>由于<code>环</code>和<code>分组</code>问题都依赖于<code>IP首部</code>结构, 下面就说说.</p><p><strong>IP首部</strong></p><p>ip协议头(20字节, 加上选项部分, 最大60字节), 这里有很多设计讲究.<br><img src="http://omotkhw3y.bkt.clouddn.com/ipheader.png" alt=""></p><p>8位的<code>TTL字段</code>(解决环的问题, 不可能让你无限传下去)<br>这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><p>其他部分介绍:(从上往下一层层看)</p><ul><li>4位版本信息(表示该协议的内容解析方式, 也记录了选项部分最多40字节: 15*4-20=40; 注意4bit最大值就是15)</li><li>TOS 8位: 分别分为3组: 3bit(IP优先级), 4bit(最小延迟, 最大吞吐量, 最高可靠性, 最小费用; 置1表示选择; 全0表示普通包), 1bit(保留).<br>一般是给路由用的(给路由的建议, 路由器不理睬就没办法了), 保证其服务质量和服务侧重. (比如FTP就需要最大吞吐量, 它就会把这里面的最大吞吐量位置1)</li><li>总长度(Total Length)：表示IP首部与数据部分总的字节数，该段长16比特，所以IP包的最大长度为65535字节(2^16)。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。<br>(上层看不到下层的MTU限制)</li><li>16位标识（ID：Identification）：用于分片重组。属于同一个分片的帧的ID相同。但即使ID相同，如果目标地址、源地址、上层协议中有任何一个不同，都被认为不属于同一个分片。</li><li>标志（Flags）：由于分片重组，由3个比特构成。<br>第一个比特未使用，目前必须是0。<br>第二个比特表示是否进行分片，0表示可以分片，1表示不能分片。(例如如果你要分片, 我设置了df位, 你就不要分了, 直接丢弃然后icmp返回路由信息即可) (DF)<br>第三个比特表示在分片时，是否表示最后一个包。1表示不是最后一个包，0表示分配中最后一个包。(MF)</li><li>片偏移（FO: Fragment Offset）：由13比特组成，表示被分片的段相对于原始数据的位置。它可以表示8192(2^13)个位置，单位为8字节，所以最大可以表示8 x 8192 = 65536字节的偏移量。</li><li>协议： 表示IP首部的下一个首部属于哪个协议。比如ICMP协议号为1. TCP协议的编号为6，UDP编号为17.</li><li>首部校验和：用于检查IP首部是否损坏(IP校验和只校验IP首部)</li><li>可选项：仅在试验或诊断时用，可以没有。如果有，需要配合填充（Padding）占满32比特。<br>比如路径记录(路由的IP地址), 时间戳, 严格选站路径(每跳目的IP地址都变, 一般的情况只是源IP地址会变)</li></ul><p><img src="" alt=""></p><p>IP数据报最多65535字节, 但是实际上, 还受到应用程序的限制, 即socket api的实现限制; 以及内核实现(源/目的主机的网络实现)也有关系.<br>内核到用户空间的数据拷贝也和内核实现有关, 应用程序接口socket api有关.</p><p><strong>IP分片</strong><br><em>卷1里面讲完udp数据报协议之后才讲了IP分片.</em></p><p>术语:</p><ul><li>IP数据报: 一个完整的IP数据包</li><li>IP分组: IP层和链路层传输的单元(即不分片的时是数据报, 分片时是一个分片)</li></ul><p>在TCP的时候, 由MSS保证了应用数据的分/合(分片), 并且只按照字节计算, 所以TCP的包一般不存在IP分组, 可以理解成TCP帮助处理了流量数据, 所以避免了IP层在动手.<br>而UDP协议的时候, udp协议不做这个事情(udp不做判断, 也不做处理), 因为整个应用数据是报文(有边界), 直接按照应用数据来封包, 也不进行拆分, 一股脑交给IP, 即:</p><pre><code>应用数据 --&gt; UDP头部+应用数据 --&gt; IP头部+UDP头部+应用数据</code></pre><p>所以这个时候, IP在传输的时候, 可能就要进行分组传输了(由链路层的MTU限制了)</p><p>udp 不做判断也有好处, 来一个任务, 就封装一个包, 直接传输走(tcp可能会嫌弃包的字节数太少, 等积攒一定数据才走, 流的重组装), 实时性高; 但是udp不管对方是否收到.<br>(tcp 保证可靠传输, 但是其建立连接握手, 协商, 重传等都是需要时间的) </p><p>IP把数据包和MTU进行比较(送出的时候才查), 然后决定是否分片, 中间跳可能多次再分片, 直到目的方才进行组装.<br>(但是udp层不知道 ip是否分片, 发送方也不知道中途是否会被分片; tcp自己处理了包的大小, 一般不存在分片)<br>中途如果丢了一个数据分片, 等于说整个包就失效了(tcp则可能就要重传了, 因为包不完整是不回应ack的, tcp不知道分片的事儿).<br>因为发起方(IP知道, 但是IP的上层才是发起方, 他们不知道)可能都不知道中途会被分片, 所以重传某一片是不可能的.</p><p><strong>分片大小</strong>一般整体低于1500, 但是分片不涉及IP头部部分.<br>udp首部信息只能在第一片中出现(如果端口转发的路由, 后面的分片由于没有头部信息, 就转发不了), 后面的包的大小一般是8的倍数.<br><img src="http://omotkhw3y.bkt.clouddn.com/ip-frament.png" alt=""><br>(如果最后一个分片不足, 应该填充0; 补齐到46字节) 尽量调整MTU大小, 避免IP分片.</p><p><strong>NAT 和 NAPT 技术</strong> :<br>NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。</p><p>在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。那不同网段中，IP 地址都是 192.168.1.1 的主机改如何通信呢？</p><p>下图描绘了 NAT 的工作原理：</p><p>局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 163.221.120.9 发送数据。NAT 路由器将数据包的源地址修改成自己的全局 IP 地址：202.244.174.37。同理，接收数据时，路由器把目标地址 202.244.174.37 翻译成内网地址：10.0.0.10</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-nat.png" alt=""><br>路由器只有一个对外的全局 IP 地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用 NAPT 技术，它和 NAT 从原理上类似，但它可以转换 TCP 和 UDP 端口号。</p><p>使用 NAPT 技术时，不同的内网 IP 被转换成同一个公共 IP 地址，也就是路由器对外显示的全局 IP 地址，但是被附加不同的端口号以示区分：</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-napt.png" alt=""><br>不管是 NAT 还是 NAPT，都需要路由器路由器内部维护一张自动生成的地址转换表。以 TCP 为例，建立 TCP 连接首次握手的 SYN 包发出时会生成这个表，关闭连接时会发出 FIN 包，收到这个包的应答时转换表被删除。</p><p><strong>ICMP协议</strong> :<br>ICMP被认为是IP的一个附属协议(ICMP报文整体还是使用ip首部, 即ICMP报文封装在ip数据报内部), 负责异常通知(反应网络中出现的问题).<br>实际上不仅仅是不分包, 丢包的时候会发ICMP信息通知源, ping, traceroute等都有用到该协议. (ICMP其实蛮复杂的)</p><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。<br>其中一个重要的模块就是ICMP(网络控制报文)协议。</p><blockquote><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。<br>给主机一个处理错误的机会，这也就是为什么说建立在 IP 层以上的协议是可能做到安全的原因。</p></blockquote><p>其报文主要分为两种: 查询,差错报文.用<code>类型 + 代码</code>区分: 8位类型, 8位代码.<br> 比如ping request, 类型为8, 代码为0; response, 类型为0, 代码为0. 当然还有其他的代码, 比如不可达时候, 类型为3, 后面具体的代码根据不同的情况而不同(端口不可达是3,3).</p><p>也就是说, 可达不仅仅是包括IP层的可达, 即主机是否可达, 也还包含其他不可达, 比如协议不可达, 端口不可达等, 总之就是再反馈信息.<br>(<code>反馈报文</code> 里面除了包含包ID, 还包含协议端口信息, 即IP分片的第一片(它含有端口号信息))</p><p>该协议有一个重要应用, <code>ping</code> 命令, 具体可以参考下面 <code>其他部分</code>.<br>哦, 还有一个TTL检测工具, <code>traceroute</code> 也需要借助它.</p><p>一般的网络问题, 处理起来大致是:</p><ul><li>抓包</li><li>分析网络, 包, 协议分析</li></ul><p>要么就看首部, 报文; 或者就是看ICMP差错报文信息.</p><hr><h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>这里已经不仅仅是理论了, 而且有大量的code实践, 可以单独参考我的其他文章:</p><ul><li>tcp: <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">how-about-tcp</a></li><li>udp: <a href="http://www.merlinblog.site/2017/06/19/udp-model.html">udp model</a></li></ul><hr><h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><p>主要应用层协议:<br>FTP, Telnet, HTTP, SMTP/POP3, SSL, SNMP(了解即可), 语音协议(SIP等)</p><p><strong>FTP</strong> :  数据传输的主流协议(块数据流)</p><ul><li>两个端口: 控制信道(tcp 21) + 数据信道(tcp 20); 因为下面封装的是TCP所以都要经历TCP的握手和分手过程</li><li>两种模式: 主动模式(客户端PORT+6个数字地址信息) + 被动模式 (都是从服务器端来说的, 主要是第二信道的区别, 被动模式第二信道是服务器连接客户端; 第一信道一般都是由客户端发起)</li></ul><p>其中客户端建立控制信道通信时 PORT(建立第二信道), LIST(罗列目录), PASV(询问是否支持下载), RETR(获取文件)等命令比较重要,<br>但是具体的数据是通过第二信道传输的(比如反馈具体的数据结果).</p><p>防火墙一般做控制就是根据这些命令来的, 比如不让外部下载, 那么看到RETR命令直接掐死. (NAT, NPAT或者防火墙都是要做地址转换的)</p><p>FTP不安全, 如果使用了账号密码, 域管理员抓包是可以看到具体的信息的(nc + ftp命令模拟一下就知道了);</p><p><strong>TELNET</strong> : 交互式数据流(你的行为有反馈)<br>远程登录协议和主要方式(使用23号端口), 但不安全. 一般现在使用ssh协议.(不再是明文, 而是密文; 乱码)<br>(多个字符可能在多个包中, 收到第一个包才能收第二个; 可以回显出结果)</p><p><strong>SMTP/POP3</strong> : 发/收邮件的协议 (25号端口)<br>这个协议也完全可以用命令行指令(在TCP建立连接之后), 例如RCPT, DATA, QUIT等命令完成收发邮件.</p><p>防火墙监控, 也是通过上述协议里面的命令进行控制的.  上面所有这些协议, 都可以通过<code>nc IP 端口</code>然后进行模拟.</p><p><strong>DNS</strong> : Domain Name System，域名解析系统<br>因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。<br>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 (也还分A类解析, B类解析等)</p><p>以解析域名： www.ietf.org为例：<br><img src="http://omotkhw3y.bkt.clouddn.com/network-dns.png" alt=""><br>根服务器其实并不知道 www.ietf.org 的 IP 地址，但是它知道 itef.org 域名服务器的地址，所以它把这条查询请求转发给 itef.org 域名服务器。<br>DNS请求被逐层下发，直到找到对应的 IP 地址为止。</p><blockquote><p>DNS协议运行在UDP协议之上，使用端口号53; (当然也能运行在TCP之上, 只是同时查询广播, 用UDP更好)</p></blockquote><p> 应用层, 我接触的,最主要的还是 HTTP, HTTPS协议, 由于比较重要, 我还是单独成文了.</p><p><strong>HTTP</strong> :<br>超文本传输协议(请求应答协议, 80端口)<br>它其中也有一些命令比如GET, HEAD等8个(OPTIONS, DELETE, POST等服务器考虑到安全性, 一般是不支持的), 但一般由于浏览器已经可以使用HTTP协议, 所以一般看不到.<br>也还有cookie和session来保存客户端或者服务端的状态信息(因为HTTP是无状态&amp;瞬时协议, 完成任务连接就没有了, 根本不维护数据或者状态或者连接), 让多次HTTP连接可以共用一些信息.<br>例如我已经登录了微博, 我在新开一个窗口, 发现还是登录的.</p><p>多连接问题, 比如远端网页信息比较大, 它会分多次get去拿数据, 即一次通信可能就有几十个连接同时发出.</p><p>HTTP非加密传输(中途可能会用到Base64编码方式(基本认证), 相当于明文), 总之是不安全的, 有些抓包软件比如<code>omni peek</code>直接给解码了.</p><p>一般要走认证的服务, 可以使用https, 而不是使用http.</p><p>详细可以参考: <a href="http://www.merlinblog.site/2017/09/07/network-base-http.html">HTTP相关</a></p><p><strong>HTTPS</strong> :<br>详细可以参考: <a href="http://www.merlinblog.site/2017/09/08/network-base-https.html">HTTPS相关</a></p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="MTU-相关问题"><a href="#MTU-相关问题" class="headerlink" title="MTU 相关问题"></a>MTU 相关问题</h2><p><code>MTU</code>, 根据协议性质&amp;网络性质&amp;操作系统(内核协议栈)实现等因素的不同而不同, 通常认为这也是IP分片传输或者设置TCP MSS的依据.<br>其实这这个MTU指的是<strong>链路层的数据区</strong>, 并不包括链路层的首部和尾部的18个字节.<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer1.png" alt=""></p><p>链路层谈MTU, 即链路层的传输极限. 一般认为MTU如果是以太网就是1500(802.3shi 1492).<br>并且都是<strong>出方向</strong>去查MTU, 例如如果IP层的数据大于1500, 那么IP层就会进行分片(fragmentation). 分为若干片, 让每一片都小于MTU. (组装只会在目的地进行组装)<br>(实际上从卷1的介绍来看, 其实tcp有mss保证, 所以一般不会经由IP再分片; 但是udp本身不处理数据大小, 所以会让IP插手分片事宜)<br><code>链路层的MTU(最大传输单元)</code>会和操作系统(Unix, Linux, windows), 和 TCP分节(MSS, max sgement size), 网络类型(以太网, ASDL)会扯上关系: </p><ul><li>如果只谈 以太网 最大传输单元, 那么就是 1500 字节</li><li>如果谈IP数据报的数据区长度, 最大为1480字节</li><li>如果谈TCP packet 最大长度, 那么 window 是, 1500-20-20=1460(减掉ip, tcp头部各20字节), linux/mac/unix则还要减去12字节 tcp time stamp, 即1448字节<br>tcp time stamp 是避免序列回绕以及计算RTT的依据; 当然windows没有这么实现, 自然也不需要.</li><li>如果谈udp, UDP数据报的首部8字节, 所以UDP数据报的数据区最大长度为1472字节</li></ul><p>强调一下, 这里说的是<strong>最大</strong>, <code>最小为64字节</code> (以太网最大数据帧1500+14+4=1518字节, 头14字节, 尾CRC校验位4字节)<br>大于MTU, 这个时候发送方IP层就需要分片(fragmentation). 把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.</p><p>用于ping时, 一般就是1500-20-8 = 1472, ipv4中icmp协议头为8字节, 但是ipv6中可能是4也可能是8.</p><h3 id="MTU-路径发现"><a href="#MTU-路径发现" class="headerlink" title="MTU 路径发现"></a>MTU 路径发现</h3><p>但是 MTU 不是一成不变的, 它会根据网络的性质(比如中途有低速链路), 通信状态(网络的传输能力可能会有一些差别)进行一些列的调整.<br>比如传输过程经过3条(3个链路网络), 分别是: 800, 600, 500; 此时路径MTU就是500, 保证每个包(分组)的数据小于路径MTU, 那么才绝对不会分片(IP分片).<br>否则, 不能保证一定不被分; 例如数据大小是700, 第一跳(hop)不被分, 但是第二跳就被分了.</p><p>并且, 一旦分片, 可能还会被多次分片. 这样带来的丢失重传处理, 很麻烦/浪费时间, 降低传输效率.<br>但同时也希望在不分片的基础上, 尽可能大的数据包去发送.</p><p>MTU路径发现, 就是解决办法:<br>主机会首先获取整个路径中所有数据链路的最小MTU，保证每次传输都小于该值。<br>传输过程(通常都只是检查出去方向的, 即由发送方控制)中的任何一个路由器都不用进行(再)分片工作(但路由器有这个能力)。</p><ul><li>为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.<br>这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回给主机<br>(如果路由器配合的话, 还会返回下一跳, 即出口MTU的值; [不配合的话, 那么就逐跳减少探测)</li><li>主机将ICMP通知中的MTU设置为当前MTU，根据整个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。</li></ul><p>一般互联网, 即以太网链路层的网络, 一般都是1500, 而如果是隧道, 比如vpn, 那么可能就需要自己配置一下了(因为还有物理接口, VPN等字段需要配置&amp;传输), 比如降低一下MTU值.</p><p>还是以udp为例子:(1500-20-8=1472的理论值)<br><img src="http://omotkhw3y.bkt.clouddn.com/net-work-udp-mtu.png" alt=""></p><p><em>上图也可以看到ICMP协议也是用的IP首部</em></p><p>由链路层的传输能力, 限制了上层的IP层的分片(分组), tcp的分节(segment)MSS.  <strong>MTU是对输出链路探测的结果, MSS大小是双方协商的结果.</strong></p><h3 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h3><p>TCP中谈论的更多的是, MSS (maximum segment size) 最大分节大小. 一般为了避免分节, 也会进行相关的协商或者探测, 取网络的最小值.<br>撇开系统因素(比如linux/unix下可能会有tcp time stamp部分), 一般是:</p><pre><code>ipv4 1500-20-20 = 1460 字节ipv6 1500-20-40 = 1440 字节</code></pre><p>MSS属于TCP的内容, 它通常也会和<code>通知窗口</code>, <code>拥塞窗口</code>搅和在一起, 但是总可以认为, 不管其他因素怎么变, 一般TCP发送的大小最大是MSS.<br>因为它是可靠传输, 它自己处理好上层应用数据的分节, 这样才不会让IP层再进行分片/分组交付给链路层; 其实也方便它自己处理丢包重传等问题.</p><p>详细内容请查看 TCP 的文章:  <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">how-about-tcp</a></p><h2 id="大小端问题"><a href="#大小端问题" class="headerlink" title="大小端问题"></a>大小端问题</h2><p>编写一个程序， 看一下主机字节序是<code>little-endian</code>还是<code>big-endian</code>.</p><p>下面给出一种简单的方案:</p><pre><code class="C++">#include &lt;stdio.h&gt;int main(){    int a = 0x1122;    char *b = (char*)&amp;a; //取低8位    if(*b == 0x11){        printf(&quot;BE\n&quot;);    }else{        printf(&quot;LE\n&quot;);    }    printf(&quot;%d\n&quot;, *b==0x22); //1    return 0;}</code></pre><p>当然你用联合union也挺好：</p><pre><code class="C++">#include &lt;stdio.h&gt;int main(){    typedef union {        int num;        char num_low8;    } NUM;    NUM number;    number.num = 0x1122;    if(number.num_low8 == 0x11){        printf(&quot;BE\n&quot;);    }else{        printf(&quot;LE\n&quot;);    }    printf(&quot;%d\n&quot;, number.num_low8==0x22); //1    return 0;}</code></pre><p>注意：操作系统读写内存都是从低地址到高地址。</p><blockquote><p>一般本地主机是小端，但是网络字节序就是大端了</p></blockquote><p>这个时候涉及到转换问题，一般是IP地址的转换(端口可能也需要)，有相应的函数htons()、ntohs()、htonl()、ntohl() ,<br>并且像protobuf库也有相关的API, asio库直接就封装好了, 什么都不用管.</p><h2 id="Ping原理"><a href="#Ping原理" class="headerlink" title="Ping原理"></a>Ping原理</h2><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站, 如果丢包研究就是网络问题, 如果其他连接不可达, 就会出现超时或者主机拒绝连接等信息。</p><p>它利用ICMP协议包来侦测另一个主机是否可达, 原理如下:</p><blockquote><p>用类型码为0的ICMP发请求, 收到请求的主机则用类型码为8的ICMP回应</p></blockquote><p>ping: 除了type和code注意, 还要注意TCP/IP在内核中就支持了ping服务端.<br>并且ping报文部分, 即ICMP报文部分就包含了标识符, 即用户进程的id号(linux实现), 但是windows实现, 是全局统一编号, 而不是进程对应;<br>其他部分还包括收发包的时间(报文体记录或者window上是由系统记录).</p><p><code>ping -R &lt;ip&gt;</code> 路径IP记录, 最多记录9个IP (2条就会用掉6个)<br>(因为IP首部整个最多60字节, 去掉20字节, 选项部分还剩下40字节(40/4=10); 加上ping自己需要传送的信息, 最多就只能记录9个路径ip地址)</p><p>用于ping时, MTU一般是1500-20-8 = 1472, ipv4中icmp协议头为8字节, 但是ipv6中可能是4也可能是8.</p><h2 id="Traceroute原理"><a href="#Traceroute原理" class="headerlink" title="Traceroute原理"></a>Traceroute原理</h2><p>这个工具比较强大, 给的选项也比较多, 通常是来检查跳(hop)数.<br>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p><p>原理: (改变ttl数, 借助icmp反馈)</p><blockquote><p>它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机<br>主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后第二个路由器给主机发ICMP数据报<br>如此往复直到到达目的主机</p></blockquote><p>traceroute 用的udp的包(目的端口号33434), 但ttl=1, 即路由不转发该包, 然后收到icmp反馈(超时差错报文), 知道该跳的相应时间.<br>之后发送ttl=2(此时目的端口号33435, 之后慢慢增长), 然后再收到反馈, 直到到达目的地(此时端口号肯定大于33434), 然后该服务器反馈端口不可达差错.</p><p>这样，traceroute就拿到了所有的路由器IP.</p><hr><p>就写这么多吧.</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="">《图解TCP/IP》</a></li><li><a href="">《TCP/IP详解》</a></li><li><a href="http://www.cnblogs.com/hjslovewcl/archive/2011/07/18/2314316.html" target="_blank" rel="external">http://www.cnblogs.com/hjslovewcl/archive/2011/07/18/2314316.html</a></li><li><a href="http://www.choudan.net/2014/09/12/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4-%E4%B8%80.html" target="_blank" rel="external">http://www.choudan.net/2014/09/12/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4-%E4%B8%80.html</a></li><li><a href="https://juejin.im/post/598ba1d06fb9a03c4d6464ab" target="_blank" rel="external">https://juejin.im/post/598ba1d06fb9a03c4d6464ab</a></li><li><a href="https://www.zhihu.com/question/21064101" target="_blank" rel="external">https://www.zhihu.com/question/21064101</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)                                                                                                  </p><p>Saturday, 11. March 2017 04:09PM </p>]]></content>
    
    <summary type="html">
    
      个人是比较喜欢研究网络问题的, 最初可能是为了玩更多高大上配置的服务器, 之后就是为了弄清楚编程中遇到的问题以及其原因.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>领域信息系统开源构想</title>
    <link href="www.merlinblog.site/2017/10/12/domain-specific-system.html"/>
    <id>www.merlinblog.site/2017/10/12/domain-specific-system.html</id>
    <published>2017-10-12T08:21:08.000Z</published>
    <updated>2017-11-04T12:13:53.523Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直以来我获取行业调研报告的途径都是券商的网站, 比如中金所, 建投等, 后来朋友建议你可以试试Python爬虫</p></blockquote><h1 id="尴聊"><a href="#尴聊" class="headerlink" title="尴聊"></a>尴聊</h1><p>机缘巧合, 朋友正在考虑要不要去<code>七牛</code>上海这边工作时, 我就存储的问题咨询了一下他, 为啥七牛, 又拍运的存储后台可以做的这么好.<br>其实呢, 我心里是有一定的见解的, 大致上由于其服务器分布位置以及网络供应商的合作, 没想到这个<strong>未来架构师</strong>的<code>老男人</code>开始大谈特谈架构问题.</p><p>他推荐了一篇文章, 我找了一个有用的架构图(单人使用的工具系统, 有必要这么复杂么?)<br><img src="http://omotkhw3y.bkt.clouddn.com/design.gif" alt=""></p><p>其实我是不太懂架构, 或者是不想懂; 上学那会儿我还会憧憬一下架构师, 可是经过2年多的工作, 我的兴趣点, 长处渐渐明确, 其实也应该是由于看到了架构师在单位内部尴尬的位置&amp;处境, 怎么说呢, 不说架构师, 反正就是, 死活不想做架构师. (希望5年内可以做领域专家)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>后端信息系统, 我其实死没有考虑这个的, 我希望要的是一个可以搜集数据, 分析数据, 然后适当分析数据的系统(当然主要的分析数据能力在我, 人类专家知识).</p><blockquote><p>但是当前没有太详细的构想; python 爬虫? + 可视化? 以及我要的<code>领域&amp;行业调研报告</code>? 有点乱.</p></blockquote><p>总之, 这个事情, <strong>先记录一下, 之后有时间, 仔细思考和实践</strong>, 作为了mini-project or side-project.</p><h1 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h1><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      暂存一个构想, 接下来如果有时间就去实现
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
      <category term="python" scheme="www.merlinblog.site/categories/codings/python/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>抓紧时间, 突破!</title>
    <link href="www.merlinblog.site/2017/09/29/cherish-time.html"/>
    <id>www.merlinblog.site/2017/09/29/cherish-time.html</id>
    <published>2017-09-29T06:49:52.000Z</published>
    <updated>2017-10-13T17:54:37.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有很多的问题的答案, 其实就在前辈的回答中, 在前辈的思考, 经历中; 可惜有些人偏偏要自己再重复一遍, 比如说过去我, (苦笑)</p><blockquote><p>一定要看看下面, 侯捷老师的演讲词</p></blockquote></blockquote><p>也是在今年在一场说走就走的冲动下, 我才有机会去思考, 去做自己真正想做的事情, 也体会到<code>珍惜你可以自由支配的时间</code>的重要性.</p><p>过去的经历, 大致是5年内(应该是大学二年级), 我和父母的矛盾一直很大, 很激化.</p><p><code>也因为这样浪费的很多时间</code>, 直到今天, 我的父母虽然开始支持我, 但也只是部分支持我. 我曾经在急需在关键点的时刻需要抢跑或者抓住机会, 父母有能力却不帮助我, 也没有试图理解我. 事实上却是观点冲突太大了, 父母的意思是, 我太小不懂事, 外面碰了壁, 多摔摔就知道他们是对的了. 这样时间一直过, 一连错了至少三次重大的机会, 包括那次去三星电子的机会.</p><p>时间过去那么久, 我也从最初的埋怨父母, 变得知道理解和懂得父母的用心. 但是价值观不同, 或者性格不同是不会变的, 换句话说, 本质上的矛盾很难根本上的根除, 除非我成家或者妥协了. 我想真的没有时间再去纠结或者顾忌这些了.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/hj.jpg" alt="post-cover"></p><p>因为困难而被打趴下的人很多, 在窘迫面前坚持不下去的, 放眼一大片. 可是, <code>开弓没有回头箭</code>, 即便以后还是会碰壁, <code>即便是碰了南墙, 我也不回头, 我要翻过去</code>.</p><blockquote><p>不知不觉的磨合以及埋怨, 会让你浪费好几年的时间, 好几次的重要机会, 想做的事情也没有做成. </p></blockquote><p>其实, <code>和父母的矛盾</code>不仅仅让我明白珍惜时间的重要性, 更重要的我知道, 如果没有父母的资助, 很多事情, 你要准备很长一段时间才可能有机会.</p><blockquote><p>是的, 没有选择的日子太苦了, 尤其上学那会儿, 明明那么多想做的事儿.</p></blockquote><p><strong>没有经历过痛苦和折磨, 或者有那么一段刻骨铭心的深刻记忆, 我想我现在也不会这么加倍珍惜时间吧.</strong> 所以<code>感谢过往痛苦的经历</code>吧.</p><p>有能力和机会做自己想做的事情的话, 请加倍珍惜!</p><p>哪么现在该怎么做?</p><ul><li><code>抢跑</code>很重要(有些机会错过很难再来)</li><li><code>坚持</code>很重要(有些路是跳着走的, 但更多的路是一步一个脚印, 一步一个台阶走的)—见侯捷老师原话<pre><code>练琴很辛苦， 音阶训练枯燥无比， 但如果稍加坚持， 也许你得到了赞美， 也就发掘了兴趣。很多人说兴趣不能当饭吃，错，兴趣可以当饭吃。出问题的不在&quot;兴趣何方&quot;， 而在“能否坚持”。</code></pre></li><li><code>独立思考</code>很重要</li><li><code>老师</code>很重要(见陈硕大师的回答)<pre><code>如果你在名校, 你的老师可能会问你指出一些古董书籍中的一些不必要过度深究的问题, 为你省下很多时间;如果你没有老师, 你知道去啃经典教材, 其中有些过时的东西, 你也不知道, 比如unp卷1中的一些篇章.</code></pre></li></ul><p>及时的意识到当前的限制因素, 然后根据限制因素, <code>做原则以内的调整</code>, 我的优势明显, 其实劣势也很明显:</p><p>相比去<code>滴滴</code>的同学, 不论是在金钱回报, 还是在成长上, 我可能都要落后一些或者一大截. </p><blockquote><p>是的, 我已经错过了<code>抢跑</code>的机会. </p></blockquote><p>现在要做的只有扬长避短, 我称之为<code>快速突破</code>, 目标超越80%, 剩下20%交给30岁之后, 也就是我说, 还有5年不到的时间.</p><p>但是意识到问题所在, 就不用怕, 开动脑筋, 想想自己过去做过的那么多准备和努力. 还有超车的机会:</p><ul><li>谨慎做好选择, 这个非常重要; 宁缺毋滥</li><li>坚持下去, 闯过, 突破相应的难关 (这个非常难, 你没经历过的话, 可能不会动; 这期间太孤独, 很多不被理解)</li><li><code>坚持独立思考</code>, 现在信息复杂, 很多<code>好心人</code>他们的观点其实没有太多的帮助(但有一定的参考价值, 供你分析), 反而为你带来了迷茫</li></ul><blockquote><p>珍惜自己的时间, 做自己要做的事情, 好坏不回头</p><blockquote><p>我现在每每遇到难题, 都会这样暗示自己: <code>if u wanna it, u just go and get it no matter how(difficult) and what others&#39; saying about it.</code></p></blockquote></blockquote><p>当然, 侯捷老师当前在<code>华科</code>讲话那几条也不错, 我就摘抄一下吧: (转载from豆瓣, 请Google)</p><pre><code>程序人生－－侯捷在华中科技大学的演讲 如果你不曾听过侯捷的名字，不曾知道侯捷做的事情，你不可能有兴趣走入会场。因此，各位远道而来，我窃以为，无非想看看侯捷本人，听听他说话。如果你期盼在这种场合听到某某技术的剖析，某某趋势的发展，肯定你会失望。我不是趋势专家，对此也毫无兴趣。台上说话和台下聊天不同，我不能也不敢讲我没有心得没有研究的话题。&quot;程序人生&quot; 这个话题旨在让大家对一个你感兴趣的人（侯捷我）的学习历程有些了解，或许从中给你一些灵感或激励。我在一个被昵称为“ 少林寺”（台湾工研院）的地方，磨练三年。后半期因为发现了自己浓烈的兴趣与不错的天赋，决定转向技术写作与教育这条路。30岁之后的我， 行事常思“ 贡献度”，我知道自己在技术写作与教育这条路上能够走得比程序开发更好，所以决定把自己摆在最适当的位置。一口食物，放在嘴里是佳肴，吐出来就成了秽物。天生我材必有用，每个人都应该仔细思考，自己真正的兴趣和才能在哪里。很多人都问，30岁之后做不动程序员了怎么办。30年正是英年，体力和智力和成熟度都正达到巅峰，怎么会做不动程序？想往管理阶层走当然很好，那就努力充实自己，并且扪心自问，你做管理快乐吗？要知道，人事绝对比机器让你更焦头烂额。如果你决定争取一个粥少僧多的职位，就不要再问“ 怎么办”。还能怎么办？努力以赴呀。比赛还没开始就问输了怎么办，这不像话，你注定要输。技术养成阶段，对我影响最大的一件事是，我自动请缨做一套公用程序库，目标给全部门乃至全所使用。这使我学习到技术的整理、文件（documents）的撰写、人际的沟通。重要的不在具体实作，而在多方培养了正确观念。如果你问我，对于程序，我最重视什么？我最重视可读性（含说明文件）、维护性、复用性，完整性。这些其实是一体多面。转向技术写作后，我的生活和待在业界没有什么改变，只不过业界的产出是软体，我的产出是书籍和文章。写一本书和规划一个专案（project）没什么两样。但是，专心于技术写作之后，从此我有绝对的自由钻研我最感兴趣的“ 技术本质” 与“ 技术核心”。我周遭的朋友，但凡表现不凡者，都有非凡的资料整理功夫。如今网络发达，资讯爆炸，硬盘又便宜，资料整理功夫更显重要。没有经过自己整理的资料，形同垃圾。许多人喜欢上网“ 收集” 一大堆电子书、电子文档。你得想个办法把这些庞大的资料化为你的图书馆，而不是搁在硬盘角落里做为安慰或炫耀。书籍也一样，买来要看，安慰自己或炫耀他人都没有任何意义。当然，一旦你到达某种层次，以及某种经济能力，你买书不见得马上看，不见得整本看。我有个私人小图书馆，其中的书有许多还没看，当初购买是准备随时参考用的，也有些是当做学习的目标，摆着准备有空时看。今年是我写作的第1 0 个年头。我认为自己确实走上了一条最适合我的路，尤其今天这么热烈的场面，实在令我情绪激昂。我不会忸怩作态地不愿承认我的作品给别人带来帮助，然而我要说，作者和读者是相互激励相互影响的，我们彼此进入了一个良性循环。没有优秀的读者，就没有优秀的作者。艺术家可能不是这样，但电脑技术写作，或更缩小范围地说，我，是这样。因此，我要衷心感谢那些给我鼓舞、给我勘误、给我赞美、给我批评的热情读者。下面回答几个常被提出来的问题。一、 如何学习大哉问。学习需要明师。但是明师可遇不可求，所以退而求其次你需要好书，并尽早建立自修的基础。迷时师渡，悟了自渡，寻好书看好书，就是你的自渡法门。切记，徒学不足以自行，计算机是实作性很强的一门科技，你一定要动手做，最忌讳眼高手低。学而不思则罔，思而不学则殆，一定要思考、沉淀、整理。整理的功夫我要特别强调。许多人一味勇往直前，追求最新技术发展，却忽略了整理沉淀的功夫。如果知识不能深刻内化为你的思想，那么这份知识很快会离你而去。二、 科班与非科班, 名校与非名校各位身为名校学生，身为科班生，从来不必在乎这个问题，那是饱人不知饿人饥。这个题目上我是50比50， 我出身名校，但非科班。虽然我从来没有被这个问题所惑，但的确有许多年轻学子为此辗转反侧，苦恼不已。学历和背景只是一个证明，证明你曾经经历过某种考验，证明你曾经经历过某种训练。但并不保证考验后或训练后的质量。你所处的环境如果极重视出身，这是你无能为力的— — 毛主席要废除封建，千百年来的人心却难以废除。但是不要气馁，你总有机会证明你的能力。上天不会不给任何人至少一个机会，关键在于机会来时你准备好了没有。三、升学（ 考研）与就业先升学好还是先就业好？未曾深刻对发问者的个人背景做一番了解与分析，就遽然给答案，是不负责任的骗子。我只能说，以我的经验和我的观察，如果你能够先就业再继续深造，就业所得的各种经验会对你的治学方式带来很大的帮助。就连你的人生历练，都会对你和你的指导教授的相处带来帮助─ 这可是件大事， 影响你3~6年的生活。（注：台湾硕士生两年，博士生四年，大陆硕士生三年，博士生三年）四、培养自信心嘴巴无法培养自信心，手才能够。只要切切实实地动手做点东西，你的自信心就会逐渐建立起来。随着自信心的建立，你就再也不会问&quot;C++还有前途吗&quot;、 &quot;Java还有前途吗&quot;、“VB还有前途吗”这种问题。下面是我给同学的七个勉励：1.乐趣linux操作系统的创造者 linus 最近出了一本自传：《Just for Fun 》，简体版译名为《乐者为王》。如果我来译，我就译为《一切只为乐趣》。是的，兴趣才能使你乐在其中，乐在其中你才会产生热情，热情才能使你卓越。要忠于自己的兴趣。有人问，怎样才能找到自己的兴趣，如果我有答案，我就可以开一个“ 卡内基兴趣开发中心”，成为全球首富。这种问题不会有明确答案的，你的兴趣要别人来帮你开发，咄咄怪事。你可以多方尝试，但是首先要有起码的坚持。练琴很辛苦，音阶训练枯燥无比，但如果稍加坚持，也许你得到了赞美，也就发掘了兴趣。很多人说兴趣不能当饭吃，错，兴趣可以当饭吃。出问题的不在 “兴趣何方”， 而在“能否坚持”。2 . 坚持我在今年四月份给新竹交通大学资讯系一个演讲，题目是：唯坚持得成功。我自己才能平庸，但我很能坚持。我的这种个性在朋友之间是被称道的。坚持并不代表一定成功，不过坚持本身就是一种美好的情操。所谓谋事在人，成事在天，只要坚持，我们总可以心安理得地说：那美好的战我打过了。人生最后要的不就是心安理得吗？3 . 格调做事不但要坚持，而且要坚持高格调。格调使人高贵。俗世成功不保证格调，格调也不保证俗世成功，但是格调使人拥有尊严，使人获得尊敬。我在台湾，观察计算机书籍的写作与出版，对于格调特别有所感触。有些作者与出版社，并不在乎格调，也不在乎贡献，只在乎生意，只在乎利润。生意要做，利润要赚，传道还需道粮嘛，但是金钱绝不能摆在第一位，否则生意和利润都不会长远。因金钱而结合的，终将因金钱而分手而结束。关于这个，台湾有许多活生生的例子，可为大陆出版社借鉴。4 . 谦虚与教养再怎么开明的师长前辈，也许可以接纳年轻人的飞扬跋扈，也许可以接受年轻人的无理取闹，但当他真正需要帮手或真正要培养人才时， 他一定特别考虑谦虚有教养的年轻人。没有什么是不能挑战的， 但是做为挑战者，你要言之有物、言之有理。毛主席说， &quot;没有调查就没有发言权&quot;， 这话说的真好。5 . 气势气势和先前说到的谦虚，两间之间不好拿捏，拿捏尺寸属于艺术范畴。圆熟的人生历练，才能把两者调理得恰到好处。我的想法是：做人要谦虚，做事要有气势。这次来内地演讲，接触读者，网上很多的评语是：他很谦虚。为什么这么说？难道侯捷曾经给人不谦虚的印象吗？是因为我文章中的气势吗？谦虚和气势，并不是两条平行线。6 . 勤奋爱迪生说， &quot;成功是百分之一的天才加上百分之九十九的努力&quot;。道理非常清楚，我没有什么引申。你问任何一位你认为成功的人他是否勤奋，看看他怎么说。我有一位大学同学，跳舞打牌爱吃爱玩，但是每次微积分考试都比我好。我比他勤奋，他比我聪明。天赋使然，别在上面钻牛角尖（我曾经钻得很痛苦）。要知道，人生的成绩单和学校的成绩单没有必然关联。人生很长，要看长远，要计久长。7 . 超越自己的&quot;局限&quot;清华一位同学问我，最佩服哪些程序员，我一时答不上来。经过同学的引导，我说了几个名字。同学又问我，我佩服的都是些外国人吗？我略略想了一下说是。同学（似乎）失望地坐了下来。事实上，在那个突然的问题中，我的思考迷了路。我的回答并不真正代表我的心意。我从来没有想过谁是我最佩服的程序员。在我的生活中那是一个不存在的话题。技术不是真理，我没有崇拜过哪一位程序员或技术大师。我知道大陆有着地位极为崇高（近乎民族英雄）的程序员，他们的事迹对来自台湾地区的我而言，总是有着一层陌生。当然， 传奇令人神往，我也爱听他们的事迹。至于台湾，从来没有知名的程序员，台湾不曾走过这样一个个人英雄时代。现在，我要修正我在清华的回答。我真正佩服的，是那些超越自己局限的人——任何人，不只是程序员。&quot;局限&quot; 是你的家庭、你的环境加在你身上的先天桎梏，谁能摆脱先天桎梏，谁便是人生勇者，值得最大的尊敬与佩服。如果我的读者之中有人佩服我，我希望那是因为我对技术写作的执着以及对年轻学子的关怀，不是因为我的技术。再且，我的技术也只普通而已。任重而道远我为什么有机会在华中科技大学和同学们有这么热烈的一次接触？原因是我的书在华中科技大学出版社出版，而他们追求质量的态度，对作者的尊重，令我感动。当我拿到《Essential C++》简体版，我大吃一惊，制作质量完全不逊于繁体版。我告诉我的编辑，侯捷所有后续书籍秉此办理。这几天，仔细了解《深入浅出MFC》一波三折的出版过程后，真正体会到，没有优秀的后援，好书终究到不了读者手上，那么，作者再多的质量、坚持、格调，终是一场空。    身为一个自由作家，没有任何理由我需要在乎计算器技术书籍的整体发展。我把自己的书写好，已经很对得起我的社会责任。然而我诚恳告诉各位，计算机技术书籍的整体发展和侯捷个人的发展，两者在我心中有相同的比重。前者说小了，影响大家的求知，说大了，影响国家的IT产业。读者对于这方面的殷切期待，在侯捷网站上的读者来函中一再出现。昨天我从周老师手上又获得几封读者来信，其中一封言词诚恳，不卑不亢，特别令我感动，我把它念出来与大家分享。信中对我个人的谬赞，不敢当。</code></pre><p>(但是侯捷老师年轻的时候, 都在专攻术业, 到三十岁才开始想明白一些事情, 哈哈, 我想我比他早了5年时间)</p><blockquote><blockquote><p>如果你决定争取一个粥少僧多的职位，就不要再问”怎么办”。还能怎么办？ 努力以赴呀。比赛还没开始就问输了怎么办，这不像话，你注定要输。<br>我真正佩服的，是那些<code>超越自己局限</code>的人——任何人，不只是程序员。</p></blockquote></blockquote><p>请再读一遍他的演讲稿吧, 那里面深刻处理几个常见的问题(虽然有一些观点, 现在的我有一些不认同…)</p><blockquote><p>谨以此篇纪念过去对我帮助很大的<code>侯捷</code>大师的(译)作品, 也为我自己突破3.0阶段开路.</p></blockquote><hr><p>2017年9月29号, 再次重返上海的第7日<br>几个朋友多次邀我国庆出去玩, 都拒绝了, 也没有具体解释原因, 顺其自然吧</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      谨以此篇纪念过去对我帮助很大的侯捷大师的(译)作品, 也为我自己突破3.0阶段开路.
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>在家装修有感</title>
    <link href="www.merlinblog.site/2017/09/20/experience-when-doing-house-up.html"/>
    <id>www.merlinblog.site/2017/09/20/experience-when-doing-house-up.html</id>
    <published>2017-09-20T14:06:03.000Z</published>
    <updated>2017-09-29T09:27:03.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>it’s not about love, it’s all about life and work. 要说的是不感情， 而是做人做事的态度; (当然老爸也和我谈了一些经验)</p></blockquote><p>本文也感谢父母, 为了拼搏解决了<code>他们觉得是问题的问题</code>(虽然这不是我想要的, 但依旧), 感谢.</p><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>父母借着监工装修的理由把我喊回家了， 母亲还是没有改变， 苦口婆心劝我回家发展， 不要再<code>玩电脑</code>了(至今我妈妈只知道我在电信行业, 不知道我是码农,或者软件工程师), 而父亲则是有一些改变， 从退让变为了支持. 与家里人冲突很大，和父母的观念完全格格不入，直到今天，我仍旧不能判别谁对谁错。或者根本没有对错。 </p><p>监工的日子短暂而又枯燥， 但是经历和体会却是良多. </p><blockquote><p>要做一件事情，先要进行逻辑梳理，确认是基于哪些事实(类别)，再逐个解决问题.(<code>黑天鹅</code>除外)</p></blockquote><p>第二个层面, 要说做事儿的态度的原因, 是<code>歉信君</code>的一篇博文, <a href="http://www.cnblogs.com/kenshinobiy/p/4876788.html" target="_blank" rel="external">为什么给的待遇很丰厚，我的90后员工还是要走？</a>, 试图解释一下, <code>我作为90后的工作态度</code>, 见下文, 细说.</p><hr><p>下面分成4个部分来说：</p><ul><li>房子和发展</li><li>做事情的态度</li><li>兴趣和工作</li><li>坚持还是退让</li><li>老板的激励原则</li></ul><h2 id="房子"><a href="#房子" class="headerlink" title="房子"></a>房子</h2><h3 id="房子和个人价值"><a href="#房子和个人价值" class="headerlink" title="房子和个人价值"></a>房子和个人价值</h3><p><code>在我这个年龄</code>， 房子对于我似乎是可有可无的。 </p><p>为什么这么说呢？ </p><p>因为我并不是一个安分的人， 像我的某些同学所说的那样“白天有酒喝， 晚上有奶摸， 此生足以”。 我心里还是有我想做的事儿。 一方面我想提升自己的能力， 追求才华， 想把自己变得更有用，让自己的价值得以体现； 另一方面， 我还存在一定的虚荣心（当然， 现在已经好太多了）, 想进一步拉开和同学的差距, 至少将来不能是个垃圾吧.</p><p>但是父母早早就给我在筹划这个事情。 学妹说，“知足吧， 得了便宜还卖乖就是矫情了”。 我只能说， “知我心者， 谓我心忧； 不知我者谓我何求”。</p><p>就像<code>叔本华</code>说的， <strong>一个人过度依赖外物的话, 就会在那些东西失去的时候变得空虚和孤独， 很多时候要反求于内心</strong>。 </p><blockquote><p>有钱就住大点儿的房子， 没有那么多财力， 小点儿的未尝不可；<br>如果父母那一辈不够努力， 没有给你积累财富， 也不用过分气馁或者埋怨， 租房住也未尝不可（但最好为你的下一代积累一点儿），</p><p>我现在在上海租房住， 和房东， 和住户们未尝不开心了。</p></blockquote><p>房子给女人带来的是安定， 给男人的意义， 个人觉得没有那么大.</p><p>并且<code>拿房子来说明自己的成功与否的人， 我个人是不认同的</code>， 因为我遇见过太多的牛人，有才华的人， 对物质生活的追求其实是非常少的。</p><h3 id="房子和发展"><a href="#房子和发展" class="headerlink" title="房子和发展"></a>房子和发展</h3><p>废话不多说， 先上图再说.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/deco2.jpg" alt=""> <img src="http://omotkhw3y.bkt.clouddn.com/deco5.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/deco3.jpg" alt=""> <img src="http://omotkhw3y.bkt.clouddn.com/deco4.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/deco1.jpg" alt=""> <img src="http://omotkhw3y.bkt.clouddn.com/deco6.jpg" alt=""></p><p>拿到房子的时候， 其实大致上的建筑面积是改变不了的； 然后主要支撑结构的位置也改变不了的。 <code>这就像我们的人生其实也是非常局限的</code>， 这不仅仅是说人生的长度， 更说的是<code>如果不从外部扩展， 只在内部开拓的话， 发展是有限的</code>。</p><blockquote><p>当然有的人会说， 有限的空间争取无限的可能， 利用空间的才能不一样， 同样的面积造就的精彩程度也不一样. </p></blockquote><p>这个道理当然没有错， 就像我们上学的时候， 即便是一样的努力， 最后的成果也是不一样的， 抛开运气因素不说， 每个人学习能力不一样， 这也是客观事实。</p><p>但是， 一个人的力量是有限的， 这一点你也不能否则。 不管一个人怎么开拓， 他始终要借助外力， <code>这就好像一个人不能不进食一样， 他自身也要成功， 需要外部能量</code>。</p><p>就像<code>卡内基</code>先生所说的一样， 一个人在事业上的发展只有15%是依靠自身的技能， 其他85%是依赖和别人的 <strong>交流合作</strong>。</p><p>而落实到我们金融IT业(<code>FinTec</code>)， 其实个人技能点， 一般3-5年差不多就能点亮80%了， 其余的20%如果你决心要成为技术专家才需要话另外5-7年去钻研； 而如果你能体会到自身的局限， <code>懂得合作</code>， 那么即便你的个人能力最终不如那些专家， 但是最终创造的个人价值也好， 社会价值也好， 或者赚取的财务也好， 都不一定会比那些个人专家少。（技术都是花时间， 熬时间，慢慢钻研的； 当然也和机遇平台相关）</p><p>也就是说:</p><blockquote><p>想要发展的个更好， 就要在<code>理解自身局限和长处的同时, 努力向外扩展</code>。</p></blockquote><h2 id="做事情的态度"><a href="#做事情的态度" class="headerlink" title="做事情的态度"></a>做事情的态度</h2><p>看工人们装修， 摆弄， 即便是偶尔搭搭手， 也是比较枯燥的。 什么原因呢？ 不是因为他和我利益不相干， 也不是因为我完全不懂（毕竟也不需要我懂）， <code>而是我不感兴趣</code>。</p><p>回想我当初辞职时候的毅然决然， 除了不想养老之外， 可能也有一部分原因是觉得很枯燥。</p><blockquote><p>而老爸晚饭的时候， 问我装修的事情怎么样， 我并没有意识到，<code>这其实是在对上级汇报工作</code></p></blockquote><p>然后老板和我说了一些对待工作的态度, 其中有一些还是深受启发的。</p><ul><li>不要觉得有些事情烦躁， 没有成就感， 简单枯燥就不去做， 那样不仅是没有耐心的表现， 也是成不了大才的；<br>如果那是个必须经历和忍受的过程， 那你就要坚持下来， 毕竟和你想法一样， 受不了枯燥的人， 不是少数</li><li>工人和老板的利益， 员工和公司的利益不总是一致的； 所以需要监管和激励。</li><li>假如你是装修师傅， 你如何保证这个主顾以后有生意还会找你或者推荐你？ <code>无论为谁做事情， 为自己也好， 为公司也好， 都要尽心尽责</code>。<br>我在这个岗位， 做这件事儿， 只要当前还是我负责的， 我就要做好； 即便是不想做了， 这一单也要做好了， 后面再说别的；<br>这不是工作的事， <code>是一个人态度和修养的问题</code>; </li></ul><h2 id="兴趣和工作"><a href="#兴趣和工作" class="headerlink" title="兴趣和工作"></a>兴趣和工作</h2><p>老爸和我说的多事家庭和工作，以及装修的事儿。 不过我自己私底下也思考了兴趣和工作。</p><p>如果你现在已经对工作游刃有余， 那么如果这工作也是你的兴趣， 那么请深挖； </p><blockquote><p>如果这工作不是你的兴趣， 也没有关系， 因为工作和兴趣扯在一起的时候， 我通常认为这是悲剧的开始， 就像你喜欢吃牛肉， 但是天天吃， 迟早也腻了。</p></blockquote><p>我们一生中大致上会经历一种或者两种状态：</p><ul><li>为自己家里的产业打拼， 然后交棒退休</li><li>为老板工作，然后在合适的时候自己干或者跟着合适的人干</li></ul><p>但是无论是哪一种情况， 我个人的思考和建议是， <code>工作和兴趣最好不要扯在一起</code>(你想做的事儿, 就是你的工作, 那又不一样了)。<br>因为一旦涉及利益， 即便你不思考(不往这方面想)， 也不能否认这样的兴趣已经不能是实实在在的兴趣( pure pleasure )了.</p><p>工作和兴趣的关系, 侯捷大师, 有一段演讲稿说的很好, 原话我记不清楚了, 大致是说:</p><pre><code>练琴很辛苦, 可是一旦取得一定的成果, 就变得有意思; 兴趣的培养在于能不能坚持下去.</code></pre><h2 id="坚持和退让"><a href="#坚持和退让" class="headerlink" title="坚持和退让"></a>坚持和退让</h2><p>某些时候， 到底是该坚持， 还是该退让， 真的很难说的清楚， 而能够说清楚的是，<code>时间永远是往一个方向走， 而且不再回头</code>。</p><p>我一直坚持 <code>The Best Or Nothing</code> 的观念， 这种想法的本身就是一种很极端， 很倔强， 不做退让的价值观。</p><p>但是偶然看到母亲变老的样子， 我不仅问自己， 到底当初那个信誓旦旦的说 <code>Win Or Home; All or None</code> 的我， 到底是对还是错？</p><p>行文之时， 我在武汉金融港， 而两天后， 我又要回到上海。</p><blockquote><p>或许坚持和退让， 很久之前， 我就做好了选择， 而且还没有打算改变选择。– <code>其实我们心里早早就有了答案</code>.</p></blockquote><p> 本次大修正之后， 几年内我都将不再休息， 而是全身心在<code>上海</code>投入, 工作和成长, 突破。</p><blockquote><p>let it be / So be it. 顺其自然吧。</p></blockquote><p>感谢那些所有一直关注和帮助我的人, 衷心感谢.</p><h2 id="激励原则"><a href="#激励原则" class="headerlink" title="激励原则"></a>激励原则</h2><p>关于歉信君的博客, 这里引用一下: (指出他文章中, 我认为有一些出入的地方)</p><blockquote><p><em>很显然，相较于长辈和前辈们，90后成长于殷实的年代，生存和生理上的、安全的两层需要被轻易满足，所以基于此的薪酬、稳定等因素已经失效了。社交上的认可、他人和自我的尊重、以及一种自我成就感，才是需要优先考虑的。如果一份工作不能拿出去在朋友圈晒、如果工作成果不能让顾客和老板真诚表扬、如果由于公司或者上司的支持力度不够而不能做到最好，那么这份工作对于他们的激励是远远不够的。</em></p></blockquote><p>我想说, 这对于<code>虚荣心强</code>的大部分我们90后是适用的, 但<code>不适用工作2-3年的人</code>, 比如说我, 因为我现在基本已经克服虚荣心问题了, 也不会轻易向上司许诺任何事情.</p><p>说出去的话就要负责, 不是能轻易许诺的. 这一点可以参考我的 <a href="http://www.merlinblog.site/2017/09/05/lessons-history.html">经验教训</a> 一文.</p><p>但是下面这一点, 他说对了:</p><blockquote><p><em>有一些是兼职的实习生和试用期的员工，他们在工作安全感和稳定性上欠佳，福利待遇上也有所不如。所以相应的激励因素就是提供转正的机会，以及提供一些职业技能培训的课程。</em></p></blockquote><p>心理学家亚伯拉罕·马斯洛将人类的需要分为了五层，分别是：</p><ul><li>生存和生理需求</li><li>安全需求</li><li>情感和归属的需求</li><li>尊重的需求</li><li>自我实现的需求</li></ul><p>有些人说 <code>马斯洛需求</code>模型是不准确的, 比方说, <code>JP摩根的父亲</code>就说过, <code>人类的多种需求是同时存在的</code>, 但是我想说, 是的, 但是<strong>马斯洛基本是对的</strong>.</p><p>我以自己的亲身体会来说, 当初我父母不支持我去上海, 毕业的时候, 一分钱没有给我, 连路费也米有; 那个时候借着老师, 学姐的力量, 我在实习的薪水, 不, 工资(wage)中, 硬是抗了下来. 那个时候, 我脑子里没有别的概念, 只有<code>钱</code>, 怎么样拿到更多的钱在上海生存下来. (但你说我那个时候, 没有自我实现的需求么? 其实有的, 只是它一点儿也不重要)</p><p>所以我的观点是, </p><blockquote><p><code>满足80%的主要需求就好</code>, 另外的是要靠自己突破自己的局限的; </p><blockquote><p>如果你要追求极致, 那不是奖励的问题, 而是自身的问题, 换句话说, <code>这是你自己对自己的要求, 与外界无关</code></p></blockquote></blockquote><p>用老东家的观点, 另外20%就顺其自然吧.</p><hr><p>好了, 废话说了这么多, 不说了, 装修工作, 就这样吧; 希望以后的工作越来越顺心.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      装修有什么好说的? 好无聊的博主... 我想, 我要说一说做事的态度.
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>C++最终篇</title>
    <link href="www.merlinblog.site/2017/09/14/c-plus-plus-final.html"/>
    <id>www.merlinblog.site/2017/09/14/c-plus-plus-final.html</id>
    <published>2017-09-14T05:28:09.000Z</published>
    <updated>2017-10-05T23:02:35.042Z</updated>
    
    <content type="html"><![CDATA[<p>这里集中说一说, 就当汇总吧; <code>以后C++更新的新内容全部在此</code>. 更新列表, 如下:</p><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>2017-8-26</td><td>初稿:C++标准文档</td></tr><tr><td>2017-9-14</td><td>更新:C++17新特性(参考《程序员杂志》,2017.09期)</td></tr><tr><td>2017-10-03</td><td>技术就是条无底洞, 尤其C++, 我不了解的内容还有很多; 遂修改部分言论</td></tr></tbody></table><hr><blockquote><p>在今天这语言百花齐放的年代, C++标准的制定又<code>被资金限制</code>推迟, 一直是在追着时代跑(已经完全不能领先于时代了)</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/cpp_all1.jpg" alt="post-cover"></p><blockquote><p>C++的著作, 非常多, 鱼龙混杂. 我当年走了不少弯路; 实际上很多书可以不读.</p></blockquote><h1 id="经典著作"><a href="#经典著作" class="headerlink" title="经典著作"></a>经典著作</h1><p>我在最开始写 <code>Modern C++</code> 的时候, 就推荐过好基本书, 这里在集中说一说.</p><p>入门我一共推荐了2本: (入门你看看《C++编程语言-十周年版》也是不错的, C++本加尼写的)</p><ul><li>《C++语言演化》</li><li>《C++ Primer(5e)》  (不要看第四版)</li></ul><p>我一共推荐4本C++的额外读物:</p><ul><li>《Effective Modern C++》</li><li>《Effective C++ 第三版》(相比第二版有很多新东西)</li><li>《More Effective C++》</li><li>《Effective STL》</li></ul><p>后面3本是经典, 需要细读.</p><p>由于我不是专门研究或者参与语法研究, 我其实不太喜欢语法来语法去, 也比较讨厌硬是把给个主题都写一遍的书, 比如<code>《Think In C++》</code>.<br>(纯粹的浪费大好的青春, 年华)</p><p>还有一些, 比如<code>《Inside C++ Object Mode》</code>, 我只能说, 如果你还在上学, 请务必读一读; 如果已经工作, 呵呵, 你好闲啊.</p><h1 id="标准文档"><a href="#标准文档" class="headerlink" title="标准文档"></a>标准文档</h1><p>C++真正正式公布的标准只有三个：C++98、C++03、C++11:</p><ul><li>C++98是第一个正式的C++标准</li><li>C++03是在C++98上面进行了小幅度的修订</li><li>C++11则是一次全面的<code>大进化</code>（之前称C++11为C++0x，以为会在08~09年公布，没想到拖到了11年, 原因?<code>缺钱</code>啊）<br>(你看它的标准文档就知道了, 前两个版本都是2.7M左右, C++11直接变成了14M)<blockquote><p>现在貌似C++17标准也快了, 据说9月就会去开会讨论啥的. 不过C++标准的跳票也没准, 就像官方所说的, 缺乏资金推动.</p></blockquote></li></ul><p>下面给出标准库的文档, 可以参考我的github库:<br>C++98 (1998年)<br><a href="https://github.com/WizardMerlin/Gate/tree/master/appendix/98.pdf" target="_blank" rel="external">https://github.com/WizardMerlin/Gate/tree/master/appendix/98.pdf</a></p><p>C++03 (2003年)<br><a href="https://github.com/WizardMerlin/Gate/tree/master/appendix/03.pdf" target="_blank" rel="external">https://github.com/WizardMerlin/Gate/tree/master/appendix/03.pdf</a></p><p>C++11 (2011年)<br><a href="https://github.com/WizardMerlin/Gate/tree/master/appendix/11.pdf" target="_blank" rel="external">https://github.com/WizardMerlin/Gate/tree/master/appendix/11.pdf</a></p><blockquote><p>如果有时间, 这些文档是值得好好读读的, 而且是<code>一手资料</code></p></blockquote><h1 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h1><blockquote><p>C++17是语言小修改（相对C++14，大概20几条）、标准库增加比较多（大概200多条）。</p><blockquote><p>C++20将会是可以和C++11可以媲美的大发展。</p></blockquote></blockquote><p>程序员杂志上《深入应用C++11》的作者给出了介绍, C++17其实主要是把Boost已经运用成熟的特性, 比如<code>any</code>, <code>optional</code>, <code>filesystem</code>等引入.<br>还有一些简化代码的机制, 比如<code>nested namespace</code>, <code>if init</code>, <code>dedution guide</code>等; 当然还增加了<code>并行算法</code>.</p><p>下面挑选我认为比较有意义的, 记录一下.</p><h2 id="来自Boost"><a href="#来自Boost" class="headerlink" title="来自Boost"></a>来自Boost</h2><p>类型擦除的三个:</p><ul><li>std::any</li><li>std::optional</li><li>std::variant</li></ul><p>其中, <code>std::optional</code>一般用于返回值(返回不确定值), 而<code>std::any</code>, <code>std::variant</code>则用于存储任意类型的值, 只是在转换回来时, std::any,<br>需要使用<code>std::any_cast&lt;类型&gt;</code>, 而 std::variant 则用 std::get即可, 当然你用<code>std::visit(functor, arg)</code>也可以.</p><p>std::filesystem<br>基本和boost中的一致, 用来处理文件和目录, 比如:</p><pre><code class="C++">namespace fs = std::filesystem;std::string path = &quot;C:\\test&quot;;for(auto&amp; p : fs::directory_iterator(&quot;test&quot;)){    std::cout &lt;&lt; p &lt;&lt; std::endl;}</code></pre><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>这里最显著的就是, 嵌套的命名空间, 例如C++11会这么写:</p><pre><code class="C++">namespace A{    namespace B    {        namespace C        {            struct Foo{};            //...        };    };};</code></pre><p>然后C++17就直接这么搞:</p><pre><code class="C++">namespace A::B::C{    struct Foo{};    //...};</code></pre><p>static_assert<br>原来的静态断言, 你必须制定错误提示, 现在不用了, 直接给单个参数就好了, 下面是对比</p><pre><code class="C++">static_assert(false, &quot;sth. wrong&quot;); //C++11static_assert(false); //C++17, let compiler do message</code></pre><p>条件初始化<br>在if语句里面初始化相关判断的变量, 之后if代码块执行完毕, 自动析构; 多好. 直接看例子吧: (举锁的例子)</p><p>C++11我们这么写的一段代码:</p><pre><code class="C++">std::mutex mtx;std::vector&lt;int&gt; v;{    std::lock_guard&lt;std::mutex&gt; lock(mtx);    if(v.empty()) {        v.emplace_back(1);                      }}</code></pre><p>凸出来的一段<code>{ }</code>代码块, 好看么? 再看看C++17, 直接起飞:</p><pre><code class="C++">std::mutext mtx;std::vector&lt;int&gt; v;if(std::lock_guard&lt;std::mutex&gt; lock(mtx); v.empty()){    v.emplace_back(1);}</code></pre><p>演绎推导deduction guide<br>有人还是很羡慕 <code>JAVA的菱形语法</code>, 但是C++17可以直接省略泛型, 编译时会自动推导:</p><pre><code>std::pair p(1,1.5);</code></pre><p>直接推导为</p><pre><code class="C++">std::pair&lt;int, double&gt; p(1, 1.5);</code></pre><p>也就是说, 进行了隐式推导.</p><blockquote><p>当然你可以去写<code>显示推导</code>表达式, 个人认为比较麻烦, 除非你在写框架, 需要定义大量模板</p></blockquote><p><code>capture *this</code><br>lambda表达里面捕获外部的值, 以<code>值传递</code>的方式, 还是有的, 比如说, 在main线程里面, 你给A线程传递一个值, 这个时候传引用么? 可以么? 就怕真到A线程执行的时候, main线程已经改变这个值了, 要想保证A线程拿到的, 就是你main线程, 开启A线程时传递的值, 怎么办? <code>值传递</code>啊.</p><pre><code class="C++">[=, copy=*this]{}   //C++11[=, *this]{}        //C++17</code></pre><blockquote><p>还有一些其他的特性, 感觉<code>小修补</code>, 还不错.</p></blockquote><h2 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h2><p>std::search算法, 有点类似<code>std::find_first_of</code>, 但是它比find_first_of 更加适用于查找子串, 因为这个算法是以子串整体为单位.</p><p>再有就是<code>并行算法</code>.</p><blockquote><p>说并行算法, 我们说的最多的就是, 你开俩线程, 累加一个数组的前半部分和后半部分</p></blockquote><p>现在有了并行算法, 比如你拿<code>std::reduce</code>这个并行算法, 代替原来的 <code>std::accumulate</code> 求和, 性能直接翻翻, 还多.</p><blockquote><p>但是并行算法, 因为是标准指出的, 就看编译器怎么实现, 怎么去支持了…</p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>其他部分, 再说吧, 小修小补, 还行吧, <code>以后在说?</code></p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      以后全部的C++文章就在这里落脚了, C++17也在这里更新.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》之 HTTPS</title>
    <link href="www.merlinblog.site/2017/09/08/network-base-https.html"/>
    <id>www.merlinblog.site/2017/09/08/network-base-https.html</id>
    <published>2017-09-08T04:08:57.000Z</published>
    <updated>2017-10-16T01:52:01.515Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>加密传出相关的内容, 专门总结一下 https协议(专门研究加密SSL/HTTPS的话, 本文就会很长, 简单记录一下, <code>权当整理</code>了).</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/network-https.png" alt="post-cover"></p><p>上面一篇文章, HTTP中, 已经说过了, HTTP协议很难解决这三个问题:</p><pre><code>* 通信使用明文，不加密，内容可能会被窃听；* 不验证通信方的身份，因此有可能遭遇伪装；* 无法证明报文的完整性，所以有可能已遭篡改。</code></pre><p>换句话说, 有三种风险:(HTTP 协议直接使用了 TCP 协议进行数据传输)</p><ul><li>窃听风险：第三方节点可以获知通信内容。</li><li>篡改风险：第三方节点可以修改通信内容。</li><li>冒充风险：第三方节点可以冒充他人身份参与通信。</li></ul><p><strong>请求被篡改了?</strong><br>比如你在手机上打开应用内的网页时，有时会看到网页底部弹出了广告，这实际上就说明你的 HTTP 内容被窃听、并篡改了。</p><p>HTTPS 协议旨在解决以上三个风险，因此它可以：</p><ul><li>保证所有信息加密传输，无法被第三方窃取。</li><li>为信息添加校验机制，如果被第三方恶意破坏，可以检测出来。</li><li>配备身份证书，防止第三方伪装参与通信。</li></ul><p>也就是说:</p><blockquote><p><code>HTTP</code> + <code>加密</code> + <code>认证</code> + <code>完整性保护</code> = <code>HTTPS</code></p></blockquote><p><strong>如何实现?</strong></p><p>主要是在 http和tcp之间, 添加一个 TLS/SSL 加密层. (<code>一切计算机问题都可以通过添加中间层解决</code>)<br><img src="http://omotkhw3y.bkt.clouddn.com/network-https1.png" alt=""><br>HTTPS并不是应用层的一种新协议，而是在HTTP通信接口部分用SSL和TLS协议代替。因此，HTTP不再与TCP通信，而是先和SSL通信，再由SSL和TCP通信。因此，HTTPS就是身披着SSL协议这层外壳的HTTP。SSL协议是广泛使用的网络安全技术。</p><p>在采用 SSL 后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护这些功能。</p><p>这里面每一个细节都有大量内容, 密码怎么传输?(非对称加密时), 怎么用hash值防止篡改(完整性), 通信双方身份(证书校验).</p><p>加密方式, 一般是<code>对称加密和非对称加密结合</code>:</p><ul><li>非对称加密， 利用公钥加密的数据能且只能通过私钥解密，通过私钥加密的数据能且只能通过公钥解密。</li><li>对称加密, 速度快，但是假设秘钥由服务器保存，如何安全的让客户端得到秘钥是需要解决的问题。</li></ul><p>例如<code>使用非对称加密</code>技术传输的过程可能是这样的, 包括<code>传递对称秘钥</code> + <code>传输数据</code>:</p><p>传递秘钥: (常识: 对称秘钥加密数据, 减轻服务器压力; 非对称秘钥传输加密秘钥)</p><ul><li>客户端: 你好，我要发起一个 HTTPS 请求，请给我公钥</li><li>服务端会将自己的证书发送给客户端，其中包含了服务端的公钥(也就是说该公钥是由证书保证的, 证书是本次可靠性传输的基本)。</li><li>客户端用该公钥加密之后对称秘钥, 该秘钥是之后c-s传输数据时给数据加密用的</li><li>服务端收到这个加密后的秘钥, 用自己的私钥解密, 拿到秘钥; 并告知服务器”好, 以后就用这个秘钥进行数据加密”</li></ul><p>这实际上是个握手过程. (<code>别再问证书机构的公钥怎么传输的...</code>, 因为可能直接内置在电脑中了)</p><blockquote><p><strong>HTTPS的四次握手可能会影响传输性能, 但更多的性能应该是算法问题, 这里几乎可以忽略不计</strong></p></blockquote><p>基于非对称加密的传输过程如下：(直接使用公钥密码术也行, 不过服务器运算压力可能比较大)</p><ul><li>客户端使用公钥将信息加密，密文发送给服务端</li><li>服务端用自己的私钥解密，再将返回数据用私钥加密发回客户端</li><li>客户端用公钥解密(公钥可以解密, 说明确实是相关服务器发过来的)</li></ul><p>其中发送的内容也会有<code>内容摘要</code>信息, 即hash数据(只要内容被篡改一点, 接收方解密数据拿到的hash值一定和篡改过的内容摘要信息值不同)<br>(内容或者数据是否被篡改, 统一看hash值即可)</p><p>至于身份嘛, 用证书解决.(由权威机构颁发证书，再加上证书校验机制，避免第三方伪装参与通信) 这里的证书是服务器证明自己身份的工具，它由权威的证书颁发机构（CA）发给申请者。如果证书是虚假的，或者是自己给自己颁发的证书，服务器就会不认可这个证书并发出警告.</p><blockquote><p>核心内容我已经全部都说了, 其他扯到太多网络安全的内容(包括一些算法, 比如摘要算法, 加密算法 aes des等), 水平有限, 不展开说.</p></blockquote><p>哦, 服务器上开放 HTTPS 所需的443端口; 对于原先的80端口，需做重定向的跳转。将原先访问 HTTP 协议的用户，自动跳转用 HTTPS 上来.</p><p><strong>我下面列举的参考资料最好读一下, 比我总结的好.</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《图解HTTP》 人民邮电出版社</li><li><a href="http://www.jianshu.com/p/072a657337ae" target="_blank" rel="external">http://www.jianshu.com/p/072a657337ae</a></li><li><a href="https://github.com/jasonGeng88/blog/blob/master/201705/https.md" target="_blank" rel="external">https://github.com/jasonGeng88/blog/blob/master/201705/https.md</a>  看它的证书部分</li><li><a href="https://segmentfault.com/a/1190000004523659" target="_blank" rel="external">https://segmentfault.com/a/1190000004523659</a> 看它的加密部分</li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      在 《图解HTTP》 这本书后半部分, 讲述了 https. (该文不写很长)
    
    </summary>
    
      <category term="books" scheme="www.merlinblog.site/categories/books/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>《图解HTTP》之 HTTP</title>
    <link href="www.merlinblog.site/2017/09/07/network-base-http.html"/>
    <id>www.merlinblog.site/2017/09/07/network-base-http.html</id>
    <published>2017-09-07T02:06:35.000Z</published>
    <updated>2017-10-16T00:37:27.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实我日常工作中接触 HTTP 的内容并不多, 但是懂 HTTP 协议也是必须的.</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/network-http.jpg" alt="post-cover"></p><p>当然 HTTP 的内容虽然不难, 但是确实很多; 然而拿一本书去说, 就有点儿过分了吧, 比如<code>《图解HTTP》</code>.<em>如果不是京东需要凑单, 我肯定不买这本书</em></p><blockquote><p>如果后续相关工作, 与其有关(可能性很小), 再回来详细&amp;仔细梳理总结.</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 OSI 七层模型中， HTTP 协议位于最顶层的应用层中。通过浏览器访问网页就直接使用了 HTTP 协议。<br>使用 HTTP 协议时， 客户端首先与服务端的 80 端口建立一个 TCP 连接， 然后在这个连接的基础上进行请求和应答，以及数据的交换。</p><h2 id="模型定位"><a href="#模型定位" class="headerlink" title="模型定位"></a>模型定位</h2><p>或者说与其他模型的关系, 具体如下:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-http1.png" alt=""></p><p>补充:<br>由 HTTP 协议加载出来的网页，通常使用 HTML 语言来描述，因此 HTML 也可以理解为网页的一种数据格式。HTML 是一段纯文本，可以指定网页中的文字、图像、音频视频图片、链接，以及它们的颜色、位置等。无论计算机的底层结构如何，也无论网络底层使用了哪些协议，使用 HTML 展示出来的效果基本上是一致的。从这个角度来说 HTML 位于 OSI 七层模型的<code>表现层</code>。</p><h2 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h2><p>HTTP 有两个常用版本，分别是 1.0 和 1.1。主要区别在于 HTTP 1.0 中每次请求和应答都会使用一个新的 TCP 连接，而从 HTTP 1.1 开始，运行在一个 TCP 连接上发送多个命令和应答。因此大幅度减少了 TCP 连接的建立和断开，提高了效率。</p><p>也就是说, 主要区别是 HTTP1.1 是默认采用的<code>长连接</code>, 而 HTTP1.0是短连接.(具体是通过 Connection头信息, 和 keep alive信息)</p><p>参考如下:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-http2.png" alt=""></p><p>当然版本不同, 也有一些字段不同, 比如<code>pragma</code>纯碎保留做后面版本的兼容, 实际上已经没有太多作用.</p><p>还有其他一些字段, 在不同版本间有差别, 具体可以参考下面的<strong>HTTP首部选项</strong>.</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>一般就是用于请求网络资源, 比如图片,文件,文字等信息. 就像下图所描绘的:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-http3.png" alt=""></p><p>当然 Restful API更好的利用 HTTP 协议的优势.</p><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><blockquote><p>由于 http 协议属于应用协议, 所以相比http协议要简单许多. 但这不表示它的选项或者参数少.</p></blockquote><p>细枝末节的东西不讲太多, 这里主要<strong>总结以下内容</strong> :</p><ul><li>请求方式(主要是post/get)</li><li>cookie和session</li><li>http报文格式</li><li>http首部选项</li><li>状态码(返回码)</li></ul><h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><p>HTTP 有八种请求（也称方法），其中最常见的是 GET 请求和 POST 请求。</p><p>GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据，除了用途上的区别，它们还有以下这些不同：</p><ul><li>GET 请求可以被缓存，可以被收藏为书签，但 POST 不行。</li><li>GET 请求会保留在浏览器的历史记录中，POST 不会。</li><li>GET 请求的长度有限制（不同的浏览器不一样，大约在几 Kb 左右），URL 的数据类型只能是 ASCII 字符，POST 请求没有限制。</li><li>GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。<br>POST 请求仅比 GET 请求略安全一点，它的数据不在 URL 中，但依然以明文的形式存放于 HTTP 的请求头中。</li></ul><p>个人觉得, 主要差别就是 url 上是否会明文显示一些内容(比如传递了相关的参数).</p><p>非加密格式, 所以如果不是使用<code>https</code>协议传输, 最好自己先把要发送的内容加密, 比如简单的 base64, 复杂的 md5.</p><p>(btw: https协议, 相对复杂一些, 可以参考另外一篇文章)</p><h2 id="cookie-session"><a href="#cookie-session" class="headerlink" title="cookie/session"></a>cookie/session</h2><p>HTTP 是一种无状态的连接，客户端每次读取 web 页面时，服务器都会认为这是一次新的会话。<br>但有时候我们又需要持久保持某些信息，比如登录时的用户名、密码，用户上一次连接时的信息等。这些信息就由 Cookie 和 Session 保存。</p><blockquote><p>即cookie/session都是用来保存一些数据信息</p></blockquote><p>这两者的根本性区别在于，cookie 保存在客户端上，而 session 则保存在服务器中。</p><p>由此我们还可以拓展出以下结论：</p><ul><li>cookie 相对来说不安全， 浏览器可以分析本地的 cookie 进行 cookie 欺骗</li><li>session 可以设置超时时间， 超过这个时间后就失效，以免长期占用服务端内存</li><li>单个 cookie 的大小有限制（4 Kb），每个站点的 cookie 数量一般也有限制（20个）。</li><li>客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。</li><li>当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。</li></ul><p>以前有一种原始的方式, <strong>防止表单重复提交</strong>就是用session进行验证的; <strong>单服务器验证码</strong>貌似也可以用session去做.</p><h2 id="http报文格式"><a href="#http报文格式" class="headerlink" title="http报文格式"></a>http报文格式</h2><p>不管是1.0, 还是1.1版本的 http 协议, 他们的报文格式都是类似的, 按照发送端的不同, 一般分为<code>请求报文</code>,<code>响应报文</code>.<br>大致上可以称为<code>是三段式</code>: (<strong>首部和内容之间有空行</strong>)</p><ul><li>schema 部分 (说明请求方法, url, http协议版本, 或者返回状态码)<br>严格来说, schema 部分, 也算做首部.</li><li>首部字段部分 (罗列一些重要字段, 约束内容或者浏览器或者服务器行为)</li><li>内容实体部分 (html正文或者请求参数等, 还有可能是一些奇奇怪怪的”乱码”, 或者加密的内容)</li></ul><blockquote><p>没必要去记忆, 拿浏览器工具, 分析报文即可看到</p></blockquote><p>请求报文的构成, 例如:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-http-request.png" alt=""></p><p>响应报文格式的构成, 例如:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-http-response.png" alt=""></p><h2 id="http首部选项-重要"><a href="#http首部选项-重要" class="headerlink" title="http首部选项(重要)"></a>http首部选项(重要)</h2><p>该部分对于 web 开发人员, 不管前端还是后端都比较重要.<strong>该部分简单, 但是内容比较多(上厕所的时间翻一下, 差不多3次就看完了)</strong></p><blockquote><p>网上资料对于该部分的总结也是七零八落, 没有个标准说法. 这里尽量准确记录.</p></blockquote><p>一般格式:</p><pre><code>首部字段名: 字段值</code></pre><p>例如: </p><pre><code>Content-Type: text/html</code></pre><h3 id="通用首部字段"><a href="#通用首部字段" class="headerlink" title="通用首部字段"></a>通用首部字段</h3><p>HTTP/1.1通用首部字段是指，请求报文和响应报文双方都会使用的首部。内容如下: page 80<br>1）Cache-Control：通过指定首部Cache-Control的指令，就可以操作缓存的工作机制。如no-cache，public等。首部字段 Cache-Control 能够控制缓存的行为。<br>2）Connection：主要有两个作用，控制不再转发给代理的首部字段、管理持久连接。<br>3）Data：首部字段data表明创建HTTP报文和日期。<br>4）pragma ：报文指令。与http1.1之前的版本兼容 (比如 cache的设置, 就可以通过它)<br>5）Trailer：首部字段Trailer会事先说明在报文主体后记录了哪些首部字段，可以应用在HTTP1.1版本分块传输编码时使用。<br>6）Transfer-Encoding：规定了传输报文主体时采用的编码方式<br>7）Upgrade：用于检测HTTP协议及其他协议是否可以使用更高版本进行通信<br>8）Via ：追踪客户端与服务器之间的请求响应和响应报文的传输途径。还可以避免请求回环的发生。<br>9）Warning：告知用户一些与缓存相关问题的警告</p><h3 id="非HTTP-1-1通用首部"><a href="#非HTTP-1-1通用首部" class="headerlink" title="非HTTP/1.1通用首部"></a>非HTTP/1.1通用首部</h3><p>有一些使用频率很高, 但是归于非首部字段的内容, 比如</p><ul><li>Cookie</li><li>Set-Cookie</li><li>Content-Disposition</li></ul><p>例如:</p><pre><code>   字段                  作用                 首部类型Set-Cookie  开始状态管理所使用的Cookie信息    响应首部字段Cookie      服务器接收到的Cookie信息         请求首部字段</code></pre><p>例如<code>Cookie: status=enable</code>.</p><p>该部分请参考 <code>RFC4229 HTTP Header Field</code> 或者相关wiki.</p><h3 id="请求首部"><a href="#请求首部" class="headerlink" title="请求首部"></a>请求首部</h3><p>请求首部字段是从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关优先级等内容。</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-http-head1.png" alt=""></p><h3 id="响应首部"><a href="#响应首部" class="headerlink" title="响应首部"></a>响应首部</h3><p>响应首部字段是由服务器向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息。</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-http-head2.png" alt=""></p><h3 id="实体首部"><a href="#实体首部" class="headerlink" title="实体首部"></a>实体首部</h3><p>实体首部字段是包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体信息相关的信息。</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-http-head3.png" alt=""></p><blockquote><p>由于浏览器的内容实现逻辑可能不同, 所以对不同首部/重复首部的解释也可能不同, 这就需要兼容性测试或者适配.</p></blockquote><h2 id="状态码-返回码"><a href="#状态码-返回码" class="headerlink" title="状态码(返回码)"></a>状态码(返回码)</h2><p>该内容不是很多, 主要有一下几个类别:</p><ul><li>2XX 成功<ul><li>200 OK</li><li>204 NO CONTENT</li><li>206 Partial Content</li></ul></li><li>3XX 重定向<ul><li>301 Moved Permanently</li><li>302 Found</li><li>303 See Other</li><li>304 Not Modified</li><li>307 Temporary Redirect</li></ul></li><li>4XX 客户端错误<ul><li>400 Bad Request</li><li>401 Unauthorized</li><li>403 Forbidden</li><li>404 Not Found</li></ul></li><li>5XX 服务器错误<ul><li>500 Server Internal Error</li><li>503 Service Unavailable</li></ul></li></ul><p>一般把错误码直接返回给用户的, 都是官僚主义严重的, 至少是不重视用户体验的; 还在考虑生存问题的互联网公司, 一般不会直接返回状态码给用户.</p><hr><h1 id="Vs-HTTPS"><a href="#Vs-HTTPS" class="headerlink" title="Vs HTTPS"></a>Vs HTTPS</h1><blockquote><p>btw: http明文传输, 并且不验证通信双发的身份, 也不保证报文中途是否是被篡改; 所以尽早升级到https吧.</p></blockquote><p>(不升级, 也可以, 但是要通过其他简介方式做很多事情; 比如保证不被篡改, 仅通过 md5首部还不足以解决问题)</p><p>差不多了, 就写这么多.</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《图解HTTP》 人民邮电出版社</li><li><a href="http://www.jianshu.com/p/6e7521041e92" target="_blank" rel="external">http://www.jianshu.com/p/6e7521041e92</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      本文主要讲解和总结一下HTTP相关的内容
    
    </summary>
    
      <category term="books" scheme="www.merlinblog.site/categories/books/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>经验教训汇总</title>
    <link href="www.merlinblog.site/2017/09/05/lessons-history.html"/>
    <id>www.merlinblog.site/2017/09/05/lessons-history.html</id>
    <published>2017-09-05T02:10:08.000Z</published>
    <updated>2017-09-24T07:55:57.607Z</updated>
    
    <content type="html"><![CDATA[<p>本文不记载我经历过的事情, 但是记载我遇到过的 <code>教训</code> &amp;成长, 以及 <code>遗憾</code> . 此篇是<code>最终篇</code>, 以后个人教训全部更新在这里.</p><blockquote><p>本文长期更新(最近一次2017年9月)</p></blockquote><a id="more"></a><p>修身, 修心, 积累财富, 一个不能少. 你说呢?</p><p>更新时间表:</p><ul><li>2017-07-20 17:50:08 大巨变之后</li><li>2017-09-05 10:10:09 重返上海</li></ul><p>本文最新更新主题: </p><blockquote><p>言出必行, 信守承诺, 并且不再轻易&amp;随意承诺.</p></blockquote><hr><h2 id="初心"><a href="#初心" class="headerlink" title="初心:"></a>初心:</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/history.jpg" alt=""></p><p>实习结束时, 我的<code>初心</code>.</p><hr><h2 id="2015-2017"><a href="#2015-2017" class="headerlink" title="2015-2017"></a>2015-2017</h2><p>两年内我遇到的问题, 可能是所有年轻人遇到的问题, 对于外物表象太多在乎, 消费习惯也不好. </p><p>痛定思痛, 总结如下:</p><ul><li>生活应该 “极简” . 人的欲望, 愿望小了, 那么对于外界的依赖也就少了, 得到快乐也就相对容易了. 简谱的生活, 像很多长辈一样, 并不是一件很羞耻的事情. 很多懂事儿比较玩的同龄人可能到40岁才明白, 简单的真谛.</li><li>负债有风险. 不管是用于投资, 经营, 甚至是消费, 负债就相当于把你的未来提前透支了; 不说是一种危险的做法, 但至少是不保险的做法. 有时候需要根据具体的情况具体分析, 但是有一条, 应该死守的规则: 绝对不能去负债消费</li><li>虚荣心, 面子对于个人的生活, 家庭的和睦没有半点儿作用; 并且虚荣心还会牵制一个人, 令他的思想, 行动不自由, 很多时候会做出愚蠢的事情; 也不要在乎别人的评论, 做好自己, 过好你的生活</li></ul><p>简言之:</p><pre><code>* 生活应该简谱, 从简.* 虚荣心有害, 不要在乎别人怎么说, 做好你自己(这本身就很难)</code></pre><p>而今进入2017年下半场, 南开和交大的同学, 也陆续要毕业, 心里也不再焦躁了; </p><p>我们的人生本来就不是一个模子刻出来的, 大家有自己要走的路, 做好你自己, 足矣.</p><hr><h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p><code>易经</code> 中有6个境界, 感觉我当前正处于 <code>跃龙</code> 的年纪, 一直很骄傲, 自傲有才华, 希望进入2017下半年~2018年, 可以学会: 谦虚, 谦让.</p><h3 id="2017年9月"><a href="#2017年9月" class="headerlink" title="2017年9月"></a>2017年9月</h3><pre><code>言出必行, 真的很难! 所以不要轻易许诺, 任何人.</code></pre><p>追求完美的时候, 是最看一个人品性的时候. 当你遇到别人以前从未遇到的困难, 网上找不到任何相关的资料的, 或者走了很长一段时间看不到结果, 甚至自己都开始怀疑自己的时候, 坚持 &amp; 不妥协, 不退让, 真的很难. 但是不管这么说, 如果自己说过的话, 许诺的承诺, 就一定要实现. 然后记住, <code>不要轻易许下承诺</code>, 因为未来的不可控性太强了.</p><hr><p>修身, 修心, 积累财富, 一样不能少. 控制”意欲”的同时, 提高”认识力”.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      我过去所得到的教训
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Mustang</title>
    <link href="www.merlinblog.site/2017/09/04/mustang.html"/>
    <id>www.merlinblog.site/2017/09/04/mustang.html</id>
    <published>2017-09-04T09:55:16.000Z</published>
    <updated>2017-09-24T07:34:38.147Z</updated>
    
    <content type="html"><![CDATA[<p>老东家的部门经理给说了很多人生经验, 我觉得最重要的是他说的四个字 <code>顺其自然</code> (let it be),  但是有时候自己有选择的时候, 也要注意好跟随自己的意志.顺气自然的意思是, <code>在自己能力范围以内, 做到最好</code> . 星爷不是说了么, “做人如果没有梦想, 那啥咸鱼.” 平坦的路, 让爱走的人去走; 我走一条独特点儿的.</p><blockquote><p>就像编程环境的配置一样, 一定要让自己的觉得舒服. 关注自身的需求和成长.</p></blockquote><p>本文说的是我 <code>选车</code> , 其实也是思考自身的过程. 适合的不是我想要的, 想要的不适合我. 顺气自然吧.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/%E9%87%8E%E9%A9%AC.png" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近一直有打算买车, 毕业的时候, 父母也说过”回家就给你配一台宝马”, 可是我知道, 父母其实还是希望我在武汉安家(以车把我绑定在一个安定舒适的环境里面, 找对象之后很快就结婚, 生孩子啥的). 我的同学里面有人渴望这种生活, 但是他们不知道, 这种生活其实是非常乏味无趣的.</p><p>下面讲述一下, 我对自己现状, 能力的评估, 选车过程.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="人生不止一辆车"><a href="#人生不止一辆车" class="headerlink" title="人生不止一辆车"></a>人生不止一辆车</h2><p>刚毕业的时候, G家里就给配了车, 那个时候很羡慕, 但是G是女孩子, 自己能力不够, 家里给补贴很正常. 但是作为男生的话, 要我找家里开口要, 呵呵. 真心做不到. 那个时候手里有3W(家里给的)左右, 心里心高气傲, 想买最好的, 比如 <code>Benz AMG</code> 系列. (那个时候, G应该是一台普通的大众轿车, 猜的, 具体没有看到她的数据)</p><p>一年后, 手里有14W了, 可是那个心里对未来的预期, 对自己的评估还是不够, 还是决定要买最好.</p><p>两年后, 今天, 差不多27W了, 身边的同事有换<code>雅阁</code>的, 有买本田高端系列<code>讴歌</code>的. 这个时候, 也就是现在, 我在考虑自己将来到底想做什么的时候, 我在想是不是应该买陈润生那种<code>5系</code>. 不过那车当前的售价, 我还是承受不起(全部自己承担的话).</p><p>你看到, 两年的时间, 我的心是变来变去; 一方面说明我的财力在变, 另外一方面, 也说明了我对于自己的认知再改变.</p><p>或者说, 我经历的多了, 也更加成熟了.</p><p>其实人生中重要的事情, 远没有那么纠结, G以前跟我说了这样一句话<code>你一生又不是只买一辆车</code>. 考虑到当前的现状, 考虑到未来的可能, 无论如何, 我也想说.</p><blockquote><p>人生应该浪费在美好的事物上</p></blockquote><p>就像编程环境的配置一样, 你一定要让自己的觉得舒服. </p><blockquote><p>任何选择都是有风险有代价的. 也没有一辆完美的车.</p></blockquote><h2 id="备选"><a href="#备选" class="headerlink" title="备选"></a>备选</h2><p>下面是我的一些备选考量, 以及其优缺点.</p><ul><li>2018凯美瑞混动<br>怎么说呢? 买混动为了省油但是最终算下来, 根本不省钱. 但是这台车有一个特点, 就是技术先进(丰田的混动系统), 环保. 而且在我的财力承受范围内.<br>不好的是, 这台车, 没有任何的挑战, 激情. 感觉不是太喜欢, 也不能说不喜欢. 总感觉买了这台车, 心里感觉怪怪的, 总是有一些落差.</li><li>大众途观L 380TSi 自动四驱豪华版  28.98(两驱版本25.98)<br>这种考虑, 纯碎是因为我那个走不出舒适区的自我在思考. 人人都想过安逸的生活. 我也有这样的一面. 想着, 如果过几年我结婚了, 孩子也很快出生了. 那么需要一台家用车, 大, 实用, 那么一台大众的SUV是最好不过了. 可是啊, 不是别人喜欢SUV, 你就去跟风. 这个基本术语末选项. </li><li>福特Mustang 2.3T 性能版 (注意是 50周年纪念版, 不是2017版)<br>这个是一眼我的就看上了的. 平民跑车. 作为一个敢于追求自我的人, 如果有能力, 就要勇敢尝试和挑战, 并实践. 虽然豪华品牌的跑车, 我是买不起的; 虽然野马V8的旗舰我也买不起. 但是做任何选择, 都不要让自己后悔. 只是这台车, 对于我平时的生活, 工作, 都没有任何帮助. 纯碎是心里想要.</li></ul><p>为什么不考虑BBA?<br>我的预算在30~40W之间, 而BBA的车, 如果不是50W往上走, 选择BBA, 在我心里觉得这人有点儿可怜. 就是… 实在点儿吧. 纯属于自己意见(言语不当之处, 还请多多包涵). 因为有些大佬更专注家庭, 其实以性价比作为考量, 除了选择两田, 也会选择BBA. 萝卜青菜各有所爱, 求同存异.</p><h2 id="详细剖析"><a href="#详细剖析" class="headerlink" title="详细剖析"></a>详细剖析</h2><p>主要剖析 <code>野马</code> 和 <code>凯美瑞</code> .</p><p>还剖析个啥, 日本车,特别是丰田, 那技术牛的很, 马自达都快喊丰田爸爸了; 福特车我一般对其变速箱, 发动机没有太大的信心. 但是野马是一辆情怀车, 更是一辆<code>平民跑车</code>.</p><p>不剖析了, 直接上图(图片来自网络).</p><blockquote><p>小马驹</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/mustang_front.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang_rear.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang_side.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang1.jpg" alt=""></p><p>确实非常喜欢. 平民跑车, 样子果然不错; 就是, 不实用.</p><blockquote><p>Camery</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/camery1.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery1_1.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery1_2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery3.jpg" alt=""></p><p>日常家用, 首选, 而且不容易坏, 三大件儿都好.</p><h2 id="需求match"><a href="#需求match" class="headerlink" title="需求match"></a>需求match</h2><p>其实考虑了很多问题:</p><ul><li>我的钱够不够?</li><li>买车属于投资还是消费?</li><li>是否值得?</li><li>需要一辆代步车么? </li><li>需要省油么? </li><li>为什么买车?(用途)</li><li>日常使用的方便程度?</li><li>如果经常坏怎么办?</li></ul><p>工作起来, 我就像个疯子, 住在公司旁边, 一心全在项目上; 所以买车代步不过是个笑话. 没有家庭, 所以基本也没有什么负担, 所以省钱省油也是净扯. 至于丰田的车开不坏, 福特的车爱断轴, 这些谣言就像早期德系品牌宣传日系车皮薄一样. 买车属于消费, 买了之后就只有贬值的分. 钱基本还是够的.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p><code>凯美瑞</code>是目前最适合我的车, 但不是我最想要的车;<br><code>野马</code>是我最想要的车, 但却不是目前最适合我的车.</p></blockquote><p>苦笑, 等时机成熟吧. <code>革命尚未成功, 同志还需努力</code>.</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>两年的时间, 同学中有人抽时间去上海交大, 南开读了研, 而我积累的了许多工作经验和社会经验.</p><blockquote><p>这一条路, 一旦走出来, 轨迹势必就不一样了. 尽全力吧, 否则很危险!</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/%E6%88%90%E9%95%BF%E6%9B%B2%E7%BA%BF.jpg" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://v.autohome.com.cn/v-100569.html#pvareaid=2042227" target="_blank" rel="external">http://v.autohome.com.cn/v-100569.html#pvareaid=2042227</a></li><li><a href="http://v.autohome.com.cn/v-34389.html#pvareaid=2042227" target="_blank" rel="external">http://v.autohome.com.cn/v-34389.html#pvareaid=2042227</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      小伙你网络库的源码都研究完了么, 就跑这儿若无其事的看车?
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Merlin&#39;s Emacs</title>
    <link href="www.merlinblog.site/2017/08/31/my-emacs.html"/>
    <id>www.merlinblog.site/2017/08/31/my-emacs.html</id>
    <published>2017-08-31T07:59:14.000Z</published>
    <updated>2017-09-24T07:31:45.671Z</updated>
    
    <content type="html"><![CDATA[<p>最开始(刚开始工作的时候)接触的 IDE 其实是 SourceInsight . 那时候很多 android 框架的源码要看, 要分析, 也一度想要购买正版 SI. 后来机缘巧合单位的老前辈推荐我用 emacs, 从此踏上一条不归路.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/emacs_ecb.png" alt=""></p><p>本文主要记载我的emacs配置文件, 以及配置方法. 先给一个图吧. 中间可能有一些复杂，但是按照从简单到复杂的步骤其实还好; 想要省心省力, 不折腾的同学, 可以去购买一些商业的IDE, 节省了配置的时间.</p><p>(效率上取决于对于IDE的熟悉情况, 个人以为emacs没有上限)</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>每当别人像我展示它的 <code>vim</code> 的时候, 我都是不屑的.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/vim.png" alt=""></p><p>但是渐渐的, 如果有初学者问我要不要深入emacs, 我都会建议它: 最好不要, vistual studio code, qtcreator等都是不错的选择. 因为这东西会让你投入大量的时间折腾, 而且一旦习惯了快捷键操作, 效率是很高, 不过换一种没有配置的环境, 就会感觉很不习惯的.</p><blockquote><p>Emacs 就是一个坑, 一个永远挖不完坑, 会上瘾的.</p></blockquote><p>闲话不多说, 马上来正文. 效率Up Up Up!</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>根据自己的用途，一步步配置环境，下面按照顺序叙述：</p><ul><li>配置基本faces和主题</li><li>配置按键</li><li>配置语言支持</li><li>配置hightlight</li><li>配置ibuffer</li><li>配置dropdownlist</li><li>配置gdb</li><li>配置autosave</li><li>配置session</li><li>配置showhide</li><li>配置tabbar</li><li>配置symbol-overlay (f8,f9)</li><li>配置cscode</li><li>配置autocomplete和yasippet</li><li>配置cedet</li><li>配置ecb</li></ul><blockquote><p>中途还有一些个人使用习惯，不过多解释，只贴代码</p></blockquote><h2 id="明确用途"><a href="#明确用途" class="headerlink" title="明确用途"></a>明确用途</h2><p>我使用emacs, 主要是在远程shell到服务器以及linux环境下做开发的(但不是所有的内容, 什么看网页啊, 看视频啊, 写邮件啊则不是), 归纳起来如下:</p><ul><li>linux下的终端操作, 即shell中命令操作(所有命令)</li><li>c/c++开发, 包括代码的编写(各种补全, 提示等), 测试用例的编写, 调试, 日志输出, doc输出</li><li>研究源码, 这个需求和上面有一定的区别, 研究源码的时候更加关注架构层次, 模型, 甚至详细的调用关系</li><li>linux下的shell脚本编写, 可能包括一部分python脚本</li><li>org-mode 文档的编写</li><li>git 日志查看以及提交(可能会结合gitk)</li></ul><p>(我写 Java 和 Python 应用程序统统使用IDE, JetBrain的开发环境; 一般不写QT代码, 界面无感)</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>中途的半成品<br><img src="http://omotkhw3y.bkt.clouddn.com/emacs_tmp.jpg" alt=""> </p><p>最终配置差不多就是这个样子:<br><img src="http://omotkhw3y.bkt.clouddn.com/emacs-done.jpg" alt=""></p><pre><code class="lisp">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;From Merlin deepin15.4;;;;;;;;;;;;;;;;;;;;;;;;;;;; File name: ` ~/.emacs &#39;    ;;; ---------------------;;;;;; If you need your own personal ~/.emacs;;; please make a copy of this file;;; an placein your changes and/or extension.;;;;;; Copyright (c) 2017 deepin 15.4.1;;;;;; Author: Merlin Yu, &lt;wizardmerlin945@gmail.com&gt; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 配置上, 除了基本配置外， 插件包可以采用自动管理；不过我还是采用 手动方式;; (具体的版本&amp;加强包可能自动下载不到);;(load-file &quot;/home/merlin/.emacs.d/lisp/cedet/cedet-1.1/common/cedet.el&quot;);;自动包管理;;(require &#39;merlin-init-autopackage);;;;; 手动方式(即下面自动递归添加~/.emacs.d/lisp内的包);;(add-to-list &#39;load-path &quot;~/.emacs.d/lisp&quot;)(defun add-subdirs-to-load-path (dir)  &quot;Recursive add directories to &#39;load-path&#39;.&quot;  (let ((default-directory (file-name-as-directory dir)))    (add-to-list &#39;load-path dir)   (normal-top-level-add-subdirs-to-load-path)))(add-subdirs-to-load-path &quot;~/.emacs.d/lisp&quot;);;;;;;;;;;;;;;;;;;;;基本配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;配置基本的facet和主题(load &quot;merlin-init-ui&quot;);;配置基本并且常用的设置(load &quot;merlin-init-base&quot;);;配置高效的快捷键(这个要在相关的扩展插件之后);;也包括开发语言相关的(load &quot;merlin-init-key&quot;);; 配置语言模式(load &quot;merlin-init-language-mode&quot;);;;;;;;;;;;;;;;;;;;手动配置的各种插件;;;;;;;;;;;;;;;;;;;;;;;;;;;;更好的自动保存插件(load &quot;merlin-init-autosave&quot;);;配置高亮当前行(load &quot;merlin-init-hl-line&quot;);; 配置高亮查找(load &quot;merlin-init-symbol-overlay&quot;);;配置自动补全(load &quot;merlin-init-autocomplete&quot;);; 代码折叠(本来希望依靠cedet的, 结果它不靠谱)(load &quot;merlin-init-showhide&quot;);;配置tab栏(注意只有图形化界面可以使用);;(load &quot;merlin-init-tabbar&quot;);;不要配置tabbar了, 给ecb腾出快捷键(terminal使用场景偏多);;配置shell(load &quot;merlin-init-shell&quot;);;配置gdb(load &quot;merlin-init-gdb&quot;);;配置书签 (我一般不使用书签, 寄存器);;(load &quot;merlin-init-bookmark&quot;);;配置 cscope(load &quot;merlin-init-cscope&quot;);;配置git;;(load &quot;merlin-init-git&quot;);;配置cedet(load &quot;merlin-init-cedet&quot;);;;配置ecb(load &quot;merlin-init-ecb&quot;);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not yet---begin::::::::::;;;ediff;;;dried;;;doxygen;;compile;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not yet---end::::::::::;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;配置浏览器(load &quot;merlin-init-browser&quot;);;ibuffer;;不同于系统自带的buffer, 它会单独打开一个buffer, 作为buffer的管理页面(load &quot;merlin-init-ibuffer&quot;);;保存session（下次启动的时候会在最近打开的菜单栏中显示）;;(load &quot;merlin-init-session&quot;);;配置desktop.el(每次启动的时候自动加载上次没有关闭的);;这个东西必须放在最后， 确保其可以正确辨别文件所需要的模式(load &quot;merlin-init-desktop&quot;)</code></pre><h3 id="参考gihub"><a href="#参考gihub" class="headerlink" title="参考gihub"></a>参考gihub</h3><p>代码太多了， 我直接上传了 <a href="">github</a></p><h2 id="补充配置"><a href="#补充配置" class="headerlink" title="补充配置"></a>补充配置</h2><p>一些有用的，但是我个人又没有配置的</p><p>在配置yasnippet的时候，注意到了他的已经知道的模板</p><pre><code>yasnippet:高效设置:C++ mode(c++独有的)acl            cni          delete              ffo              gnn     ita              mrg         operator[]        psc     rpl      std_colon   tfmacm            cnt          delete[]            fil              gnr     iterator         msm         operator+         pst     rtc      sth         thisajf            const_[]     doc                 fin              gtest   ltr              mxe         operator+=        ptc     rte      sti         throwalo            constructor  d_operator          fixture          ignore  lwr              namespace   operator_istream  ptn     rvc      sto         trmano            cout         d_operator[]        fln              ihp     lxc              nno         operator_ostream  public  rvr      str         tryassert         cpb          d_operator[]_const  fnd              ihu     map              ns          ostream           rci     shf      sts         trywbeginend       cpi          d_operator_istream  fne              inline  member_function  nth         pack              rmc     spt      stv         ucpboost_require  cpn          d_operator_ostream  fni              io      mkh              nxp         phh               rmf     srh      swr         uprcerr           cpp          dynamic_casting     fori             ipr     mme              oit         ppt               rmi     srn      template    uqecin            cpy          enum                fre              ipt     mne              operator=   private           rmv     srt      test case   usingclass          cstd         eql                 friend           iss     module           operator==  protected         rpc     sstream  test_main   vectorclass11        d+=          erm                 fun_declaration  isu     mpb              operator!=  prp               rpi     std      test_suiteC mode (主要是添加一些头文件)assert  compile  define  malloc  packed  printf  stdio  stdlib  string  union  unistdcc mode(c,c++共有的)case  else              fopen  for_n                 if     inc    main  member_description  printf  switch   typedefdo    file_description  for    function_description  ifdef  inc.1  math  once                struct  ternary  while</code></pre><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><p>这里记录一下，算是一个我自己的备忘吧.</p><p>Emacs中的按键不计其数，也可以自行设定，因为按键表示相应的lisp函数的快捷方式. 改坏了怎么办?, 把.meacs文件删除就好了.</p><h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><p>emacs的启动参数:</p><pre><code>emacs -q   (安静启动, 不执行.emacs文件)emacs -u joe  (使用joe用户的.emacs启动)emacs --debug-init (调试模式启动)emacs -nw  (terminal 中启动)emacs practice.b --insert myfile  (启动practice.b文件, 并把myfile插入到打开的buffer中)emacs --insert myfile (把myfile插入到临时的buffer中)emacs +15 practice.b (打开文件,并定位到15行; 注意, 如果是输入的数字长于文件的总长度, 那么就会定位到文件结尾)</code></pre><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><p><code>C-h t</code> 查看教程, 该教程看完, 用熟悉;  初次之外可以查看 info 手册:</p><p><code>C-h i</code> , 之后使用m+关键词查看, d返回, 回车是选中, 还可以使用u和l:翻页和返回上次浏览的地方)</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>使用man手册</p><ul><li><code>M-x woman</code></li><li><code>M-x man</code></li><li>然后输入相关的关键字</li></ul><p>我一般使用 <code>M-x man</code>.<br>对于man手册的支持, emacs的woman还要去解析man文件(<code>/usr/share/man</code>), 感觉比较坑爹; </p><h3 id="基本按键"><a href="#基本按键" class="headerlink" title="基本按键"></a>基本按键</h3><ol><li>C-x i  插入文件(在已打开的文件内插入文件)</li><li>C-x, C-w 另存为</li><li>C-x u 撤销(C-/)</li><li>C-x h 全部选中 (这个后面详细说)</li><li>C-% 查找替换(C-s以及C-r是查找)</li><li>C-x b 选中命名的buffer</li><li>C-x, C-b 列出所有buffer</li><li>M-x, kill-buffer  杀死buffer, 快捷键 C-x k</li><li>C-v 向下翻页 (C-u 8 C-v 向下翻8页)</li><li>M-v 向上翻页</li><li>C-k 删除一行</li><li>C-h m 查看当前模式(terminal可能)</li><li>C-x C-q 设置或者取消只读模式</li><li>格式代码(缩进)<br>C-x h TAB 格式化选中的代码<br>C-c,C-q 对整个函数进行缩进 (光标应该在函数内, 并且需要再源码mode以内)<br>选中区域,  M-x untabify, 将 TAB 字符转换为空格<br>选中区域, M-x indent-region, 对齐文本块</li><li>注释:<br><code>M-;</code> 在该行的末尾添加注释符号(当然选中块之后也就可以注释整个block)<br><code>C-c C-c</code> 对一块代码进行注释;<br>取消注释用命令 <code>uncomment-region</code> (其实用undo也可以)</li><li>折叠代码(我个人设置的是 <code>M+,</code>)</li><li>标记和调整(我个人设置的是<code>C-c m</code>, <code>C-c j</code>)</li><li>括号间跳转：(括号和函数间跳转)<br>括号之间来回跳转的时 候按 C-M-f 和 C-M-b.<br><code>C-M-a</code>   移动到当前函数的开始(如果和系统的快捷键冲突, 那么就多加一个shift键盘)<br><code>C-M-e</code>   移动到当前函数的结尾<br>(注意可以把C-M-a, C-M-e合并到C-M-f和C-M-b中, 我通常采取的策略是使用%进行跳转)</li><li>标记移动和全选:<br>标记整个页面 <code>c-x,c-p</code> (实际上这里多是整个buffer, 而不是整个frame)<br>标记整个缓冲区 c-x h (常用)<br>标记整个段落 m-h (通常没有用-而是用c-m-h)<br><code>c-space</code> 设置标记(如果冲突就多加一个shift 或者使用 c-@) 然后移动光标, 就会从标记的位置选中移动选中区域<br><code>c-x c-x</code> 快速返回移动前的光标位置(互换插入点和文本标记的位置)<br><code>c-m-h</code> 快速选中一个函数 (如何按键有冲突, 可以多加一个shift)</li><li>大小写转换(默认是被禁止)–注意是C-x开始<br>downcase-region (<code>C-x C-l</code>) ;; 选定区域全部改为小写<br>upcase-region (<code>C-x C-u</code>)   ;; 选定区域全部改为大写<br>可以直接在.emacs文件中设置:<pre><code>(put &#39;downcase-region &#39;disabled nil)(put &#39;upcase-region &#39;disabled nil)</code></pre>只是转换一个单词的话, 可以用 <code>M-u</code> 和 <code>M-l</code>, 它会把从光标开始的后面一个单词变成大写或者小写.</li></ol><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><p>frame, 缓冲区, 窗口的关系:<br>整个窗口在Emacs中叫做frame, 图形界面下的Emacs可以打开多个frame. 每个frame从上到下分成3部分，分别是缓冲区,状态栏和回显区(一般工具栏隐藏) 缓冲区是编辑的主区域, 但是在这里操作的还不是真正的文件, 而是文件的一个缓存(buffer)。只有执行写入操作时，才会将buffer的内容写入到文件. 缓冲区可以分成多个区域, 缓冲不同的内容. 这些区域在Emacs中成为”窗口”.</p><ol><li>C-x 1 只保留当前窗格</li><li>C-x 0 关闭当前窗格</li><li>C-x 2 切割为等宽半高的两个窗格</li><li>C-x o 切换到另一个窗格   (窗口相关的可以参考, 参考ibuffer.el扩展)</li></ol><p>缓冲区之下是状态栏，显示当前的一些状态信息，比如图中从左至右依次为:</p><pre><code>-UU-:----F1  tmp            Bot L31    (Fundamental) -------</code></pre><p>解释:</p><ul><li><code>UU</code>: 当前的文件编码是UTF-8, 如果是GBK会显示c</li><li><code>**</code>: 文件状态，**表示未保存，–表示可写，%%表示只读(C-x, C-q)</li><li><code>tmp</code>: 是当前编辑的文件的名称</li><li>All: 表示当前缓冲区已经显示文件的所有内容(Bot,表示处于文件的末尾处)</li><li>L31: 当前光标所在的行数</li><li>fundamental: 当前的模式</li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式:</p><ul><li>主要模式: 当前主要模式只有一种<br>fundamental-mode: 缺省的 Emacs 模式，拥有最少设置和绑定<br>text-mode：编辑文本的基本模式<br>c-mode：用于编辑程序源代码 (以及其他源码模式)<br>lisp-interaction-mode:用于编辑和编译 Lisp 代码<br>ptex-mode：用于编辑 TeX 文档</li><li>次要模式 : 可以组合到主要模式中(次要模式可以有多种), 如果输入的模式包含在当前模式中, 对于主要模式, 会清空所有的次要模式<br>abbrev-mode：用于生成和使用缩写<br>auto-fill-mode：用于自动文字回绕、填充较长的行和段落<br>line-number-mode：显示当前行号(默认在状态栏上显示的就是)<br>overwrite-mode：覆盖模式, 代替默认的插入模式<br>以及其他插件模式</li></ul><h3 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h3><p>(C-x r 开头; 和寄存器, 书签有重合)</p><p>这里可以补充一个矩形操作:(矩阵操作, 其实就是列模式)<br>其实我并没有觉得矩形剪切和复制时多么棒的东西, 平时用到的标记剪切其实也不错.</p><p>主要就是下面几个命令:(先用C-space或者C-@设一个mark, 移动光标到另一点; 剪切的其实是对角线围成的矩形)</p><pre><code>C-x r k 剪切一个矩形块C-x r y 粘贴一个矩形块  C-x r d 删除一个矩阵块C-x r c 清除一个矩形块(使其变成空白) C-x r o 插入一个矩形块(打开当前的矩形区块，使用空白字符填充整个区域，并将该矩形区块的所有文本移动到右边)C-x r t 在选定区域的所有列前插入样的字符</code></pre><p>(没有复制啊? 我说你傻啊, 先剪切, 然后undo, 然后粘贴)</p><p>Keystrokes             Command name                                             Action<br>C-x r  k                kill-rectangle                                  Delete a rectangle and store it.<br>C-x r  d                delete-rectangle                                Delete a rectangle and do not store it.<br>C-x r  y                yank-rectangle                                  Insert the last rectangle killed<br>C-x r c                 clear-rectangle                                 Using spaces, blank out the area marked as a rectangle and do not store it.<br>C-x r o                 open-rectangle                                  Insert a blank rectangle in the area marked.<br>C-x r r r               copy-rectangle-to-register                  Copy rectangle to register r (where r is any character) .<br>C-x r i r               insert-register                                 Insert rectangle from register r (where r is any character).<br>（none)                 delete-whitespace-rectangle             if a rectangle includes initial whitespace, deletes it, narrowing rectangle.<br>C-x r t string          Enter string-rectangle                      Change contents of marked rectangle to string (if string is narrower<br>                                                                    or wider than rectangle, dimensions change accordingly).<br>(none)                  string-insert-rectangle                     Prompts for string and inserts rectangle.</p><hr><p>不满意的话, 还可以使用 <code>cua-mode</code> . (我个人不用)</p><p>除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入 cua rectangle模式。<br>在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。 直接输入字符: 在每行前(或后)都插入这个字符.</p><pre><code>[M-a]: 将rect中的文字左对齐  [M-b]: 用空格(tabs或者spaces)替换所有rect中的字符  [M-c]: 去掉所有行左侧的空格  [M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)  [M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)  [M-k]: 剪切rect  [M-l]: 把rect中的内容全部转换为小写  [M-m]: 拷贝rect  [M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号)  ### 非常好用的功能  [M-o]: rect的内容右移，选中的rect用空格填充  [M-r]: 用字符串替换符满足正则表达式的字符串  [M-R]: 上下反转  [M-s]: 把rect中的每一行替换为一个字符串(提示输入)  [M-t]: 把rect整个替换为一个字符串(提示输入)  [M-u]: 把rect中的内容全部转换为大写  [M-|]: 对rect执行一个shell命令</code></pre><p>我个人一般最多用到矩阵模式.</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>(这里的命令注意和矩阵相区别一下)<br>在多个文件中逛的时候，我们常常需要快速切换到先前访问的某个位置. 因此, 我们需要把文件及其光标位置暂时存放在某个地方. (一般我们都会根据register进行一定封装, 从而进行来回的跳转) 简单说, 这里的寄存器(register), 就是保存一些位置信息(光标位置, 文件信息等)</p><p>最基本的用法(和我定义的C-c,m以及C-c,j比起来作用弱一点儿)<br>将当前光标所在位置保存入一个register中:<br><code>C-x r SPACE + register名</code> (一个字符, 比如a吧), 然后我们就可以到处瞎逛，若要回到保存的register a位置，我们可以输入: <code>C-x r j a</code></p><p>当然你可以定义好多个寄存器名字(位置)</p><pre><code>M-x view-register    查看某一个registerM-x list-registers   查看所有的register</code></pre><p>在进行矩阵操作的时候, 中间有两个命令: 保存到寄存器, 并存寄存器中恢复</p><pre><code>C-x s X                 copy-to-register                          将选定区域保存到寄存器 XC-x r r r               copy-rectangle-to-register                Copy rectangle to register r (where r is any character) .C-x r i r               insert-register                           Insert rectangle from register r (where r is any character).</code></pre><p>通常来说, 我个人不会使用这么原始的方式(偶尔可能会用), 一般使用其他更加高级的标记方式,比如我自己定义的 <code>C-.</code>以及 <code>C-,</code> .<br>比如ctags, etags, gtags, 或者csope等都是比较好的选择.   (我个人一般使用csope)</p><p>比如说 etags:<br>在代码目录中运行 <code>etags -R</code><br>如果要向现有tags表中添加，则运行 <code>etags -a</code><br>访问tag文件的话: <code>M-x visit-tags-table</code> , 常用的快捷键如下:</p><pre><code>M-.       访问tag C-u M-.   访问下一个tag M-*       返回</code></pre><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>保存缓冲区中位置的另一种工具(注意一下和矩阵操作的快捷键)<br>这些 Emacs 书签 的工作方式与寄存器相同，但是它们的标签可以超过一个字符长，而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们。它们将一直保留下来，直到您删除它们。正如它们的名称所表示的，对于保存您在缓冲区中的位置，以便您稍后可以返回到该位置（通常是在以后的 Emacs 会话期间），使用书签是非常方便的。</p><p>不过多介绍了:</p><pre><code>C-x r m Bookmark               bookmark-set              设置一个名为 Bookmark 的书签C-x r l                           bookmarks-bmenu-list        列出所有已保存的书签C-x r b Bookmark                      bookmark-jump              跳转至名为 Bookmark 的书签中所设置的位置(实际上是恢复书签)未定义                          bookmark-delete                  删除一个书签未定义                                         bookmark-save            将所有的书签保存到书签文件中(这样下次启动就可以跨越session了)</code></pre><p>注意, 自从emacs24, 退出的时候 书签是自动保存在相关文件中的:</p><ul><li>In emacs 24.x, bookmark file is at ~/.emacs.d/bookmarks.</li><li>In emacs 23.x, bookmark file is at ~/.emacs.bmk.<br>你也可以自己设置:<pre><code>(setq bookmark-save-flag 1) ; everytime bookmark is changed, automatically save it(setq bookmark-save-flag t) ; save bookmark when emacs quits(setq bookmark-save-flag nil) ; never auto save.</code></pre></li></ul><p>当然你可以设置在每次启动的时候, 自动载入书签:</p><pre><code>(require &#39;bookmark)(bookmark-bmenu-list)(switch-to-buffer &quot;*Bookmark List*&quot;)</code></pre><p>(我个人使用desktop插件, 所以不写该句)</p><p>当然你可以进行设置一些快捷键:</p><pre><code>(global-set-key [(f9)] &#39;list-bookmarks)(global-set-key [(f10)] &#39;bookmark-set)</code></pre><p>在list bookmark之后(相当于打开了bookmark文件), 可以使用下列命令在列表中操作:</p><p>Type d to mark the current item for remove.<br>Type x to remove all D marked ones. (执行)<br>Type r to rename current item’s title.<br>Type s to save the change.</p><p>现在有了 desktop, 书签显得比较鸡肋.</p><h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><p>下面说说我cscope的配置: (cscope和ecb功能上有一定重合)<br>GNU Emacs默认自带etags的支持, 但是不如cscope强大, cscope本身是一个独立软件, (建立索引之后)而且非常强大.</p><p>可以独立安装:</p><pre><code>$ which cscope/usr/local/bin/cscope$ file cscope/contrib/xcscope/cscope-indexer cscope/contrib/xcscope/cscope-indexer: POSIX shell script, ASCII text executable</code></pre><p>在外部使用:</p><p>要使用 cscope, 先建索引, 假设所有的头文件和h都在src下面</p><pre><code>find src/ -type f -iname &quot;*.h&quot; &gt;  cscope.files (这里创建)find src/ -type f -iname &quot;*.cpp&quot; &gt;&gt; cscope.files （这里是&gt;&gt;追加）</code></pre><p>(把所有符号都追加到一个文件可以加快建立索引文件的速度, 但是不利于之后展开文件)</p><pre><code>#!/bin/shfind . -name &quot;*.h&quot; -o -name &quot;*.c&quot; -o -name &quot;*.cc&quot; &gt; cscope.filescscope  -Rbkq -i cscope.files</code></pre><p>其他选项解释:</p><ul><li>-R: 在生成索引文件时, 搜索子目录树中的代码</li><li>-b: 只生成索引文件, 不进入cscope的界面</li><li>-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度</li><li>-k: 在生成索引文件时, 不搜索/usr/include目录</li><li>-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用“-”，表示由标准输入获得文件列表</li><li>-I dir: 在-I选项指出的目录中查找头文件</li><li>-u: 扫描所有文件, 重新生成交叉索引文件</li><li>-C: 在搜索时忽略大小写</li><li>-P path: 在以相对路径表示的文件前加上的path, 这样你不用切换到你数据库文件所在的目录也可以使用它了</li></ul><p>使用命令 <code>cscope -Rbkq</code>,  产生文件如下:</p><pre><code>cscope.in.outcscope.out  //基本的符号索引cscope.po.out</code></pre><p>注意一下, k在生成索引文件时, 不搜索/usr/include目录;  此时初始化和建立索引已经完成了, 之后就可以利用命令进行查找了.</p><p>在emacs里面使用:<br>当然在emacs程序里, 也可以进行初始化和建立索引(如果所有的源代码以及子目录都是在同一个目录下面的). </p><pre><code>;; C-c s a 初始化目录( 设定初始化的目录，一般是你代码的根目录);; C-c s I 对目录中的文件建立列表索引(生成 Cscope 的数据库)(cscope-set-initial-directory) 这一步最重要</code></pre><p>一般使用 <code>C-c s I</code> 就可以了, 对应 <code>cscope-set-initial-directory</code> . 如果源代码全部处于同一个目录下面，现在就可以使用了. (个人习惯还是喜欢再外部使用cscope -bkqR)</p><p>注意:</p><p>如果源代码有多层目录，或者其他地方还有附加的源代码，则需要 <code>cscope-indexer</code> 脚本. 把那个脚本拷贝到系统 PATH 里面去(如 /usr/bin/).</p><pre><code>$ sudo chmod u+x cscope-indexerexport PATH=$PATH:~/.emacs.d/lisp/cscope/contrib/xcscope</code></pre><p>然后在根目录, 建立索引</p><pre><code>$ cscope-indexer -r</code></pre><p>只要执行 C-c s I(cscope-index-files), 即`` 就可以生成 Cscope 的数据库, 接下来就可以使用了.<br>xcscope默认的快捷键都是绑定到 C-c s 的前缀上面, 更详细的使用说明请参见 xcscope.el 文件头部的注释.</p><p>我个人使用的是默认绑定: (必须要建立完索引)</p><ul><li>C-c s s         Find symbol. 寻找符号(查找C语言符号，即查找函数名、宏、枚举值等出现的地方)</li><li>C-c s d         Find global definition. 寻找全局定义—一般用这个来查找具体的定义</li><li>C-c s g         Find global definition (alternate binding). 寻找符号, 变量的定义</li><li>C-c s G         Find global definition without prompting.</li><li>C-c s c         Find functions calling a function. 看看指定函数被哪些函数所调用</li><li>C-c s C         Find called functions (list functions called<pre><code>          from a function).  看看指定函数调用了哪些函数</code></pre></li><li>C-c s t         Find text string.  查找字符串</li><li>C-c s e         Find egrep pattern. 正则表达式查找</li><li>C-c s f         Find a file. 寻找文件</li><li>C-c s i         Find files #including a file.  看看指定的文件被哪些文件include<br>```</li></ul><p>下面是在搜索到的结果之间切换用的快捷键:(一般不用, 直接跳转到窗口)</p><pre><code>C-c s b         Display *cscope* buffer.C-c s B         Auto display *cscope* buffer toggle.C-c s n         Next symbol.C-c s N         Next file.C-c s p         Previous symbol.C-c s P         Previous file.C-c s u         Pop mark.</code></pre><p>将光标停在函数名上, 按C-c s d, 回车, 即可以查询相关的定义.<br> xcscope.el 原来定义如下: </p><pre><code>;; * Keybindings:;;;; All keybindings use the &quot;C-c s&quot; prefix, but are usable only while;; editing a source file, or in the cscope results buffer:;;;;      C-c s s         Find symbol.;;      C-c s d         Find global definition.;;      C-c s g         Find global definition (alternate binding).;;      C-c s G         Find global definition without prompting.;;      C-c s c         Find functions calling a function.;;      C-c s C         Find called functions (list functions called;;                      from a function).;;      C-c s t         Find text string.;;      C-c s e         Find egrep pattern.;;      C-c s f         Find a file.;;      C-c s i         Find files #including a file.;;;; These pertain to navigation through the search results:;;;;      C-c s b         Display *cscope* buffer.;;      C-c s B         Auto display *cscope* buffer toggle.;;      C-c s n         Next symbol.;;      C-c s N         Next file.;;      C-c s p         Previous symbol.;;      C-c s P         Previous file.;;      C-c s u         Pop mark.;;;; These pertain to setting and unsetting the variable,;; `cscope-initial-directory&#39;, (location searched for the cscope database;;  directory):;;;;      C-c s a         Set initial directory.;;      C-c s A         Unset initial directory.;;;; These pertain to cscope database maintenance:;;;;      C-c s L         Create list of files to index.;;      C-c s I         Create list and index.;;      C-c s E         Edit list of files to index.;;      C-c s W         Locate this buffer&#39;s cscope directory;;                      (&quot;W&quot; --&gt; &quot;where&quot;).;;      C-c s S         Locate this buffer&#39;s cscope directory.;;                      (alternate binding: &quot;S&quot; --&gt; &quot;show&quot;).;;      C-c s T         Locate this buffer&#39;s cscope directory.;;                      (alternate binding: &quot;T&quot; --&gt; &quot;tell&quot;).;;      C-c s D         Dired this buffer&#39;s directory.</code></pre><p>如果你喜欢自定议案件的话, 提供自定义按键参考:</p><pre><code>(define-key global-map [(control f3)]  &#39;cscope-set-initial-directory)(define-key global-map [(control f4)]  &#39;cscope-unset-initial-directory)(define-key global-map [(control f5)]  &#39;cscope-find-this-symbol)(define-key global-map [(control f6)]  &#39;cscope-find-global-definition)(define-key global-map [(control f7)]  &#39;cscope-find-global-definition-no-prompting)(define-key global-map [(control f8)]  &#39;cscope-pop-mark)(define-key global-map [(control f9)]  &#39;cscope-next-symbol)(define-key global-map [(control f10)] &#39;cscope-next-file)(define-key global-map [(control f11)] &#39;cscope-prev-symbol)(define-key global-map [(control f12)] &#39;cscope-prev-file)(define-key global-map [(meta f9)]     &#39;cscope-display-buffer)(define-key global-map [(meta f10)]    &#39;cscope-display-buffer-toggle)</code></pre><h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>由于我使用了插件 symbol-overlay, 所以一般是借助f8标记和操作标记， 和 <code>M-r</code>重命名, <code>M-s</code>切换到isearch.</p><p>下面是可能涉及到的查找:<br><code>C-%</code> 查找替换<br><code>C-s</code> 以及 <code>C-r</code>是递归查找<br><code>M-x grep-find</code>, 已经设置快捷键为f3<br> <code>find . -type f -exec grep --color -nH -e &quot;content&quot; {} +</code></p><p>下面可以详细说一下技巧， 因为查找&amp;替换实在用的太多了:</p><p>Emacs中的搜索包括增量搜索和一般搜索。增加搜索是每次在前一次搜索的结果基础上继续搜索。在增量搜索时，如果上一次搜索之后进行了其他操作，则需要连续按两次快捷键才能召回关键词. 可以选中区块后在区块内进行搜索.</p><p>增量查找:<br>C - s向下查找<br>C - r向上查找<br>按下C - s后输入要搜索的词，emacs会即时显示当前光标后第一个搜索到的结果，按C - s会跳到下一个结果，按C - r会跳到上一个结果.<br>按Enter结束查找或按C - g取消查找回到原来的地方。<br>按下C - s 或 C - r后, 按M - p显示上一个搜索词, M - n显示下一个搜索词。类似C - p是上一行，C - n下一行.<br>按下C - s或 C - r后, 输入要查找的词的头几个字, 然后按C - w 会补全当前位置的单词.</p><p>查找替换:<br>按M - %启动查找替换，输入要被替换的词，回车，然后输入要替换的词，再回车。<br>被替换的词会高亮起来，这时，</p><ul><li>输入y替换并跳到下一个</li><li>^ 返回上一个替换点</li><li>输入n忽略并跳到下一个</li><li>输入q结束，输入！替换剩下的全部</li></ul><p>C - r 进入修改<br>(我一般重构的时候， 使用插件， M-r进行全部改名, M-s回归递归查找)</p><p>取消搜索<br>C-g 取消搜索，光标返回搜索前的位置<br>RET结束搜索，光标停留在当前位置。</p><p>Ocuur模式<br>有时候想列出匹配的全面模式，而不是在文档中浏览，这个可以使用occur这个函数。<br>例子：M - x occur RET 关键词 RET<br>这时emacs会新开一个窗口来列出匹配的行<br>(实际上再 M-s之后, 案件M-s o即可达到同样的效果)</p><h3 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h3><p>写代码的cc-mode(cc-mode 可以用来写 C/C++/Java/Obj-C)</p><p>使用cc-mode:<br><code>M-x c-set-style</code>, 然后选择cc-mode</p><pre><code>M-x customize 定制界面等M-x customize-themes 定制主题等</code></pre><h3 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h3><p>文件编码方面, 一般linux下都采用utf-8即可, 或者设置 <code>(prefer-coding-system &#39;utf-8)</code> .</p><p>但是如你在gbk环境下, 比如你的windows7设置的是gdk, 那么此时应该设置gbk环境编码(否则读入文件时的解释编码和系统编码不一致, 肯定乱码了)</p><pre><code>(setq file-name-coding-system &#39;gbk)(set-terminal-coding-system &#39;gbk)(set-keyboard-coding-system &#39;gbk)(setq locale-coding-system &#39;gbk)(set-selection-coding-system &#39;gbk)(set-clipboard-coding-system &#39;ctext)(set-clipboard-coding-system &#39;gbk)(set-terminal-coding-system &#39;gbk)(set-buffer-file-coding-system &#39;gbk)(modify-coding-system-alist &#39;process &quot;.&quot; &#39;gbk)(setq default-process-coding-system &#39;(gbk . gbk))</code></pre><h3 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h3><p>关于 tabbar 的再一次调整:</p><p>要达到的效果是什么呢?<br>是要在一个 buffer 里面移动, 而不会切换到被的分组.<br>键位的设定时我特意改用了tabbar-backward-tab和tabbar-forward-tab 代替tabbar-backward和tabber-forward.<br>效果是使用M-left/right的时候移动不会跨组, 也就是只能在当前分组内移动, 这样好很多.<br>中间一段设置把标签栏左边的那些按钮都取消掉了.</p><p>原来是不分组, 最后发现还是要根据主模式分组比较好.(即下面的代码全部作废)</p><pre><code>(require &#39;tabbar)  (tabbar-mode)  (global-set-key (kbd &quot;&lt;M-up&gt;&quot;)    &#39;tabbar-backward-group)  (global-set-key (kbd &quot;&lt;M-down&gt;&quot;)  &#39;tabbar-forward-group)  (global-set-key (kbd &quot;&lt;M-left&gt;&quot;)  &#39;tabbar-backward-tab)  (global-set-key (kbd &quot;&lt;M-right&gt;&quot;) &#39;tabbar-forward-tab)  (setq   tabbar-scroll-left-help-function nil   ;don&#39;t show help information   tabbar-scroll-right-help-function nil   tabbar-help-on-tab-function nil   tabbar-home-help-function nil   tabbar-buffer-home-button (quote ((&quot;&quot;) &quot;&quot;)) ;don&#39;t show tabbar button   tabbar-scroll-left-button (quote ((&quot;&quot;) &quot;&quot;))   tabbar-scroll-right-button (quote ((&quot;&quot;) &quot;&quot;)))  (defun my-tabbar-buffer-groups ()    &quot;Return the list of group names the current buffer belongs to.  Return a list of one element based on major mode.&quot;    (list     (cond      ((or (get-buffer-process (current-buffer))           ;; Check if the major mode derives from `comint-mode&#39; or           ;; `compilation-mode&#39;.           (tabbar-buffer-mode-derived-p            major-mode &#39;(comint-mode compilation-mode)))       &quot;Process&quot;       )      ((string-equal &quot;*&quot; (substring (buffer-name) 0 1))       &quot;Emacs Buffer&quot;       )      ((eq major-mode &#39;dired-mode)       &quot;Dired&quot;       )      (t       &quot;User Buffer&quot;       ))))  (setq tabbar-buffer-groups-function &#39;my-tabbar-buffer-groups)</code></pre><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>一般都是激活多窗口调试模式:</p><pre><code>+----------------------------------------------------------------------+|                               GDB Toolbar                            |+-----------------------------------+----------------------------------+| GUD buffer (I/O of GDB)           | Locals buffer                    ||                                   |                                  ||                                   |                                  ||                                   |                                  |+-----------------------------------+----------------------------------+| Source buffer                     | I/O buffer (of debugged program) ||                                   | (comint-mode)                    ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  |+-----------------------------------+----------------------------------+| Stack buffer                      | Breakpoints buffer               || RET      gdb-frames-select        | SPC    gdb-toggle-breakpoint     ||                                   | RET    gdb-goto-breakpoint       ||                                   | D      gdb-delete-breakpoint     |+-----------------------------------+----------------------------------+</code></pre><p>窗口说明:</p><ul><li>GDB Toolbar        - GDB 操作Toolbar</li><li>GUD buffer         - 执行操作的buffer</li><li>Locals buffer      - 本地变量名和值的表示buffer</li><li>Source buffer      - 表示sourcecode的buffer</li><li>IO/ buffer         - 表示程序的输入输出的buffer</li><li>Stack buffer       - 运行停止的时候，调用关系的表示buffer</li><li>Breakpoints buffer - breakpoints断点的表示buffer</li><li>buffer崩溃的时候、通过’M-x gdb-restore-windows’返回原状态</li></ul><p>当然你可以尝试关闭某些窗口.</p><pre><code>(setq gdb-use-separate-io-buffer t) ; 不需要&quot;IO buffer&quot;时，则设为nil</code></pre><p>一般会把 <code>gdb-many-windows</code> 设置为激活状态, 实际上也可以用 <code>gdb-restore-windows</code> 恢复单个布局.</p><p>我个人的习惯是, 把所有的其他窗口只是作为观察窗口, 其实还是依赖主窗口, 设置相关命令, 一方面, 这个可以减少快捷键的记忆; 另外一方面, 不和单独在terminal中使用产生冲突, 其实也不错. (gud是主窗口)</p><p>快捷键命令</p><ul><li>添加断点    gud-break    C-x C-a C-b 或 C-x <spc></spc></li><li>删除断点    gud-remove    C-x C-a C-d</li><li>运行/继续程序    gud-go        无</li><li>单步执行，无视函数        gud-next    C-x C-a C-n</li><li>单步执行，进入函数        gud-step    C-x C-a C-s</li><li>跳出当前函数            gud-finish    C-x C-a C-f</li><li>运行到光标所在语句        gud-until    C-x C-a C-u</li><li>继续运行程序            gud-cont    C-x C-a C-r</li></ul><h3 id="Autocomplete"><a href="#Autocomplete" class="headerlink" title="Autocomplete"></a>Autocomplete</h3><p>自动补全的拆建有很多, 但是真正能够TAB键玩的溜的只有 Auotocomplete .</p><p>autocomplete在使用上, 不用刻意去按键M-/, 而是在你写代码的时候, 就可以完成提示, 并且选择的话, 一直TAB就行, 之后就可以直接在后面接着写其他的代码. (按回车可以选中所选的)</p><p>具体的快捷键:</p><ul><li>TAB, C-i    ac-expand    Completion by TAB</li><li>RET, C-m    ac-complete    Completion by RET</li><li>down, M-n    ac-next        Select next candidate</li><li>up, M-p       ac-previous    Select previous candidate</li><li>C-?, f1    ac-help            Show buffer help</li></ul><p>To stop completion, simply use C-g.</p><h3 id="magit"><a href="#magit" class="headerlink" title="magit"></a>magit</h3><p>emacs中使用git虽然很好, 但是, 无疑来说, 又会增加许多负担, 当前还是使用terminal或者gitk吧. 具体可以考虑使用 magit 插件.</p><h3 id="speedbar"><a href="#speedbar" class="headerlink" title="speedbar"></a>speedbar</h3><p>就是一个文件列表， 一般再ecb中有集成.</p><p>M-x speedbar 就可以启动它(相关于一个文件目录, 可以在多个文件中切换), 我个人设置的快捷键是 f4 .</p><h3 id="ediff"><a href="#ediff" class="headerlink" title="ediff"></a>ediff</h3><p>一个相当于beyond compare的组件: <code>M-x ediff</code>. </p><h3 id="dired"><a href="#dired" class="headerlink" title="dired"></a>dired</h3><p>emacs下一个强大的文件管理器, 大多数切换到 shell 的场景被它取代: <code>M-x dired</code>.</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p><code>M-x tetris</code>, 俄罗斯方块.</p><h3 id="hideshow"><a href="#hideshow" class="headerlink" title="hideshow"></a>hideshow</h3><p>代码折叠与展开, 这个插件有用, 不过要进行一定的调整.</p><pre><code>;;配置代码折叠;(load-library &quot;hideshow&quot;)  ;(add-hook &#39;java-mode-hook &#39;hs-minor-mode)  ;(add-hook &#39;perl-mode-hook &#39;hs-minor-mode)  ;;(add-hook &#39;php-mode-hook &#39;hs-minor-mode)  ;(add-hook &#39;emacs-lisp-mode-hook &#39;hs-minor-mode)  (add-to-list &#39;hs-special-modes-alist             &#39;(c-mode &quot;[\n\t ]*{&quot; &quot;}&quot; &quot;/[*/]&quot; nil hs-c-like-adjust-block-beginning))(add-to-list &#39;hs-special-modes-alist             &#39;(c++-mode &quot;[\n\t ]*{&quot; &quot;}&quot; &quot;/[*/]&quot; nil hs-c-like-adjust-block-beginning))(define-key global-map (kbd &quot;M-,&quot;) &#39;hs-toggle-hiding)</code></pre><p>我一般设置的是 <code>M-,</code> 用于折叠和展开.</p><h3 id="窗口恢复"><a href="#窗口恢复" class="headerlink" title="窗口恢复"></a>窗口恢复</h3><p>原生没有设置案件对窗口误操作的undo, 所以我设置了一下按键:</p><pre><code>C-x 4 u 窗口undoC-x 4 r 窗口redo</code></pre><h3 id="doxygen"><a href="#doxygen" class="headerlink" title="doxygen"></a>doxygen</h3><p>这个设置起来不太麻烦, 但是我还是喜欢在shell中使用, 毕竟它可以生产图, shell操作更加方便.</p><h3 id="cedet"><a href="#cedet" class="headerlink" title="cedet"></a>cedet</h3><p>给Emacs安装CEDET是最烦恼的过程之一, 由于这个插件太大了, 所以出错的几率也比较打.</p><p>CEDET包含以下几个部分: </p><ul><li>Semantic - Parser Infrastructure for Emacs</li><li>EDE -      File manager/ Makefile generator</li><li>SRecode -  Template manager/ code generator</li><li>COGRE -    Connected Graph Editor</li></ul><p>emacs自带的cedet为1.0版本, 不能与ecb配合使用, 所以要下载并安装它的最新版本(LAST) <code>cedet1.1</code> . 安装的时候, 请仔细阅读源码目录的 <code>INSTALL</code> 文件, 我直接下载的解压缩后的文件.</p><pre><code>$ git clone https://github.com/emacs-pkg-mirrors/cedet.git</code></pre><p>根据它<a href="http://cedet.sourceforge.net/setup.shtml" target="_blank" rel="external">官网</a>的步骤, 一点儿不靠谱. 请仔细阅读源码目录的 <code>INSTALL</code> 文件!!!</p><ul><li>Step 1 : Download CEDET from the Sourceforge downloads page. </li><li>Step 2 : unpack CEDET</li><li>Step 3 : make EMACS=emacs</li><li>Step 4 : Configure CEDET in your .emacs file by adding code like this.</li></ul><p>主要代码</p><pre><code>-----------;; Load CEDET.;; See cedet/common/cedet.info for configuration details.;; IMPORTANT: For Emacs &gt;= 23.2, you must place this *before* any;; CEDET component (including EIEIO) gets activated by another ;; package (Gnus, auth-source, ...).(load-file &quot;~/cedet-VERSION/common/cedet.el&quot;);; Enable EDE (Project Management) features(global-ede-mode 1);; Enable EDE for a pre-existing C++ project;; (ede-cpp-root-project &quot;NAME&quot; :file &quot;~/myproject/Makefile&quot;);; Enabling Semantic (code-parsing, smart completion) features;; Select one of the following:;; * This enables the database and idle reparse engines(semantic-load-enable-minimum-features);; * This enables some tools useful for coding, such as summary mode,;;   imenu support, and the semantic navigator(semantic-load-enable-code-helpers);; * This enables even more coding tools such as intellisense mode,;;   decoration mode, and stickyfunc mode (plus regular code helpers);; (semantic-load-enable-gaudy-code-helpers);; * This enables the use of Exuberant ctags if you have it installed.;;   If you use C++ templates or boost, you should NOT enable it.;; (semantic-load-enable-all-exuberent-ctags-support);;   Or, use one of these two types of support.;;   Add support for new languages only via ctags.;; (semantic-load-enable-primary-exuberent-ctags-support);;   Add support for using ctags as a backup parser.;; (semantic-load-enable-secondary-exuberent-ctags-support);; Enable SRecode (Template management) minor-mode.;; (global-srecode-minor-mode 1)</code></pre><p>编译时遇到的问题:</p><p>`makeinfo is missing on your systeme, 即makeinfo未找到命令, 此时有两种方案:</p><ul><li>make EMACS=emacs MAKEINFO=echo  即不编译doc</li><li>make MAKEINFO=/usr/bin/makeinfo</li></ul><p>安装 <code>makeinfo</code>, 它包含再<code>texinfo</code>包中</p><pre><code>$ search apt-fileapt-file - search for files within Debian packages (command-line interface)cabal-debian - Create a debianization for a cabal package#利用apt-file查看某个文件属于哪个包, 再安装包$ add apt-file$ sudo apt-updateapt$ apt-file search bin/makeinfotexinfo: /usr/bin/makeinfo$ search exinfotexinfo - Documentation system for on-line information and printed output$ add texinfo$ add install-info</code></pre><p>在 <a href="http://sourceforge.net/projects/cedet/" target="_blank" rel="external">http://sourceforge.net/projects/cedet/</a>  下载 cedet1.1 .</p><pre><code>In end of data:semantic-tag-file.el:207:1:Warning: the function ‘ede-toplevel’ is not known    to be defined.Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)In toplevel form:semantic-idle.el:42:1:Error: Invalid function: class-pIn semantic-tag-customize:semantic-custom.el:210:22:Warning: ‘toggle-read-only’ is an obsolete    function (as of 24.3); use ‘read-only-mode’ instead.Makefile:61: recipe for target &#39;semantic&#39; failed</code></pre><p>总之编译的时候, 就是会遇到各种各样的问题. 一定要简单安装cedet, 它真的太复杂了(我安装它也只是为了安装ecb).</p><h3 id="ecb"><a href="#ecb" class="headerlink" title="ecb"></a>ecb</h3><p>这个代码浏览器, 比较实用. 配置好了普通编写代码, 跑测试用例的界面大概是这样的:</p><pre><code>   ------------------------------------------------------------------   |              |                                                 |   |  Directories |                                                 |   |              |                                                 |   |--------------|                                                 |   |              |                                                 |   |  Sources     |                                                 |   |              |                                                 |   |--------------|                   Edit-area                     |   |              |   (can be splitted in several edit-windows)     |   |  Methods     |                                                 |   |              |                                                 |   |--------------|                                                 |   |              |                                                 |   |  History     |                                                 |   |              |                                                 |   ------------------------------------------------------------------   |                                                                |   |            Persistent Compilation-window (optional)            |   |                                                                |   ------------------------------------------------------------------</code></pre><p>我一般设置如下快捷键：</p><ul><li>f5 启用ecb</li><li>f6 禁用ecb</li><li>control + f5 显示ecb窗口</li><li>control + f6 隐藏ecb窗口</li><li>C-c 0-4 分别是还原，以及最大化某个窗口</li><li>M-方向键, 切换到某个窗口</li><li>选定某个窗口的某个展开标记(即加号减号) 方向键左代表折叠, 方向键右代表展开.</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学些emacs, 手册中遇到的(可能)生词:</p><ul><li>overlap 交叠 </li><li>likewise 相似的</li><li>opposite 相反的 </li><li>interspersed 穿插 </li><li>parallel 并行 </li><li>repeated 重复</li><li>paraphrase 释义 </li><li>terminal终端 </li><li>get rid of 摆脱</li><li>contiguous 邻近的 </li><li>incremental 增量  </li><li>for reference 仅供参考 </li><li>sufficient 足够</li><li>command               命令</li><li>scrolling             滚动</li><li>numeric argument      数字参数</li><li>yank                  召回,剪切</li><li>echo area             回显区</li><li>mode line             状态栏</li><li>incremental search    渐进式搜索</li></ul><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>有些插件真坑爹…编译安装都烦, 莫名其妙的问题, 浪费了好长时间.</p><p>首先 emacs 还是很强大的, 然而不得不说, 由于平台的严谨, 以及开后和后续支持的缺乏, 对于emacs的兼容性造成了很大的调整. 如果和visual studio code相比, 其兼容性明显不好. 而且这种情况如果没有更多的人参与和带动, 不说emacs会死, 至少可以说, 能玩的起来的都是神了.</p><p>唯一的希望是, emacs的兼容性可以好起来(各种插件的稳定性慢慢变好一些).</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org" target="_blank" rel="external">一年成为 Emacs 高手</a></li><li><a href="http://www.gnu.org/software/emacs/tour/" target="_blank" rel="external">A Guided Tour of Emacs</a></li><li><a href="https://zhuanlan.zhihu.com/p/26068894" target="_blank" rel="external">emacs按键绑定方式介绍</a></li><li><a href="https://github.com/wolray/symbol-overlay" target="_blank" rel="external">emacs高亮插件推荐</a></li><li><a href="http://www.cnblogs.com/logicbaby/archive/2011/10/19/2217253.html" target="_blank" rel="external">emacs项目路径设置</a></li><li><a href="http://blog.csdn.net/lujun9972/article/details/46002881" target="_blank" rel="external">woman参考</a></li><li><a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html" target="_blank" rel="external">查找替换参考</a></li><li><a href="http://emacser.com/ann77/Emacs/EmacsSearch.html" target="_blank" rel="external">查找汇总</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html" target="_blank" rel="external">书签和寄存器</a><br>(文中有一处错误:删除书签的命令是 M-x bookmark-delete而不是C-x bookmark delete)</li><li><a href="http://emacser.com/emacs-gdb.htm" target="_blank" rel="external">gdb参考</a></li><li><a href="https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md" target="_blank" rel="external">autocomplete参考</a></li><li><a href="https://magit.vc/" target="_blank" rel="external">magit参考</a></li><li><a href="http://www.emacswiki.org/cgi-bin/wiki/HideShow" target="_blank" rel="external">hideshow</a></li></ol><p>这一些列文档差不多一共有7篇, 讲的比较啰嗦, 可以自行参考一下:</p><ul><li><a href="https://www.ibm.com/developerworks/cn/education/aix/emacs1/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/emacs1/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/emacs2/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/emacs2/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs3/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs3/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs5/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs5/index.html</a></li></ul><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      刚好换新的环境,顺便把emacs环境重新修正一下
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Deepin Linux</title>
    <link href="www.merlinblog.site/2017/08/31/deepin.html"/>
    <id>www.merlinblog.site/2017/08/31/deepin.html</id>
    <published>2017-08-31T05:45:39.000Z</published>
    <updated>2017-10-09T10:54:29.170Z</updated>
    
    <content type="html"><![CDATA[<p>以前的老系统, 由于系统太老, 有时候安装软件真的非常不适合. 我个人开发一直使用linux(Ubuntu64), 主要用terminal(emacs -nw). 所以要换一个稳定, 新一点儿的系统; 考虑了ubuntu麒麟, 16, 17, 不得不说, 一点儿也不好用, 支持的非常差. 原版的ubuntu也是, 系统有时动不动就内部错误(Ubuntu可能会突然告诉你已经不提供软件更新了, 请升级到17.04; 然后你升级的时候又引来内部错误).<br>正好 <code>武汉深之度</code> 开发的 <code>deepin</code> 近来大家伙好评不断, 所以, 我就来试试. </p><blockquote><p>趁此机会, 把原来的所有 <code>开发环境</code> 切换到 deepin (旧 ubuntu 仅用于发布博客).<br>(如果有机会, 以后也想为它贡献代码)</p></blockquote><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>为什么换deepin? 原系统 和 deepin对比如下, 不多解释了.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/deepin1.jpg" alt=""></p><p>(好吧还是说一下,它的这个<code>terminal</code>太棒了;后期发现和emacs有些键可能冲突, 改以下就好了)</p><p>真正一个好的环境, 仅仅从一个技术人员触发, 至少具备3点:</p><ul><li>开发舒服(效率高和个人水平有关)</li><li>看源码舒服(特别是源码庞大, 调用复杂时)</li><li>debug舒服</li></ul><h2 id="安装deepin"><a href="#安装deepin" class="headerlink" title="安装deepin"></a>安装deepin</h2><p>这里我装的是虚拟机.</p><p>电脑的原配操作系统win10专业版, 所以一般不改变, 主要工作环境全部放在虚拟机里面, 一来编程对机器要求不是太高, 而来虚拟机文件也方便在电脑间移植.</p><p>虚拟机里安装deepin很简单: 原来怎么安装ubuntu_amd64, 这里就怎么装deepin, 并且操作习惯也不用改, 和debain系列一致.</p><p>安装完, 先升级一下系统 <code>sudo apt-get dist-upgrade</code> 或者可能也需要 <code>sudo apt-get update</code> 和 <code>sudo apt-get upgrade</code>.</p><p>下面开始安装主要工作软件以及环境配置.</p><hr><h2 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h2><p>最先安装的就是emacs, 不然后面很捉急.</p><pre><code class="bash">$ sudo apt-get install emacs25#安装完毕之后$ emacs --versionGNU Emacs 25.1.1Copyright (C) 2016 Free Software Foundation, Inc.GNU Emacs comes with ABSOLUTELY NO WARRANTY.You may redistribute copies of GNU Emacsunder the terms of the GNU General Public License.For more information about these matters, see the file named COPYING.</code></pre><p>不过我使用的时候, 一般都是不带界面的emacs, 习惯了; 所以去加一个alias.</p><p>现在<code>.bashrc</code>结尾面添加一个语句(<code>$ nano .bashrc</code>)</p><pre><code class="shell">if [ -f ~/.merlin_bash ]; then    . ~/.merlin_bashfi</code></pre><p>保存之后建立一个<code>.merlin_bash</code>文件:</p><pre><code class="bash"># here we confiure some alias and environment info # 1. alias# 2. environmen path# my aliasalias ll=&#39;ls -l&#39;alias la=&#39;ls -A&#39;alias l=&#39;ls -CF&#39;alias em=&#39;emacs -nw&#39;</code></pre><p>(重新打开以下终端或者source .bashrc)<br>现在可以使用emacs了, 还不错哦.</p><p>关于emacs的配置, 请看我的另外一篇 <a href="http://www.merlinblog.site/2017/08/31/my-emacs.html">文章</a>.</p><p>如果你不配置<code>emacs</code>, 基本呵呵, 不配置除非你是神(要求你水平非常高), 不然很难用的顺手.</p><blockquote><p>以后的所有配置,都在.merlin_bash文件中.</p></blockquote><h2 id="rm绑定"><a href="#rm绑定" class="headerlink" title="rm绑定"></a>rm绑定</h2><p>rm命令已经引起无数次灾害了(深受其害!!), 这东西不处理不行. 如果在UI界面放入Trash, 那么会在<code>~/.local/share/Trash/</code>的两个子目录进行如下操作:</p><ul><li>把具体的文件放入files目录</li><li><p>info目录里以文件相同的filename保存删除的信息</p><pre><code>[Trash Info]Path=/home/merlin/Desktop/test/ideaIC-2017.2.3.tar.gzDeletionDate=2017-08-31T17:15:09</code></pre><p>所以我们的rm命令可以简单的用来把东西移动到Trash目录, 但不写入Info信息(而是添加尾缀时间戳), 以此区分是用rm命令删除的, 代码很简单(要考虑一下连续重复删除同一个文件, 删除的目录和文件同名等情况):<br>```</p><h2 id="rm-related"><a href="#rm-related" class="headerlink" title="rm related"></a>rm related</h2><p>trash()<br>{<br>TRASH_DIR=”/home/merlin/.local/share/Trash/files”<br>RF=”-rf”<br>R=”-r”<br>F=”-f”</p><p>if [ “$1” == ${RF} -o  “$1” == ${R} -o “$1” == ${F} ] ; then<br>   shift<br>fi</p><p>for i in $*; do<br>   FILENAME=<code>basename $i</code><br>   STAMP=<code>date +%s</code><br>   mv -f “$i” ${TRASH_DIR}/${FILENAME}.${STAMP}<br>done<br>}</p></li></ul><p>alias rm=trash</p><pre><code>## bashrc文件德国人有一个造车时, 有一个思想, 这个思想用中国谚语说就是 `工欲善其事必先利其器` .有一些常用命令, 来弄个别名吧, 编辑`.merlin_bash`:```shell# here we confiure some alias and environment info# 1. alias# 2. environmen path# my alias## ls relatedalias ll=&#39;ls -al&#39;alias la=&#39;ls -A&#39;alias l=&#39;ls -CF&#39;## emacs relatedalias em=&#39;emacs -nw&#39;## move relatedalias mv=&#39;mv -i&#39;## cp relatedalias cp=&#39;cp -i&#39;## apt relatedalias add=&#39;sudo apt-get install&#39;alias delete=&#39;sudo apt-get --purge remove&#39;alias autoremove=&#39;sudo apt-get autoremove&#39;alias search=&#39;sudo apt-cache search&#39;alias policy=&#39;sudo apt-cache policy&#39;alias update=&#39;sudo apt-get update&#39;alias upgrade=&#39;sudo apt-get upgrade&#39;alias sysupgrade=&#39;sudo apt-get dist-upgrade&#39;## git related# path## java relatedJAVA_OPT=${_JAVA_OPTIONS}unset _JAVA_OPTIONSalias java=&quot;java ${JAVA_OPT}&quot;## node npm relatedexport NODE_HOME=/home/merlin/Software/node-v6.11.2-linux-x64export NODE_PATH=$NODE_HOME/lib/node_modulesexport PATH=$PATH:$NODE_HOME/bin## go relatedexport GOROOT=/usr/lib/go-1.7export GOBIN=$GOROOT/binexport PATH=$GOBIN:$PATHexport GOPATH=/home/merlin/Desktop/GOPATH###for cross-compling go-codeexport GOOS=linuxexport GOARCH=amd64## ld and static pathexport LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATHexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</code></pre><p>差不多就这样了.</p><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>想下载东西, wget和curl必不可少(wget常用于下载, curl常用于调试RESTful)</p><pre><code>$ add wget$ add curl</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>没有git几乎无法生存, 想要去拉个库, 晕,没有安装git.</p><pre><code class="bash">$ add git正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  git-man liberror-perl建议安装：  git-daemon-run | git-daemon-sysvinit git-doc git-el git-email git-gui gitk gitweb git-arch git-cvs git-mediawiki git-svn下列【新】软件包将被安装：  git git-man liberror-perl升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 5,614 kB 的归档。解压缩后会消耗 31.0 MB 的额外空间。您希望继续执行吗？ [Y/n] Y获取:1 http://packages.deepin.com/deepin panda/main amd64 liberror-perl all 0.17024-1 [26.9 kB]获取:2 http://packages.deepin.com/deepin panda/main amd64 git-man all 1:2.11.0-4 [1,432 kB]获取:3 http://packages.deepin.com/deepin panda/main amd64 git amd64 1:2.11.0-4 [4,156 kB]                                       已下载 5,614 kB，耗时 15秒 (359 kB/s)                                                                                           正在选中未选择的软件包 liberror-perl。(正在读取数据库 ... 系统当前共安装有 152772 个文件和目录。)正准备解包 .../liberror-perl_0.17024-1_all.deb  ...正在解包 liberror-perl (0.17024-1) ...正在选中未选择的软件包 git-man。正准备解包 .../git-man_1%3a2.11.0-4_all.deb  ...正在解包 git-man (1:2.11.0-4) ...正在选中未选择的软件包 git。正准备解包 .../git_1%3a2.11.0-4_amd64.deb  ...正在解包 git (1:2.11.0-4) ...正在设置 git-man (1:2.11.0-4) ...正在设置 liberror-perl (0.17024-1) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...正在设置 git (1:2.11.0-4) ...</code></pre><p>看一下版本, 还挺新的.</p><pre><code>$ git --versiongit version 2.11.0</code></pre><p>配置一下自己的信息:</p><pre><code>$ git config --global user.name &quot;xxx&quot;$ git config --global user.email &quot;yyy&quot;</code></pre><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>本机其实已经安装了ssh工具, 并且我也可以远程到我的remote服务器:</p><pre><code># 一般默认22端口$ ssh username@address</code></pre><p>但是本机是否允许别的机器远程呢? 还是配置一下, 允许远程登录</p><pre><code>$ ls /etc/sshmoduli    ssh_config</code></pre><p>自己建议一个文件<code>sshd_config</code>, 配置ssh-server，配置文件位于/etc/ssh/sshd_config, 默认端口为22, 为了安全, 一般自定义为其他端口.</p><p>修改配置文件sshd_config, 一般修改远程登录过来的端口, 允许的账户, 超时是否断开.</p><pre><code>1. 配置端口：　   Port 22 配置端口时你可以修改称自己想要的比方说23333,防止被端口扫描.2. 配置是否允许远程root账户登录   (但是你登录后可以su到root账户)   # Authentication:   LoginGraceTime 120   PermitRootLogin yes   StrictModes yes   一般可以禁止远程root账户登录.3. 避免超时自动断开   # keep alive within an hour if no operation happened of client   ClientAliveInterval 60   ClientAliveCountMax 60注意:每次一次配置都要重启sshd守护进程: service ssh restart(我这边儿重启sshd，提示unrecognized service)</code></pre><p>关于sshd的启动:</p><p>首先确保ssh服务已经安装, 检查服务是否已经启动 </p><pre><code>ps -e | grep sshd</code></pre><p>启动、停止、重启服务 </p><pre><code>$ service sshd start     #开启ssh服务 $ service sshd stop      #停止ssh服务 $ service sshd restart   #重启ssh服务</code></pre><p>或者使用带有路径的脚本： </p><pre><code>/etc/init.d/sshd start /etc/init.d/sshd stop /etc/init.d/restart</code></pre><h3 id="产生ssh-key"><a href="#产生ssh-key" class="headerlink" title="产生ssh_key"></a>产生ssh_key</h3><p>步骤很简单, 但是我劝你还是采用HTTPS实时的输入账号密码验证上传和下载; 不要使用ssh key(任何一个登录到你电脑的人可以随便弄你的库, 多可怕).</p><pre><code># 如果~/.ssh下已经有了秘钥文件则不必生成$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;(直接回车什么都不做)</code></pre><p>在~/.ssh/得到了两个文件：id_rsa和id_rsa.pub, 打开id_rsa.pub文件，里面的信息即为SSH key; 在github上把公钥贴到SSH Key认证的位置, 那么凡是走ssh协议的传入, 你都可以不用密码了.</p><p>当然如果你把自己的公钥<code>id_rsa.pub</code>拷贝到别人的<code>authorized_keys</code>文件内, 然后你ssh登录别人的电脑就不用认证密码了(但是你scp拷贝的这一回, 还是要输入登录到别人电脑的密码). 例如把我的公钥拷贝到xxx_ip地址的主机上, 登录那台电脑的用户名是yyy.</p><pre><code>scp -r ~/.ssh/id_rsa.pub xxx_ip:/home/yyy/.ssh/authorized_keys# 然后输入用户yyy的密码, 拷贝成功的话, 下次你登录xxx_ip这台电脑, 就不要密码了, 直接即可$ ssh xxx_ip</code></pre><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>真的要是要什么没有什么.</p><pre><code>$ add locate正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。下列【新】软件包将被安装：  locate升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 212 kB 的归档。解压缩后会消耗 322 kB 的额外空间。获取:1 http://packages.deepin.com/deepin panda/main amd64 locate amd64 4.6.0+git+20161106-2 [212 kB]已下载 212 kB，耗时 0秒 (278 kB/s)正在选中未选择的软件包 locate。(正在读取数据库 ... 系统当前共安装有 153643 个文件和目录。)正准备解包 .../locate_4.6.0+git+20161106-2_amd64.deb  ...正在解包 locate (4.6.0+git+20161106-2) ...正在设置 locate (4.6.0+git+20161106-2) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...$ sudo updatedb</code></pre><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><pre><code>$ add tree正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。下列【新】软件包将被安装：  tree升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 46.1 kB 的归档。解压缩后会消耗 106 kB 的额外空间。获取:1 http://packages.deepin.com/deepin panda/main amd64 tree amd64 1.7.0-5 [46.1 kB]已下载 46.1 kB，耗时 0秒 (150 kB/s)正在选中未选择的软件包 tree。(正在读取数据库 ... 系统当前共安装有 153657 个文件和目录。)正准备解包 .../tree_1.7.0-5_amd64.deb  ...正在解包 tree (1.7.0-5) ...正在设置 tree (1.7.0-5) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...</code></pre><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>gcc的版本很给力, 但是有时候为了某些方便, 我还需要装一个低版本的.</p><pre><code class="bash">$ gcc --versiongcc (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$ locate gcc | grep -E &quot;/usr/bin/gcc-[0-9]&quot;/usr/bin/gcc-6</code></pre><p>安装4.8, 4.9, 5.0版本的gcc</p><pre><code>$ add gcc-4.8 gcc-4.9 gcc-5正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  cpp-4.8 cpp-4.9 cpp-5 libasan0 libasan1 libasan2 libcloog-isl4 libgcc-4.8-dev libgcc-4.9-dev libgcc-5-dev libmpx0建议安装：  gcc-4.8-locales gcc-4.9-locales gcc-5-locales gcc-4.8-multilib gcc-4.8-doc libgcc1-dbg libgomp1-dbg libitm1-dbg  libatomic1-dbg libasan0-dbg libtsan0-dbg libquadmath0-dbg gcc-4.9-multilib gcc-4.9-doc libasan1-dbg liblsan0-dbg  libubsan0-dbg libcilkrts5-dbg gcc-5-multilib gcc-5-doc libasan2-dbg libmpx0-dbg下列【新】软件包将被安装：  cpp-4.8 cpp-4.9 cpp-5 gcc-4.8 gcc-4.9 gcc-5 libasan0 libasan1 libasan2 libcloog-isl4 libgcc-4.8-dev libgcc-4.9-dev  libgcc-5-dev libmpx0升级了 0 个软件包，新安装了 14 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 42.6 MB 的归档。解压缩后会消耗 141 MB 的额外空间。您希望继续执行吗？ [Y/n] Y</code></pre><p>安装完成之后, <code>sudo updatedb</code>, 然后查看一下相应的版本</p><pre><code>$ locate gcc | grep -E &quot;/usr/bin/gcc-[0-9]&quot;/usr/bin/gcc-4.8/usr/bin/gcc-4.9/usr/bin/gcc-5/usr/bin/gcc-6$ gcc --versiongcc (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><p>然后利用 <code>update-alternatives</code> 建立文件关联(当然你也可以自己建立软链接):</p><pre><code># 首先要让系统知道我们安装了多个版本的gcc# 命令最后的 20和50是优先级，如果使用auto选择模式，系统将默认使用优先级高的$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20update-alternatives: 使用 /usr/bin/gcc-4.8 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 30update-alternatives: 使用 /usr/bin/gcc-4.9 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 40update-alternatives: 使用 /usr/bin/gcc-5 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 50update-alternatives: 使用 /usr/bin/gcc-6 来在自动模式中提供 /usr/bin/gcc (gcc)</code></pre><p>再查看一下当前系统中安装的gcc有哪些:</p><pre><code>$ sudo update-alternatives --query gccName: gccLink: /usr/bin/gccStatus: autoBest: /usr/bin/gcc-6Value: /usr/bin/gcc-6Alternative: /usr/bin/gcc-4.8Priority: 20Alternative: /usr/bin/gcc-4.9Priority: 30Alternative: /usr/bin/gcc-5Priority: 40Alternative: /usr/bin/gcc-6Priority: 50</code></pre><p>想切换默认的gcc可以使用修改优先值的方式:</p><pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 60</code></pre><p>或者交互的方式:<br><img src="http://omotkhw3y.bkt.clouddn.com/update-alternatives.jpg" alt="交互方式"></p><blockquote><p>update-alternatives 还可以用于配置多版本的Java或者Python等.</p></blockquote><p>当然你配置gcc的时候, 也可以顺带配置一下, gcc需要调用的binuitls, 比如 ar, nm, ranlib等(当然也可以配置对应版本的g++), 使用<code>--slave</code>选项.</p><pre><code>$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50 \--slave /usr/bin/g++ g++ /usr/bin/g++-5 \--slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-5 \--slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-5 \--slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-5</code></pre><h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p>有些软件的安装, 需要其他的软件或者库; 如果那个工具&amp;库你经常用, 最好不要让它顺便给你装, 比如:</p><pre><code>$ add build-essential正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  g++ g++-6建议安装：  g++-multilib g++-6-multilib gcc-6-doc libstdc++6-6-dbg下列【新】软件包将被安装：  build-essential g++ g++-6升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 7,096 kB 的归档。解压缩后会消耗 24.5 MB 的额外空间。您希望继续执行吗？ [Y/n] n中止。</code></pre><p>我自己装<code>g++</code>, 因为我可能要在多个版本的c++编译器间切换.</p><pre><code class="bash">$ search &quot;g\+\+-[0-9]&quot; | less$ add g++-4.9 g++-5 g++-6正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  libstdc++-4.9-dev libstdc++-5-dev建议安装：  g++-4.9-multilib gcc-4.9-doc libstdc++6-4.9-dbg g++-5-multilib gcc-5-doc libstdc++6-5-dbg g++-6-multilib gcc-6-doc  libstdc++6-6-dbg libstdc++-4.9-doc libstdc++-5-doc下列【新】软件包将被安装：  g++-4.9 g++-5 g++-6 libstdc++-4.9-dev libstdc++-5-dev升级了 0 个软件包，新安装了 5 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 35.8 MB 的归档。解压缩后会消耗 106 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb</code></pre><p>然后用<code>update-alternatives</code>来配置一下:</p><pre><code>$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 30$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 50</code></pre><p>然后query检查一下:</p><pre><code class="bash">$ sudo update-alternatives --query g++Name: g++Link: /usr/bin/g++Status: autoBest: /usr/bin/g++-6Value: /usr/bin/g++-6Alternative: /usr/bin/g++-4.9Priority: 30Alternative: /usr/bin/g++-5Priority: 40Alternative: /usr/bin/g++-6Priority: 50$ g++ --versiong++ (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h2 id="build-essential"><a href="#build-essential" class="headerlink" title="build-essential"></a>build-essential</h2><p>先查看一下依赖:</p><pre><code class="bash">$ depends build-essentialbuild-essential |依赖: libc6-dev  依赖: &lt;libc-dev&gt;    libc6-dev  依赖: gcc  依赖: g++  依赖: make    make-guile  依赖: dpkg-dev</code></pre><p>先看一下哪些没有</p><pre><code class="bash"># 先更新一下本机数据$ update$ upgrade$ policy libc6-devlibc6-dev:  已安装：2.24-9  候选： 2.24-9  版本列表： *** 2.24-9 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status$ policy makemake:  已安装：4.1-9.1  候选： 4.1-9.1  版本列表： *** 4.1-9.1 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status$ policy make-guilemake-guile:  已安装：(无)  候选： 4.1-9.1  版本列表：     4.1-9.1 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages$ policy dpkg-devdpkg-dev:  已安装：1.18.23  候选： 1.18.23  版本列表： *** 1.18.23 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        500 http://packages.deepin.com/deepin panda/main i386 Packages        100 /var/lib/dpkg/status</code></pre><p>那就安装一下<code>make-guile</code>:</p><pre><code>$ search &quot;make-guile*&quot;make-guile - utility for directing compilation with guile support$ add &quot;make-guile&quot;正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  guile-2.0-libs建议安装：  make-doc下列软件包将被【卸载】：  make下列【新】软件包将被安装：  guile-2.0-libs make-guile升级了 0 个软件包，新安装了 2 个软件包，要卸载 1 个软件包，有 0 个软件包未被升级。需要下载 2,536 kB 的归档。解压缩后会消耗 11.8 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb$ make-guile --versionbash: make-guile: 未找到命令$ locate make-guile/usr/share/doc/make-guile/usr/share/doc/make-guile/ABOUT-NLS.gz/usr/share/doc/make-guile/AUTHORS/usr/share/doc/make-guile/Explanations.gz/usr/share/doc/make-guile/NEWS.Debian.gz/usr/share/doc/make-guile/NEWS.gz/usr/share/doc/make-guile/README.Debian-Source/usr/share/doc/make-guile/README.customs.gz/usr/share/doc/make-guile/README.gz/usr/share/doc/make-guile/changelog.Debian.gz/usr/share/doc/make-guile/copyright/var/cache/apt/archives/make-guile_4.1-9.1_amd64.deb/var/lib/dpkg/info/make-guile.list/var/lib/dpkg/info/make-guile.md5sums</code></pre><p>再装<code>build-essential</code>:</p><pre><code>$ add build-essential正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  g++建议安装：  g++-multilib下列【新】软件包将被安装：  build-essential g++升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 8,890 B 的归档。解压缩后会消耗 35.8 kB 的额外空间。您希望继续执行吗？ [Y/n] Y获取:1 http://packages.deepin.com/deepin panda/main amd64 g++ amd64 4:6.3.0-2 [1,544 B]获取:2 http://packages.deepin.com/deepin panda/main amd64 build-essential amd64 12.3 [7,346 B]已下载 8,890 B，耗时 6秒 (1,466 B/s)                                                                                            正在选中未选择的软件包 g++。(正在读取数据库 ... 系统当前共安装有 156361 个文件和目录。)正准备解包 .../g++_4%3a6.3.0-2_amd64.deb  ...正在解包 g++ (4:6.3.0-2) ...正在选中未选择的软件包 build-essential。正准备解包 .../build-essential_12.3_amd64.deb  ...正在解包 build-essential (12.3) ...正在设置 g++ (4:6.3.0-2) ...update-alternatives: 使用 /usr/bin/g++ 来在自动模式中提供 /usr/bin/c++ (c++)正在设置 build-essential (12.3) ...</code></pre><p>这么看来<code>policy</code>可能后面的<code>dpkg</code>工具可能和<code>update-alternatives</code>有点儿误会, 手动调整一下:</p><pre><code>$ sudo update-alternatives --config g++有 3 个候选项可用于替换 g++ (提供 /usr/bin/g++)。  选择       路径            优先级  状态------------------------------------------------------------* 0            /usr/bin/g++-6     50        自动模式  1            /usr/bin/g++-4.9   30        手动模式  2            /usr/bin/g++-5     40        手动模式  3            /usr/bin/g++-6     50        手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：update-alternatives: 警告: 链接组 g++ 已损坏，故强制重新安装候选项 /usr/bin/g++-6$ ls /usr/bin/g++*/usr/bin/g++  /usr/bin/g++-4.9  /usr/bin/g++-5  /usr/bin/g++-6merlin@merlin-deepin:~$ ll /usr/bin/g++$ sudo update-alternatives --config g++有 3 个候选项可用于替换 g++ (提供 /usr/bin/g++)。  选择       路径            优先级  状态------------------------------------------------------------* 0            /usr/bin/g++-6     50        自动模式  1            /usr/bin/g++-4.9   30        手动模式  2            /usr/bin/g++-5     40        手动模式  3            /usr/bin/g++-6     50        手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：$ policy g++g++:  已安装：4:6.3.0-2  候选： 4:6.3.0-2  版本列表： *** 4:6.3.0-2 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status</code></pre><p>好了.</p><h2 id="binutils"><a href="#binutils" class="headerlink" title="binutils"></a>binutils</h2><p>这里, 可能会装一些, 不太常用的工具,(常用的可能都已经装了) 为下面可能装的库打基础(下面会详细说明, 哪些库要用到这些工具).</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>老实说, java, groovy, scala这类jvm语言已经写的很少了.(现在多用shell, python和c++).</p><p>但是有些工具比如thrif还是需要这货的, 为java语言做支持.</p><p>还是装两个版本, jdk7和jdk8, 然后用update-alternatives进行调整.</p><pre><code>$ wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz -P ~/Desktop/apps--2017-08-31 17:58:54--  http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz正在解析主机 download.oracle.com (download.oracle.com)... 184.28.218.123, 184.28.218.122正在连接 download.oracle.com (download.oracle.com)|184.28.218.123|:80... 已连接。已发出 HTTP 请求，正在等待回应... 302 Found位置：http://101.44.1.8/files/2130000006C99F22/download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz [跟随至新的 URL]--2017-08-31 17:58:54--  http://101.44.1.8/files/2130000006C99F22/download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz正在连接 101.44.1.8:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：185515842 (177M) [application/octet-stream]正在保存至: “/home/merlin/Desktop/apps/jdk-8u144-linux-x64.tar.gz”jdk-8u144-linux-x64.tar.gz       100%[=======================================================&gt;] 176.92M  3.60MB/s  用时 44s     2017-08-31 17:59:44 (3.98 MB/s) - 已保存 “/home/merlin/Desktop/apps/jdk-8u144-linux-x64.tar.gz” [185515842/185515842])$ sudo mkdir /usr/local/lib/jvm$ sudo tar -xzvf ~/Desktop/apps/jdk-8u144-linux-x64.tar.gz -C /usr/local/lib/jvm$ $ ls /usr/local/lib/jvmjdk1.8.0_144# 设置环境变量, 在.merlin_bash结尾加上</code></pre><h2 id="jdk-path"><a href="#jdk-path" class="headerlink" title="jdk path"></a>jdk path</h2><p>export JAVA_HOME=/usr/local/lib/jvm/jdk1.8.0_144<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p><pre><code>然后看一下是否安装成功:</code></pre><p>$ source .bashrc<br>$ which java<br>/usr/local/lib/jvm/jdk1.8.0_144/bin/java</p><p>$ java -version<br>Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp<br>java version “1.8.0_144”<br>Java(TM) SE Runtime Environment (build 1.8.0_144-b01)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</p><pre><code>上面的`Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp`好奇怪, 检查一下`_JAVA_OPTIONS`这个环境变量:</code></pre><p>$ sudo grep -nr “JAVA_OPTIONS” /etc<br>/etc/profile.d/java-awt-font-gasp.sh:2:if ! echo ${_JAVA_OPTIONS} |grep -q – ${opt}  ;then<br>/etc/profile.d/java-awt-font-gasp.sh:3:    export _JAVA_OPTIONS=”${_JAVA_OPTIONS}  ${opt}”</p><pre><code>查看了一下:</code></pre><p>$ cat /etc/profile.d/java-awt-font-gasp.sh</p><pre><code>opt=&quot;-Dawt.useSystemAAFontSettings=gasp&quot;if ! echo ${_JAVA_OPTIONS} |grep -q -- ${opt}  ;then     export _JAVA_OPTIONS=&quot;${_JAVA_OPTIONS}  ${opt}&quot;fi</code></pre><p>这个宏本来是指定运行参数(<code>java %JAVA_OPTIONS% -Xmx1024m -XX:MaxPermSize=128m</code>), 这里检查到”JAVA_OPTIONS”里没有设置<code>awt</code>界面组建的宏, 所以在这里指定了运行系统的字体和图形库. 但是一旦这里export, 后面运行<code>java</code>命令就会打印那条语句, 没办法, 在我的配置文件里面做一下处理吧.(JAVA_OPTIONS是运行时会自动指定的), 这里的文件就不要动了.<br>(意思是, 你的运行参数不要export了, 我运行的时候自己手动加载好了)</p><pre><code>## java related (关于是否配置环境变量, 看下面说明)JAVA_OPT=${_JAVA_OPTIONS}unset _JAVA_OPTIONSalias java=&quot;java ${JAVA_OPT}&quot;</code></pre><p>然后注销重新登录, 运行<code>java -version</code> :</p><pre><code>$ alias javaalias java=&#39;java   -Dawt.useSystemAAFontSettings=gasp&#39;$ java -versionjava version &quot;1.8.0_144&quot;Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</code></pre><blockquote><p>这里注意了,如果后面你要用update-alternatives管理javac,java等工具, 就不要配置环境变量!</p></blockquote><p>装完oralble的jdk, 还要装一个open jdk, 以免有时候编译需要(可能是某些版本的android框架或者应用需要).</p><pre><code>$ search openjdk-8-jdkdefault-jdk - Standard Java or Java compatible Development Kitdefault-jdk-headless - Standard Java or Java compatible Development Kit (headless)openjdk-8-jdk - OpenJDK Development Kit (JDK)openjdk-8-jdk-headless - OpenJDK Development Kit (JDK) (headless)$ add openjdk-8-jdk正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  ca-certificates-java fonts-dejavu-extra java-common libatk-wrapper-java libatk-wrapper-java-jni libice-dev  libpthread-stubs0-dev libsm-dev libx11-dev libx11-doc libxau-dev libxcb1-dev libxdmcp-dev libxt-dev  openjdk-8-jdk-headless openjdk-8-jre openjdk-8-jre-headless x11proto-core-dev x11proto-input-dev x11proto-kb-dev  xorg-sgml-doctools xtrans-dev建议安装：  default-jre libice-doc libsm-doc libxcb-doc libxt-doc openjdk-8-demo openjdk-8-source visualvm icedtea-8-plugin  libnss-mdns fonts-ipafont-gothic fonts-ipafont-mincho fonts-wqy-zenhei fonts-indic下列【新】软件包将被安装：  ca-certificates-java fonts-dejavu-extra java-common libatk-wrapper-java libatk-wrapper-java-jni libice-dev  libpthread-stubs0-dev libsm-dev libx11-dev libx11-doc libxau-dev libxcb1-dev libxdmcp-dev libxt-dev openjdk-8-jdk  openjdk-8-jdk-headless openjdk-8-jre openjdk-8-jre-headless x11proto-core-dev x11proto-input-dev x11proto-kb-dev  xorg-sgml-doctools xtrans-dev升级了 0 个软件包，新安装了 23 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 43.5 MB 的归档。解压缩后会消耗 170 MB 的额外空间。您希望继续执行吗？ [Y/n] Y...update-alternatives: 使用 /usr/lib/jvm/java-8-openjdk-amd64/bin/jconsole 来在自动模式中提供 /usr/bin/jconsole (jconsole)正在处理用于 libc-bin (2.24-9) 的触发器 ...正在处理用于 ca-certificates (20161130) 的触发器 ...Updating certificates in /etc/ssl/certs...0 added, 0 removed; done.Running hooks in /etc/ca-certificates/update.d...done.done.</code></pre><p>查看一下是不是update-alternatives已经托管:</p><pre><code>sudo update-alternatives --config java链接组 java (提供 /usr/bin/java)中只有一个候选项：/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java无需配置。</code></pre><p>看来还是要手动配置一下, 我自己安装的/usr/local/lib/jvm下的那个, 以及这一个(因为他的路径不对, 主要到是jre)</p><pre><code>$ sudo update-alternatives --remove java /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java$ sudo update-alternatives --install /usr/bin/java java /usr/local/lib/jvm/jdk1.8.0_144/bin/java 300$ sudo update-alternatives --install /usr/bin/javac javac /usr/local/lib/jvm/jdk1.8.0_144/bin/javac 300$ sudo update-alternatives --install /usr/bin/jar jar /usr/local/lib/jvm/jdk1.8.0_144/bin/jar 300$ sudo update-alternatives --install /usr/bin/javah javah /usr/local/lib/jvm/jdk1.8.0_144/bin/javah 300$ sudo update-alternatives --install /usr/bin/javap javap /usr/local/lib/jvm/jdk1.8.0_144/bin/javap 300$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-openjdk-amd64/bin/java 200$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8-openjdk-amd64/bin/javac 200$ sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/java-8-openjdk-amd64/bin/jar 200$ sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/java-8-openjdk-amd64/bin/javah 200$ sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/java-8-openjdk-amd64/bin/javap 200$ sudo update-alternatives --display javajava - 手动模式  最佳链接版本为 /usr/local/lib/jvm/jdk1.8.0_144/bin/java 链接目前指向 /usr/local/lib/jvm/jdk1.8.0_144/bin/java  链接 java 指向 /usr/bin/java/usr/lib/jvm/java-8-openjdk-amd64/bin/java - 优先级 200/usr/local/lib/jvm/jdk1.8.0_144/bin/java - 优先级 300</code></pre><p>(这里如果你配置了JAVA_HOME等环境变量, 那么<code>upate-alternatives</code>就失效了, 不能起到切换的作用)</p><p>破Java环境, 终于闹腾好了.</p><h2 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h2><p>ant: Java based build tool like make; 可能大家现在用maven啊, gradle啊比较多. 但是这个软件可能用于编译某些工具的库或者包, 所以还是要装一个.</p><pre><code>$ add ant正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  ant-optional建议安装：  ant-doc ant-gcj ant-optional-gcj antlr javacc junit junit4 jython libbcel-java libbsf-java libcommons-logging-java libcommons-net-java libmail-java libjaxp1.3-java  libjdepend-java libjsch-java liblog4j1.2-java liboro-java libregexp-java libxalan2-java libxml-commons-resolver1.1-java下列【新】软件包将被安装：  ant ant-optional升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 2,270 kB 的归档。解压缩后会消耗 3,170 kB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which ant/usr/bin/ant</code></pre><p>安装完毕.</p><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>有些库编译需要, 没有什么好说的.</p><pre><code>$ add maven正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  junit junit4 libaopalliance-java libapache-pom-java libasm-java libatinject-jsr330-api-java libbsh-java libcdi-api-java  libcglib-java libclassworlds-java libcommons-cli-java libcommons-codec-java libcommons-httpclient-java libcommons-io-java  libcommons-lang-java libcommons-lang3-java libcommons-logging-java libcommons-net-java libcommons-parent-java libdom4j-java  libdoxia-core-java libeasymock-java libeclipse-aether-java libgeronimo-interceptor-3.0-spec-java libguava-java libguice-java  libhamcrest-java libhttpclient-java libhttpcore-java libisorelax-java libjaxen-java libjaxp1.3-java libjdom1-java libjetty9-java  libjsch-java libjsoup-java libjsr305-java libjzlib-java liblog4j1.2-java libmaven-parent-java libmaven2-core-java  libmaven3-core-java libmsv-java libobjenesis-java libplexus-ant-factory-java libplexus-archiver-java libplexus-bsh-factory-java  libplexus-cipher-java libplexus-classworlds-java libplexus-classworlds2-java libplexus-cli-java  libplexus-component-annotations-java libplexus-component-metadata-java libplexus-container-default-java  libplexus-container-default1.5-java libplexus-containers-java libplexus-containers1.5-java libplexus-interactivity-api-java  libplexus-interpolation-java libplexus-io-java libplexus-sec-dispatcher-java libplexus-utils-java libplexus-utils2-java  libqdox2-java librelaxng-datatype-java libservlet3.1-java libsisu-inject-java libsisu-plexus-java libslf4j-java libwagon-java  libwagon2-java libxalan2-java libxbean-java libxerces2-java libxml-commons-external-java libxml-commons-resolver1.1-java  libxom-java libxpp2-java libxpp3-java建议安装：  junit-doc libaopalliance-java-doc libatinject-jsr330-api-java-doc libclassworlds-java-doc libcommons-httpclient-java-doc  libcommons-io-java-doc libcommons-lang-java-doc libcommons-lang3-java-doc libavalon-framework-java libcommons-logging-java-doc  libexcalibur-logkit-java libcommons-net-java-doc libdom4j-java-doc libeasymock-java-doc libjaxp1.3-java-gcj libjdom1-java-doc  jetty9 libjsoup-java-doc libjsr305-java-doc libmail-java liblog4j1.2-java-doc libobjenesis-java-doc libplexus-cipher-java-doc  libplexus-classworlds-java-doc libplexus-classworlds2-java-doc libplexus-cli-java-doc libplexus-container-default-java-doc  libplexus-interactivity-api-java-doc libplexus-interpolation-java-doc libplexus-sec-dispatcher-java-doc libplexus-utils-java-doc  libplexus-utils2-java-doc libqdox2-java-doc testng libwagon-java-doc libxalan2-java-doc libbsf-java libxsltc-java groovy  libequinox-osgi-java libosgi-compendium-java libosgi-core-java libqdox-java libspring-beans-java libspring-context-java  libspring-core-java libspring-web-java libxerces2-java-doc libxerces2-java-gcj libxml-commons-resolver1.1-java-doc  libxom-java-doc下列【新】软件包将被安装：  junit junit4 libaopalliance-java libapache-pom-java libasm-java libatinject-jsr330-api-java libbsh-java libcdi-api-java  libcglib-java libclassworlds-java libcommons-cli-java libcommons-codec-java libcommons-httpclient-java libcommons-io-java  libcommons-lang-java libcommons-lang3-java libcommons-logging-java libcommons-net-java libcommons-parent-java libdom4j-java  libdoxia-core-java libeasymock-java libeclipse-aether-java libgeronimo-interceptor-3.0-spec-java libguava-java libguice-java  libhamcrest-java libhttpclient-java libhttpcore-java libisorelax-java libjaxen-java libjaxp1.3-java libjdom1-java libjetty9-java  libjsch-java libjsoup-java libjsr305-java libjzlib-java liblog4j1.2-java libmaven-parent-java libmaven2-core-java  libmaven3-core-java libmsv-java libobjenesis-java libplexus-ant-factory-java libplexus-archiver-java libplexus-bsh-factory-java  libplexus-cipher-java libplexus-classworlds-java libplexus-classworlds2-java libplexus-cli-java  libplexus-component-annotations-java libplexus-component-metadata-java libplexus-container-default-java  libplexus-container-default1.5-java libplexus-containers-java libplexus-containers1.5-java libplexus-interactivity-api-java  libplexus-interpolation-java libplexus-io-java libplexus-sec-dispatcher-java libplexus-utils-java libplexus-utils2-java  libqdox2-java librelaxng-datatype-java libservlet3.1-java libsisu-inject-java libsisu-plexus-java libslf4j-java libwagon-java  libwagon2-java libxalan2-java libxbean-java libxerces2-java libxml-commons-external-java libxml-commons-resolver1.1-java  libxom-java libxpp2-java libxpp3-java maven升级了 0 个软件包，新安装了 80 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 27.6 MB 的归档。解压缩后会消耗 38.0 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which maven</code></pre><h2 id="IntelliJ"><a href="#IntelliJ" class="headerlink" title="IntelliJ"></a>IntelliJ</h2><p>直接去 <a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="external">页面</a> 下载安装包.</p><pre><code>$ wget https://download.jetbrains.8686c.com/idea/ideaIC-2017.2.3.tar.gz -P Desktop/apps$ mkdir Software$ tar -xzvf ~/Desktop/apps/ideaIC-2017.2.3.tar.gz -C Software/$ cd Software/idea-IC-172.3968.16/bin$ ./idea.sh</code></pre><p>之后安装时, 它会有一个步骤, 问你是否建立执行脚本, 点击确定即可, 然后可以看到:</p><pre><code>$ which idea/usr/local/bin/idea$ whereis ideaidea: /usr/local/bin/idea$ ll /usr/local/bin/idea-rwxr-xr-x 1 root root 3111 8月  31 21:58 /usr/local/bin/idea$ file /usr/local/bin/idea/usr/local/bin/idea: Python script, ASCII text executable</code></pre><p>这样就算安装完毕了.</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>一般linux是自带2.7版本的python的, 出于某些目的有时候也要安装python3(比如cppman就是需要python3安装), 幸好deepin也自带了.</p><pre><code>$ which python/usr/bin/python$ whereis pythonpython: /usr/bin/python /usr/bin/python2.7 /usr/bin/python3.5 /usr/bin/python3.5m /usr/lib/python2.7 /usr/lib/python3.5 /etc/python /etc/python2.7 /etc/python3.5 /usr/local/lib/python2.7 /usr/local/lib/python3.5 /usr/include/python2.7 /usr/include/python3.5m /usr/share/python /usr/share/man/man1/python.1.gz$ python --versionPython 2.7.13</code></pre><p>那么先把python2.7交给update-altertives管理再说.</p><pre><code>$ sudo update-alternatives --list pythonupdate-alternatives: 错误: 无 python 的候选项$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 200$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100  $ sudo update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.5$ sudo update-alternatives --display pythonpython - 自动模式  最佳链接版本为 /usr/bin/python3.5 链接目前指向 /usr/bin/python3.5  链接 python 指向 /usr/bin/python/usr/bin/python2.7 - 优先级 100/usr/bin/python3.5 - 优先级 200$ python --versionPython 3.5.3</code></pre><p>还没有完, 你会发现/usr/include/python2.7下面没有多少头文件! 所以还要安装相关的, 必要的库.</p><pre><code>$ sudo updatedb$ locate Python.h   #没有结果#下面也没有结果$ dpkg --get-selections |grep python-dev$ ldconfig -p | grep python-dev  libpython3.5m.so.1.0 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython3.5m.so.1.0  libpython3.5m.so (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython3.5m.so  libpython2.7.so.1.0 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython2.7.so.1.0  libpyglib-2.0-python2.7.so.0 (libc6,x86-64) =&gt; /usr/lib/libpyglib-2.0-python2.7.so.0  libboost_python3.so.1.63.0 (libc6,x86-64) =&gt; /usr/local/lib/libboost_python3.so.1.63.0  libboost_python3.so (libc6,x86-64) =&gt; /usr/local/lib/libboost_python3.so  libboost_python.so.1.63.0 (libc6,x86-64) =&gt; /usr/local/lib/libboost_python.so.1.63.0  libboost_python.so (libc6,x86-64) =&gt; /usr/local/lib/libboost_python.so(可以查看库文件, 但不见得有头文件)</code></pre><p>所以下面安装一下(Python.h is provided by -dev)</p><pre><code>$ add python-dev libboost-python-dev libboost-mpi-python-dev正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  libboost-mpi-python1.62-dev libboost-mpi-python1.62.0 libboost-mpi1.62-dev libboost-mpi1.62.0 libboost-python1.62-dev  libboost-python1.62.0 libboost-serialization1.62-dev libboost-serialization1.62.0 libboost1.62-dev libfabric1 libhwloc-dev  libhwloc-plugins libhwloc5 libibverbs-dev libnuma-dev libopenmpi-dev libopenmpi2 libpsm-infinipath1 libpython-dev  libpython2.7-dev mpi-default-bin mpi-default-dev ocl-icd-libopencl1 openmpi-bin openmpi-common python2.7-dev建议安装：  libboost-graph1.62-dev libboost1.62-doc gccxml libboost-atomic1.62-dev libboost-chrono1.62-dev libboost-context1.62-dev  libboost-coroutine1.62-dev libboost-date-time1.62-dev libboost-exception1.62-dev libboost-fiber1.62-dev  libboost-filesystem1.62-dev libboost-graph-parallel1.62-dev libboost-iostreams1.62-dev libboost-locale1.62-dev  libboost-log1.62-dev libboost-math1.62-dev libboost-program-options1.62-dev libboost-random1.62-dev libboost-regex1.62-dev  libboost-signals1.62-dev libboost-system1.62-dev libboost-test1.62-dev libboost-thread1.62-dev libboost-timer1.62-dev  libboost-type-erasure1.62-dev libboost-wave1.62-dev libboost1.62-tools-dev libmpfrc++-dev libntl-dev libhwloc-contrib-plugins  openmpi-doc opencl-icd gfortran下列【新】软件包将被安装：  libboost-mpi-python-dev libboost-mpi-python1.62-dev libboost-mpi-python1.62.0 libboost-mpi1.62-dev libboost-mpi1.62.0  libboost-python-dev libboost-python1.62-dev libboost-python1.62.0 libboost-serialization1.62-dev libboost-serialization1.62.0  libboost1.62-dev libfabric1 libhwloc-dev libhwloc-plugins libhwloc5 libibverbs-dev libnuma-dev libopenmpi-dev libopenmpi2  libpsm-infinipath1 libpython-dev libpython2.7-dev mpi-default-bin mpi-default-dev ocl-icd-libopencl1 openmpi-bin openmpi-common  python-dev python2.7-dev升级了 0 个软件包，新安装了 29 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 40.9 MB 的归档。解压缩后会消耗 185 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb$ locate Python.h/usr/include/python2.7/Python.h/usr/include/python3.5m/Python.h</code></pre><p>差不多了.</p><p>安装pip3工具:</p><pre><code>$ add python3-pip[sudo] merlin 的密码：正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  libexpat1-dev libpython3-dev libpython3.5-dev python-pip-whl python3-cffi-backend python3-crypto  python3-cryptography python3-dev python3-idna python3-keyring python3-keyrings.alt python3-pyasn1  python3-secretstorage python3-setuptools python3-wheel python3.5-dev建议安装：  python3-crypto-dbg python-crypto-doc python-cryptography-doc python3-cryptography-vectors libkf5wallet-bin  gir1.2-gnomekeyring-1.0 python3-pykde4 doc-base python-secretstorage-doc python-setuptools-doc下列【新】软件包将被安装：  libexpat1-dev libpython3-dev libpython3.5-dev python-pip-whl python3-cffi-backend python3-crypto  python3-cryptography python3-dev python3-idna python3-keyring python3-keyrings.alt python3-pip python3-pyasn1  python3-secretstorage python3-setuptools python3-wheel python3.5-dev升级了 0 个软件包，新安装了 17 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 40.8 MB 的归档。解压缩后会消耗 63.2 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ $ which pip3/usr/bin/pip3</code></pre><p>这样就算差不多了, 以后根据自己的需求, 选择安装相应的库即可.</p><h2 id="安装pycharm"><a href="#安装pycharm" class="headerlink" title="安装pycharm"></a>安装pycharm</h2><p>下载 pycharm</p><pre><code>$ wget https://download.jetbrains.8686c.com/python/pycharm-community-2017.2.2.tar.gz -P Desktop/apps</code></pre><p>安装</p><pre><code>$ tar -xzvf Desktop/apps/pycharm-community-2017.2.2.tar.gz -C Software/$ cd Software/pycharm-community-2017.2.2/bin$ ./pycharm.sh</code></pre><p>安装时, 请勾选建立<code>/usr/local/bin/pycharm</code>脚本这一项, 然后可以看到:</p><pre><code>$ which pycharm /usr/local/bin/pycharm$ file /usr/local/bin/pycharm /usr/local/bin/pycharm: Python script, ASCII text executable</code></pre><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><p>一般而言, 选择apt工具就够了 <code>sudo apt-get install golang</code>, 但是为了能够实时更新一下, 可以采用源:</p><pre><code>sudo add-apt-repository ppa:gophers/gosudo apt-get updatesudo apt-get install golang-stable</code></pre><p>我直接安装的:</p><pre><code>$ add golang正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  golang-1.7 golang-1.7-doc golang-1.7-go golang-1.7-src golang-doc golang-go golang-src建议安装：  bzr mercurial subversion下列【新】软件包将被安装：  golang golang-1.7 golang-1.7-doc golang-1.7-go golang-1.7-src golang-doc golang-go golang-src升级了 0 个软件包，新安装了 8 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 29.5 MB 的归档。解压缩后会消耗 147 MB 的额外空间。您希望继续执行吗？ [Y/n] Y</code></pre><p>之后需要配置一下环境变量:(网上很多配的是错的)</p><pre><code>export GOROOT=/usr/lib/go-1.7export GOBIN=$GOROOT/binexport PATH=$GOBIN:$PATHexport GOPATH=/home/merlin/Desktop/GOPATHexport GOOS=linuxexport GOARCH=amd64</code></pre><p>查看一下配置:</p><pre><code>$ go versiongo version go1.7.4 linux/amd64$ source ~/.bashrc$ echo $GOPATH/home/merlin/Desktop/GOPATH</code></pre><p>在GOPATH下新建3个目录:(为你的项目)</p><ul><li>src 存放源码</li><li>pkg 存放编译生成的文件</li><li>bin 存放生成的可执行文件</li></ul><h2 id="cppman"><a href="#cppman" class="headerlink" title="cppman"></a>cppman</h2><p>我主业C++, 所以马上来配置一下c++的开发环境.</p><p><code>cppman</code> 可以实时从cplusplus.com以及cppreference.com上面下载文档的一个小工具.<br>repo的地址是: <a href="https://github.com/aitjcize/cppman" target="_blank" rel="external">https://github.com/aitjcize/cppman</a> </p><p>可以直接用apt工具安装</p><pre><code class="shell">$ search &quot;cppman&quot;cppman - C++ 98/11 manual pages for Linux, with source from cplusplus.com$ add cppman正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  python3-bs4 python3-html5lib python3-webencodings建议安装：  python3-genshi下列【新】软件包将被安装：  cppman python3-bs4 python3-html5lib python3-webencodings升级了 0 个软件包，新安装了 4 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 321 kB 的归档。解压缩后会消耗 1,861 kB 的额外空间。您希望继续执行吗？ [Y/n] Y# 安装完成之后, 要先从网站上缓存页面才可以.## 切换源$ cppman -s cppreference.comSource set to `cppreference.com&#39;.## 缓存$ cppman -cBy default, cppman fetches pages on-the-fly if corresponding page is not found in the cache. The &quot;cache-all&quot; option is only useful if you want to view man pages offline. Caching all contents will take several minutes, do you want to continue [y/N]?y</code></pre><p>注意它需要装python3, 才行; 但是python是常用的, 所以版本管理还是交给update-alternatives吧.<br>(安装完python3之后再来安装cppman)</p><p>(再缓存<code>cppman -c</code>的时候, 你最好使用一下代理, 否则很容易缓存失败)</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>像boost, thrift虽然都不适用cmake编译, 但是现在很多流行的库, 比如gtest等, 都是用cmake, 而且相对于make的好, 不需要我多说.</p><p>下面就安装一下cmake.</p><p><code>sudo apt-get install</code> 安装的版本往往比较老, 所以一般需要自己去下载, 然后编译安装.</p><p>下载:  <a href="https://cmake.org/download/" target="_blank" rel="external">https://cmake.org/download/</a> 或者 (<a href="https://github.com/Kitware/CMake" target="_blank" rel="external">https://github.com/Kitware/CMake</a>)<br>直接去官网拿压缩包源码</p><pre><code>$ wget https://cmake.org/files/v3.9/cmake-3.9.1.tar.gz -P Desktop/apps/$ cd Desktop/apps$ tar -xzvf cmake-3.9.1.tar.gz</code></pre><p>编译安装</p><pre><code>$ ./configureCMake has bootstrapped.  Now run make.$ make -j4$ sudo make install</code></pre><p>可以从安装日志中看到, 主要是这三个工具</p><pre><code>-- Installing: /usr/local/bin/cmake-- Installing: /usr/local/bin/ctest-- Installing: /usr/local/bin/cpack</code></pre><p>最后删除, 安装包.<br>(你不要去下载它的gui客户端呀, 好神经的说)</p><h2 id="qt"><a href="#qt" class="headerlink" title="qt"></a>qt</h2><p>主要包括qtcreator和qt库, 这是它的<a href="https://www.qt.io/download-open-source/" target="_blank" rel="external">官网</a>, 越来越恶心的官网, 我决定直接用apt工具下载qtcreator, 之后qt核心库再去官网下载.</p><pre><code>add qtcreator正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  binfmt-support clang clang-3.8 gdb libbabeltrace-ctf1 libbabeltrace1 libbotan-1.10-1 libc6-dbg  libclang-common-3.8-dev libclang1-3.8 libclang1-3.9 libdw1 libffi-dev libjsoncpp1 libllvm3.8 libobjc-6-dev  libqbscore1.8 libqbsqtprofilesetup1.8 libqt5designercomponents5 libqt5quicktest5 libqt5script5 libtinfo-dev llvm-3.8  llvm-3.8-dev llvm-3.8-runtime qml-module-qtqml-models2 qmlscene qt5-doc qt5-qmltooling-plugins qtbase5-dev-tools  qtbase5-doc qtconnectivity5-doc qtcreator-data qtcreator-doc qtdeclarative5-dev-tools qtdeclarative5-doc  qtgraphicaleffects5-doc qtlocation5-doc qtmultimedia5-doc qtquickcontrols5-doc qtscript5-doc qtsensors5-doc  qtserialport5-doc qtsvg5-doc qttools5-dev-tools qttools5-doc qtwebkit5-doc qtwebkit5-examples-doc qtwebsockets5-doc  qtx11extras5-doc qtxmlpatterns5-dev-tools qtxmlpatterns5-doc建议安装：  gnustep gnustep-devel clang-3.8-doc gdb-doc gdbserver llvm-3.8-doc qtbase5-dev cmake kdelibs5-data subversion下列【新】软件包将被安装：  binfmt-support clang clang-3.8 gdb libbabeltrace-ctf1 libbabeltrace1 libbotan-1.10-1 libc6-dbg  libclang-common-3.8-dev libclang1-3.8 libclang1-3.9 libdw1 libffi-dev libjsoncpp1 libllvm3.8 libobjc-6-dev  libqbscore1.8 libqbsqtprofilesetup1.8 libqt5designercomponents5 libqt5quicktest5 libqt5script5 libtinfo-dev llvm-3.8  llvm-3.8-dev llvm-3.8-runtime qml-module-qtqml-models2 qmlscene qt5-doc qt5-qmltooling-plugins qtbase5-dev-tools  qtbase5-doc qtconnectivity5-doc qtcreator qtcreator-data qtcreator-doc qtdeclarative5-dev-tools qtdeclarative5-doc  qtgraphicaleffects5-doc qtlocation5-doc qtmultimedia5-doc qtquickcontrols5-doc qtscript5-doc qtsensors5-doc  qtserialport5-doc qtsvg5-doc qttools5-dev-tools qttools5-doc qtwebkit5-doc qtwebkit5-examples-doc qtwebsockets5-doc  qtx11extras5-doc qtxmlpatterns5-dev-tools qtxmlpatterns5-doc升级了 0 个软件包，新安装了 53 个软件包，要卸载 0 个软件包，有 5 个软件包未被升级。需要下载 204 MB 的归档。解压缩后会消耗 601 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which qtcreator /usr/bin/qtcreator</code></pre><p>之后设置qt库的版本(环境变量), 比如<code>add libqt4-dev</code>, 可以在你的<code>.bashrc</code>里面, 或者使用<code>/usr/bin/qtchooser</code>来设置. 如要需要换最新版本的qt, 可以<code>sudo apt-get remove qtcreator</code>进行卸载, 或者purge.</p><h2 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h2><p>玩cpp的, 不装boost?<br>你可以用apt工具去装, 比如:</p><pre><code># 一般安装libboost-dev就行sudo apt-get install libboost-all-devsudo apt-get install libboost-dev# 或者sudo apt-cache search boost搜自己想要的库sudo apt-get install mpi-default-dev　　#安装mpi库sudo apt-get install libicu-dev　　　　　#支持正则表达式的UNICODE字符集sudo apt-get install python-dev　　　　　#需要python的话sudo apt-get install libbz2-dev     #失败的话 sudo apt-get update试试</code></pre><p>然后日常开发中, 常常用到这个库, 要确定的版本, 最好自己去官网下载安装(linux和vs版都要装).</p><p>关于安装, 你可以参考一下, 我这篇文章<a href="http://www.merlinblog.site/2017/06/21/boost.html">boost</a>, 下面快速说:<br>下载</p><pre><code>## 我直接从我的远端服务器拷贝了 boost_1_63_0.7z$ scp -r merlin@xxxx:/home/merlin/packages/boost_1_63_0.7z ./apps/$ 7z x boost_1_63_0.7z -o.</code></pre><p>编译安装:</p><pre><code>$ ./bootstrap.sh$ ./b2 --show-librariesThe following libraries require building:    - atomic    - chrono    - container    - context    - coroutine    - coroutine2    - date_time    - exception    - fiber    - filesystem    - graph    - graph_parallel    - iostreams    - locale    - log    - math    - metaparse    - mpi    - program_options    - python    - random    - regex    - serialization    - signals    - system    - test    - thread    - timer    - type_erasure    - wave# 也就是说, 下面编译全是为了上面那些库(下面还是全编译吧)# 如果./b2 --with-atomic --buildtype=complete install表示只编译atomic库# 注意一下拷贝权限问题$ sudo ./b2 --buildtype=complete install</code></pre><p>之后查看一下编译日志:</p><pre><code>Component configuration:    - atomic                   : building    - chrono                   : building    - container                : building    - context                  : building    - coroutine                : building    - coroutine2               : building    - date_time                : building    - exception                : building    - fiber                    : building    - filesystem               : building    - graph                    : building    - graph_parallel           : building    - iostreams                : building    - locale                   : building    - log                      : building    - math                     : building    - metaparse                : building    - mpi                      : building    - program_options          : building    - python                   : building    - random                   : building    - regex                    : building    - serialization            : building    - signals                  : building    - system                   : building    - test                     : building    - thread                   : building    - timer                    : building    - type_erasure             : building    - wave                     : building</code></pre><p>之后跟着一大堆common.copy把lib和头文件分别拷贝到了, <code>/usr/local/include</code>和<code>/usr/local/lib</code>下面.</p><p>只要不出现<code>failure</code>基本可以认定编译, 安装成功了.</p><h2 id="log4cpp"><a href="#log4cpp" class="headerlink" title="log4cpp"></a>log4cpp</h2><h2 id="rapidxml"><a href="#rapidxml" class="headerlink" title="rapidxml"></a>rapidxml</h2><p>这个是常用的库, 不过有个坑需要你调整一下. 详细内容不再叙述, 请参考我的文章 <a href="http://www.merlinblog.site/2017/08/22/rapid-xml.html">rapidxml</a></p><pre><code>$ wget https://nchc.dl.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip$ unzip rapidxml-1.13.zipArchive:  rapidxml-1.13.zip   creating: rapidxml-1.13/  inflating: rapidxml-1.13/license.txt    inflating: rapidxml-1.13/manual.html    inflating: rapidxml-1.13/rapidxml.hpp    inflating: rapidxml-1.13/rapidxml_iterators.hpp    inflating: rapidxml-1.13/rapidxml_print.hpp    inflating: rapidxml-1.13/rapidxml_utils.hpp $ sudo mv rapidxml-1.13 /usr/local/include/rapidxml</code></pre><h2 id="rapidjson"><a href="#rapidjson" class="headerlink" title="rapidjson"></a>rapidjson</h2><p>全部是头文件的库, 安装起来也比较简单:</p><pre><code>$ git clone https://github.com/miloyip/rapidjson.git$ cd rapidjson$ cmake .$ sudo make install</code></pre><h2 id="protobuffer"><a href="#protobuffer" class="headerlink" title="protobuffer"></a>protobuffer</h2><p>下载</p><pre><code>$ git clone https://github.com/google/protobuf.git</code></pre><p>编译安装:</p><pre><code>$ ./autogen.sh$ ./configure$ make$ make check$ sudo make install$ sudo ldconfig # refresh shared library cache.</code></pre><p>(整个过程还是比较顺利的)</p><h2 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h2><p>直接参考的文章 thrift.</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer.<br>可能你不写JavaScript的东西, 不过这个npm被很多其他软件用到, 所以最好你还是装一下(三兄弟一起).</p><pre><code>checking for nodejs... nochecking for node... nochecking for npm... no</code></pre><p>下载并安装(不要使用apt工具, 因为版本都不新)</p><pre><code>$ wget https://nodejs.org/dist/v6.11.2/node-v6.11.2-linux-x64.tar.xz -P  ~/Desktop/apps$ tar -xJvf Desktop/apps/node-v6.11.2-linux-x64.tar.xz -C Software/</code></pre><p>之后配置一下环境变量就可以了:</p><pre><code>## node     npm relatedexport NODE_HOME=/home/merlin/Software/node-v6.11.2-linux-x64export NODE_PATH=$NODE_HOME/lib/node_modulesexport PATH=$PATH:$NODE_HOME/bin</code></pre><p>测试一下安装工作:</p><pre><code>$ npm -v3.10.10$ node -vv6.11.2</code></pre><h2 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h2><p>一般使用的就是 glibc-doc 和 manpages-posix-dev.</p><pre><code>$ add glibc-doc$ add glibc-doc-reference$ add manpages-dev$ add manpages-posix$ add manpages-posix-dev</code></pre><h2 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h2><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>一般我熟悉的项目, 我直接用<a href="git clone https://github.com/tsgates/git-emacs.git">git-emacs</a>:<br>提交等写入操作, 使用git-emacs.</p><pre><code>;;git-emacs(add-to-list &#39;load-path &quot;/path/to/git-emacs/&quot;)(require &#39;git-emacs)</code></pre><p>如果是别人的项目, 要我接手或者帮忙找错, 那么我直接使用gitk: <code>M-x gitk</code><br>(阅读建议使用 <code>gitk</code>)</p><pre><code>add gitk正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  libtk8.6 tcl tcl8.6 tk tk8.6建议安装：  git-doc tcl-tclreadline下列【新】软件包将被安装：  gitk libtk8.6 tcl tcl8.6 tk tk8.6升级了 0 个软件包，新安装了 6 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 1,757 kB 的归档。解压缩后会消耗 4,101 kB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which gitk/usr/bin/gitk</code></pre><p>运行的时候, 切换到相应的库目录里面, 然后<code>gitk</code>, 例如我查看别人的库:<br><img src="" alt=""></p><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>资源监控器</p><h3 id="understand"><a href="#understand" class="headerlink" title="understand"></a>understand</h3><p><a href="http://blog.csdn.net/p942005405/article/details/53639970" target="_blank" rel="external">Scientific Toolworks Understand</a><br>源码查看器(和gtags, source in sight类似)</p><h3 id="remarkable"><a href="#remarkable" class="headerlink" title="remarkable"></a>remarkable</h3><p>专门用于写markdown, 导出到pdf的编辑器.</p><pre><code># 安装的时候, 先把python切换到2.7版本$ add remarkable正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  gir1.2-javascriptcoregtk-3.0 gir1.2-soup-2.4 gir1.2-webkit-3.0 libjavascriptcoregtk-3.0-0 libqt5xmlpatterns5  libwebkitgtk-3.0-0 libyaml-0-2 python3-markdown python3-pygments python3-yaml wkhtmltopdf下列【新】软件包将被安装：  gir1.2-javascriptcoregtk-3.0 gir1.2-soup-2.4 gir1.2-webkit-3.0 libjavascriptcoregtk-3.0-0 libqt5xmlpatterns5  libwebkitgtk-3.0-0 libyaml-0-2 python3-markdown python3-pygments python3-yaml remarkable wkhtmltopdf升级了 0 个软件包，新安装了 12 个软件包，要卸载 0 个软件包，有 5 个软件包未被升级。需要下载 12.3 MB 的归档。解压缩后会消耗 53.3 MB 的额外空间。您希望继续执行吗？ [Y/n] Y# 安装成功$ which remarkable/usr/bin/remarkable</code></pre><p>配置一下</p><pre><code>## remarkable (u could add &amp; to run)alias md=&#39;nohup remarkable&#39;</code></pre><p>然后运行一下, 功能正常</p><pre><code>$ md read.md &amp;</code></pre><h3 id="vistual-studio-code"><a href="#vistual-studio-code" class="headerlink" title="vistual studio code"></a>vistual studio code</h3><p>我原来是用remarkable打开markdown文件, 后来发现这个vistual studio code越来越强大, 就直接用它了.<br>直接去<a href="https://code.visualstudio.com/" target="_blank" rel="external">官网</a>下载deb安装包, 安装即可.<br><code>`$ sudo dpkg -i code_1.15.1-1502903936_amd64.deb$ which code/usr/bin/code</code></p><hr><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>当初把 Mac pro 15 卖掉的原因就是, 我已经非常熟悉Ubuntu了, 没必要在改变习惯, 使用homebrew等其他软件, 并且机器的配置文件位置我也习惯了. 所以即便是换系统, 也会和Ubuntu搭边儿, 正好deepin, 感觉不错哦.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      把自己的代码环境, 迁移新的 Deepin 发行版, 记录了一些常用库和工具的安装参考.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>里程碑1(Linux后台开发经验分享)</title>
    <link href="www.merlinblog.site/2017/08/30/milestone1.html"/>
    <id>www.merlinblog.site/2017/08/30/milestone1.html</id>
    <published>2017-08-30T08:07:59.000Z</published>
    <updated>2017-10-27T03:37:11.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文只在每一次 milestone 记录点更新, 记录我开发中遇到的经验,体会; 有的单独总结了, 所以只给出链接</p></blockquote><p>当前文章(以后会更新), 总结了我的个人经验, 包括我自己亲身经历的, 后台同学一起讨论的, 网络曾经看到的等等. </p><p><strong>如果你把你学到的知识, 而不是思考问题的方式, 细心&amp;耐心的品质, 健康的身体, 银行的存款, 结交的人缘作为核心竞争力;</strong><br><strong>那么分享自己所学可能对你有点儿困难.(虽然最初的时候我写博客也只是完全为了记录我成长的过程, 不过渐渐目的已经转变了)</strong></p><a id="more"></a><h1 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h1><h2 id="milestone1-大巨变"><a href="#milestone1-大巨变" class="headerlink" title="milestone1: 大巨变"></a>milestone1: 大巨变</h2><blockquote><p><code>大巨变100天(100 days from New Era)</code></p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/new_era_1.png" alt="里程碑"></p><p>当前里程碑记录<strong>Linux后台开发经验</strong>.</p><p>下面是一些<code>基于当前工作经验&amp;年限</code>的认识:</p><ul><li>对于c++, go这类稍微偏底层, 并且常用的语言, 一定要了解细节, 深知见底.</li><li>对于python, shell这类脚本或者模型语言, 用好为主</li><li>对于数据结构和算法: 数据结构深入, 算法了解.</li><li>对于操作系统, 如果决心做高级工程师, 业内技术专家linux一定要深入到内核(具体的是内核哪个模块?所有.)</li><li>对于网络编程, 根据工作的不同, 有人工作在应用层,有人工作在传输层和网络层, 甚至是链路层(但是不管这么说, 应用层和网络层是要知道的)</li><li>对于项目管理和人员管理等管理问题, 请入行的第3年再去涉及.(也就是工作的第5-7年)</li><li>对于金钱, 抱歉我看到的身边的人30W一大把, 50W是一个坎大多人突破不过去. (自己实力稍弱的时候, <code>不要太看重钱</code>)</li><li></li></ul><p><code>表面上看我成长不少, 但是从一个高手的要求上看, 我所做的其实远远不够; 希望慢慢会快, 后期抓紧时间!</code></p><h2 id="milestone2-领域专家"><a href="#milestone2-领域专家" class="headerlink" title="milestone2 : 领域专家"></a>milestone2 : 领域专家</h2><p>期待 <strong>2019.9</strong>, 一个全新&amp;加强版的我.</p><blockquote><p>TODO, 等待下一次更新; 深入行业!</p></blockquote><hr><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>游戏业内主要的是c/c++ + Python/lua模式做游戏服务器。<br>c/c++做网络通讯数据传输，python/lua做业务逻辑。这样既保持了网络传输的效率(c++)，又提升开发效率(Python/lua)，同时也支持热更新。</p><p>其他用 erlang, go, C#, 甚至java, node.js也有, 只是没有接触过.</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>我看到同学中, 一般小公司的, 用mysql, mongodb足以; 如果要访问提升效率(减轻数据库压力), 选择内存数据库redis, memcached都不错.<br>(存盘可以即使存盘, 但一般都不这么做, 一般采用固定存盘减少服务器压力; 个别效率苛刻的场景除外)</p><h3 id="消息件"><a href="#消息件" class="headerlink" title="消息件"></a>消息件</h3><p>一般用于服务器或者多进程之间通信, 比如zeromq等.<br>网络通信方面可以自己处理粘包问题, 直接传输字节流, 也可以传输xml, json; 常见的可能是采用框架, 比如protobuffer, 二进制传输.</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议部分的, 一般会涉及三个协议: http, tcp, udp<br><strong>http</strong>: 如果是那种弱联网单机玩法，用http足够了，像天天酷跑之类，只在需要的时候处理一条http请求响应。<br><strong>tcp</strong>: 现在的网络游戏大多数都是tcp<br><strong>udp</strong>: 其实游戏是有udp的，在一些高效率(即时性, 实时性要求高)的场景下比如pvp即时战斗,tcp的拥塞控制和超时重传并不适合，有些就用的udp,然后自己做丢包重发</p><p>现在参与开发的游戏就同时使用了http协议和tcp协议，在游戏服是单机玩法用http协议,战斗服需要长连接保存协议状态，用的tcp。</p><h3 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h3><p>libevent, boost.asio等网络库， 网上有很多开源网络库，与其自己造轮子，不如就用开源网络库作为自己服务器的通讯库, 例如:<br>libevent和boost.asio:</p><ul><li>Boost的ASIO是一个异步IO库，封装了对Socket的常用操作，简化了基于socket程序的开发。支持跨平台。</li><li>Libevent是一个C语言写的事件驱动的开源网络库, 应用和异步IO逻辑思想类似的 reactor反应堆模型.</li></ul><p>这两个库我都有详细介绍过, 这里就不再多说了, 具体可以参考我的文章: <a href="http://www.merlinblog.site/2017/10/13/network-base.html">网络部分汇总</a></p><h3 id="相关架构"><a href="#相关架构" class="headerlink" title="相关架构"></a>相关架构</h3><p>后端服务器架构应该说有很多种, 我熟悉的:</p><ul><li>Gate: 首先要有一个Gate(网关)服务器，负责客户端连接及消息转发到Game(游戏服),保持客户端到服务端的连接<br>没有任何逻辑，只做消息加密和解密，以及客户端和服务器消息的转发(相当于两者之间的桥梁).</li><li>GameServer: GameServer是游戏进程,提供游戏逻辑功能(采用单进程(或者单线程)模型,游戏服务器的瓶颈从来不在CPU,所以只做逻辑功能的话单线程足够了,在这里没必要用多线程或多进程)。</li><li>DBManager:实现数据库的读写，方便Game服务器异步读写数据库的数据(有些把数据库读写放在游戏服务器，没有单独的服务器，那恐怕游戏服单进程就不够用了)。</li><li>GameManager: 负责管理所有的GameServer，GameServer之间消息转发，提供广播到所有Game的功能。</li></ul><p>分布式架构我就不太熟悉了, 一般需要到专门的大公司学习.</p><h3 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h3><p>一般用的都是开源的, 比如gtest, glog/zlog, tcmalloc(内存性能分析), distcc, repo等</p><blockquote><p>其他技术, 请参考我的博客其他文章.</p></blockquote><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="core文件"><a href="#core文件" class="headerlink" title="core文件"></a>core文件</h3><p>产生 core 文件, 命令 <code>ulimit -c</code> 如果显示 1024 那么说明 coredump 已经被开启, 0 则表示没有开启.</p><blockquote><p>一般临时修改: ulimit -c unlimited  或者 <code>ulimit -c 1024</code>;关闭的话<code>ulimit -c 0</code>.</p></blockquote><p>1024 限制产生的 core 文件的大小不能超过 1024kb，可以使用参数unlimited，取消该限制</p><p>也可以修改文件配置<code>/etc/security/limits.conf</code>, 添加一行<code>* soft core unilimited</code><br>其实这个是由pam来完成的，pam里有个模块叫pam_limits，它默认的会读取/etc/security/limits.conf文件来进行资源限制。而用户登录时会调用/etc/pam.d/login文件来进行检查，这个文件里标明了使用哪些模块。其中它include了一个叫system_auth的配置文件，在这个文件里有对pam_limits.so的调用。</p><p>如果上面没有生效, 可能是其他登陆模块强制修改了, 典型的需要查看一下<code>/etc/profile</code>, <code>/etc/init.d/functions</code>.<br>这些文件在用户登录时会执行，因此即使pam修改了还是会被它改回去, 可以把那几行注释掉, 不过我一直截止很简单的:</p><pre><code>echo &quot;ulimit -c 1024&quot; &gt;&gt; /etc/profile</code></pre><blockquote><p>将不该清空的内存清空了，导致执行的时候会进入不可状态; 此时每次看到的core dump信息都不一样.</p></blockquote><h2 id="RESTful相关"><a href="#RESTful相关" class="headerlink" title="RESTful相关"></a>RESTful相关</h2><p>本段属于上层协议内容, 感谢土哥的经验交流.</p><h3 id="restful简介"><a href="#restful简介" class="headerlink" title="restful简介"></a>restful简介</h3><p>RESTful 架构, 由于其以资源中心, 依赖http协议和uri, 虽然也会涉及c-s模型, 不过其更多的是强调对于相关资源的crud操作, 并且提供了统一的API形式:</p><ul><li>看Url就知道要什么</li><li>看http method就知道干什么</li><li>看http status  code就知道结果如何</li></ul><p>举几个例子就会发现它非常规范:</p><pre><code>https://api.qzone.com/user/getUserFeedList?from=web https://api.qzone.com?m=user&amp;c=getUserFeedList?from=web https://qzone.com/api/user/getUserFeedList?from=web https://qzone.com?m=api&amp;c=user&amp;a=getUserFeedList?from=web</code></pre><p>HTTP协议形式例如:</p><pre><code>GET /posts HTTP/1.1Accept: application/atom+xml响应：HTTP/1.1 200 OKContent-Type: application/atom+xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;    &lt;title&gt;Posts&lt;/title&gt;    &lt;link href=&quot;http://example.org/posts&quot; rel=&quot;self&quot; /&gt;    &lt;link href=&quot;http://example.org/posts?pn=2&quot; rel=&quot;next&quot; /&gt;    &lt;id&gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6&lt;/id&gt;    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;    &lt;entry&gt;        &lt;title&gt;Post XXX&lt;/title&gt;        &lt;link href=&quot;http://example.org/post-xxx&quot; /&gt;        &lt;id&gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id&gt;        &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;        &lt;content type=&quot;xhtml&quot;&gt;            &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;                &lt;p&gt;This is the post content.&lt;/p&gt;            &lt;/div&gt;        &lt;/content&gt;    &lt;/entry&gt;    &lt;entry&gt;...&lt;/entry&gt;&lt;/feed&gt;</code></pre><h3 id="api返回值经验"><a href="#api返回值经验" class="headerlink" title="api返回值经验"></a>api返回值经验</h3><blockquote><p>针对JSON型API的返回结果设计, 总结下自己的经验</p></blockquote><p>一般的返回结果是怎么样的?</p><pre><code>{    data : { // 请求数据        user_id: 123,        user_name: &quot;tutuge&quot;,        ...    },    msg : &quot;done&quot;, // 请求状态描述，调试用    code: 1001, // 业务自定义状态码    extra : { // 全局附加数据(optional字段)        type: 1,        desc: &quot;秒数信息&quot;    }}</code></pre><p>下面详细解释:</p><ul><li>data字段<br>本次请求结果的数据 data 字段, 其值为对象(字典)或数组(列表)均可以, 根据业务而定. 例如:<pre><code>data: [  {user_id: 123, user_name: &quot;tutuge&quot;},  {user_id: 321, user_name: &quot;zekunyan&quot;},  ...]</code></pre>当然数组, 对象还可以嵌套, 怎么灵活怎么用.(不用担心现有库对于字段的解析问题)</li><li>msg字段<br>该字段是本次请求的业务&amp;状态描述信息, 主要用于调试、测试等, 例如 “done”, “测试缺少参数”. 根据相关开发人员协商即可. </li><li>code字段<br>这是比较有争议的一个字段, 因为Http请求本身已经有了完备的状态码，再定义一套状态码直观上感受却是不对劲。但是实际开发中，确实发现 <code>自定义业务状态码</code> 的必要性，如一次成功的Http status 200的请求，可能由于用户未登录、登录过期而有不同的返回结果和处理方式，所以还是保留了; 权当http协议的详细说明.<br>定义规范根据业务来, 例如按照用户相关、授权相关、各种业务，做简单的分类:<pre><code>// Code 业务自定义状态码定义示例// 授权相关1001: 无权限访问1002: access_token过期1003: unique_token无效...// 用户相关2001: 未登录2002: 用户信息错误2003: 用户不存在// 业务13001: 业务1XXX3002: 业务1XXX// ...</code></pre>最好定义为常量, 当然能够动态解析最好.</li><li><p>extra字段<br>这个纯粹是附加字段(全局的附加数据), 为的是灵活扩展, 比如升级啊, 需求变化等. 由服务端的规则决定并且客户端要及时向用户展示变化, 所以加上了extra字段. 例如:</p><pre><code>// 升级type: 1,show_msg: &quot;恭喜您升级到XXX&quot;// 完成任务type: 2,task_desc: &quot;达成XXX成就&quot;</code></pre></li></ul><p>其实最终还是要看客户端和服务端人员的协商; 服务端人员切不可以为添加一个字段简单没有什么, 就随口答应, 一切都要走流程, 并且避免乱用. 这不仅仅是为了规范, 而是为了让项目不会再将来出现意想不到的 <code>惊喜</code> .</p><p>补充经验:</p><ul><li>命名, 和C语言保持一致就可以了(字段统一小写加下划线)<br>例如:<pre><code>// 字符串user_name, task_desc, date_str, article_title, feed_content 等// 数字user_id, users_count, task_num, xxx_offset 等// 日期login_at, create_date, logout_time 等// 布尔is_done, is_vip, protected, can_read 等// URLuser_avatar_url, thumb_url 等// 数组users, profiles, thumb_imgs 等</code></pre></li><li>设置默认值(空值)<ul><li>数字就是 <code>0</code></li><li>字符串就是空字符串<code>&quot;&quot;</code></li><li>数组就是空数组<code>[]</code></li><li>对象就是空对象{}</li></ul></li><li>bool值, 统一成0和1.<br>由于多种语言不统一, 所以一开始就要做好限定, 而不是<code>true</code>, <code>True</code>, <code>1</code>漫天乱飞.. 在客户端和服务端统一设置常量、宏定义，定义布尔的类型，所有的参数、结果的布尔字段全部做强制约束</li><li>时间处理, 统一使用Unix时间戳, 即GMT/UTC时间戳, 可以用<code>date +%s</code>命令查看, 然后各自客户端根据自己的时区, 显示做转换.<br>例如:<pre><code>// 从服务器接收的时间数据login_at: 1462068610// 根据时区、显示要求转换，如北京时间显示：2016年5月1日下午1点、1天前等</code></pre>(如果用字符串,可以参考<code>YYYY-MM-DDThh:mm:ssTZD</code>格式,保留了时区)</li><li>字符串常量 请用常量文档约束.<pre><code>// 如登录类型，QQ、微信、微博等login_type: &quot;qq&quot;,login_type: &quot;wechat&quot;,login_type: &quot;sina_weibo&quot;,</code></pre></li><li>使用完整的url, 指明网络协议(scheme).</li></ul><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><h3 id="window移植"><a href="#window移植" class="headerlink" title="window移植"></a>window移植</h3><p>windows迁移问题, 自己遇到的, 记录一下:</p><ul><li>缺少最后一行空行, 多余的\r回车符<br><code>dos2unix &lt;file&gt; fromdos &lt;file&gt;</code></li><li>中文注释乱码<br><code>iconv –f gbk –t utf8</code> (utf8也可以写成utf-8)</li><li>不能忍的头文件<br><code>windows.h</code></li><li>不兼容的宏, 库函数<br><code>snprintf()</code>,<code>__FUNCTION__</code>, <code>__FILE__</code>, <code>__LINE__</code></li><li>特殊的宏<br><code>#ifdef WIN_32  #define …  #endif</code></li></ul><h3 id="宽字符问题"><a href="#宽字符问题" class="headerlink" title="宽字符问题"></a>宽字符问题</h3><p>本质上是ascii码和unicode的存储问题.(单字节不够用, 采用多字节)<br>先注意一下文件编码, windows下默认是gbk编码:</p><pre><code>iconv -f GBK -t UTF-8 main.cc &gt; mainu.cc</code></pre><p>之后注意一下多字节字符问题, 基本情况如下:(实际上wchar_t同样没有标准限定)</p><ul><li>Windows 下的 char 是 ANSI，WCHAR 是 UTF-16（UCS-2），跟 locale设置有关系</li><li>Linux   下的 char 是 UTF-8，WCHAR 是 UTF-32（UCS-4），都是 Unicode，与 locale 无关</li></ul><p>我建议你 Windows 下调用<code>MultiByteToWideChar</code>和<code>WideCharToMultiByte</code>，<br>而 Linux 直接自己写一个转换函数(UTF-8 和 UTF-32 转换规律很简单), 大致如下:</p><pre><code class="C++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int UTF8ToUnicode(const char *pmbs, wchar_t *pwcs, int size){    int cnt = 0;    // 这里 size-- 是预先除去尾零所需位置    if (pmbs != NULL &amp;&amp; pwcs != NULL &amp;&amp; size-- &gt; 0) {        while (*pmbs != 0 &amp;&amp; size &gt; 0) {            unsigned char ch = *pmbs;            if (ch &gt; 0x7FU) {                int cwch = 0;                while (ch &amp; 0x80U) {                    ch &lt;&lt;= 1;                    cwch++;                }                *pwcs = *pmbs++ &amp; (0xFFU &gt;&gt; cwch);                while (--cwch &gt; 0) {                    *pwcs &lt;&lt;= 6;                    *pwcs |= (*pmbs++ &amp; 0x3FU);                }            } else {                *pwcs = *pmbs++;            }            pwcs++;            size--;            cnt++;        }        *pwcs = 0;        cnt++;    }    return cnt;}int UnicodeToUTF8(const wchar_t *pwcs, char *pmbs, int size){    int cnt = 0;    // 这里 size-- 是预先除去尾零所需位置    if (pwcs != NULL &amp;&amp; pmbs != NULL &amp;&amp; size-- &gt; 0) {        while (*pwcs != 0 &amp;&amp; size &gt; 0) {            if (*pwcs &lt; 0x00000080U) {                *pmbs++ = (char)*pwcs;                size -= 1;                cnt += 1;            } else if (*pwcs &lt; 0x00000800U) {                // 剩余空间不够存放该字符                if (size &lt; 2) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 6) | (*pwcs &gt;&gt; 6);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 2;                cnt += 2;            } else if (*pwcs &lt; 0x00010000U) {                // 剩余空间不够存放该字符                if (size &lt; 3) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 5) | (*pwcs &gt;&gt; 12);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 3;                cnt += 3;            } else if (*pwcs &lt; 0x00200000U) {                // 剩余空间不够存放该字符                if (size &lt; 4) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 4) | (*pwcs &gt;&gt; 18);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 4;                cnt += 4;            } else if (*pwcs &lt; 0x04000000U) {                // 剩余空间不够存放该字符                if (size &lt; 5) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 3) | (*pwcs &gt;&gt; 24);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 5;                cnt += 5;            } else if (*pwcs &lt; 0x80000000U) {                // 剩余空间不够存放该字符                if (size &lt; 6) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 2) | (*pwcs &gt;&gt; 30);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 24) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 6;                cnt += 6;            } else {                // 无法识别的 Unicode 字符                break;            }            pwcs++;        }        *pmbs = 0;        cnt++;    }    return cnt;}int main(void){    // 这部分代码请在 Linux 上测试，Windows 命令行无法打印 UTF-8 字符串。    char mbs1[256] = { 0 };    wchar_t wcs1[] = L&quot;测试文字&quot;; //单个中文, utf8存储3字节    int ret1 = UnicodeToUTF8(wcs1, mbs1, sizeof(mbs1)/sizeof(char));    printf(&quot;%d\n&quot;, ret1); //13    // 这部分代码请在 Linux 上测试，Windows 的 char 类型非 UTF-8 编码。    char mbs2[] = &quot;测试文字&quot;;    wchar_t wcs2[256] = { 0 };    int ret2 = UTF8ToUnicode(mbs2, wcs2, sizeof(wcs2)/sizeof(wchar_t));    printf(&quot;%d\n&quot;, ret2); //5    return 0;}</code></pre><p>参数作用简单说明如下：</p><ul><li>第一个参数为待转换的字符串</li><li>第二个参数为接收结果的缓冲区</li><li>第三个参数为结果缓冲区大小(包含尾零)<br>返回值为所写入缓冲区的大小(包含尾零)</li></ul><p>最好不要使用<code>wchar_t</code>, 而直接使用<code>std::wstring</code>, 例如下面的代码:(windows环境)</p><pre><code class="C++">//const wchar_t* ws = L&quot;世界你好！&quot;;std::wstring wstr = L&quot;世界你好！&quot;;std::wcout.imbue( std::locale(&quot;chs&quot;) );std::wcout &lt;&lt; wstr &lt;&lt; std::endl;</code></pre><p><code>std::locale( std::locale(),&quot;&quot;,std::locale::ctype )</code>会创建当前系统环境下locale，这个locale中会保存这个系统 ansi 使用 code page.<br>(wofstream，wcout 在处理 unicode字符 时，必须进行内部编码转换（unicode -&gt; ansi ）)</p><p>具体参考以下链接:</p><ol><li><a href="http://blog.csdn.net/xujiezhige/article/details/17843831" target="_blank" rel="external">http://blog.csdn.net/xujiezhige/article/details/17843831</a></li><li><a href="http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html" target="_blank" rel="external">http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html</a></li><li><a href="http://bbs.csdn.net/topics/391079600?page=1" target="_blank" rel="external">http://bbs.csdn.net/topics/391079600?page=1</a></li></ol><h3 id="操作大文件"><a href="#操作大文件" class="headerlink" title="操作大文件"></a>操作大文件</h3><p>1.包含所有头文件以前，先定义这些宏：</p><pre><code class="C++">#ifndef __USE_FILE_OFFSET64#define __USE_FILE_OFFSET64#endif#ifndef __USE_LARGEFILE64#define __USE_LARGEFILE64#endif#ifndef _LARGEFILE64_SOURCE#define _LARGEFILE64_SOURCE#endif</code></pre><p>一般用 /usr/include/features.h 重定义的:</p><p>32位LINUX使用超过2G的大文件，需要定义很多宏，与文件操作API相关的宏都有这样一些：</p><pre><code>_FILE_OFFSET_BITS_LARGEFILE_SOURCE_LARGEFILE64_SOURCE__USE_FILE_OFFSET64__USE_LARGEFILE__USE_LARGEFILE64</code></pre><p>那么，它们之间的关系究竟是怎么样的呢？<br>终于在linux的头文件<code>/usr/include/features.h</code>中找到了定义。</p><pre><code class="C++">//原来这个文件就是专门让用户定义各种特性的：/*These are defined by the user (or the compiler)to specify the desired environment其中几个供用户配置的宏的注释为：_LARGEFILE_SOURCE    Some more functions for correct standard I/O._LARGEFILE64_SOURCE    Additional functionality from LFS for large files._FILE_OFFSET_BITS=N    Select default filesystem interface._GNU_SOURCE        All of the above, plus GNU extensions.__USE_LARGEFILE    Define correct standard I/O things.__USE_LARGEFILE64    Define LFS things with separate names.__USE_FILE_OFFSET64    Define 64bit interface as default.*/// use前缀的宏定义都先取消掉，说明这些宏不是直接供用户使用的，而是由其他宏的定义衍生这些宏#undef    __USE_LARGEFILE#undef    __USE_LARGEFILE64#undef    __USE_FILE_OFFSET64//   _GNU_SOURCE是一张很大的通行证，定义了这个，很多相关的开关都会打开/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */#ifdef _GNU_SOURCE# undef     _LARGEFILE64_SOURCE# define _LARGEFILE64_SOURCE    1#endif// 下面是打开各个USE宏的位置#ifdef _LARGEFILE_SOURCE# define __USE_LARGEFILE    1#endif#ifdef _LARGEFILE64_SOURCE# define __USE_LARGEFILE64    1#endif#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64# define __USE_FILE_OFFSET64    1#endif</code></pre><p>总结： <strong>使用64位大文件，定义_LARGEFILE64_SOURCE和_FILE_OFFSET_BITS=64这两个宏即可</strong></p><p><strong>2.</strong>使用open打开文件的时候，加上O_LARGEFILE标志：<br>int fd = open(“test.dat”, O_RDWR|O_APPEND|O_CREAT|O_LARGEFILE, 0666);<br>read(), write()等与一般的用法一致，无变化。</p><p><strong>3.</strong>注意lseek()函数，文件未超过2G的时候，一切工作良好；<br>文件超过2G后，调用返回-1，errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>需要使用lseek64()代替lseek()。很奇怪，定义了宏以后，并未自动将lseek变成lseek64。（知道原因的朋友可以教教我）</p><p><strong>4.</strong>注意stat()函数，传入的文件如果在2G内，工作良好；<br>传入的文件如果超过2G，返回-1, errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>应该这样使用：struct stat64 st; stat64(“file”, &amp;st);</p><p><strong>5.</strong>为了保险，建议所有操作文件的函数都是用支持64位大文件的。否则当文件超过2G后，难免会出现什么未知的异常</p><h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>具体可以参考一下我的文章, <a href="">C++11一致性初始化</a>, 提倡&amp;建议使用一致性初始化.</p><p>其他还有需要注意的就是, <strong>在线程编码中,尽量不要使用匿名对象</strong></p><blockquote><p>尽量不使用匿名对象，如果想要用完立即释放，可以使用单独的代码块包裹。</p></blockquote><h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><p>标准库的 bind 和 boost::bind 使用起来类似</p><p>举个例子</p><pre><code class="C++">void test(int a, int b, int c)boost::bind(test, 1, _1, _2);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(1,3,4)boost::bind(test, _2, 3, _1);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(4,3,3)</code></pre><p>而在标准库中一般是这么用的:</p><pre><code class="C++">auto handler = std::bind(test, 1, std::placeholders::_1, std::placeholders::_2);handler(3,4);// 相当于 test(1,3,4);</code></pre><p>其他的可以参考文章<a href="http://www.merlinblog.site/2017/07/01/bind-in-cpp.html">C++11 std:bind探究</a></p><h3 id="智能指针-多线程-问题"><a href="#智能指针-多线程-问题" class="headerlink" title="智能指针(多线程)问题"></a>智能指针(多线程)问题</h3><p>其实是异步代码问题.<br>具体现象描述:<br>一旦压力达到一定程度，程序立即就会崩溃，报的错误几乎都在new的时候没有内存了，一开始以为确实是因为内存分配的问题，后来在<strong>程序运行过程中</strong>用top观察，发现内存使用很低，因此可以确认不应该是瞬间内存使用完造成的。</p><p>因此认真看了一下 core dump 的地方，发现几乎都是在自己写的一个智能指针分配内存那里出的问题。<br>于是仔细思考了一下，发现是因为<strong>智能指针的引用计数没有加锁</strong>导致的, 或者说<strong>同一时间, 可能有多个线程持有该指针</strong>, 导致引用计数不能减为0。</p><p>例如下面的代码:</p><pre><code class="C++">void func(){    shared_ptr a;    async_call(a);}</code></pre><p>解释:首先有一个智能指针，接下来，这个智能指针被丢给了异步程序，因此这个时候其实已经有两个线程同时持有这个智能指针了，因为这个函数还未退出，当前线程还拥有这个指针a. 一般低压情况下，这两句很快就执行完了，不会出问题，但是高压情况下，这个函数先执行完，还是异步程序先执行完就不一定了（或者说是因为高压情况样本变多了）, 也就造成了资源没有释放.</p><h2 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost.Asio"></a>Boost.Asio</h2><h3 id="read-util相关"><a href="#read-util相关" class="headerlink" title="read_util相关"></a>read_util相关</h3><p>在使用boost的read_util库的时候遇到一个很诡异的问题，如果用read_util(““)这样的调用，第一个请求可以得到，但是第二个请求会卡住，永远也拿不到。从服务器端看到的情况是，第二个响应已经完整的发送出去，但是read_util就是不返回。比较奇怪的是如果用read_util(‘&gt;’)这样调用，那是没有任何问题的。</p><blockquote><p>read_util(string)这样的函数，它所用的肯定是string.find这样的函数，而这样的函数它是用字符串查找的，这表示它一旦遇到<code>\0</code>就不再往后查找了。</p></blockquote><p>每个响应最后会有一个/0字符。因此在第一个包读完之后，接下来读到的第一个字符就是<code>\0</code>，那么第二个包读的时候，不论读到多少数据，这个字符串的内容是<code>\0xxxxxxxx</code>，在这个一个长度为0的字符串上进行查找<code>&quot;&lt;/data&gt;&quot;</code>，必然找不到任何有用的信息。</p><p>结论：<strong>在处理网络流的时候，即使协议是文本协议，最好还是把它当作二进制来处理或者用一些自己写的字符串匹配函数.</strong></p><h3 id="请求队列积压问题"><a href="#请求队列积压问题" class="headerlink" title="请求队列积压问题"></a>请求队列积压问题</h3><p>测试用asio写的模块时发现，在高压力情况下，内存使用很大，而且涨上去之后在低压力情况下内存依然没降下来。一开始以为是内存泄露，后来用valgrind查了半天，发现根本没有内存泄露的代码。</p><p>通过post方法将多个其他线程的日志内容推到这个日志线程的中去。于是这个时候就比较容易理解了，<strong>多线程来喂一个单线程，单线程必然响应不过来，这样子导致整个task队列比较一直在增长</strong>，并且当压力降下来之后，整个队列已经很大了，并不会再降回去。</p><blockquote><p>在所有异步系统中普遍存在的，当响应很慢时，会导致请求队列积压，造成内存的大量占用。</p></blockquote><p>解决办法: </p><ul><li>给队列一个上限，当走出这个队列长度之后，拒绝新的请求。这种方法很暴力，但是不会造成系统崩溃。<br>检查了io_service的构造函数之后发现，没有提供任何关于队列长度限制的函数，因此这个方法可以直接忽略了</li></ul><p>一般就是这么做, 但是这里由于环境限制, 所以只能提高日志的级别, 解决队列积压问题.</p><h1 id="linux-网络部分"><a href="#linux-网络部分" class="headerlink" title="linux 网络部分"></a>linux 网络部分</h1><p>写网络的博文已经够多了, 请参考我的<strong>标签</strong>: <code>网络</code>, 大部分问题网络问题已经探讨过了.</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>这个是相对于短连接而言的, 比如可能会遇到的<code>TIME_WAIT</code>过多, 就是由于大量的短连接造成的. 这里的长短都是指的的连接时间.</p><p>首先一般不会用c/c++去写业务代码, 维护和开发成本太高, 一般都是通过服务器转发给前端其他模块&amp;语言处理, 比如php,<br>此时转发请求的服务器就要能保存状态&amp;维护长连接, 例如可以采用<code>boost/asio + fastcgi + php</code>.</p><p>当前端将请求发上来之后，长连接服务器通过 <code>fastcgi协议</code> 将请求发给 php，由php处理完成后再返回给长连接服务器，由长连接服务器返回给用户。<br>好处如下:</p><ul><li>web服务器是基于http协议的(架构显然协议不一定是http的，可以任意自己想要的协议)</li><li>http协议是无状态的</li></ul><p>那么第二个问题，如何解决无状态，通常web服务器是通过session，这个显然有性能问题，而且session是没有保证的。<br>于是我们反过来，长连接服务器同时作为session服务器，在把请求发给php时，同时将存储在长连接服务器的session也发给php，<br>php对session的任何更改也在响应中回传给服务器，由<strong>服务器保存(session)</strong>，下一次调用时再传回去。</p><p>这样一来，从 php 服务器端看到的是一个有状态的请求序列。 </p><h2 id="禁用Nagle算法"><a href="#禁用Nagle算法" class="headerlink" title="禁用Nagle算法"></a>禁用Nagle算法</h2><p>这个问题也差不多也是由大量小数据包引起的问题, 它影响了IO性能, 或者吞吐量. 核心思想就是, 延迟应答.</p><p>和<code>TCP_NODELAY</code>选项有关, 简单地说，这个(启动)选项的作用就是禁用 Nagle 算法，禁止后当然就不会有它引起的一系列问题了。<br>使用setsockopt可以做到：</p><pre><code class="C++">static void _set_tcp_nodelay(int fd) {      int enable = 1;      setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void*)&amp;enable, sizeof(enable));  }</code></pre><p>具体可以参考我的这篇文章 <a href="http://merlinblog.site/2017/06/19/how-about-tcp.html#Nagle算法" target="_blank" rel="external">how about tcp</a></p><h2 id="常用-tcp-选项"><a href="#常用-tcp-选项" class="headerlink" title="常用 tcp 选项"></a>常用 tcp 选项</h2><p>关于这一点, 可以查看 <code>man 7 tcp</code>, 或者看一下<code>man 7 socket</code>, 里面详细列举了相关的参数.</p><p>具体可以参考一下 我的文章 <strong>how-about-tcp</strong>.</p><h2 id="socket-编程问题"><a href="#socket-编程问题" class="headerlink" title="socket 编程问题"></a>socket 编程问题</h2><h3 id="socket-选项"><a href="#socket-选项" class="headerlink" title="socket 选项"></a>socket 选项</h3><p>常用的有:</p><ul><li>SO_REUSEADDR</li><li>SO_RECVBUF/SO_SNDBUF</li><li>SO_KEEPALIVE</li><li>SO_LINGER</li></ul><p>下面详细说一下:<br><strong>SO_REUSEADDR选项</strong> :<br>在服务器程序中，SO_REUSEADDR socket 选项通常在调用bind()之前被设置。<br>SO_REUSEADDR可以用在以下四种情况下： (摘自《Unix网络编程》卷一，即UNPv1)</p><ul><li>当有一个有相同本地地址和端口的socket1处于TIME_WAIT状态时，而你启动的程序的socket2要占用该地址和端口，你的程序就要用到该选项</li><li>SO_REUSEADDR允许同一端口上启动同一服务器的多个实例(多个进程), 但每个实例绑定的IP地址是不能相同的。在有多块网卡或用IP Alias技术的机器可以测试这种情况。 </li><li>SO_REUSEADDR允许单个进程绑定相同的端口到多个socket上，但每个socket绑定的ip地址不同。这和2很相似，区别请看UNPv1。 </li><li>SO_REUSEADDR允许完全相同的地址和端口的重复绑定。但这只用于UDP的多播，不用于TCP。</li></ul><p><strong>SO_LINGER选项</strong> :<br>linger，顾名思义是延迟延缓的意思，这里是延缓面向连接的socket的close操作。<br>默认，close立即返回，但是当发送缓冲区中还有一部分数据的时候， 系统将会尝试将数据发送给对端, SO_LINGER可以改变close的行为.<br>控制SO_LINGER通过下面一个结构：</p><pre><code class="C++">struct linger{      int l_onoff; /*0=off, nonzero=on*/      int l_linger; /*linger time, POSIX specifies units as seconds*/};</code></pre><p>通过结构体中成员的不同赋值，可以表现为下面几种情况：</p><ol><li>l_onoff设置为0，选项被关闭。l_linger值被忽略，就是上面的默认情形，close立即返回。</li><li>l_onoff设置为非0，l_linger被设置为0，则close()不被阻塞立即执行，丢弃socket发送缓冲区中的数据，并向对端发送一个RST报文。<br> 这种关闭方式称为“强制”或“失效”关闭。</li><li>l_onoff设置为非0，l_linger被设置为非0，则close()调用阻塞进程，直到所剩数据发送完毕或超时。<br> 这种关闭称为“优雅的”关闭。</li></ol><p>注意： 这个选项需要谨慎使用，尤其是强制式关闭，会丢失服务器发给客户端的最后一部分数据。UNP中:</p><blockquote><p>The TIME_WAIT state is our friend and is there to help us(i.e., to let the old duplicate segments expire in the network).</p></blockquote><p><strong>SO_KEEPALIVE选项</strong> :<br>通常这个选型关联: SO_KEEPALIVE, TCP_KEEPCNT, TCP_KEEPIDLE, TCP_KEEPINTVL</p><p>如果一方已经关闭或异常终止连接，而另一方却不知道，我们将这样的TCP连接称为半打开的, TCP通过保活定时器(KeepAlive)来检测半打开连接.</p><p>在高并发的网络服务器中，经常会出现漏掉socket的情况，对应的结果有一种情况就是出现大量的CLOSE_WAIT状态的连接(确认对端已经关闭了).<br>这个时候，可以通过设置 KEEPALIVE 选项来解决这个问题，当然还有其他的方法可以解决这个问题.</p><p>使用方法如下：</p><pre><code class="C++">//Setting For KeepAliveint keepalive = 1;setsockopt(incomingsock,SOL_SOCKET,SO_KEEPALIVE,(void*)(&amp;keepalive),(socklen_t)sizeof(keepalive));int keepalive_time = 30;setsockopt(incomingsock, IPPROTO_TCP, TCP_KEEPIDLE,(void*)(&amp;keepalive_time),(socklen_t)sizeof(keepalive_time));int keepalive_intvl = 3;setsockopt(incomingsock, IPPROTO_TCP, TCP_KEEPINTVL,(void*)(&amp;keepalive_intvl),(socklen_t)sizeof(keepalive_intvl));int keepalive_probes= 3;setsockopt(incomingsock, IPPROTO_TCP, TCP_KEEPCNT,(void*)(&amp;keepalive_probes),(socklen_t)sizeof(keepalive_probes));</code></pre><p>设置<code>SO_KEEPALIVE</code>选项来开启KEEPALIVE，然后通过<code>TCP_KEEPIDLE</code>、<code>TCP_KEEPINTVL</code>和<code>TCP_KEEPCNT</code>设置keepalive的开始时间、间隔、次数等参数。</p><p>当然，也可以通过设置 <code>/proc/sys/net/ipv4/tcp_keepalive_time</code>、<code>tcp_keepalive_intvl</code>和<code>tcp_keepalive_probes</code>等内核参数来达到目的，<br>但是这样的话，会影响所有的socket，因此建议使用setsockopt设置。</p><h2 id="心跳保活"><a href="#心跳保活" class="headerlink" title="心跳保活"></a>心跳保活</h2><p>有TCP侧的保活机制, 又有应用侧的保活机制, 但是他们的侧重不同.</p><h3 id="TCP保活"><a href="#TCP保活" class="headerlink" title="TCP保活"></a>TCP保活</h3><p>检测连接是否可用, 是否还有数据继续发送.</p><p>tcp的keepalive是侧重在保持客户端和服务端的连接，一方会不定期发送心跳包给另一方，当一方断掉的时候，没有断掉的定时发送几次心跳包，<br>如果间隔发送几次，对方都返回的是RST，而不是ACK，那么就释放当前链接。<br>设想一下，如果tcp层没有keepalive的机制，一旦一方断开连接却没有发送FIN给另外一方的话，那么另外一方会一直以为这个连接还是存活的，几天，几月。<br>那么这对服务器资源的影响是很大的。</p><p>tcp的keepalive就是为了检测链接的可用性。主要调节的参数有三个：</p><pre><code>tcp_keepalive_time // 距离上次传送数据多少时间未收到判断为开始检测tcp_keepalive_intvl // 检测开始每多少时间发送心跳包tcp_keepalive_probes // 发送几次心跳包对方未响应则close连接</code></pre><p>默认设定是:<br>当tcp发现有<code>tcp_keepalive_time</code>(7200)秒未收到对端数据后，开始以间隔<code>tcp_keepalive_intvl</code>(75)秒的频率发送的空心跳包，<br>如果连续<code>tcp_keepalive_probes</code>(9)次以上(实际上是10次)未响应代码对端已经down了，close连接.</p><p>运行流程：<br>在客户端和服务端进行完三次握手之后，客户端和服务端都处在ESTABLISH状态，这个时候进行正常的PSH和ACK交互，但是一旦一方服务中断了，<br>另一方在距离上次PSH时间tcp_keepalive_time发现对方未发送数据，则开始心跳检测。<br>心跳检测实际就是发送一个PSH的空心跳包，这里说的空心跳包就是包的数据为空，但是TCP包的头部的数据和标识和正常包一样。<br>如果这个包获取到的是RST返回的话，下面就会继续每隔tcp_keepalive_intval的时长发送一个空心跳包，如果tcp_keepalive_probes次心跳包对方都是返回RST而不是ACK，<br>则心跳发起方就判断这个连接已经失效，主动CLOST这个连接。</p><p>如果是对方服务器进行重启的时候，我们<strong>不能根据一次的tcp返回重置信号就判定这个连接失效</strong>:</p><ul><li>连接一方服务中止</li><li>网络不好导致的服务长时间无响应</li><li>连接一方服务重启中</li></ul><p>相反的，重启之后，这个心跳包一旦正常，这个连接仍然可以继续使用。</p><p>如果要单独设定每个TCP连接的参数, 可以使用<code>setsockopt</code>函数:</p><pre><code class="C++">int setsockopt(int s, int level, int optname,                   const void *optval, socklen_t optlen);</code></pre><p>具体代码控制如下:</p><pre><code class="C++">opt = 1;  setsockopt(listenfd, SOL_SOCKET, SO_KEEPALIVE, (void*)&amp;opt, sizeof(opt));opt = 1000;  setsockopt(listenfd, SOL_TCP, TCP_KEEPIDLE, (void *)&amp;opt, sizeof(opt));  //tcp_keepalive_time  opt = 10;  setsockopt(listenfd, SOL_TCP,TCP_KEEPINTVL, (void *)&amp;opt, sizeof(opt));  //tcp_keepalive_intvl  opt = 10;  setsockopt(listenfd,SOL_TCP, TCP_KEEPCNT, (void *)&amp;opt, sizeof(opt));  //tcp_keepalive_probes</code></pre><p><strong>代码中如何判断TCP连接是否断开?</strong><br>当tcp检测到对端socket不再可用时(不能发出探测包,或探测包没有收到ACK的响应包),select会返回socket可读(不可写),并且在recv时返回-1,同时置上errno为ETIMEDOUT。</p><h3 id="HTTP保活"><a href="#HTTP保活" class="headerlink" title="HTTP保活"></a>HTTP保活</h3><p>HTTP的保活主要是重用连接, 而不用反复三次握手, 四次分手. (可以简单的认为HTTP保活, 就是要利用长连接)</p><p>普通的http连接是客户端连接上服务端，然后结束请求后，由客户端或者服务端进行http连接的关闭。<br>下次再发送请求的时候，客户端再发起一个连接，传送数据，关闭连接。这么个流程反复。<br>但是一旦客户端发送<code>connection:keep-alive</code>头给服务端，且服务端也接受这个<code>keep-alive</code>的话，两边对上暗号，这个连接就可以复用了，<br>一个http处理完之后，另外一个http数据直接从这个连接走了。</p><p><strong>http层的keep-alive, 它主要是用于客户端告诉服务端，这个连接我还会继续使用，在使用完之后不要关闭</strong></p><p>区分一下长短连接:</p><ul><li>短连接， 就是每次请求一个资源就建立连接，请求完成后连接立马关闭。每次请求都经过“创建tcp连接-&gt;请求资源-&gt;响应资源-&gt;释放连接”这样的过程</li><li>长连接， 就是只建立一次连接，多次资源请求都复用该连接，完成后关闭。要请求一个页面上的十张图，只需要建立一次tcp连接，然后依次请求十张图，等待资源响应，释放连接。</li></ul><p>具体client和server要从短连接到长连接最简单演变需要做如下改进:</p><ul><li>client发出的HTTP请求头需要增加Connection:keep-alive字段</li><li>Web-Server端要能识别Connection:keep-alive字段，并且在http的response里指定Connection:keep-alive字段，告诉client，我能提供keep-alive服务，并且”应允”client我暂时不会关闭socket连接</li></ul><p>在HTTP/1.0里，为了实现client到web-server能支持长连接，必须在HTTP请求头里显示指定Connection:keep-alive<br>在HTTP/1.1里，就默认是开启了keep-alive，要关闭keep-alive需要在HTTP请求头里显示指定Connection:close<br>现在大多数浏览器都默认是使用HTTP/1.1，所以keep-alive都是默认打开的。一旦client和server达成协议，那么长连接就建立好了。</p><p>少了TCP的三次握手和四次挥手，第二次传递数据就可以通过前一个连接直接进行数据交互了。</p><p><strong>联系TIME_WAIT</strong></p><p>由于HTTP服务的发起方一般都是浏览器，即客户端。但是先执行完逻辑，传输完数据的一定是服务端。那么一旦没有keep-alive机制，服务端在传送完数据之后会率先发起连接断开的操作。由于TCP的四次挥手机制，先发起连接断开的一方会在连接断开之后进入到TIME_WAIT的状态达到2MSL之久。设想，如果没有开启HTTP的keep-alive，那么这个TIME_WAIT就会留在服务端，由于服务端资源是非常有限的，我们当然倾向于服务端不会同一时间hold住过多的连接，这种TIME_WAIT的状态应该尽量在客户端保持。那么这个http的keep-alive机制就起到非常重要的作用了。</p><p>基于重用,性能和TIME_WAIT等原因, 现在浏览器发起web请求, 一般都会带上connection:keep-alive的头.</p><h3 id="应用保活"><a href="#应用保活" class="headerlink" title="应用保活"></a>应用保活</h3><p>KeepAlive仅用于检测连接的死活，而应用层心跳机制还有一个目的是检测简练的存活状态。<br>考虑一个场景：当某台服务器处理负载过高，CPU利用率100%，无法处理任何业务请求，在这种情况下，TCP探针仍然确认对方可用，<br>而实际上，服务器已经不能处理任何请求了，这种情况下应该断开当前连接，重新建立连接，而不是认为服务器仍然可用。</p><p>因此，从这个角度出发，应用层心跳机制也是必然需要的。</p><p>另外, 应用层的心跳机制, 基本和HTTPS一致的要求需要<code>长连接</code>.</p><p>对于客户端而言，保持长连接的长连接的有效性可以使得每次请求都只是简单的数据发送和接受，而不必要每次重新建立一个连接，重新解析DNS，<br>省去连接建立的时间，加快了于服务器之间的通信速度，有利于接收服务器的实时消息，前提都是连接必须可用。</p><p>对于服务器而言，保持连接的有效性可以让服务器降低负载，及时清除无效的连接。</p><p><strong>最简单的实现</strong></p><p>定时心跳.</p><p>例如:<br>由登录端每隔5秒向消息服务器发送心跳信息，如果30秒内没有收到消息服务器的相应，则关闭当前连接；<br>服务器每隔60s向移动端或者PC端发送定时心跳，60s没收到对端相应，则关闭当前连接。<br>(重发心跳保活指令，心跳超时时间为5S; 最长尝试时间为30秒和60s; 服务器还是客户端发送并不重要)</p><p>其实需要应用层检测, 更主要的原因是可以更好的判断服务器状态, 以此给出是否保持或者断开连接.</p><blockquote><p>现在的很多框架, 系统都已经提供了相关的API, 定时器等, 实现起来也比较容易.</p></blockquote><p>实际上很多时候, 往往是UDP协议的应用才需要专门这么做.<br>虽然TCP本身的包头要比UDP多，但是<strong>UDP在实际应用中往往需要维护双向通道</strong>，就必须要通过大量的心跳包数据来维护端口资源。<br>总的比较起来，UDP的实际流量要比TCP还要大。很多使用者在初期的时候并不了解UDP需要大量心跳包来维持端口资源这个问题，往往都认为UDP要比TCP更节省流量，实际上这里存在着一个误区。<br>在某些特定的应用场合，例如一些银行的时时交互系统，对响应速度要求很高，此时数据传输频率较快，不需要大量心跳包维持UDP端口资源，采用UDP就比较有利了。</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>这篇文章会一直更新, 直到哪一天我不再在一线编码了, 希望能给看到的人提供一些帮助.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="external">知乎大神们对restful的看法</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">http状态码大全</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      一些列工作经验的分享,干货
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="里程碑" scheme="www.merlinblog.site/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>网络吞吐量测试</title>
    <link href="www.merlinblog.site/2017/08/28/network-throughput-test.html"/>
    <id>www.merlinblog.site/2017/08/28/network-throughput-test.html</id>
    <published>2017-08-28T09:47:33.000Z</published>
    <updated>2017-10-12T20:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文结合网络编程&amp;工作中, 常用的命令, 测试一下<code>网络吞吐量</code>.</p><blockquote><p>我自己也是很长一段时间搞不清楚<code>TPS</code>, <code>QPS</code>, <code>吞吐量</code>等关系; 并且总是听别人说高性能, 但是不知道所谓的高性能是主观臆测的还是测量出来的</p></blockquote><p>先来一张有趣的图.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/throughput1.jpg" alt=""></p><h1 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h1><p>注意一下<code>带宽</code>, <code>传输速率</code>常常和<code>吞吐量</code>扯在一起, 下面先区分一下它们. </p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>定义：计算机网络中的主机在数字信道上，单位时间内从一段传送到另一端的最大数据量，即<code>最大速率</code>, <code>Max net bit rate</code><br>类比：一个供水管，假设管子中有流动的水，这里的水为数据。单位时间内，从管子的某个横截面就是速率，即单位时间内传送的数据量。当管子充满水的时候，管子的某个横截面就是最大速率，即带宽<br>单位：<code>bps</code>, 和<code>速率</code>一样, 注意是<code>b</code>,p<code>,</code>s` (bits per second).</p><p>1Byte=8bit, 即<code>1字节=8比特</code>， 所以<code>1Bps=8bps</code>.</p><blockquote><p>网络带宽为100Mbps, 但是我们性能测试出来的吞吐量却只有10MB多一点, 就是因为单位不同: 100Mbps的带宽实际上传输速率为12.5MB/s </p><blockquote><p>区分<code>Mbps</code>和<code>MBps</code></p></blockquote></blockquote><p>以前家里电信网是4M的, 4M的理论下载速度为500KB/S，实际速率只能达到200-440KB/S.</p><h2 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h2><blockquote><p>我们平常说的速率是<code>额定速率</code></p></blockquote><p>定义：在数据传输中，两个设备之间数据流动的物理速度成为传输速率，单位为bps<br>单位：比特是数据量最小单位，秒是时间的最小单位， 所以速率单位为bps, 类似的，有<code>kb/s</code>，<code>Mb/s</code>(M=10^6),<code>Gb/s</code>（G=10^9）,<code>Tb/s</code>(t=10^12)</p><blockquote><p>上面的单位都是<code>bit</code>, 比特.</p><blockquote><p>通常, 你把带宽理解成传输速率是不错的, 但不准确;但是反过来说传输速率是带宽就不对了.</p></blockquote></blockquote><p>各种传输媒介中信号的流动速度是恒定的，即使数据链路的传输速率不同，也不会出现忽快忽慢的情况。传输速率不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少。<br>以我们生活中的道路交通为例，低速数据链路如同车道较少无法让很多车同时通过的情况，与之相反，高速数据链路就相当于有多个车道，一次允许更多车辆行驶的道路。</p><blockquote><p>理论上说, 带宽越大网络传输能力就越强, 因为上限拉大了.</p></blockquote><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>理论不等于实际, <code>吞吐量</code>, throuhgput就是<code>实际传输速率</code>. 你可以从它的单位可以看出来<code>bps</code>, 但是, 吞吐量不仅衡量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度等.</p><blockquote><p>说的通俗一点，就是单位时间内某个（端口）实际的数据量</p></blockquote><p>上面的内容都和速率有关. 下面的概念和<code>事务</code>, ``</p><h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><p>可以参考我的文章 <a href="http://www.merlinblog.site/2017/08/23/net-work-tools.html">net-work-tools</a></p><h1 id="正式测量"><a href="#正式测量" class="headerlink" title="正式测量"></a>正式测量</h1><h2 id="为啥要测试"><a href="#为啥要测试" class="headerlink" title="为啥要测试?"></a>为啥要测试?</h2><p>当我们讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数，它取决于链路时钟速率和信道编码在计算机网络中又称为线速。我们可以说以太网的带宽是10Mbps。但是，我们需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。我们倾向于用“吞吐量”一次来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p><p>数据吞吐量 就是的数据包转发能力。也就是能同时转发多少数据包。也就是一个单位时间内，满负载，可以转发多少的一个数值 数据流量/秒 或者数据流量/分钟。</p><blockquote><p>简单说, 为了找出服务性能的瓶颈.</p></blockquote><h2 id="一般测试方法"><a href="#一般测试方法" class="headerlink" title="一般测试方法"></a>一般测试方法</h2><p>吞吐量的测试方法是：在测试中以一定速率发送一定数量的帧，并计算待测设备传输的帧，如果发送的帧与接收的帧数量相等，那么就将发送速率提高并重新测试；如果接收帧少于发送帧则降低发送速率重新测试，直至得出最终结果。吞吐量测试结果以比特/秒或字节/秒表示。</p><h2 id="实际测量"><a href="#实际测量" class="headerlink" title="实际测量"></a>实际测量</h2><blockquote><p>在linux平台下, 借助<code>nc</code>, <code>dd</code>, <code>time</code>等工具, 工作远没有那么复杂.</p></blockquote><p>测试环境, 本机(上海浦东金融区) –&gt; 华北(具体不知道哪)阿里云服务器, 指定端口5000</p><p>姑且成为, A –&gt; B 之间的测试吧, 带宽50Mbps. (阿里云的带宽应该远超50M)</p><p>下面开始几组测量: </p><h3 id="dd-nc"><a href="#dd-nc" class="headerlink" title="dd+nc"></a>dd+nc</h3><p>A也就是本机进行写(读完即舍弃):<br><img src="http://omotkhw3y.bkt.clouddn.com/dd-nc-first.png" alt=""></p><p>B,也就是阿里云服务器进行读:<br><img src="http://omotkhw3y.bkt.clouddn.com/dd-nc-first1.jpg" alt=""></p><h3 id="time-nc"><a href="#time-nc" class="headerlink" title="time+nc"></a>time+nc</h3><p>然后用time进行测试, 得出结果:</p><p>A端写的结果:<br><img src="http://omotkhw3y.bkt.clouddn.com/time-nc.png" alt=""></p><p>B端读的结果:<br><img src="http://omotkhw3y.bkt.clouddn.com/time-nc1.jpg" alt=""></p><blockquote><p>好吧, 这个结果应该是被别的因素干扰了.</p></blockquote><p>分析如下:</p><p>因为dd在统计时也会占用一部分资源(或者多了一次管道读写), 具体如下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/nc_dd.jpg" alt=""></p><blockquote><p>此外, netcat的版本也是影响测量因素的原因, 只是这个案例中没有体现出来.</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p><h1 id="TPS-QPS"><a href="#TPS-QPS" class="headerlink" title="TPS QPS"></a>TPS QPS</h1><blockquote><p>一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。</p></blockquote><p><strong>TPS</strong>：Transactions Per Second（<code>每秒传输的事物处理个数</code>），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。<br>（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。<strong>客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数</strong>。</p><p><strong>QPS</strong>：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p><p>下面有个具体的例子:<br>一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。<br>可以用下面的方法计算。<br><code>QPS = 1000/(30*60) 事务/秒</code>,<br><code>平均响应时间为 = 5*60  秒</code>,<br><code>并发数= QPS*平均响应时间 = 1000/(30*60) *(5*60)=166.7</code>;</p><p><strong>并发数</strong>也很好理解, 在处理响应的时间内, 能够处理的事物总个数; 即<code>qps * 平均响应时间</code>.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://blog.csdn.net/wind19/article/details/8600083" target="_blank" rel="external">http://blog.csdn.net/wind19/article/details/8600083</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      主要使用nc测试一下网络吞吐量(throughput), 辅助工具time, pv, dd, nc
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>First Agile</title>
    <link href="www.merlinblog.site/2017/08/27/first-about-agile.html"/>
    <id>www.merlinblog.site/2017/08/27/first-about-agile.html</id>
    <published>2017-08-27T03:37:08.000Z</published>
    <updated>2017-09-24T07:26:34.663Z</updated>
    
    <content type="html"><![CDATA[<p>老东家一直有个站会, 在看板(Kan Board)面前阐述一下自己的任务进度. 说实话, 我非常排斥这种东西(虽然我拥护TDD和XP). 后来听京东和支付宝的同学也在说敏捷会议, 敏捷开发, 我这才意识过来:</p><pre><code>哦, 敏捷已经是趋势了.</code></pre><p>开始认真接受 <code>Agile</code> .</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我亲身实践的敏捷, 印象比较深刻的有两部分内容:</p><ul><li>站会的反馈</li><li>(配合SCM)持续集成</li><li>测试驱动</li></ul><p>总结起来, 我所重视的是: <code>参与</code>, <code>协作</code>, <code>持续交付</code> (每个阶段都是可交付的).</p><p>本文先说敏捷, 之后再说我的个人体会.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>敏捷到底是一种软件开发方法, 还是一种技术思想? 到现在我的觉得, 这些已经不再重要, 重要的是, 我们通过 Agile 能够获得什么, 而不是我最初跟风的, 尝试敏捷.</p><h2 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h2><p>主要的内容就这么几句话:</p><pre><code> Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan</code></pre><p>如下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/agile.jpg" alt="agile"></p><p>看得出, 宣言其实是很空洞的, 所以又出现了下面的 <code>12项原则</code> .</p><h2 id="12项原则"><a href="#12项原则" class="headerlink" title="12项原则"></a>12项原则</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/agile_principle.jpg" alt="agile"></p><p>从中可以提取很多关键思想: <code>不断交付</code>, <code>拥抱变化</code>, <code>合作</code>, <code>可工作的软件</code>, <code>简洁为本</code>, <code>定期反思</code> …</p><h2 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h2><p>不管一个产品, 还是一个项目, 整个团队的协作, 参与是最重要的. 所以比起其他一些(重视开发流程, 过程的)方法, Scrum更加注重协作&amp;参与(当然也包括交付, 每一个过程都是可交付的).</p><p>是的, 我这里多次强调了 <code>参与</code> .</p><p>关于这部分理论, 请找专业的资料参考吧, 不要去网上看一些不太专业的转载.</p><h2 id="站会反馈"><a href="#站会反馈" class="headerlink" title="站会反馈"></a>站会反馈</h2><p>每天早上9:30, 会有一个站会, 内容是围绕看板任务, 大家各自汇报一下. 说实话, 效果很差. 因为除非是你的模块, 否则大家对你的进度, 遇到的困难, 没有太多的体会, 也很难给出意见. (何况有时候我都是单独一个项目, 单枪匹马).</p><p>但是在这里, 我却有一些很深刻的体会, 大体可以归纳为: 我们认为重要的, 用户不一定觉得重要.</p><p>这么说呢? 具体解释:</p><p>好比我的模块, 是否需要一个数据库View(视图), 一个Contoller调度模块, 是否要给出应用界面, 表格是竖着展开还是横向排列, 你的意见, 和最终用户的意见可能相差很远, 甚至你觉得重要的, 用户完全不care, 不关注的.</p><p>所以站会反馈, 最好能让用户, 客户参与到团队的开发中; 这里增加一点儿成本, 却省下了后期需求变更, 调整的代价. 好处不言自明.</p><p>也就是宣言中所说的 <code>Customer collaboration over contract negotiation</code>, 客户协作胜过合同谈判.</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>在持续集成方面, 老东家 <code>ZTE</code> 可以说, 做的非常好; 因为面对的北美项目比较多, 所以在集成测试做不好, 不仅会加大人力投入, 还会降低开发效率. 但是就像自动测试一样, 是否应该持续集成关键在于投资回报率和缓解风险. 我想这一点, 不必多解释, 请看下面的要点.</p><p>持续集成的要点:</p><ul><li>统一的代码库</li><li>自动构建</li><li>自动测试</li><li>每个人每天都要向代码库主干提交代码</li><li>每次代码递交后都会在持续集成服务器上触发一次构建</li><li>保证快速构建</li><li>模拟生产环境的自动测试</li><li>每个人都可以很容易的获取最新可执行的应用程序</li><li>每个人都清楚正在发生的状况</li><li>自动化的部署</li></ul><p>个人的经验是:<br>以前我的代码入库前, 至少经历这样的步骤:<br>代码编写完毕, 本地验证通过(包括编译和功能验证), 然后在本地集成(可能是具体的开发板,比如手机), 之后上传代码, 在容器(生产环境)中测试, 而且分两次, 早上和下午(赶上一次就可以了), 之后通过了, 才合入dev分支, 经过几个版本的测试, 没有问题了, 才最终合入master分支. 中间经过了N次自动化测试, 集成, 而且你的提交根本不干预集成.</p><p>这里面相关的技术也很多, Jekins, Gerrit, repo, Docker等.</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>关心团队协作, 用心做产品.</p><p>希望敏捷的路越走越顺吧.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      谈谈自己经历 敏捷开发 的体会
    
    </summary>
    
      <category term="managements" scheme="www.merlinblog.site/categories/managements/"/>
    
    
      <category term="开发管理" scheme="www.merlinblog.site/tags/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>集中谈谈C++资源管理</title>
    <link href="www.merlinblog.site/2017/08/25/cpp-resource-manage.html"/>
    <id>www.merlinblog.site/2017/08/25/cpp-resource-manage.html</id>
    <published>2017-08-25T02:24:19.000Z</published>
    <updated>2017-10-09T11:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++中谈资源管理, 已经不是一天两天的事儿了, 感觉心好累. 看看大佬们为了资源管理(偷懒), 都做哪些事儿.</p><p>由于以前已经写了好多篇了, 这里算作汇总吧:</p><ul><li>RAII</li><li>PIMPL</li><li>智能指针(引用计数,标记擦除)</li><li>GC</li><li>对齐问题</li><li>malloc/free</li><li>new/delete (placement new)</li><li>分配器</li><li>内存池</li></ul><a id="more"></a><blockquote><p>还是有时间再写吧…</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      白话一下资源管理, 虽然以前就已经谈过很多次了.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>网络开发中常用的工具</title>
    <link href="www.merlinblog.site/2017/08/23/net-work-tools.html"/>
    <id>www.merlinblog.site/2017/08/23/net-work-tools.html</id>
    <published>2017-08-23T10:48:19.000Z</published>
    <updated>2017-10-09T11:01:44.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络中常用的Linux命令, 主要涉及, <code>time</code>, <code>dd</code>, <code>pv</code>, <code>nc</code>或者全称<code>netcat</code>, 还有tcpdump</p><blockquote><p><code>tcpdump</code>以后有时间再说, 这一篇写简单点.</p></blockquote></blockquote><p>本篇就算linux常用工具的一个补充吧.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/net-tools.png" alt="post-cover"></p><h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p>这个太熟悉了</p><pre><code>real    0m0.000suser    0m0.000ssys     0m0.000s</code></pre><p>主要是来统计某个程序运行的时间, 分为<code>用户时间</code>和<code>内核时间</code>.</p><h1 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h1><p>我以前在加密打包的时候用到过<code>dd</code>工具, 它比较适合处理<code>字节块</code>. </p><p>例如你可以拿它去测量<code>拷贝数据的时间</code>, 即磁盘跑分:</p><pre><code>dd if=/dev/zero of=sun.txt bs=100M count=10</code></pre><p>从/dev/zero不断拿0字符, 拿100M大小的数据块x1, 写到sun.txt, 统计操作所花费的时间, 以及写入速度.<br>其中<code>bs</code> 代表块, 它可以使用下面的单位:</p><pre><code>字节（1B）    c 字（2B）    w 块（512B）    b 千字节（1024B）    k 兆字节（1024KB）    M 吉字节（1024MB）    G</code></pre><p>当然还有其他参考, 不过我常用的就这么多了.</p><h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1><blockquote><p>或者叫做 netcat, 不同的Linux或者Unix可能有不同的实现版本, 所对应的参数也不一样.</p></blockquote><p>常用的参数如下:</p><pre><code>nc -h[v1.10-41+b1]connect to somewhere:    nc [-options] hostname port[s] [ports] ... listen for inbound:    nc -l -p port [-options] [hostname] [port]options:    -c shell commands    as `-e&#39;; use /bin/sh to exec [dangerous!!]    -e filename        program to exec after connect [dangerous!!]    -b            allow broadcasts    -g gateway        source-routing hop point[s], up to 8    -G num            source-routing pointer: 4, 8, 12, ...    -h            this cruft    -i secs            delay interval for lines sent, ports scanned    -k                      set keepalive option on socket    -l            listen mode, for inbound connects    -n            numeric-only IP addresses, no DNS    -o file            hex dump of traffic    -p port            local port number    -r            randomize local and remote ports    -q secs            quit after EOF on stdin and delay of secs    -s addr            local source address    -T tos            set Type Of Service    -t            answer TELNET negotiation    -u            UDP mode    -v            verbose [use twice to be more verbose]    -w secs            timeout for connects and final net reads    -C            Send CRLF as line-ending    -z            zero-I/O mode [used for scanning]port numbers can be individual or ranges: lo-hi [inclusive];hyphens in port names must be backslash escaped (e.g. &#39;ftp\-data&#39;).</code></pre><p>解释一下:</p><pre><code>[-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;]           [-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]其他参数:    -g&lt;网关&gt; 设置路由器跃程通信网关，最丢哦可设置8个。    -G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。    -h 在线帮助。    -i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。    -l 使用监听模式，管控传入的资料。    -n 直接使用IP地址，而不通过域名服务器。    -o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。    -p&lt;通信端口&gt; 设置本地主机使用的通信端口。    -r 乱数指定本地与远端主机的通信端口。        -s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。    -u 使用UDP传输协议。    -v 显示指令执行过程。    -w&lt;超时秒数&gt; 设置等待连线的时间。    -z 使用0输入/输出模式，只在扫描通信端口时使用。    -q 超时退出时间</code></pre><p>nc 往指定端口发送数据, 例如:<br><code>nc localhost 3306 &lt; xxx.txt</code>  向本机的3306端口发送数据<br>或者<br><code>dd if=/dev/zero bs=100M count=10 | nc localhost 3306</code> 向本机3306端口发送数据, 同时dd统计.</p><p>当然你用time统计也可以:<br><code>time nc localhost 3306 &lt; xxx.txt</code></p><p>别人(与我IP不同)要取得数据?<br>直接连接我的IP, 3306端口即可, 例如: <code>nc &lt;my_ip&gt; 3306 &gt; xxx.txt</code>,<br>如果是发送的压缩文件, 或者发送的识货用tar处理了, 例如:<br><code>tar -zcvf - xxx.txt | pv | nc -l -p 3306 -q 5</code>, 那么接收的时候要进行相应的解压缩, 例如:<br><code>nc &lt;target_ip&gt; 3306 | pv | tar -zxvf -</code> </p><p>如果是我向你的端口写, 那么你直接连接你的端口即可获取数据, 例如:<br>写:<br><code>nc &lt;ur ip&gt; &lt;ur port&gt; &lt; /dev/zero</code> 或者你可以使用dd, 做一下网络带宽写出速度统计<br><code>dd if=/dev/zero bs=1MB count=1000 | nc &lt;ur_ip&gt; &lt;ur_port&gt;</code></p><p>接收端, 就非常好办了:<br><code>nc -l &lt;port&gt; &gt;/dev/null</code> 或者看看进度 <code>nc -l  &lt;port&gt; |pv -W &gt; /dev/null</code><br>(你要保留文件的话, 就不要把它重定向到<code>/dev/null</code>了)</p><blockquote><p>注意这里的接收端, 不要写ip选项 (我实验了一下, 如果指定了<code>localhost</code>返回会出问题)</p></blockquote><p>当然也可以进行端口扫描(即<code>-z</code>选项):</p><pre><code>nc -v -z -w2 192.168.0.3 1-100     扫描192.168.0.3 的端口 范围是 1-100.nc -u -z -w2 192.168.0.1 1-1000    扫描192.168.0.3 的端口 范围是 1-1000不过扫描的是UDP端口nc -nv 192.168.0.1 80              扫描 80端口</code></pre><blockquote><p>查看目录下文件大小: <code>ls -lh</code>;   查看文件的大小: <code>du -sh &lt;filename&gt;</code></p></blockquote><h1 id="pv"><a href="#pv" class="headerlink" title="pv"></a>pv</h1><p>pv, 即pip viewer; 它会显示当前在命令行执行的命令的进度信息 <code>sudo apt-get install pv</code> .<br>pv 命令提供了多种显示选项开关: </p><ul><li><code>-p</code>来显示百分比</li><li><code>-t</code>来显示时间</li><li><code>-r</code>表示传输速率</li><li><code>-e</code> 代表eta（LCTT 译注：估计剩余的时间）</li></ul><blockquote><p>好事是你不必记住某一个选项，因为默认这几个选项都是启用的。但是，如果你只要其中某一个信息，那么可以通过控制这几个选项来完成任务。</p></blockquote><p>这里还有一个<code>-n</code>选项来允许 pv 命令显示整数百分比，在标准错误输出上每行显示一个数字，用来替代通常的可视进度条, 但是会分行打印, <code>个人不推荐</code></p><p>接下来还有一个命令行选项，<code>-L</code> 可以让你修改 pv 命令的传输速率。举个例子，使用 -L 选项来限制传输速率为2MB/s。</p><pre><code>pv -L 2m xxx.mkv &gt; ./Desktop/yyy.mkv</code></pre><p>这条命令等价于 <code>cp xxx.mkv &gt; ./Desktop/yyy.mkv | pv -L 2m</code><br>(Pv测试管道前面紧邻的任务)</p><p>另一个pv 可以帮上忙的情景是压缩文件。这里有一个例子可以向你解释如何与压缩软件Gzip 一起工作。</p><p><code>pv /media/himanshu/1AC2-A8E3/fnf.mkv | gzip &gt; ./Desktop/fnf.log.gz</code></p><p>但是注意, 凡是不加密的传输, 都不安全.</p><blockquote><p><code>nc</code>和<code>pv</code>传输文件? 还是使用<code>SSH</code>或者<code>SCP</code>吧, 这样比较安全.</p><blockquote><p>emacs的<code>TRAMP</code>也不错哦.</p></blockquote></blockquote><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>这个在调试, 管理连接方面, 非常有用, 也是网络编程中, 最最常用的东西, 比如说, 你可能会碰上数据<code>鬼打墙</code>的状况, 这可能就是<code>TCP自连接</code>问题, 自己连接自己, 然后收发数据.<br>(发现这个现象, 查看一下连接, 断开, 重置连接就好了)</p><blockquote><p>关于tcpdump的经验总结, 本月有机会, 再说.</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      整理和重新发布一下网络编程中的调试&amp;测试工具.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
</feed>
