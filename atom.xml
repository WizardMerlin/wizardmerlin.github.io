<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Merlin&#39;s Blog</title>
  
  <subtitle>Alfred, I did find someone..</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.merlinblog.site/"/>
  <updated>2017-09-26T02:17:08.314Z</updated>
  <id>www.merlinblog.site/</id>
  
  <author>
    <name>Merlin Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>集中谈谈C++资源管理</title>
    <link href="www.merlinblog.site/2017/09/12/cpp-resource-manage.html"/>
    <id>www.merlinblog.site/2017/09/12/cpp-resource-manage.html</id>
    <published>2017-09-12T02:24:19.000Z</published>
    <updated>2017-09-26T02:17:08.314Z</updated>
    
    <content type="html"><![CDATA[<p>C++中谈资源管理, 已经不是一天两天的事儿了, 感觉心好累. 看看大佬们为了资源管理(偷懒), 都做哪些事儿.</p><p>由于以前已经写了好多篇了, 这里算作汇总吧:</p><ul><li>RAII</li><li>PIMPL</li><li>智能指针(引用计数,标记擦除)</li><li>GC</li><li>对齐问题</li><li>malloc/free</li><li>new/delete (placement new)</li><li>分配器</li><li>内存池</li></ul><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      白话一下资源管理, 虽然以前就已经谈过很多次了.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>经验教训汇总</title>
    <link href="www.merlinblog.site/2017/09/05/lessons-history.html"/>
    <id>www.merlinblog.site/2017/09/05/lessons-history.html</id>
    <published>2017-09-05T02:10:08.000Z</published>
    <updated>2017-09-24T07:55:57.607Z</updated>
    
    <content type="html"><![CDATA[<p>本文不记载我经历过的事情, 但是记载我遇到过的 <code>教训</code> &amp;成长, 以及 <code>遗憾</code> . 此篇是<code>最终篇</code>, 以后个人教训全部更新在这里.</p><blockquote><p>本文长期更新(最近一次2017年9月)</p></blockquote><a id="more"></a><p>修身, 修心, 积累财富, 一个不能少. 你说呢?</p><p>更新时间表:</p><ul><li>2017-07-20 17:50:08 大巨变之后</li><li>2017-09-05 10:10:09 重返上海</li></ul><p>本文最新更新主题: </p><blockquote><p>言出必行, 信守承诺, 并且不再轻易&amp;随意承诺.</p></blockquote><hr><h2 id="初心"><a href="#初心" class="headerlink" title="初心:"></a>初心:</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/history.jpg" alt=""></p><p>实习结束时, 我的<code>初心</code>.</p><hr><h2 id="2015-2017"><a href="#2015-2017" class="headerlink" title="2015-2017"></a>2015-2017</h2><p>两年内我遇到的问题, 可能是所有年轻人遇到的问题, 对于外物表象太多在乎, 消费习惯也不好. </p><p>痛定思痛, 总结如下:</p><ul><li>生活应该 “极简” . 人的欲望, 愿望小了, 那么对于外界的依赖也就少了, 得到快乐也就相对容易了. 简谱的生活, 像很多长辈一样, 并不是一件很羞耻的事情. 很多懂事儿比较玩的同龄人可能到40岁才明白, 简单的真谛.</li><li>负债有风险. 不管是用于投资, 经营, 甚至是消费, 负债就相当于把你的未来提前透支了; 不说是一种危险的做法, 但至少是不保险的做法. 有时候需要根据具体的情况具体分析, 但是有一条, 应该死守的规则: 绝对不能去负债消费</li><li>虚荣心, 面子对于个人的生活, 家庭的和睦没有半点儿作用; 并且虚荣心还会牵制一个人, 令他的思想, 行动不自由, 很多时候会做出愚蠢的事情; 也不要在乎别人的评论, 做好自己, 过好你的生活</li></ul><p>简言之:</p><pre><code>* 生活应该简谱, 从简.* 虚荣心有害, 不要在乎别人怎么说, 做好你自己(这本身就很难)</code></pre><p>而今进入2017年下半场, 南开和交大的同学, 也陆续要毕业, 心里也不再焦躁了; </p><p>我们的人生本来就不是一个模子刻出来的, 大家有自己要走的路, 做好你自己, 足矣.</p><hr><h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p><code>易经</code> 中有6个境界, 感觉我当前正处于 <code>跃龙</code> 的年纪, 一直很骄傲, 自傲有才华, 希望进入2017下半年~2018年, 可以学会: 谦虚, 谦让.</p><h3 id="2017年9月"><a href="#2017年9月" class="headerlink" title="2017年9月"></a>2017年9月</h3><pre><code>言出必行, 真的很难! 所以不要轻易许诺, 任何人.</code></pre><p>追求完美的时候, 是最看一个人品性的时候. 当你遇到别人以前从未遇到的困难, 网上找不到任何相关的资料的, 或者走了很长一段时间看不到结果, 甚至自己都开始怀疑自己的时候, 坚持 &amp; 不妥协, 不退让, 真的很难. 但是不管这么说, 如果自己说过的话, 许诺的承诺, 就一定要实现. 然后记住, <code>不要轻易许下承诺</code>, 因为未来的不可控性太强了.</p><hr><p>修身, 修心, 积累财富, 一样不能少. 控制”意欲”的同时, 提高”认识力”.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      我过去所得到的教训
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Mustang</title>
    <link href="www.merlinblog.site/2017/09/04/mustang.html"/>
    <id>www.merlinblog.site/2017/09/04/mustang.html</id>
    <published>2017-09-04T09:55:16.000Z</published>
    <updated>2017-09-24T07:34:38.147Z</updated>
    
    <content type="html"><![CDATA[<p>老东家的部门经理给说了很多人生经验, 我觉得最重要的是他说的四个字 <code>顺其自然</code> (let it be),  但是有时候自己有选择的时候, 也要注意好跟随自己的意志.顺气自然的意思是, <code>在自己能力范围以内, 做到最好</code> . 星爷不是说了么, “做人如果没有梦想, 那啥咸鱼.” 平坦的路, 让爱走的人去走; 我走一条独特点儿的.</p><blockquote><p>就像编程环境的配置一样, 一定要让自己的觉得舒服. 关注自身的需求和成长.</p></blockquote><p>本文说的是我 <code>选车</code> , 其实也是思考自身的过程. 适合的不是我想要的, 想要的不适合我. 顺气自然吧.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/%E9%87%8E%E9%A9%AC.png" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近一直有打算买车, 毕业的时候, 父母也说过”回家就给你配一台宝马”, 可是我知道, 父母其实还是希望我在武汉安家(以车把我绑定在一个安定舒适的环境里面, 找对象之后很快就结婚, 生孩子啥的). 我的同学里面有人渴望这种生活, 但是他们不知道, 这种生活其实是非常乏味无趣的.</p><p>下面讲述一下, 我对自己现状, 能力的评估, 选车过程.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="人生不止一辆车"><a href="#人生不止一辆车" class="headerlink" title="人生不止一辆车"></a>人生不止一辆车</h2><p>刚毕业的时候, G家里就给配了车, 那个时候很羡慕, 但是G是女孩子, 自己能力不够, 家里给补贴很正常. 但是作为男生的话, 要我找家里开口要, 呵呵. 真心做不到. 那个时候手里有3W(家里给的)左右, 心里心高气傲, 想买最好的, 比如 <code>Benz AMG</code> 系列. (那个时候, G应该是一台普通的大众轿车, 猜的, 具体没有看到她的数据)</p><p>一年后, 手里有14W了, 可是那个心里对未来的预期, 对自己的评估还是不够, 还是决定要买最好.</p><p>两年后, 今天, 差不多27W了, 身边的同事有换<code>雅阁</code>的, 有买本田高端系列<code>讴歌</code>的. 这个时候, 也就是现在, 我在考虑自己将来到底想做什么的时候, 我在想是不是应该买陈润生那种<code>5系</code>. 不过那车当前的售价, 我还是承受不起(全部自己承担的话).</p><p>你看到, 两年的时间, 我的心是变来变去; 一方面说明我的财力在变, 另外一方面, 也说明了我对于自己的认知再改变.</p><p>或者说, 我经历的多了, 也更加成熟了.</p><p>其实人生中重要的事情, 远没有那么纠结, G以前跟我说了这样一句话<code>你一生又不是只买一辆车</code>. 考虑到当前的现状, 考虑到未来的可能, 无论如何, 我也想说.</p><blockquote><p>人生应该浪费在美好的事物上</p></blockquote><p>就像编程环境的配置一样, 你一定要让自己的觉得舒服. </p><blockquote><p>任何选择都是有风险有代价的. 也没有一辆完美的车.</p></blockquote><h2 id="备选"><a href="#备选" class="headerlink" title="备选"></a>备选</h2><p>下面是我的一些备选考量, 以及其优缺点.</p><ul><li>2018凯美瑞混动<br>怎么说呢? 买混动为了省油但是最终算下来, 根本不省钱. 但是这台车有一个特点, 就是技术先进(丰田的混动系统), 环保. 而且在我的财力承受范围内.<br>不好的是, 这台车, 没有任何的挑战, 激情. 感觉不是太喜欢, 也不能说不喜欢. 总感觉买了这台车, 心里感觉怪怪的, 总是有一些落差.</li><li>大众途观L 380TSi 自动四驱豪华版  28.98(两驱版本25.98)<br>这种考虑, 纯碎是因为我那个走不出舒适区的自我在思考. 人人都想过安逸的生活. 我也有这样的一面. 想着, 如果过几年我结婚了, 孩子也很快出生了. 那么需要一台家用车, 大, 实用, 那么一台大众的SUV是最好不过了. 可是啊, 不是别人喜欢SUV, 你就去跟风. 这个基本术语末选项. </li><li>福特Mustang 2.3T 性能版 (注意是 50周年纪念版, 不是2017版)<br>这个是一眼我的就看上了的. 平民跑车. 作为一个敢于追求自我的人, 如果有能力, 就要勇敢尝试和挑战, 并实践. 虽然豪华品牌的跑车, 我是买不起的; 虽然野马V8的旗舰我也买不起. 但是做任何选择, 都不要让自己后悔. 只是这台车, 对于我平时的生活, 工作, 都没有任何帮助. 纯碎是心里想要.</li></ul><p>为什么不考虑BBA?<br>我的预算在30~40W之间, 而BBA的车, 如果不是50W往上走, 选择BBA, 在我心里觉得这人有点儿可怜. 就是… 实在点儿吧. 纯属于自己意见(言语不当之处, 还请多多包涵). 因为有些大佬更专注家庭, 其实以性价比作为考量, 除了选择两田, 也会选择BBA. 萝卜青菜各有所爱, 求同存异.</p><h2 id="详细剖析"><a href="#详细剖析" class="headerlink" title="详细剖析"></a>详细剖析</h2><p>主要剖析 <code>野马</code> 和 <code>凯美瑞</code> .</p><p>还剖析个啥, 日本车,特别是丰田, 那技术牛的很, 马自达都快喊丰田爸爸了; 福特车我一般对其变速箱, 发动机没有太大的信心. 但是野马是一辆情怀车, 更是一辆<code>平民跑车</code>.</p><p>不剖析了, 直接上图(图片来自网络).</p><blockquote><p>小马驹</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/mustang_front.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang_rear.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang_side.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang1.jpg" alt=""></p><p>确实非常喜欢. 平民跑车, 样子果然不错; 就是, 不实用.</p><blockquote><p>Camery</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/camery1.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery1_1.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery1_2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery3.jpg" alt=""></p><p>日常家用, 首选, 而且不容易坏, 三大件儿都好.</p><h2 id="需求match"><a href="#需求match" class="headerlink" title="需求match"></a>需求match</h2><p>其实考虑了很多问题:</p><ul><li>我的钱够不够?</li><li>买车属于投资还是消费?</li><li>是否值得?</li><li>需要一辆代步车么? </li><li>需要省油么? </li><li>为什么买车?(用途)</li><li>日常使用的方便程度?</li><li>如果经常坏怎么办?</li></ul><p>工作起来, 我就像个疯子, 住在公司旁边, 一心全在项目上; 所以买车代步不过是个笑话. 没有家庭, 所以基本也没有什么负担, 所以省钱省油也是净扯. 至于丰田的车开不坏, 福特的车爱断轴, 这些谣言就像早期德系品牌宣传日系车皮薄一样. 买车属于消费, 买了之后就只有贬值的分. 钱基本还是够的.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p><code>凯美瑞</code>是目前最适合我的车, 但不是我最想要的车;<br><code>野马</code>是我最想要的车, 但却不是目前最适合我的车.</p></blockquote><p>苦笑, 等时机成熟吧. <code>革命尚未成功, 同志还需努力</code>.</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>两年的时间, 同学中有人抽时间去上海交大, 南开读了研, 而我积累的了许多工作经验和社会经验.</p><blockquote><p>这一条路, 一旦走出来, 轨迹势必就不一样了. 尽全力吧, 否则很危险!</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/%E6%88%90%E9%95%BF%E6%9B%B2%E7%BA%BF.jpg" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://v.autohome.com.cn/v-100569.html#pvareaid=2042227" target="_blank" rel="external">http://v.autohome.com.cn/v-100569.html#pvareaid=2042227</a></li><li><a href="http://v.autohome.com.cn/v-34389.html#pvareaid=2042227" target="_blank" rel="external">http://v.autohome.com.cn/v-34389.html#pvareaid=2042227</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      小伙你网络库的源码都研究完了么, 就跑这儿若无其事的看车?
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Merlin&#39;s Emacs</title>
    <link href="www.merlinblog.site/2017/08/31/my-emacs.html"/>
    <id>www.merlinblog.site/2017/08/31/my-emacs.html</id>
    <published>2017-08-31T07:59:14.000Z</published>
    <updated>2017-09-24T07:31:45.671Z</updated>
    
    <content type="html"><![CDATA[<p>最开始(刚开始工作的时候)接触的 IDE 其实是 SourceInsight . 那时候很多 android 框架的源码要看, 要分析, 也一度想要购买正版 SI. 后来机缘巧合单位的老前辈推荐我用 emacs, 从此踏上一条不归路.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/emacs_ecb.png" alt=""></p><p>本文主要记载我的emacs配置文件, 以及配置方法. 先给一个图吧. 中间可能有一些复杂，但是按照从简单到复杂的步骤其实还好; 想要省心省力, 不折腾的同学, 可以去购买一些商业的IDE, 节省了配置的时间.</p><p>(效率上取决于对于IDE的熟悉情况, 个人以为emacs没有上限)</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>每当别人像我展示它的 <code>vim</code> 的时候, 我都是不屑的.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/vim.png" alt=""></p><p>但是渐渐的, 如果有初学者问我要不要深入emacs, 我都会建议它: 最好不要, vistual studio code, qtcreator等都是不错的选择. 因为这东西会让你投入大量的时间折腾, 而且一旦习惯了快捷键操作, 效率是很高, 不过换一种没有配置的环境, 就会感觉很不习惯的.</p><blockquote><p>Emacs 就是一个坑, 一个永远挖不完坑, 会上瘾的.</p></blockquote><p>闲话不多说, 马上来正文. 效率Up Up Up!</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>根据自己的用途，一步步配置环境，下面按照顺序叙述：</p><ul><li>配置基本faces和主题</li><li>配置按键</li><li>配置语言支持</li><li>配置hightlight</li><li>配置ibuffer</li><li>配置dropdownlist</li><li>配置gdb</li><li>配置autosave</li><li>配置session</li><li>配置showhide</li><li>配置tabbar</li><li>配置symbol-overlay (f8,f9)</li><li>配置cscode</li><li>配置autocomplete和yasippet</li><li>配置cedet</li><li>配置ecb</li></ul><blockquote><p>中途还有一些个人使用习惯，不过多解释，只贴代码</p></blockquote><h2 id="明确用途"><a href="#明确用途" class="headerlink" title="明确用途"></a>明确用途</h2><p>我使用emacs, 主要是在远程shell到服务器以及linux环境下做开发的(但不是所有的内容, 什么看网页啊, 看视频啊, 写邮件啊则不是), 归纳起来如下:</p><ul><li>linux下的终端操作, 即shell中命令操作(所有命令)</li><li>c/c++开发, 包括代码的编写(各种补全, 提示等), 测试用例的编写, 调试, 日志输出, doc输出</li><li>研究源码, 这个需求和上面有一定的区别, 研究源码的时候更加关注架构层次, 模型, 甚至详细的调用关系</li><li>linux下的shell脚本编写, 可能包括一部分python脚本</li><li>org-mode 文档的编写</li><li>git 日志查看以及提交(可能会结合gitk)</li></ul><p>(我写 Java 和 Python 应用程序统统使用IDE, JetBrain的开发环境; 一般不写QT代码, 界面无感)</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>中途的半成品<br><img src="http://omotkhw3y.bkt.clouddn.com/emacs_tmp.jpg" alt=""> </p><p>最终配置差不多就是这个样子:<br><img src="http://omotkhw3y.bkt.clouddn.com/emacs-done.jpg" alt=""></p><pre><code class="lisp">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;From Merlin deepin15.4;;;;;;;;;;;;;;;;;;;;;;;;;;;; File name: ` ~/.emacs &#39;    ;;; ---------------------;;;;;; If you need your own personal ~/.emacs;;; please make a copy of this file;;; an placein your changes and/or extension.;;;;;; Copyright (c) 2017 deepin 15.4.1;;;;;; Author: Merlin Yu, &lt;wizardmerlin945@gmail.com&gt; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 配置上, 除了基本配置外， 插件包可以采用自动管理；不过我还是采用 手动方式;; (具体的版本&amp;加强包可能自动下载不到);;(load-file &quot;/home/merlin/.emacs.d/lisp/cedet/cedet-1.1/common/cedet.el&quot;);;自动包管理;;(require &#39;merlin-init-autopackage);;;;; 手动方式(即下面自动递归添加~/.emacs.d/lisp内的包);;(add-to-list &#39;load-path &quot;~/.emacs.d/lisp&quot;)(defun add-subdirs-to-load-path (dir)  &quot;Recursive add directories to &#39;load-path&#39;.&quot;  (let ((default-directory (file-name-as-directory dir)))    (add-to-list &#39;load-path dir)   (normal-top-level-add-subdirs-to-load-path)))(add-subdirs-to-load-path &quot;~/.emacs.d/lisp&quot;);;;;;;;;;;;;;;;;;;;;基本配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;配置基本的facet和主题(load &quot;merlin-init-ui&quot;);;配置基本并且常用的设置(load &quot;merlin-init-base&quot;);;配置高效的快捷键(这个要在相关的扩展插件之后);;也包括开发语言相关的(load &quot;merlin-init-key&quot;);; 配置语言模式(load &quot;merlin-init-language-mode&quot;);;;;;;;;;;;;;;;;;;;手动配置的各种插件;;;;;;;;;;;;;;;;;;;;;;;;;;;;更好的自动保存插件(load &quot;merlin-init-autosave&quot;);;配置高亮当前行(load &quot;merlin-init-hl-line&quot;);; 配置高亮查找(load &quot;merlin-init-symbol-overlay&quot;);;配置自动补全(load &quot;merlin-init-autocomplete&quot;);; 代码折叠(本来希望依靠cedet的, 结果它不靠谱)(load &quot;merlin-init-showhide&quot;);;配置tab栏(注意只有图形化界面可以使用);;(load &quot;merlin-init-tabbar&quot;);;不要配置tabbar了, 给ecb腾出快捷键(terminal使用场景偏多);;配置shell(load &quot;merlin-init-shell&quot;);;配置gdb(load &quot;merlin-init-gdb&quot;);;配置书签 (我一般不使用书签, 寄存器);;(load &quot;merlin-init-bookmark&quot;);;配置 cscope(load &quot;merlin-init-cscope&quot;);;配置git;;(load &quot;merlin-init-git&quot;);;配置cedet(load &quot;merlin-init-cedet&quot;);;;配置ecb(load &quot;merlin-init-ecb&quot;);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not yet---begin::::::::::;;;ediff;;;dried;;;doxygen;;compile;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not yet---end::::::::::;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;配置浏览器(load &quot;merlin-init-browser&quot;);;ibuffer;;不同于系统自带的buffer, 它会单独打开一个buffer, 作为buffer的管理页面(load &quot;merlin-init-ibuffer&quot;);;保存session（下次启动的时候会在最近打开的菜单栏中显示）;;(load &quot;merlin-init-session&quot;);;配置desktop.el(每次启动的时候自动加载上次没有关闭的);;这个东西必须放在最后， 确保其可以正确辨别文件所需要的模式(load &quot;merlin-init-desktop&quot;)</code></pre><h3 id="参考gihub"><a href="#参考gihub" class="headerlink" title="参考gihub"></a>参考gihub</h3><p>代码太多了， 我直接上传了 <a href="">github</a></p><h2 id="补充配置"><a href="#补充配置" class="headerlink" title="补充配置"></a>补充配置</h2><p>一些有用的，但是我个人又没有配置的</p><p>在配置yasnippet的时候，注意到了他的已经知道的模板</p><pre><code>yasnippet:高效设置:C++ mode(c++独有的)acl            cni          delete              ffo              gnn     ita              mrg         operator[]        psc     rpl      std_colon   tfmacm            cnt          delete[]            fil              gnr     iterator         msm         operator+         pst     rtc      sth         thisajf            const_[]     doc                 fin              gtest   ltr              mxe         operator+=        ptc     rte      sti         throwalo            constructor  d_operator          fixture          ignore  lwr              namespace   operator_istream  ptn     rvc      sto         trmano            cout         d_operator[]        fln              ihp     lxc              nno         operator_ostream  public  rvr      str         tryassert         cpb          d_operator[]_const  fnd              ihu     map              ns          ostream           rci     shf      sts         trywbeginend       cpi          d_operator_istream  fne              inline  member_function  nth         pack              rmc     spt      stv         ucpboost_require  cpn          d_operator_ostream  fni              io      mkh              nxp         phh               rmf     srh      swr         uprcerr           cpp          dynamic_casting     fori             ipr     mme              oit         ppt               rmi     srn      template    uqecin            cpy          enum                fre              ipt     mne              operator=   private           rmv     srt      test case   usingclass          cstd         eql                 friend           iss     module           operator==  protected         rpc     sstream  test_main   vectorclass11        d+=          erm                 fun_declaration  isu     mpb              operator!=  prp               rpi     std      test_suiteC mode (主要是添加一些头文件)assert  compile  define  malloc  packed  printf  stdio  stdlib  string  union  unistdcc mode(c,c++共有的)case  else              fopen  for_n                 if     inc    main  member_description  printf  switch   typedefdo    file_description  for    function_description  ifdef  inc.1  math  once                struct  ternary  while</code></pre><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><p>这里记录一下，算是一个我自己的备忘吧.</p><p>Emacs中的按键不计其数，也可以自行设定，因为按键表示相应的lisp函数的快捷方式. 改坏了怎么办?, 把.meacs文件删除就好了.</p><h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><p>emacs的启动参数:</p><pre><code>emacs -q   (安静启动, 不执行.emacs文件)emacs -u joe  (使用joe用户的.emacs启动)emacs --debug-init (调试模式启动)emacs -nw  (terminal 中启动)emacs practice.b --insert myfile  (启动practice.b文件, 并把myfile插入到打开的buffer中)emacs --insert myfile (把myfile插入到临时的buffer中)emacs +15 practice.b (打开文件,并定位到15行; 注意, 如果是输入的数字长于文件的总长度, 那么就会定位到文件结尾)</code></pre><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><p><code>C-h t</code> 查看教程, 该教程看完, 用熟悉;  初次之外可以查看 info 手册:</p><p><code>C-h i</code> , 之后使用m+关键词查看, d返回, 回车是选中, 还可以使用u和l:翻页和返回上次浏览的地方)</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>使用man手册</p><ul><li><code>M-x woman</code></li><li><code>M-x man</code></li><li>然后输入相关的关键字</li></ul><p>我一般使用 <code>M-x man</code>.<br>对于man手册的支持, emacs的woman还要去解析man文件(<code>/usr/share/man</code>), 感觉比较坑爹; </p><h3 id="基本按键"><a href="#基本按键" class="headerlink" title="基本按键"></a>基本按键</h3><ol><li>C-x i  插入文件(在已打开的文件内插入文件)</li><li>C-x, C-w 另存为</li><li>C-x u 撤销(C-/)</li><li>C-x h 全部选中 (这个后面详细说)</li><li>C-% 查找替换(C-s以及C-r是查找)</li><li>C-x b 选中命名的buffer</li><li>C-x, C-b 列出所有buffer</li><li>M-x, kill-buffer  杀死buffer, 快捷键 C-x k</li><li>C-v 向下翻页 (C-u 8 C-v 向下翻8页)</li><li>M-v 向上翻页</li><li>C-k 删除一行</li><li>C-h m 查看当前模式(terminal可能)</li><li>C-x C-q 设置或者取消只读模式</li><li>格式代码(缩进)<br>C-x h TAB 格式化选中的代码<br>C-c,C-q 对整个函数进行缩进 (光标应该在函数内, 并且需要再源码mode以内)<br>选中区域,  M-x untabify, 将 TAB 字符转换为空格<br>选中区域, M-x indent-region, 对齐文本块</li><li>注释:<br><code>M-;</code> 在该行的末尾添加注释符号(当然选中块之后也就可以注释整个block)<br><code>C-c C-c</code> 对一块代码进行注释;<br>取消注释用命令 <code>uncomment-region</code> (其实用undo也可以)</li><li>折叠代码(我个人设置的是 <code>M+,</code>)</li><li>标记和调整(我个人设置的是<code>C-c m</code>, <code>C-c j</code>)</li><li>括号间跳转：(括号和函数间跳转)<br>括号之间来回跳转的时 候按 C-M-f 和 C-M-b.<br><code>C-M-a</code>   移动到当前函数的开始(如果和系统的快捷键冲突, 那么就多加一个shift键盘)<br><code>C-M-e</code>   移动到当前函数的结尾<br>(注意可以把C-M-a, C-M-e合并到C-M-f和C-M-b中, 我通常采取的策略是使用%进行跳转)</li><li>标记移动和全选:<br>标记整个页面 <code>c-x,c-p</code> (实际上这里多是整个buffer, 而不是整个frame)<br>标记整个缓冲区 c-x h (常用)<br>标记整个段落 m-h (通常没有用-而是用c-m-h)<br><code>c-space</code> 设置标记(如果冲突就多加一个shift 或者使用 c-@) 然后移动光标, 就会从标记的位置选中移动选中区域<br><code>c-x c-x</code> 快速返回移动前的光标位置(互换插入点和文本标记的位置)<br><code>c-m-h</code> 快速选中一个函数 (如何按键有冲突, 可以多加一个shift)</li><li>大小写转换(默认是被禁止)–注意是C-x开始<br>downcase-region (<code>C-x C-l</code>) ;; 选定区域全部改为小写<br>upcase-region (<code>C-x C-u</code>)   ;; 选定区域全部改为大写<br>可以直接在.emacs文件中设置:<pre><code>(put &#39;downcase-region &#39;disabled nil)(put &#39;upcase-region &#39;disabled nil)</code></pre>只是转换一个单词的话, 可以用 <code>M-u</code> 和 <code>M-l</code>, 它会把从光标开始的后面一个单词变成大写或者小写.</li></ol><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><p>frame, 缓冲区, 窗口的关系:<br>整个窗口在Emacs中叫做frame, 图形界面下的Emacs可以打开多个frame. 每个frame从上到下分成3部分，分别是缓冲区,状态栏和回显区(一般工具栏隐藏) 缓冲区是编辑的主区域, 但是在这里操作的还不是真正的文件, 而是文件的一个缓存(buffer)。只有执行写入操作时，才会将buffer的内容写入到文件. 缓冲区可以分成多个区域, 缓冲不同的内容. 这些区域在Emacs中成为”窗口”.</p><ol><li>C-x 1 只保留当前窗格</li><li>C-x 0 关闭当前窗格</li><li>C-x 2 切割为等宽半高的两个窗格</li><li>C-x o 切换到另一个窗格   (窗口相关的可以参考, 参考ibuffer.el扩展)</li></ol><p>缓冲区之下是状态栏，显示当前的一些状态信息，比如图中从左至右依次为:</p><pre><code>-UU-:----F1  tmp            Bot L31    (Fundamental) -------</code></pre><p>解释:</p><ul><li><code>UU</code>: 当前的文件编码是UTF-8, 如果是GBK会显示c</li><li><code>**</code>: 文件状态，**表示未保存，–表示可写，%%表示只读(C-x, C-q)</li><li><code>tmp</code>: 是当前编辑的文件的名称</li><li>All: 表示当前缓冲区已经显示文件的所有内容(Bot,表示处于文件的末尾处)</li><li>L31: 当前光标所在的行数</li><li>fundamental: 当前的模式</li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式:</p><ul><li>主要模式: 当前主要模式只有一种<br>fundamental-mode: 缺省的 Emacs 模式，拥有最少设置和绑定<br>text-mode：编辑文本的基本模式<br>c-mode：用于编辑程序源代码 (以及其他源码模式)<br>lisp-interaction-mode:用于编辑和编译 Lisp 代码<br>ptex-mode：用于编辑 TeX 文档</li><li>次要模式 : 可以组合到主要模式中(次要模式可以有多种), 如果输入的模式包含在当前模式中, 对于主要模式, 会清空所有的次要模式<br>abbrev-mode：用于生成和使用缩写<br>auto-fill-mode：用于自动文字回绕、填充较长的行和段落<br>line-number-mode：显示当前行号(默认在状态栏上显示的就是)<br>overwrite-mode：覆盖模式, 代替默认的插入模式<br>以及其他插件模式</li></ul><h3 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h3><p>(C-x r 开头; 和寄存器, 书签有重合)</p><p>这里可以补充一个矩形操作:(矩阵操作, 其实就是列模式)<br>其实我并没有觉得矩形剪切和复制时多么棒的东西, 平时用到的标记剪切其实也不错.</p><p>主要就是下面几个命令:(先用C-space或者C-@设一个mark, 移动光标到另一点; 剪切的其实是对角线围成的矩形)</p><pre><code>C-x r k 剪切一个矩形块C-x r y 粘贴一个矩形块  C-x r d 删除一个矩阵块C-x r c 清除一个矩形块(使其变成空白) C-x r o 插入一个矩形块(打开当前的矩形区块，使用空白字符填充整个区域，并将该矩形区块的所有文本移动到右边)C-x r t 在选定区域的所有列前插入样的字符</code></pre><p>(没有复制啊? 我说你傻啊, 先剪切, 然后undo, 然后粘贴)</p><p>Keystrokes             Command name                                             Action<br>C-x r  k                kill-rectangle                                  Delete a rectangle and store it.<br>C-x r  d                delete-rectangle                                Delete a rectangle and do not store it.<br>C-x r  y                yank-rectangle                                  Insert the last rectangle killed<br>C-x r c                 clear-rectangle                                 Using spaces, blank out the area marked as a rectangle and do not store it.<br>C-x r o                 open-rectangle                                  Insert a blank rectangle in the area marked.<br>C-x r r r               copy-rectangle-to-register                  Copy rectangle to register r (where r is any character) .<br>C-x r i r               insert-register                                 Insert rectangle from register r (where r is any character).<br>（none)                 delete-whitespace-rectangle             if a rectangle includes initial whitespace, deletes it, narrowing rectangle.<br>C-x r t string          Enter string-rectangle                      Change contents of marked rectangle to string (if string is narrower<br>                                                                    or wider than rectangle, dimensions change accordingly).<br>(none)                  string-insert-rectangle                     Prompts for string and inserts rectangle.</p><hr><p>不满意的话, 还可以使用 <code>cua-mode</code> . (我个人不用)</p><p>除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入 cua rectangle模式。<br>在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。 直接输入字符: 在每行前(或后)都插入这个字符.</p><pre><code>[M-a]: 将rect中的文字左对齐  [M-b]: 用空格(tabs或者spaces)替换所有rect中的字符  [M-c]: 去掉所有行左侧的空格  [M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)  [M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)  [M-k]: 剪切rect  [M-l]: 把rect中的内容全部转换为小写  [M-m]: 拷贝rect  [M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号)  ### 非常好用的功能  [M-o]: rect的内容右移，选中的rect用空格填充  [M-r]: 用字符串替换符满足正则表达式的字符串  [M-R]: 上下反转  [M-s]: 把rect中的每一行替换为一个字符串(提示输入)  [M-t]: 把rect整个替换为一个字符串(提示输入)  [M-u]: 把rect中的内容全部转换为大写  [M-|]: 对rect执行一个shell命令</code></pre><p>我个人一般最多用到矩阵模式.</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>(这里的命令注意和矩阵相区别一下)<br>在多个文件中逛的时候，我们常常需要快速切换到先前访问的某个位置. 因此, 我们需要把文件及其光标位置暂时存放在某个地方. (一般我们都会根据register进行一定封装, 从而进行来回的跳转) 简单说, 这里的寄存器(register), 就是保存一些位置信息(光标位置, 文件信息等)</p><p>最基本的用法(和我定义的C-c,m以及C-c,j比起来作用弱一点儿)<br>将当前光标所在位置保存入一个register中:<br><code>C-x r SPACE + register名</code> (一个字符, 比如a吧), 然后我们就可以到处瞎逛，若要回到保存的register a位置，我们可以输入: <code>C-x r j a</code></p><p>当然你可以定义好多个寄存器名字(位置)</p><pre><code>M-x view-register    查看某一个registerM-x list-registers   查看所有的register</code></pre><p>在进行矩阵操作的时候, 中间有两个命令: 保存到寄存器, 并存寄存器中恢复</p><pre><code>C-x s X                 copy-to-register                          将选定区域保存到寄存器 XC-x r r r               copy-rectangle-to-register                Copy rectangle to register r (where r is any character) .C-x r i r               insert-register                           Insert rectangle from register r (where r is any character).</code></pre><p>通常来说, 我个人不会使用这么原始的方式(偶尔可能会用), 一般使用其他更加高级的标记方式,比如我自己定义的 <code>C-.</code>以及 <code>C-,</code> .<br>比如ctags, etags, gtags, 或者csope等都是比较好的选择.   (我个人一般使用csope)</p><p>比如说 etags:<br>在代码目录中运行 <code>etags -R</code><br>如果要向现有tags表中添加，则运行 <code>etags -a</code><br>访问tag文件的话: <code>M-x visit-tags-table</code> , 常用的快捷键如下:</p><pre><code>M-.       访问tag C-u M-.   访问下一个tag M-*       返回</code></pre><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>保存缓冲区中位置的另一种工具(注意一下和矩阵操作的快捷键)<br>这些 Emacs 书签 的工作方式与寄存器相同，但是它们的标签可以超过一个字符长，而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们。它们将一直保留下来，直到您删除它们。正如它们的名称所表示的，对于保存您在缓冲区中的位置，以便您稍后可以返回到该位置（通常是在以后的 Emacs 会话期间），使用书签是非常方便的。</p><p>不过多介绍了:</p><pre><code>C-x r m Bookmark               bookmark-set              设置一个名为 Bookmark 的书签C-x r l                           bookmarks-bmenu-list        列出所有已保存的书签C-x r b Bookmark                      bookmark-jump              跳转至名为 Bookmark 的书签中所设置的位置(实际上是恢复书签)未定义                          bookmark-delete                  删除一个书签未定义                                         bookmark-save            将所有的书签保存到书签文件中(这样下次启动就可以跨越session了)</code></pre><p>注意, 自从emacs24, 退出的时候 书签是自动保存在相关文件中的:</p><ul><li>In emacs 24.x, bookmark file is at ~/.emacs.d/bookmarks.</li><li>In emacs 23.x, bookmark file is at ~/.emacs.bmk.<br>你也可以自己设置:<pre><code>(setq bookmark-save-flag 1) ; everytime bookmark is changed, automatically save it(setq bookmark-save-flag t) ; save bookmark when emacs quits(setq bookmark-save-flag nil) ; never auto save.</code></pre></li></ul><p>当然你可以设置在每次启动的时候, 自动载入书签:</p><pre><code>(require &#39;bookmark)(bookmark-bmenu-list)(switch-to-buffer &quot;*Bookmark List*&quot;)</code></pre><p>(我个人使用desktop插件, 所以不写该句)</p><p>当然你可以进行设置一些快捷键:</p><pre><code>(global-set-key [(f9)] &#39;list-bookmarks)(global-set-key [(f10)] &#39;bookmark-set)</code></pre><p>在list bookmark之后(相当于打开了bookmark文件), 可以使用下列命令在列表中操作:</p><p>Type d to mark the current item for remove.<br>Type x to remove all D marked ones. (执行)<br>Type r to rename current item’s title.<br>Type s to save the change.</p><p>现在有了 desktop, 书签显得比较鸡肋.</p><h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><p>下面说说我cscope的配置: (cscope和ecb功能上有一定重合)<br>GNU Emacs默认自带etags的支持, 但是不如cscope强大, cscope本身是一个独立软件, (建立索引之后)而且非常强大.</p><p>可以独立安装:</p><pre><code>$ which cscope/usr/local/bin/cscope$ file cscope/contrib/xcscope/cscope-indexer cscope/contrib/xcscope/cscope-indexer: POSIX shell script, ASCII text executable</code></pre><p>在外部使用:</p><p>要使用 cscope, 先建索引, 假设所有的头文件和h都在src下面</p><pre><code>find src/ -type f -iname &quot;*.h&quot; &gt;  cscope.files (这里创建)find src/ -type f -iname &quot;*.cpp&quot; &gt;&gt; cscope.files （这里是&gt;&gt;追加）</code></pre><p>(把所有符号都追加到一个文件可以加快建立索引文件的速度, 但是不利于之后展开文件)</p><pre><code>#!/bin/shfind . -name &quot;*.h&quot; -o -name &quot;*.c&quot; -o -name &quot;*.cc&quot; &gt; cscope.filescscope  -Rbkq -i cscope.files</code></pre><p>其他选项解释:</p><ul><li>-R: 在生成索引文件时, 搜索子目录树中的代码</li><li>-b: 只生成索引文件, 不进入cscope的界面</li><li>-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度</li><li>-k: 在生成索引文件时, 不搜索/usr/include目录</li><li>-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用“-”，表示由标准输入获得文件列表</li><li>-I dir: 在-I选项指出的目录中查找头文件</li><li>-u: 扫描所有文件, 重新生成交叉索引文件</li><li>-C: 在搜索时忽略大小写</li><li>-P path: 在以相对路径表示的文件前加上的path, 这样你不用切换到你数据库文件所在的目录也可以使用它了</li></ul><p>使用命令 <code>cscope -Rbkq</code>,  产生文件如下:</p><pre><code>cscope.in.outcscope.out  //基本的符号索引cscope.po.out</code></pre><p>注意一下, k在生成索引文件时, 不搜索/usr/include目录;  此时初始化和建立索引已经完成了, 之后就可以利用命令进行查找了.</p><p>在emacs里面使用:<br>当然在emacs程序里, 也可以进行初始化和建立索引(如果所有的源代码以及子目录都是在同一个目录下面的). </p><pre><code>;; C-c s a 初始化目录( 设定初始化的目录，一般是你代码的根目录);; C-c s I 对目录中的文件建立列表索引(生成 Cscope 的数据库)(cscope-set-initial-directory) 这一步最重要</code></pre><p>一般使用 <code>C-c s I</code> 就可以了, 对应 <code>cscope-set-initial-directory</code> . 如果源代码全部处于同一个目录下面，现在就可以使用了. (个人习惯还是喜欢再外部使用cscope -bkqR)</p><p>注意:</p><p>如果源代码有多层目录，或者其他地方还有附加的源代码，则需要 <code>cscope-indexer</code> 脚本. 把那个脚本拷贝到系统 PATH 里面去(如 /usr/bin/).</p><pre><code>$ sudo chmod u+x cscope-indexerexport PATH=$PATH:~/.emacs.d/lisp/cscope/contrib/xcscope</code></pre><p>然后在根目录, 建立索引</p><pre><code>$ cscope-indexer -r</code></pre><p>只要执行 C-c s I(cscope-index-files), 即`` 就可以生成 Cscope 的数据库, 接下来就可以使用了.<br>xcscope默认的快捷键都是绑定到 C-c s 的前缀上面, 更详细的使用说明请参见 xcscope.el 文件头部的注释.</p><p>我个人使用的是默认绑定: (必须要建立完索引)</p><ul><li>C-c s s         Find symbol. 寻找符号(查找C语言符号，即查找函数名、宏、枚举值等出现的地方)</li><li>C-c s d         Find global definition. 寻找全局定义—一般用这个来查找具体的定义</li><li>C-c s g         Find global definition (alternate binding). 寻找符号, 变量的定义</li><li>C-c s G         Find global definition without prompting.</li><li>C-c s c         Find functions calling a function. 看看指定函数被哪些函数所调用</li><li>C-c s C         Find called functions (list functions called<pre><code>          from a function).  看看指定函数调用了哪些函数</code></pre></li><li>C-c s t         Find text string.  查找字符串</li><li>C-c s e         Find egrep pattern. 正则表达式查找</li><li>C-c s f         Find a file. 寻找文件</li><li>C-c s i         Find files #including a file.  看看指定的文件被哪些文件include<br>```</li></ul><p>下面是在搜索到的结果之间切换用的快捷键:(一般不用, 直接跳转到窗口)</p><pre><code>C-c s b         Display *cscope* buffer.C-c s B         Auto display *cscope* buffer toggle.C-c s n         Next symbol.C-c s N         Next file.C-c s p         Previous symbol.C-c s P         Previous file.C-c s u         Pop mark.</code></pre><p>将光标停在函数名上, 按C-c s d, 回车, 即可以查询相关的定义.<br> xcscope.el 原来定义如下: </p><pre><code>;; * Keybindings:;;;; All keybindings use the &quot;C-c s&quot; prefix, but are usable only while;; editing a source file, or in the cscope results buffer:;;;;      C-c s s         Find symbol.;;      C-c s d         Find global definition.;;      C-c s g         Find global definition (alternate binding).;;      C-c s G         Find global definition without prompting.;;      C-c s c         Find functions calling a function.;;      C-c s C         Find called functions (list functions called;;                      from a function).;;      C-c s t         Find text string.;;      C-c s e         Find egrep pattern.;;      C-c s f         Find a file.;;      C-c s i         Find files #including a file.;;;; These pertain to navigation through the search results:;;;;      C-c s b         Display *cscope* buffer.;;      C-c s B         Auto display *cscope* buffer toggle.;;      C-c s n         Next symbol.;;      C-c s N         Next file.;;      C-c s p         Previous symbol.;;      C-c s P         Previous file.;;      C-c s u         Pop mark.;;;; These pertain to setting and unsetting the variable,;; `cscope-initial-directory&#39;, (location searched for the cscope database;;  directory):;;;;      C-c s a         Set initial directory.;;      C-c s A         Unset initial directory.;;;; These pertain to cscope database maintenance:;;;;      C-c s L         Create list of files to index.;;      C-c s I         Create list and index.;;      C-c s E         Edit list of files to index.;;      C-c s W         Locate this buffer&#39;s cscope directory;;                      (&quot;W&quot; --&gt; &quot;where&quot;).;;      C-c s S         Locate this buffer&#39;s cscope directory.;;                      (alternate binding: &quot;S&quot; --&gt; &quot;show&quot;).;;      C-c s T         Locate this buffer&#39;s cscope directory.;;                      (alternate binding: &quot;T&quot; --&gt; &quot;tell&quot;).;;      C-c s D         Dired this buffer&#39;s directory.</code></pre><p>如果你喜欢自定议案件的话, 提供自定义按键参考:</p><pre><code>(define-key global-map [(control f3)]  &#39;cscope-set-initial-directory)(define-key global-map [(control f4)]  &#39;cscope-unset-initial-directory)(define-key global-map [(control f5)]  &#39;cscope-find-this-symbol)(define-key global-map [(control f6)]  &#39;cscope-find-global-definition)(define-key global-map [(control f7)]  &#39;cscope-find-global-definition-no-prompting)(define-key global-map [(control f8)]  &#39;cscope-pop-mark)(define-key global-map [(control f9)]  &#39;cscope-next-symbol)(define-key global-map [(control f10)] &#39;cscope-next-file)(define-key global-map [(control f11)] &#39;cscope-prev-symbol)(define-key global-map [(control f12)] &#39;cscope-prev-file)(define-key global-map [(meta f9)]     &#39;cscope-display-buffer)(define-key global-map [(meta f10)]    &#39;cscope-display-buffer-toggle)</code></pre><h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>由于我使用了插件 symbol-overlay, 所以一般是借助f8标记和操作标记， 和 <code>M-r</code>重命名, <code>M-s</code>切换到isearch.</p><p>下面是可能涉及到的查找:<br><code>C-%</code> 查找替换<br><code>C-s</code> 以及 <code>C-r</code>是递归查找<br><code>M-x grep-find</code>, 已经设置快捷键为f3<br> <code>find . -type f -exec grep --color -nH -e &quot;content&quot; {} +</code></p><p>下面可以详细说一下技巧， 因为查找&amp;替换实在用的太多了:</p><p>Emacs中的搜索包括增量搜索和一般搜索。增加搜索是每次在前一次搜索的结果基础上继续搜索。在增量搜索时，如果上一次搜索之后进行了其他操作，则需要连续按两次快捷键才能召回关键词. 可以选中区块后在区块内进行搜索.</p><p>增量查找:<br>C - s向下查找<br>C - r向上查找<br>按下C - s后输入要搜索的词，emacs会即时显示当前光标后第一个搜索到的结果，按C - s会跳到下一个结果，按C - r会跳到上一个结果.<br>按Enter结束查找或按C - g取消查找回到原来的地方。<br>按下C - s 或 C - r后, 按M - p显示上一个搜索词, M - n显示下一个搜索词。类似C - p是上一行，C - n下一行.<br>按下C - s或 C - r后, 输入要查找的词的头几个字, 然后按C - w 会补全当前位置的单词.</p><p>查找替换:<br>按M - %启动查找替换，输入要被替换的词，回车，然后输入要替换的词，再回车。<br>被替换的词会高亮起来，这时，</p><ul><li>输入y替换并跳到下一个</li><li>^ 返回上一个替换点</li><li>输入n忽略并跳到下一个</li><li>输入q结束，输入！替换剩下的全部</li></ul><p>C - r 进入修改<br>(我一般重构的时候， 使用插件， M-r进行全部改名, M-s回归递归查找)</p><p>取消搜索<br>C-g 取消搜索，光标返回搜索前的位置<br>RET结束搜索，光标停留在当前位置。</p><p>Ocuur模式<br>有时候想列出匹配的全面模式，而不是在文档中浏览，这个可以使用occur这个函数。<br>例子：M - x occur RET 关键词 RET<br>这时emacs会新开一个窗口来列出匹配的行<br>(实际上再 M-s之后, 案件M-s o即可达到同样的效果)</p><h3 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h3><p>写代码的cc-mode(cc-mode 可以用来写 C/C++/Java/Obj-C)</p><p>使用cc-mode:<br><code>M-x c-set-style</code>, 然后选择cc-mode</p><pre><code>M-x customize 定制界面等M-x customize-themes 定制主题等</code></pre><h3 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h3><p>文件编码方面, 一般linux下都采用utf-8即可, 或者设置 <code>(prefer-coding-system &#39;utf-8)</code> .</p><p>但是如你在gbk环境下, 比如你的windows7设置的是gdk, 那么此时应该设置gbk环境编码(否则读入文件时的解释编码和系统编码不一致, 肯定乱码了)</p><pre><code>(setq file-name-coding-system &#39;gbk)(set-terminal-coding-system &#39;gbk)(set-keyboard-coding-system &#39;gbk)(setq locale-coding-system &#39;gbk)(set-selection-coding-system &#39;gbk)(set-clipboard-coding-system &#39;ctext)(set-clipboard-coding-system &#39;gbk)(set-terminal-coding-system &#39;gbk)(set-buffer-file-coding-system &#39;gbk)(modify-coding-system-alist &#39;process &quot;.&quot; &#39;gbk)(setq default-process-coding-system &#39;(gbk . gbk))</code></pre><h3 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h3><p>关于 tabbar 的再一次调整:</p><p>要达到的效果是什么呢?<br>是要在一个 buffer 里面移动, 而不会切换到被的分组.<br>键位的设定时我特意改用了tabbar-backward-tab和tabbar-forward-tab 代替tabbar-backward和tabber-forward.<br>效果是使用M-left/right的时候移动不会跨组, 也就是只能在当前分组内移动, 这样好很多.<br>中间一段设置把标签栏左边的那些按钮都取消掉了.</p><p>原来是不分组, 最后发现还是要根据主模式分组比较好.(即下面的代码全部作废)</p><pre><code>(require &#39;tabbar)  (tabbar-mode)  (global-set-key (kbd &quot;&lt;M-up&gt;&quot;)    &#39;tabbar-backward-group)  (global-set-key (kbd &quot;&lt;M-down&gt;&quot;)  &#39;tabbar-forward-group)  (global-set-key (kbd &quot;&lt;M-left&gt;&quot;)  &#39;tabbar-backward-tab)  (global-set-key (kbd &quot;&lt;M-right&gt;&quot;) &#39;tabbar-forward-tab)  (setq   tabbar-scroll-left-help-function nil   ;don&#39;t show help information   tabbar-scroll-right-help-function nil   tabbar-help-on-tab-function nil   tabbar-home-help-function nil   tabbar-buffer-home-button (quote ((&quot;&quot;) &quot;&quot;)) ;don&#39;t show tabbar button   tabbar-scroll-left-button (quote ((&quot;&quot;) &quot;&quot;))   tabbar-scroll-right-button (quote ((&quot;&quot;) &quot;&quot;)))  (defun my-tabbar-buffer-groups ()    &quot;Return the list of group names the current buffer belongs to.  Return a list of one element based on major mode.&quot;    (list     (cond      ((or (get-buffer-process (current-buffer))           ;; Check if the major mode derives from `comint-mode&#39; or           ;; `compilation-mode&#39;.           (tabbar-buffer-mode-derived-p            major-mode &#39;(comint-mode compilation-mode)))       &quot;Process&quot;       )      ((string-equal &quot;*&quot; (substring (buffer-name) 0 1))       &quot;Emacs Buffer&quot;       )      ((eq major-mode &#39;dired-mode)       &quot;Dired&quot;       )      (t       &quot;User Buffer&quot;       ))))  (setq tabbar-buffer-groups-function &#39;my-tabbar-buffer-groups)</code></pre><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>一般都是激活多窗口调试模式:</p><pre><code>+----------------------------------------------------------------------+|                               GDB Toolbar                            |+-----------------------------------+----------------------------------+| GUD buffer (I/O of GDB)           | Locals buffer                    ||                                   |                                  ||                                   |                                  ||                                   |                                  |+-----------------------------------+----------------------------------+| Source buffer                     | I/O buffer (of debugged program) ||                                   | (comint-mode)                    ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  |+-----------------------------------+----------------------------------+| Stack buffer                      | Breakpoints buffer               || RET      gdb-frames-select        | SPC    gdb-toggle-breakpoint     ||                                   | RET    gdb-goto-breakpoint       ||                                   | D      gdb-delete-breakpoint     |+-----------------------------------+----------------------------------+</code></pre><p>窗口说明:</p><ul><li>GDB Toolbar        - GDB 操作Toolbar</li><li>GUD buffer         - 执行操作的buffer</li><li>Locals buffer      - 本地变量名和值的表示buffer</li><li>Source buffer      - 表示sourcecode的buffer</li><li>IO/ buffer         - 表示程序的输入输出的buffer</li><li>Stack buffer       - 运行停止的时候，调用关系的表示buffer</li><li>Breakpoints buffer - breakpoints断点的表示buffer</li><li>buffer崩溃的时候、通过’M-x gdb-restore-windows’返回原状态</li></ul><p>当然你可以尝试关闭某些窗口.</p><pre><code>(setq gdb-use-separate-io-buffer t) ; 不需要&quot;IO buffer&quot;时，则设为nil</code></pre><p>一般会把 <code>gdb-many-windows</code> 设置为激活状态, 实际上也可以用 <code>gdb-restore-windows</code> 恢复单个布局.</p><p>我个人的习惯是, 把所有的其他窗口只是作为观察窗口, 其实还是依赖主窗口, 设置相关命令, 一方面, 这个可以减少快捷键的记忆; 另外一方面, 不和单独在terminal中使用产生冲突, 其实也不错. (gud是主窗口)</p><p>快捷键命令</p><ul><li>添加断点    gud-break    C-x C-a C-b 或 C-x <spc></spc></li><li>删除断点    gud-remove    C-x C-a C-d</li><li>运行/继续程序    gud-go        无</li><li>单步执行，无视函数        gud-next    C-x C-a C-n</li><li>单步执行，进入函数        gud-step    C-x C-a C-s</li><li>跳出当前函数            gud-finish    C-x C-a C-f</li><li>运行到光标所在语句        gud-until    C-x C-a C-u</li><li>继续运行程序            gud-cont    C-x C-a C-r</li></ul><h3 id="Autocomplete"><a href="#Autocomplete" class="headerlink" title="Autocomplete"></a>Autocomplete</h3><p>自动补全的拆建有很多, 但是真正能够TAB键玩的溜的只有 Auotocomplete .</p><p>autocomplete在使用上, 不用刻意去按键M-/, 而是在你写代码的时候, 就可以完成提示, 并且选择的话, 一直TAB就行, 之后就可以直接在后面接着写其他的代码. (按回车可以选中所选的)</p><p>具体的快捷键:</p><ul><li>TAB, C-i    ac-expand    Completion by TAB</li><li>RET, C-m    ac-complete    Completion by RET</li><li>down, M-n    ac-next        Select next candidate</li><li>up, M-p       ac-previous    Select previous candidate</li><li>C-?, f1    ac-help            Show buffer help</li></ul><p>To stop completion, simply use C-g.</p><h3 id="magit"><a href="#magit" class="headerlink" title="magit"></a>magit</h3><p>emacs中使用git虽然很好, 但是, 无疑来说, 又会增加许多负担, 当前还是使用terminal或者gitk吧. 具体可以考虑使用 magit 插件.</p><h3 id="speedbar"><a href="#speedbar" class="headerlink" title="speedbar"></a>speedbar</h3><p>就是一个文件列表， 一般再ecb中有集成.</p><p>M-x speedbar 就可以启动它(相关于一个文件目录, 可以在多个文件中切换), 我个人设置的快捷键是 f4 .</p><h3 id="ediff"><a href="#ediff" class="headerlink" title="ediff"></a>ediff</h3><p>一个相当于beyond compare的组件: <code>M-x ediff</code>. </p><h3 id="dired"><a href="#dired" class="headerlink" title="dired"></a>dired</h3><p>emacs下一个强大的文件管理器, 大多数切换到 shell 的场景被它取代: <code>M-x dired</code>.</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p><code>M-x tetris</code>, 俄罗斯方块.</p><h3 id="hideshow"><a href="#hideshow" class="headerlink" title="hideshow"></a>hideshow</h3><p>代码折叠与展开, 这个插件有用, 不过要进行一定的调整.</p><pre><code>;;配置代码折叠;(load-library &quot;hideshow&quot;)  ;(add-hook &#39;java-mode-hook &#39;hs-minor-mode)  ;(add-hook &#39;perl-mode-hook &#39;hs-minor-mode)  ;;(add-hook &#39;php-mode-hook &#39;hs-minor-mode)  ;(add-hook &#39;emacs-lisp-mode-hook &#39;hs-minor-mode)  (add-to-list &#39;hs-special-modes-alist             &#39;(c-mode &quot;[\n\t ]*{&quot; &quot;}&quot; &quot;/[*/]&quot; nil hs-c-like-adjust-block-beginning))(add-to-list &#39;hs-special-modes-alist             &#39;(c++-mode &quot;[\n\t ]*{&quot; &quot;}&quot; &quot;/[*/]&quot; nil hs-c-like-adjust-block-beginning))(define-key global-map (kbd &quot;M-,&quot;) &#39;hs-toggle-hiding)</code></pre><p>我一般设置的是 <code>M-,</code> 用于折叠和展开.</p><h3 id="窗口恢复"><a href="#窗口恢复" class="headerlink" title="窗口恢复"></a>窗口恢复</h3><p>原生没有设置案件对窗口误操作的undo, 所以我设置了一下按键:</p><pre><code>C-x 4 u 窗口undoC-x 4 r 窗口redo</code></pre><h3 id="doxygen"><a href="#doxygen" class="headerlink" title="doxygen"></a>doxygen</h3><p>这个设置起来不太麻烦, 但是我还是喜欢在shell中使用, 毕竟它可以生产图, shell操作更加方便.</p><h3 id="cedet"><a href="#cedet" class="headerlink" title="cedet"></a>cedet</h3><p>给Emacs安装CEDET是最烦恼的过程之一, 由于这个插件太大了, 所以出错的几率也比较打.</p><p>CEDET包含以下几个部分: </p><ul><li>Semantic - Parser Infrastructure for Emacs</li><li>EDE -      File manager/ Makefile generator</li><li>SRecode -  Template manager/ code generator</li><li>COGRE -    Connected Graph Editor</li></ul><p>emacs自带的cedet为1.0版本, 不能与ecb配合使用, 所以要下载并安装它的最新版本(LAST) <code>cedet1.1</code> . 安装的时候, 请仔细阅读源码目录的 <code>INSTALL</code> 文件, 我直接下载的解压缩后的文件.</p><pre><code>$ git clone https://github.com/emacs-pkg-mirrors/cedet.git</code></pre><p>根据它<a href="http://cedet.sourceforge.net/setup.shtml" target="_blank" rel="external">官网</a>的步骤, 一点儿不靠谱. 请仔细阅读源码目录的 <code>INSTALL</code> 文件!!!</p><ul><li>Step 1 : Download CEDET from the Sourceforge downloads page. </li><li>Step 2 : unpack CEDET</li><li>Step 3 : make EMACS=emacs</li><li>Step 4 : Configure CEDET in your .emacs file by adding code like this.</li></ul><p>主要代码</p><pre><code>-----------;; Load CEDET.;; See cedet/common/cedet.info for configuration details.;; IMPORTANT: For Emacs &gt;= 23.2, you must place this *before* any;; CEDET component (including EIEIO) gets activated by another ;; package (Gnus, auth-source, ...).(load-file &quot;~/cedet-VERSION/common/cedet.el&quot;);; Enable EDE (Project Management) features(global-ede-mode 1);; Enable EDE for a pre-existing C++ project;; (ede-cpp-root-project &quot;NAME&quot; :file &quot;~/myproject/Makefile&quot;);; Enabling Semantic (code-parsing, smart completion) features;; Select one of the following:;; * This enables the database and idle reparse engines(semantic-load-enable-minimum-features);; * This enables some tools useful for coding, such as summary mode,;;   imenu support, and the semantic navigator(semantic-load-enable-code-helpers);; * This enables even more coding tools such as intellisense mode,;;   decoration mode, and stickyfunc mode (plus regular code helpers);; (semantic-load-enable-gaudy-code-helpers);; * This enables the use of Exuberant ctags if you have it installed.;;   If you use C++ templates or boost, you should NOT enable it.;; (semantic-load-enable-all-exuberent-ctags-support);;   Or, use one of these two types of support.;;   Add support for new languages only via ctags.;; (semantic-load-enable-primary-exuberent-ctags-support);;   Add support for using ctags as a backup parser.;; (semantic-load-enable-secondary-exuberent-ctags-support);; Enable SRecode (Template management) minor-mode.;; (global-srecode-minor-mode 1)</code></pre><p>编译时遇到的问题:</p><p>`makeinfo is missing on your systeme, 即makeinfo未找到命令, 此时有两种方案:</p><ul><li>make EMACS=emacs MAKEINFO=echo  即不编译doc</li><li>make MAKEINFO=/usr/bin/makeinfo</li></ul><p>安装 <code>makeinfo</code>, 它包含再<code>texinfo</code>包中</p><pre><code>$ search apt-fileapt-file - search for files within Debian packages (command-line interface)cabal-debian - Create a debianization for a cabal package#利用apt-file查看某个文件属于哪个包, 再安装包$ add apt-file$ sudo apt-updateapt$ apt-file search bin/makeinfotexinfo: /usr/bin/makeinfo$ search exinfotexinfo - Documentation system for on-line information and printed output$ add texinfo$ add install-info</code></pre><p>在 <a href="http://sourceforge.net/projects/cedet/" target="_blank" rel="external">http://sourceforge.net/projects/cedet/</a>  下载 cedet1.1 .</p><pre><code>In end of data:semantic-tag-file.el:207:1:Warning: the function ‘ede-toplevel’ is not known    to be defined.Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)In toplevel form:semantic-idle.el:42:1:Error: Invalid function: class-pIn semantic-tag-customize:semantic-custom.el:210:22:Warning: ‘toggle-read-only’ is an obsolete    function (as of 24.3); use ‘read-only-mode’ instead.Makefile:61: recipe for target &#39;semantic&#39; failed</code></pre><p>总之编译的时候, 就是会遇到各种各样的问题. 一定要简单安装cedet, 它真的太复杂了(我安装它也只是为了安装ecb).</p><h3 id="ecb"><a href="#ecb" class="headerlink" title="ecb"></a>ecb</h3><p>这个代码浏览器, 比较实用. 配置好了普通编写代码, 跑测试用例的界面大概是这样的:</p><pre><code>   ------------------------------------------------------------------   |              |                                                 |   |  Directories |                                                 |   |              |                                                 |   |--------------|                                                 |   |              |                                                 |   |  Sources     |                                                 |   |              |                                                 |   |--------------|                   Edit-area                     |   |              |   (can be splitted in several edit-windows)     |   |  Methods     |                                                 |   |              |                                                 |   |--------------|                                                 |   |              |                                                 |   |  History     |                                                 |   |              |                                                 |   ------------------------------------------------------------------   |                                                                |   |            Persistent Compilation-window (optional)            |   |                                                                |   ------------------------------------------------------------------</code></pre><p>我一般设置如下快捷键：</p><ul><li>f5 启用ecb</li><li>f6 禁用ecb</li><li>control + f5 显示ecb窗口</li><li>control + f6 隐藏ecb窗口</li><li>C-c 0-4 分别是还原，以及最大化某个窗口</li><li>M-方向键, 切换到某个窗口</li><li>选定某个窗口的某个展开标记(即加号减号) 方向键左代表折叠, 方向键右代表展开.</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学些emacs, 手册中遇到的(可能)生词:</p><ul><li>overlap 交叠 </li><li>likewise 相似的</li><li>opposite 相反的 </li><li>interspersed 穿插 </li><li>parallel 并行 </li><li>repeated 重复</li><li>paraphrase 释义 </li><li>terminal终端 </li><li>get rid of 摆脱</li><li>contiguous 邻近的 </li><li>incremental 增量  </li><li>for reference 仅供参考 </li><li>sufficient 足够</li><li>command               命令</li><li>scrolling             滚动</li><li>numeric argument      数字参数</li><li>yank                  召回,剪切</li><li>echo area             回显区</li><li>mode line             状态栏</li><li>incremental search    渐进式搜索</li></ul><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>有些插件真坑爹…编译安装都烦, 莫名其妙的问题, 浪费了好长时间.</p><p>首先 emacs 还是很强大的, 然而不得不说, 由于平台的严谨, 以及开后和后续支持的缺乏, 对于emacs的兼容性造成了很大的调整. 如果和visual studio code相比, 其兼容性明显不好. 而且这种情况如果没有更多的人参与和带动, 不说emacs会死, 至少可以说, 能玩的起来的都是神了.</p><p>唯一的希望是, emacs的兼容性可以好起来(各种插件的稳定性慢慢变好一些).</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org" target="_blank" rel="external">一年成为 Emacs 高手</a></li><li><a href="http://www.gnu.org/software/emacs/tour/" target="_blank" rel="external">A Guided Tour of Emacs</a></li><li><a href="https://zhuanlan.zhihu.com/p/26068894" target="_blank" rel="external">emacs按键绑定方式介绍</a></li><li><a href="https://github.com/wolray/symbol-overlay" target="_blank" rel="external">emacs高亮插件推荐</a></li><li><a href="http://www.cnblogs.com/logicbaby/archive/2011/10/19/2217253.html" target="_blank" rel="external">emacs项目路径设置</a></li><li><a href="http://blog.csdn.net/lujun9972/article/details/46002881" target="_blank" rel="external">woman参考</a></li><li><a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html" target="_blank" rel="external">查找替换参考</a></li><li><a href="http://emacser.com/ann77/Emacs/EmacsSearch.html" target="_blank" rel="external">查找汇总</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html" target="_blank" rel="external">书签和寄存器</a><br>(文中有一处错误:删除书签的命令是 M-x bookmark-delete而不是C-x bookmark delete)</li><li><a href="http://emacser.com/emacs-gdb.htm" target="_blank" rel="external">gdb参考</a></li><li><a href="https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md" target="_blank" rel="external">autocomplete参考</a></li><li><a href="https://magit.vc/" target="_blank" rel="external">magit参考</a></li><li><a href="http://www.emacswiki.org/cgi-bin/wiki/HideShow" target="_blank" rel="external">hideshow</a></li></ol><p>这一些列文档差不多一共有7篇, 讲的比较啰嗦, 可以自行参考一下:</p><ul><li><a href="https://www.ibm.com/developerworks/cn/education/aix/emacs1/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/emacs1/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/emacs2/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/emacs2/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs3/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs3/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs5/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs5/index.html</a></li></ul><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      刚好换新的环境,顺便把emacs环境重新修正一下
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Deepin Linux</title>
    <link href="www.merlinblog.site/2017/08/31/deepin.html"/>
    <id>www.merlinblog.site/2017/08/31/deepin.html</id>
    <published>2017-08-31T05:45:39.000Z</published>
    <updated>2017-09-24T07:30:13.895Z</updated>
    
    <content type="html"><![CDATA[<p>以前的老系统, 由于系统太老, 有时候安装软件真的非常不适合. 我个人开发一直使用linux(Ubuntu64), 主要用terminal(emacs -nw). 所以要换一个稳定, 新一点儿的系统; 考虑了ubuntu麒麟, 16, 17, 不得不说, 一点儿也不好用, 支持的非常差. 原版的ubuntu也是, 系统有时动不动就内部错误(Ubuntu可能会突然告诉你已经不提供软件更新了, 请升级到17.04; 然后你升级的时候又引来内部错误).<br>正好 <code>武汉深之度</code> 开发的 <code>deepin</code> 近来大家伙好评不断, 所以, 我就来试试. </p><blockquote><p>趁此机会, 把原来的所有 <code>开发环境</code> 切换到 deepin (旧 ubuntu 仅用于发布博客).<br>(如果有机会, 以后也想为它贡献代码)</p></blockquote><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>为什么换deepin? 原系统 和 deepin对比如下, 不多解释了.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/deepin1.jpg" alt=""></p><p>(好吧还是说一下,它的这个<code>terminal</code>太棒了;后期发现和emacs有些键可能冲突, 改以下就好了)</p><p>真正一个好的环境, 仅仅从一个技术人员触发, 至少具备3点:</p><ul><li>开发舒服(效率高和个人水平有关)</li><li>看源码舒服(特别是源码庞大, 调用复杂时)</li><li>debug舒服</li></ul><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="安装deepin"><a href="#安装deepin" class="headerlink" title="安装deepin"></a>安装deepin</h2><p>这里我装的是虚拟机.</p><p>电脑的原配操作系统win10专业版, 所以一般不改变, 主要工作环境全部放在虚拟机里面, 一来编程对机器要求不是太高, 而来虚拟机文件也方便在电脑间移植.</p><p>虚拟机里安装deepin很简单: 原来怎么安装ubuntu_amd64, 这里就怎么装deepin, 并且操作习惯也不用改, 和debain系列一致.</p><p>安装完, 先升级一下系统 <code>sudo apt-get dist-upgrade</code> 或者可能也需要 <code>sudo apt-get update</code> 和 <code>sudo apt-get upgrade</code>.</p><p>下面开始安装主要工作软件以及环境配置.</p><hr><h2 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h2><p>最先安装的就是emacs, 不然后面很捉急.</p><pre><code class="bash">$ sudo apt-get install emacs25#安装完毕之后$ emacs --versionGNU Emacs 25.1.1Copyright (C) 2016 Free Software Foundation, Inc.GNU Emacs comes with ABSOLUTELY NO WARRANTY.You may redistribute copies of GNU Emacsunder the terms of the GNU General Public License.For more information about these matters, see the file named COPYING.</code></pre><p>不过我使用的时候, 一般都是不带界面的emacs, 习惯了; 所以去加一个alias.</p><p>现在<code>.bashrc</code>结尾面添加一个语句(<code>$ nano .bashrc</code>)</p><pre><code class="shell">if [ -f ~/.merlin_bash ]; then    . ~/.merlin_bashfi</code></pre><p>保存之后建立一个<code>.merlin_bash</code>文件:</p><pre><code class="bash"># here we confiure some alias and environment info # 1. alias# 2. environmen path# my aliasalias ll=&#39;ls -l&#39;alias la=&#39;ls -A&#39;alias l=&#39;ls -CF&#39;alias em=&#39;emacs -nw&#39;</code></pre><p>(重新打开以下终端或者source .bashrc)<br>现在可以使用emacs了, 还不错哦.</p><p>关于emacs的配置, 请看我的另外一篇 <a href="http://www.merlinblog.site/2017/08/31/my-emacs.html">文章</a>.</p><p>如果你不配置<code>emacs</code>, 基本呵呵, 不配置除非你是神(要求你水平非常高), 不然很难用的顺手.</p><blockquote><p>以后的所有配置,都在.merlin_bash文件中.</p></blockquote><h2 id="rm绑定"><a href="#rm绑定" class="headerlink" title="rm绑定"></a>rm绑定</h2><p>rm命令已经引起无数次灾害了(深受其害!!), 这东西不处理不行. 如果在UI界面放入Trash, 那么会在<code>~/.local/share/Trash/</code>的两个子目录进行如下操作:</p><ul><li>把具体的文件放入files目录</li><li><p>info目录里以文件相同的filename保存删除的信息</p><pre><code>[Trash Info]Path=/home/merlin/Desktop/test/ideaIC-2017.2.3.tar.gzDeletionDate=2017-08-31T17:15:09</code></pre><p>所以我们的rm命令可以简单的用来把东西移动到Trash目录, 但不写入Info信息(而是添加尾缀时间戳), 以此区分是用rm命令删除的, 代码很简单(要考虑一下连续重复删除同一个文件, 删除的目录和文件同名等情况):<br>```</p><h2 id="rm-related"><a href="#rm-related" class="headerlink" title="rm related"></a>rm related</h2><p>trash()<br>{<br>TRASH_DIR=”/home/merlin/.local/share/Trash/files”<br>RF=”-rf”<br>R=”-r”<br>F=”-f”</p><p>if [ “$1” == ${RF} -o  “$1” == ${R} -o “$1” == ${F} ] ; then<br>   shift<br>fi</p><p>for i in $*; do<br>   FILENAME=<code>basename $i</code><br>   STAMP=<code>date +%s</code><br>   mv -f “$i” ${TRASH_DIR}/${FILENAME}.${STAMP}<br>done<br>}</p></li></ul><p>alias rm=trash</p><pre><code>## bashrc文件德国人有一个造车时, 有一个思想, 这个思想用中国谚语说就是 `工欲善其事必先利其器` .有一些常用命令, 来弄个别名吧, 编辑`.merlin_bash`:```shell# here we confiure some alias and environment info# 1. alias# 2. environmen path# my alias## ls relatedalias ll=&#39;ls -al&#39;alias la=&#39;ls -A&#39;alias l=&#39;ls -CF&#39;## emacs relatedalias em=&#39;emacs -nw&#39;## move relatedalias mv=&#39;mv -i&#39;## cp relatedalias cp=&#39;cp -i&#39;## apt relatedalias add=&#39;sudo apt-get install&#39;alias delete=&#39;sudo apt-get --purge remove&#39;alias autoremove=&#39;sudo apt-get autoremove&#39;alias search=&#39;sudo apt-cache search&#39;alias policy=&#39;sudo apt-cache policy&#39;alias update=&#39;sudo apt-get update&#39;alias upgrade=&#39;sudo apt-get upgrade&#39;alias sysupgrade=&#39;sudo apt-get dist-upgrade&#39;## git related# path## java relatedJAVA_OPT=${_JAVA_OPTIONS}unset _JAVA_OPTIONSalias java=&quot;java ${JAVA_OPT}&quot;## node npm relatedexport NODE_HOME=/home/merlin/Software/node-v6.11.2-linux-x64export NODE_PATH=$NODE_HOME/lib/node_modulesexport PATH=$PATH:$NODE_HOME/bin## go relatedexport GOROOT=/usr/lib/go-1.7export GOBIN=$GOROOT/binexport PATH=$GOBIN:$PATHexport GOPATH=/home/merlin/Desktop/GOPATH###for cross-compling go-codeexport GOOS=linuxexport GOARCH=amd64## ld and static pathexport LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATHexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</code></pre><p>差不多就这样了.</p><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>想下载东西, wget和curl必不可少(wget常用于下载, curl常用于调试RESTful)</p><pre><code>$ add wget$ add curl</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>没有git几乎无法生存, 想要去拉个库, 晕,没有安装git.</p><pre><code class="bash">$ add git正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  git-man liberror-perl建议安装：  git-daemon-run | git-daemon-sysvinit git-doc git-el git-email git-gui gitk gitweb git-arch git-cvs git-mediawiki git-svn下列【新】软件包将被安装：  git git-man liberror-perl升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 5,614 kB 的归档。解压缩后会消耗 31.0 MB 的额外空间。您希望继续执行吗？ [Y/n] Y获取:1 http://packages.deepin.com/deepin panda/main amd64 liberror-perl all 0.17024-1 [26.9 kB]获取:2 http://packages.deepin.com/deepin panda/main amd64 git-man all 1:2.11.0-4 [1,432 kB]获取:3 http://packages.deepin.com/deepin panda/main amd64 git amd64 1:2.11.0-4 [4,156 kB]                                       已下载 5,614 kB，耗时 15秒 (359 kB/s)                                                                                           正在选中未选择的软件包 liberror-perl。(正在读取数据库 ... 系统当前共安装有 152772 个文件和目录。)正准备解包 .../liberror-perl_0.17024-1_all.deb  ...正在解包 liberror-perl (0.17024-1) ...正在选中未选择的软件包 git-man。正准备解包 .../git-man_1%3a2.11.0-4_all.deb  ...正在解包 git-man (1:2.11.0-4) ...正在选中未选择的软件包 git。正准备解包 .../git_1%3a2.11.0-4_amd64.deb  ...正在解包 git (1:2.11.0-4) ...正在设置 git-man (1:2.11.0-4) ...正在设置 liberror-perl (0.17024-1) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...正在设置 git (1:2.11.0-4) ...</code></pre><p>看一下版本, 还挺新的.</p><pre><code>$ git --versiongit version 2.11.0</code></pre><p>配置一下自己的信息:</p><pre><code>$ git config --global user.name &quot;xxx&quot;$ git config --global user.email &quot;yyy&quot;</code></pre><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>本机其实已经安装了ssh工具, 并且我也可以远程到我的remote服务器:</p><pre><code># 一般默认22端口$ ssh username@address</code></pre><p>但是本机是否允许别的机器远程呢? 还是配置一下, 允许远程登录</p><pre><code>$ ls /etc/sshmoduli    ssh_config</code></pre><p>自己建议一个文件<code>sshd_config</code>, 配置ssh-server，配置文件位于/etc/ssh/sshd_config, 默认端口为22, 为了安全, 一般自定义为其他端口.</p><p>修改配置文件sshd_config, 一般修改远程登录过来的端口, 允许的账户, 超时是否断开.</p><pre><code>1. 配置端口：　   Port 22 配置端口时你可以修改称自己想要的比方说23333,防止被端口扫描.2. 配置是否允许远程root账户登录   (但是你登录后可以su到root账户)   # Authentication:   LoginGraceTime 120   PermitRootLogin yes   StrictModes yes   一般可以禁止远程root账户登录.3. 避免超时自动断开   # keep alive within an hour if no operation happened of client   ClientAliveInterval 60   ClientAliveCountMax 60注意:每次一次配置都要重启sshd守护进程: service ssh restart(我这边儿重启sshd，提示unrecognized service)</code></pre><p>关于sshd的启动:</p><p>首先确保ssh服务已经安装, 检查服务是否已经启动 </p><pre><code>ps -e | grep sshd</code></pre><p>启动、停止、重启服务 </p><pre><code>$ service sshd start     #开启ssh服务 $ service sshd stop      #停止ssh服务 $ service sshd restart   #重启ssh服务</code></pre><p>或者使用带有路径的脚本： </p><pre><code>/etc/init.d/sshd start /etc/init.d/sshd stop /etc/init.d/restart</code></pre><h2 id="产生ssh-key"><a href="#产生ssh-key" class="headerlink" title="产生ssh_key"></a>产生ssh_key</h2><p>步骤很简单, 但是我劝你还是采用HTTPS实时的输入账号密码验证上传和下载; 不要使用ssh key(任何一个登录到你电脑的人可以随便弄你的库, 多可怕).</p><pre><code># 如果~/.ssh下已经有了秘钥文件则不必生成$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;(直接回车什么都不做)</code></pre><p>在~/.ssh/得到了两个文件：id_rsa和id_rsa.pub, 打开id_rsa.pub文件，里面的信息即为SSH key; 在github上把公钥贴到SSH Key认证的位置, 那么凡是走ssh协议的传入, 你都可以不用密码了.</p><p>当然如果你把自己的公钥<code>id_rsa.pub</code>拷贝到别人的<code>authorized_keys</code>文件内, 然后你ssh登录别人的电脑就不用认证密码了(但是你scp拷贝的这一回, 还是要输入登录到别人电脑的密码). 例如把我的公钥拷贝到xxx_ip地址的主机上, 登录那台电脑的用户名是yyy.</p><pre><code>scp -r ~/.ssh/id_rsa.pub xxx_ip:/home/yyy/.ssh/authorized_keys# 然后输入用户yyy的密码, 拷贝成功的话, 下次你登录xxx_ip这台电脑, 就不要密码了, 直接即可$ ssh xxx_ip</code></pre><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>真的要是要什么没有什么.</p><pre><code>$ add locate正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。下列【新】软件包将被安装：  locate升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 212 kB 的归档。解压缩后会消耗 322 kB 的额外空间。获取:1 http://packages.deepin.com/deepin panda/main amd64 locate amd64 4.6.0+git+20161106-2 [212 kB]已下载 212 kB，耗时 0秒 (278 kB/s)正在选中未选择的软件包 locate。(正在读取数据库 ... 系统当前共安装有 153643 个文件和目录。)正准备解包 .../locate_4.6.0+git+20161106-2_amd64.deb  ...正在解包 locate (4.6.0+git+20161106-2) ...正在设置 locate (4.6.0+git+20161106-2) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...$ sudo updatedb</code></pre><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><pre><code>$ add tree正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。下列【新】软件包将被安装：  tree升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 46.1 kB 的归档。解压缩后会消耗 106 kB 的额外空间。获取:1 http://packages.deepin.com/deepin panda/main amd64 tree amd64 1.7.0-5 [46.1 kB]已下载 46.1 kB，耗时 0秒 (150 kB/s)正在选中未选择的软件包 tree。(正在读取数据库 ... 系统当前共安装有 153657 个文件和目录。)正准备解包 .../tree_1.7.0-5_amd64.deb  ...正在解包 tree (1.7.0-5) ...正在设置 tree (1.7.0-5) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...</code></pre><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>gcc的版本很给力, 但是有时候为了某些方便, 我还需要装一个低版本的.</p><pre><code class="bash">$ gcc --versiongcc (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$ locate gcc | grep -E &quot;/usr/bin/gcc-[0-9]&quot;/usr/bin/gcc-6</code></pre><p>安装4.8, 4.9, 5.0版本的gcc</p><pre><code>$ add gcc-4.8 gcc-4.9 gcc-5正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  cpp-4.8 cpp-4.9 cpp-5 libasan0 libasan1 libasan2 libcloog-isl4 libgcc-4.8-dev libgcc-4.9-dev libgcc-5-dev libmpx0建议安装：  gcc-4.8-locales gcc-4.9-locales gcc-5-locales gcc-4.8-multilib gcc-4.8-doc libgcc1-dbg libgomp1-dbg libitm1-dbg  libatomic1-dbg libasan0-dbg libtsan0-dbg libquadmath0-dbg gcc-4.9-multilib gcc-4.9-doc libasan1-dbg liblsan0-dbg  libubsan0-dbg libcilkrts5-dbg gcc-5-multilib gcc-5-doc libasan2-dbg libmpx0-dbg下列【新】软件包将被安装：  cpp-4.8 cpp-4.9 cpp-5 gcc-4.8 gcc-4.9 gcc-5 libasan0 libasan1 libasan2 libcloog-isl4 libgcc-4.8-dev libgcc-4.9-dev  libgcc-5-dev libmpx0升级了 0 个软件包，新安装了 14 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 42.6 MB 的归档。解压缩后会消耗 141 MB 的额外空间。您希望继续执行吗？ [Y/n] Y</code></pre><p>安装完成之后, <code>sudo updatedb</code>, 然后查看一下相应的版本</p><pre><code>$ locate gcc | grep -E &quot;/usr/bin/gcc-[0-9]&quot;/usr/bin/gcc-4.8/usr/bin/gcc-4.9/usr/bin/gcc-5/usr/bin/gcc-6$ gcc --versiongcc (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><p>然后利用 <code>update-alternatives</code> 建立文件关联(当然你也可以自己建立软链接):</p><pre><code># 首先要让系统知道我们安装了多个版本的gcc# 命令最后的 20和50是优先级，如果使用auto选择模式，系统将默认使用优先级高的$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20update-alternatives: 使用 /usr/bin/gcc-4.8 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 30update-alternatives: 使用 /usr/bin/gcc-4.9 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 40update-alternatives: 使用 /usr/bin/gcc-5 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 50update-alternatives: 使用 /usr/bin/gcc-6 来在自动模式中提供 /usr/bin/gcc (gcc)</code></pre><p>再查看一下当前系统中安装的gcc有哪些:</p><pre><code>$ sudo update-alternatives --query gccName: gccLink: /usr/bin/gccStatus: autoBest: /usr/bin/gcc-6Value: /usr/bin/gcc-6Alternative: /usr/bin/gcc-4.8Priority: 20Alternative: /usr/bin/gcc-4.9Priority: 30Alternative: /usr/bin/gcc-5Priority: 40Alternative: /usr/bin/gcc-6Priority: 50</code></pre><p>想切换默认的gcc可以使用修改优先值的方式:</p><pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 60</code></pre><p>或者交互的方式:<br><img src="http://omotkhw3y.bkt.clouddn.com/update-alternatives.jpg" alt="交互方式"></p><blockquote><p>update-alternatives 还可以用于配置多版本的Java或者Python等.</p></blockquote><p>当然你配置gcc的时候, 也可以顺带配置一下, gcc需要调用的binuitls, 比如 ar, nm, ranlib等(当然也可以配置对应版本的g++), 使用<code>--slave</code>选项.</p><pre><code>$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50 \--slave /usr/bin/g++ g++ /usr/bin/g++-5 \--slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-5 \--slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-5 \--slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-5</code></pre><h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p>有些软件的安装, 需要其他的软件或者库; 如果那个工具&amp;库你经常用, 最好不要让它顺便给你装, 比如:</p><pre><code>$ add build-essential正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  g++ g++-6建议安装：  g++-multilib g++-6-multilib gcc-6-doc libstdc++6-6-dbg下列【新】软件包将被安装：  build-essential g++ g++-6升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 7,096 kB 的归档。解压缩后会消耗 24.5 MB 的额外空间。您希望继续执行吗？ [Y/n] n中止。</code></pre><p>我自己装<code>g++</code>, 因为我可能要在多个版本的c++编译器间切换.</p><pre><code class="bash">$ search &quot;g\+\+-[0-9]&quot; | less$ add g++-4.9 g++-5 g++-6正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  libstdc++-4.9-dev libstdc++-5-dev建议安装：  g++-4.9-multilib gcc-4.9-doc libstdc++6-4.9-dbg g++-5-multilib gcc-5-doc libstdc++6-5-dbg g++-6-multilib gcc-6-doc  libstdc++6-6-dbg libstdc++-4.9-doc libstdc++-5-doc下列【新】软件包将被安装：  g++-4.9 g++-5 g++-6 libstdc++-4.9-dev libstdc++-5-dev升级了 0 个软件包，新安装了 5 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 35.8 MB 的归档。解压缩后会消耗 106 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb</code></pre><p>然后用<code>update-alternatives</code>来配置一下:</p><pre><code>$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 30$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 50</code></pre><p>然后query检查一下:</p><pre><code class="bash">$ sudo update-alternatives --query g++Name: g++Link: /usr/bin/g++Status: autoBest: /usr/bin/g++-6Value: /usr/bin/g++-6Alternative: /usr/bin/g++-4.9Priority: 30Alternative: /usr/bin/g++-5Priority: 40Alternative: /usr/bin/g++-6Priority: 50$ g++ --versiong++ (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h2 id="build-essential"><a href="#build-essential" class="headerlink" title="build-essential"></a>build-essential</h2><p>先查看一下依赖:</p><pre><code class="bash">$ depends build-essentialbuild-essential |依赖: libc6-dev  依赖: &lt;libc-dev&gt;    libc6-dev  依赖: gcc  依赖: g++  依赖: make    make-guile  依赖: dpkg-dev</code></pre><p>先看一下哪些没有</p><pre><code class="bash"># 先更新一下本机数据$ update$ upgrade$ policy libc6-devlibc6-dev:  已安装：2.24-9  候选： 2.24-9  版本列表： *** 2.24-9 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status$ policy makemake:  已安装：4.1-9.1  候选： 4.1-9.1  版本列表： *** 4.1-9.1 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status$ policy make-guilemake-guile:  已安装：(无)  候选： 4.1-9.1  版本列表：     4.1-9.1 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages$ policy dpkg-devdpkg-dev:  已安装：1.18.23  候选： 1.18.23  版本列表： *** 1.18.23 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        500 http://packages.deepin.com/deepin panda/main i386 Packages        100 /var/lib/dpkg/status</code></pre><p>那就安装一下<code>make-guile</code>:</p><pre><code>$ search &quot;make-guile*&quot;make-guile - utility for directing compilation with guile support$ add &quot;make-guile&quot;正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  guile-2.0-libs建议安装：  make-doc下列软件包将被【卸载】：  make下列【新】软件包将被安装：  guile-2.0-libs make-guile升级了 0 个软件包，新安装了 2 个软件包，要卸载 1 个软件包，有 0 个软件包未被升级。需要下载 2,536 kB 的归档。解压缩后会消耗 11.8 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb$ make-guile --versionbash: make-guile: 未找到命令$ locate make-guile/usr/share/doc/make-guile/usr/share/doc/make-guile/ABOUT-NLS.gz/usr/share/doc/make-guile/AUTHORS/usr/share/doc/make-guile/Explanations.gz/usr/share/doc/make-guile/NEWS.Debian.gz/usr/share/doc/make-guile/NEWS.gz/usr/share/doc/make-guile/README.Debian-Source/usr/share/doc/make-guile/README.customs.gz/usr/share/doc/make-guile/README.gz/usr/share/doc/make-guile/changelog.Debian.gz/usr/share/doc/make-guile/copyright/var/cache/apt/archives/make-guile_4.1-9.1_amd64.deb/var/lib/dpkg/info/make-guile.list/var/lib/dpkg/info/make-guile.md5sums</code></pre><p>再装<code>build-essential</code>:</p><pre><code>$ add build-essential正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  g++建议安装：  g++-multilib下列【新】软件包将被安装：  build-essential g++升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 8,890 B 的归档。解压缩后会消耗 35.8 kB 的额外空间。您希望继续执行吗？ [Y/n] Y获取:1 http://packages.deepin.com/deepin panda/main amd64 g++ amd64 4:6.3.0-2 [1,544 B]获取:2 http://packages.deepin.com/deepin panda/main amd64 build-essential amd64 12.3 [7,346 B]已下载 8,890 B，耗时 6秒 (1,466 B/s)                                                                                            正在选中未选择的软件包 g++。(正在读取数据库 ... 系统当前共安装有 156361 个文件和目录。)正准备解包 .../g++_4%3a6.3.0-2_amd64.deb  ...正在解包 g++ (4:6.3.0-2) ...正在选中未选择的软件包 build-essential。正准备解包 .../build-essential_12.3_amd64.deb  ...正在解包 build-essential (12.3) ...正在设置 g++ (4:6.3.0-2) ...update-alternatives: 使用 /usr/bin/g++ 来在自动模式中提供 /usr/bin/c++ (c++)正在设置 build-essential (12.3) ...</code></pre><p>这么看来<code>policy</code>可能后面的<code>dpkg</code>工具可能和<code>update-alternatives</code>有点儿误会, 手动调整一下:</p><pre><code>$ sudo update-alternatives --config g++有 3 个候选项可用于替换 g++ (提供 /usr/bin/g++)。  选择       路径            优先级  状态------------------------------------------------------------* 0            /usr/bin/g++-6     50        自动模式  1            /usr/bin/g++-4.9   30        手动模式  2            /usr/bin/g++-5     40        手动模式  3            /usr/bin/g++-6     50        手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：update-alternatives: 警告: 链接组 g++ 已损坏，故强制重新安装候选项 /usr/bin/g++-6$ ls /usr/bin/g++*/usr/bin/g++  /usr/bin/g++-4.9  /usr/bin/g++-5  /usr/bin/g++-6merlin@merlin-deepin:~$ ll /usr/bin/g++$ sudo update-alternatives --config g++有 3 个候选项可用于替换 g++ (提供 /usr/bin/g++)。  选择       路径            优先级  状态------------------------------------------------------------* 0            /usr/bin/g++-6     50        自动模式  1            /usr/bin/g++-4.9   30        手动模式  2            /usr/bin/g++-5     40        手动模式  3            /usr/bin/g++-6     50        手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：$ policy g++g++:  已安装：4:6.3.0-2  候选： 4:6.3.0-2  版本列表： *** 4:6.3.0-2 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status</code></pre><p>好了.</p><h2 id="binutils"><a href="#binutils" class="headerlink" title="binutils"></a>binutils</h2><p>这里, 可能会装一些, 不太常用的工具,(常用的可能都已经装了) 为下面可能装的库打基础(下面会详细说明, 哪些库要用到这些工具).</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>老实说, java, groovy, scala这类jvm语言已经写的很少了.(现在多用shell, python和c++).</p><p>但是有些工具比如thrif还是需要这货的, 为java语言做支持.</p><p>还是装两个版本, jdk7和jdk8, 然后用update-alternatives进行调整.</p><pre><code>$ wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz -P ~/Desktop/apps--2017-08-31 17:58:54--  http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz正在解析主机 download.oracle.com (download.oracle.com)... 184.28.218.123, 184.28.218.122正在连接 download.oracle.com (download.oracle.com)|184.28.218.123|:80... 已连接。已发出 HTTP 请求，正在等待回应... 302 Found位置：http://101.44.1.8/files/2130000006C99F22/download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz [跟随至新的 URL]--2017-08-31 17:58:54--  http://101.44.1.8/files/2130000006C99F22/download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz正在连接 101.44.1.8:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：185515842 (177M) [application/octet-stream]正在保存至: “/home/merlin/Desktop/apps/jdk-8u144-linux-x64.tar.gz”jdk-8u144-linux-x64.tar.gz       100%[=======================================================&gt;] 176.92M  3.60MB/s  用时 44s     2017-08-31 17:59:44 (3.98 MB/s) - 已保存 “/home/merlin/Desktop/apps/jdk-8u144-linux-x64.tar.gz” [185515842/185515842])$ sudo mkdir /usr/local/lib/jvm$ sudo tar -xzvf ~/Desktop/apps/jdk-8u144-linux-x64.tar.gz -C /usr/local/lib/jvm$ $ ls /usr/local/lib/jvmjdk1.8.0_144# 设置环境变量, 在.merlin_bash结尾加上</code></pre><h2 id="jdk-path"><a href="#jdk-path" class="headerlink" title="jdk path"></a>jdk path</h2><p>export JAVA_HOME=/usr/local/lib/jvm/jdk1.8.0_144<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p><pre><code>然后看一下是否安装成功:</code></pre><p>$ source .bashrc<br>$ which java<br>/usr/local/lib/jvm/jdk1.8.0_144/bin/java</p><p>$ java -version<br>Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp<br>java version “1.8.0_144”<br>Java(TM) SE Runtime Environment (build 1.8.0_144-b01)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</p><pre><code>上面的`Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp`好奇怪, 检查一下`_JAVA_OPTIONS`这个环境变量:</code></pre><p>$ sudo grep -nr “JAVA_OPTIONS” /etc<br>/etc/profile.d/java-awt-font-gasp.sh:2:if ! echo ${_JAVA_OPTIONS} |grep -q – ${opt}  ;then<br>/etc/profile.d/java-awt-font-gasp.sh:3:    export _JAVA_OPTIONS=”${_JAVA_OPTIONS}  ${opt}”</p><pre><code>查看了一下:</code></pre><p>$ cat /etc/profile.d/java-awt-font-gasp.sh</p><pre><code>opt=&quot;-Dawt.useSystemAAFontSettings=gasp&quot;if ! echo ${_JAVA_OPTIONS} |grep -q -- ${opt}  ;then     export _JAVA_OPTIONS=&quot;${_JAVA_OPTIONS}  ${opt}&quot;fi</code></pre><p>这个宏本来是指定运行参数(<code>java %JAVA_OPTIONS% -Xmx1024m -XX:MaxPermSize=128m</code>), 这里检查到”JAVA_OPTIONS”里没有设置<code>awt</code>界面组建的宏, 所以在这里指定了运行系统的字体和图形库. 但是一旦这里export, 后面运行<code>java</code>命令就会打印那条语句, 没办法, 在我的配置文件里面做一下处理吧.(JAVA_OPTIONS是运行时会自动指定的), 这里的文件就不要动了.<br>(意思是, 你的运行参数不要export了, 我运行的时候自己手动加载好了)</p><pre><code>## java related (关于是否配置环境变量, 看下面说明)JAVA_OPT=${_JAVA_OPTIONS}unset _JAVA_OPTIONSalias java=&quot;java ${JAVA_OPT}&quot;</code></pre><p>然后注销重新登录, 运行<code>java -version</code> :</p><pre><code>$ alias javaalias java=&#39;java   -Dawt.useSystemAAFontSettings=gasp&#39;$ java -versionjava version &quot;1.8.0_144&quot;Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</code></pre><blockquote><p>这里注意了,如果后面你要用update-alternatives管理javac,java等工具, 就不要配置环境变量!</p></blockquote><p>装完oralble的jdk, 还要装一个open jdk, 以免有时候编译需要(可能是某些版本的android框架或者应用需要).</p><pre><code>$ search openjdk-8-jdkdefault-jdk - Standard Java or Java compatible Development Kitdefault-jdk-headless - Standard Java or Java compatible Development Kit (headless)openjdk-8-jdk - OpenJDK Development Kit (JDK)openjdk-8-jdk-headless - OpenJDK Development Kit (JDK) (headless)$ add openjdk-8-jdk正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  ca-certificates-java fonts-dejavu-extra java-common libatk-wrapper-java libatk-wrapper-java-jni libice-dev  libpthread-stubs0-dev libsm-dev libx11-dev libx11-doc libxau-dev libxcb1-dev libxdmcp-dev libxt-dev  openjdk-8-jdk-headless openjdk-8-jre openjdk-8-jre-headless x11proto-core-dev x11proto-input-dev x11proto-kb-dev  xorg-sgml-doctools xtrans-dev建议安装：  default-jre libice-doc libsm-doc libxcb-doc libxt-doc openjdk-8-demo openjdk-8-source visualvm icedtea-8-plugin  libnss-mdns fonts-ipafont-gothic fonts-ipafont-mincho fonts-wqy-zenhei fonts-indic下列【新】软件包将被安装：  ca-certificates-java fonts-dejavu-extra java-common libatk-wrapper-java libatk-wrapper-java-jni libice-dev  libpthread-stubs0-dev libsm-dev libx11-dev libx11-doc libxau-dev libxcb1-dev libxdmcp-dev libxt-dev openjdk-8-jdk  openjdk-8-jdk-headless openjdk-8-jre openjdk-8-jre-headless x11proto-core-dev x11proto-input-dev x11proto-kb-dev  xorg-sgml-doctools xtrans-dev升级了 0 个软件包，新安装了 23 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 43.5 MB 的归档。解压缩后会消耗 170 MB 的额外空间。您希望继续执行吗？ [Y/n] Y...update-alternatives: 使用 /usr/lib/jvm/java-8-openjdk-amd64/bin/jconsole 来在自动模式中提供 /usr/bin/jconsole (jconsole)正在处理用于 libc-bin (2.24-9) 的触发器 ...正在处理用于 ca-certificates (20161130) 的触发器 ...Updating certificates in /etc/ssl/certs...0 added, 0 removed; done.Running hooks in /etc/ca-certificates/update.d...done.done.</code></pre><p>查看一下是不是update-alternatives已经托管:</p><pre><code>sudo update-alternatives --config java链接组 java (提供 /usr/bin/java)中只有一个候选项：/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java无需配置。</code></pre><p>看来还是要手动配置一下, 我自己安装的/usr/local/lib/jvm下的那个, 以及这一个(因为他的路径不对, 主要到是jre)</p><pre><code>$ sudo update-alternatives --remove java /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java$ sudo update-alternatives --install /usr/bin/java java /usr/local/lib/jvm/jdk1.8.0_144/bin/java 300$ sudo update-alternatives --install /usr/bin/javac javac /usr/local/lib/jvm/jdk1.8.0_144/bin/javac 300$ sudo update-alternatives --install /usr/bin/jar jar /usr/local/lib/jvm/jdk1.8.0_144/bin/jar 300$ sudo update-alternatives --install /usr/bin/javah javah /usr/local/lib/jvm/jdk1.8.0_144/bin/javah 300$ sudo update-alternatives --install /usr/bin/javap javap /usr/local/lib/jvm/jdk1.8.0_144/bin/javap 300$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-openjdk-amd64/bin/java 200$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8-openjdk-amd64/bin/javac 200$ sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/java-8-openjdk-amd64/bin/jar 200$ sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/java-8-openjdk-amd64/bin/javah 200$ sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/java-8-openjdk-amd64/bin/javap 200$ sudo update-alternatives --display javajava - 手动模式  最佳链接版本为 /usr/local/lib/jvm/jdk1.8.0_144/bin/java 链接目前指向 /usr/local/lib/jvm/jdk1.8.0_144/bin/java  链接 java 指向 /usr/bin/java/usr/lib/jvm/java-8-openjdk-amd64/bin/java - 优先级 200/usr/local/lib/jvm/jdk1.8.0_144/bin/java - 优先级 300</code></pre><p>(这里如果你配置了JAVA_HOME等环境变量, 那么<code>upate-alternatives</code>就失效了, 不能起到切换的作用)</p><p>破Java环境, 终于闹腾好了.</p><h2 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h2><p>ant: Java based build tool like make; 可能大家现在用maven啊, gradle啊比较多. 但是这个软件可能用于编译某些工具的库或者包, 所以还是要装一个.</p><pre><code>$ add ant正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  ant-optional建议安装：  ant-doc ant-gcj ant-optional-gcj antlr javacc junit junit4 jython libbcel-java libbsf-java libcommons-logging-java libcommons-net-java libmail-java libjaxp1.3-java  libjdepend-java libjsch-java liblog4j1.2-java liboro-java libregexp-java libxalan2-java libxml-commons-resolver1.1-java下列【新】软件包将被安装：  ant ant-optional升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 2,270 kB 的归档。解压缩后会消耗 3,170 kB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which ant/usr/bin/ant</code></pre><p>安装完毕.</p><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>有些库编译需要, 没有什么好说的.</p><pre><code>$ add maven正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  junit junit4 libaopalliance-java libapache-pom-java libasm-java libatinject-jsr330-api-java libbsh-java libcdi-api-java  libcglib-java libclassworlds-java libcommons-cli-java libcommons-codec-java libcommons-httpclient-java libcommons-io-java  libcommons-lang-java libcommons-lang3-java libcommons-logging-java libcommons-net-java libcommons-parent-java libdom4j-java  libdoxia-core-java libeasymock-java libeclipse-aether-java libgeronimo-interceptor-3.0-spec-java libguava-java libguice-java  libhamcrest-java libhttpclient-java libhttpcore-java libisorelax-java libjaxen-java libjaxp1.3-java libjdom1-java libjetty9-java  libjsch-java libjsoup-java libjsr305-java libjzlib-java liblog4j1.2-java libmaven-parent-java libmaven2-core-java  libmaven3-core-java libmsv-java libobjenesis-java libplexus-ant-factory-java libplexus-archiver-java libplexus-bsh-factory-java  libplexus-cipher-java libplexus-classworlds-java libplexus-classworlds2-java libplexus-cli-java  libplexus-component-annotations-java libplexus-component-metadata-java libplexus-container-default-java  libplexus-container-default1.5-java libplexus-containers-java libplexus-containers1.5-java libplexus-interactivity-api-java  libplexus-interpolation-java libplexus-io-java libplexus-sec-dispatcher-java libplexus-utils-java libplexus-utils2-java  libqdox2-java librelaxng-datatype-java libservlet3.1-java libsisu-inject-java libsisu-plexus-java libslf4j-java libwagon-java  libwagon2-java libxalan2-java libxbean-java libxerces2-java libxml-commons-external-java libxml-commons-resolver1.1-java  libxom-java libxpp2-java libxpp3-java建议安装：  junit-doc libaopalliance-java-doc libatinject-jsr330-api-java-doc libclassworlds-java-doc libcommons-httpclient-java-doc  libcommons-io-java-doc libcommons-lang-java-doc libcommons-lang3-java-doc libavalon-framework-java libcommons-logging-java-doc  libexcalibur-logkit-java libcommons-net-java-doc libdom4j-java-doc libeasymock-java-doc libjaxp1.3-java-gcj libjdom1-java-doc  jetty9 libjsoup-java-doc libjsr305-java-doc libmail-java liblog4j1.2-java-doc libobjenesis-java-doc libplexus-cipher-java-doc  libplexus-classworlds-java-doc libplexus-classworlds2-java-doc libplexus-cli-java-doc libplexus-container-default-java-doc  libplexus-interactivity-api-java-doc libplexus-interpolation-java-doc libplexus-sec-dispatcher-java-doc libplexus-utils-java-doc  libplexus-utils2-java-doc libqdox2-java-doc testng libwagon-java-doc libxalan2-java-doc libbsf-java libxsltc-java groovy  libequinox-osgi-java libosgi-compendium-java libosgi-core-java libqdox-java libspring-beans-java libspring-context-java  libspring-core-java libspring-web-java libxerces2-java-doc libxerces2-java-gcj libxml-commons-resolver1.1-java-doc  libxom-java-doc下列【新】软件包将被安装：  junit junit4 libaopalliance-java libapache-pom-java libasm-java libatinject-jsr330-api-java libbsh-java libcdi-api-java  libcglib-java libclassworlds-java libcommons-cli-java libcommons-codec-java libcommons-httpclient-java libcommons-io-java  libcommons-lang-java libcommons-lang3-java libcommons-logging-java libcommons-net-java libcommons-parent-java libdom4j-java  libdoxia-core-java libeasymock-java libeclipse-aether-java libgeronimo-interceptor-3.0-spec-java libguava-java libguice-java  libhamcrest-java libhttpclient-java libhttpcore-java libisorelax-java libjaxen-java libjaxp1.3-java libjdom1-java libjetty9-java  libjsch-java libjsoup-java libjsr305-java libjzlib-java liblog4j1.2-java libmaven-parent-java libmaven2-core-java  libmaven3-core-java libmsv-java libobjenesis-java libplexus-ant-factory-java libplexus-archiver-java libplexus-bsh-factory-java  libplexus-cipher-java libplexus-classworlds-java libplexus-classworlds2-java libplexus-cli-java  libplexus-component-annotations-java libplexus-component-metadata-java libplexus-container-default-java  libplexus-container-default1.5-java libplexus-containers-java libplexus-containers1.5-java libplexus-interactivity-api-java  libplexus-interpolation-java libplexus-io-java libplexus-sec-dispatcher-java libplexus-utils-java libplexus-utils2-java  libqdox2-java librelaxng-datatype-java libservlet3.1-java libsisu-inject-java libsisu-plexus-java libslf4j-java libwagon-java  libwagon2-java libxalan2-java libxbean-java libxerces2-java libxml-commons-external-java libxml-commons-resolver1.1-java  libxom-java libxpp2-java libxpp3-java maven升级了 0 个软件包，新安装了 80 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 27.6 MB 的归档。解压缩后会消耗 38.0 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which maven</code></pre><h2 id="IntelliJ"><a href="#IntelliJ" class="headerlink" title="IntelliJ"></a>IntelliJ</h2><p>直接去 <a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="external">页面</a> 下载安装包.</p><pre><code>$ wget https://download.jetbrains.8686c.com/idea/ideaIC-2017.2.3.tar.gz -P Desktop/apps$ mkdir Software$ tar -xzvf ~/Desktop/apps/ideaIC-2017.2.3.tar.gz -C Software/$ cd Software/idea-IC-172.3968.16/bin$ ./idea.sh</code></pre><p>之后安装时, 它会有一个步骤, 问你是否建立执行脚本, 点击确定即可, 然后可以看到:</p><pre><code>$ which idea/usr/local/bin/idea$ whereis ideaidea: /usr/local/bin/idea$ ll /usr/local/bin/idea-rwxr-xr-x 1 root root 3111 8月  31 21:58 /usr/local/bin/idea$ file /usr/local/bin/idea/usr/local/bin/idea: Python script, ASCII text executable``这样就算安装完毕了.## python一般linux是自带2.7版本的python的, 出于某些目的有时候也要安装python3(比如cppman就是需要python3安装), 幸好deepin也自带了.</code></pre><p>$ which python<br>/usr/bin/python</p><p>$ whereis python<br>python: /usr/bin/python /usr/bin/python2.7 /usr/bin/python3.5 /usr/bin/python3.5m /usr/lib/python2.7 /usr/lib/python3.5 /etc/python /etc/python2.7 /etc/python3.5 /usr/local/lib/python2.7 /usr/local/lib/python3.5 /usr/include/python2.7 /usr/include/python3.5m /usr/share/python /usr/share/man/man1/python.1.gz</p><p>$ python –version<br>Python 2.7.13</p><pre><code>那么先把python2.7交给update-altertives管理再说.</code></pre><p>$ sudo update-alternatives –list python<br>update-alternatives: 错误: 无 python 的候选项</p><p>##我个人更喜欢python3<br>$ sudo update-alternatives –install /usr/bin/python python /usr/bin/python3.5 200<br>$ sudo update-alternatives –install /usr/bin/python python /usr/bin/python2.7 100  </p><p>$ sudo update-alternatives –list python<br>/usr/bin/python2.7<br>/usr/bin/python3.5</p><p>$ sudo update-alternatives –display python<br>python - 自动模式<br>  最佳链接版本为 /usr/bin/python3.5<br> 链接目前指向 /usr/bin/python3.5<br>  链接 python 指向 /usr/bin/python<br>/usr/bin/python2.7 - 优先级 100<br>/usr/bin/python3.5 - 优先级 200</p><p>$ python –version<br>Python 3.5.3</p><pre><code>还没有完, 你会发现/usr/include/python2.7下面没有多少头文件! 所以还要安装相关的, 必要的库.</code></pre><p>$ sudo updatedb<br>$ locate Python.h   #没有结果</p><p>#下面也没有结果<br>$ dpkg –get-selections |grep python-dev</p><p>$ ldconfig -p | grep python-dev<br>  libpython3.5m.so.1.0 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython3.5m.so.1.0<br>  libpython3.5m.so (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython3.5m.so<br>  libpython2.7.so.1.0 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython2.7.so.1.0<br>  libpyglib-2.0-python2.7.so.0 (libc6,x86-64) =&gt; /usr/lib/libpyglib-2.0-python2.7.so.0<br>  libboost_python3.so.1.63.0 (libc6,x86-64) =&gt; /usr/local/lib/libboost_python3.so.1.63.0<br>  libboost_python3.so (libc6,x86-64) =&gt; /usr/local/lib/libboost_python3.so<br>  libboost_python.so.1.63.0 (libc6,x86-64) =&gt; /usr/local/lib/libboost_python.so.1.63.0<br>  libboost_python.so (libc6,x86-64) =&gt; /usr/local/lib/libboost_python.so<br>(可以查看库文件, 但不见得有头文件)</p><pre><code>所以下面安装一下(Python.h is provided by -dev)</code></pre><p>$ add python-dev libboost-python-dev libboost-mpi-python-dev<br>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>将会同时安装下列软件：<br>  libboost-mpi-python1.62-dev libboost-mpi-python1.62.0 libboost-mpi1.62-dev libboost-mpi1.62.0 libboost-python1.62-dev<br>  libboost-python1.62.0 libboost-serialization1.62-dev libboost-serialization1.62.0 libboost1.62-dev libfabric1 libhwloc-dev<br>  libhwloc-plugins libhwloc5 libibverbs-dev libnuma-dev libopenmpi-dev libopenmpi2 libpsm-infinipath1 libpython-dev<br>  libpython2.7-dev mpi-default-bin mpi-default-dev ocl-icd-libopencl1 openmpi-bin openmpi-common python2.7-dev<br>建议安装：<br>  libboost-graph1.62-dev libboost1.62-doc gccxml libboost-atomic1.62-dev libboost-chrono1.62-dev libboost-context1.62-dev<br>  libboost-coroutine1.62-dev libboost-date-time1.62-dev libboost-exception1.62-dev libboost-fiber1.62-dev<br>  libboost-filesystem1.62-dev libboost-graph-parallel1.62-dev libboost-iostreams1.62-dev libboost-locale1.62-dev<br>  libboost-log1.62-dev libboost-math1.62-dev libboost-program-options1.62-dev libboost-random1.62-dev libboost-regex1.62-dev<br>  libboost-signals1.62-dev libboost-system1.62-dev libboost-test1.62-dev libboost-thread1.62-dev libboost-timer1.62-dev<br>  libboost-type-erasure1.62-dev libboost-wave1.62-dev libboost1.62-tools-dev libmpfrc++-dev libntl-dev libhwloc-contrib-plugins<br>  openmpi-doc opencl-icd gfortran<br>下列【新】软件包将被安装：<br>  libboost-mpi-python-dev libboost-mpi-python1.62-dev libboost-mpi-python1.62.0 libboost-mpi1.62-dev libboost-mpi1.62.0<br>  libboost-python-dev libboost-python1.62-dev libboost-python1.62.0 libboost-serialization1.62-dev libboost-serialization1.62.0<br>  libboost1.62-dev libfabric1 libhwloc-dev libhwloc-plugins libhwloc5 libibverbs-dev libnuma-dev libopenmpi-dev libopenmpi2<br>  libpsm-infinipath1 libpython-dev libpython2.7-dev mpi-default-bin mpi-default-dev ocl-icd-libopencl1 openmpi-bin openmpi-common<br>  python-dev python2.7-dev<br>升级了 0 个软件包，新安装了 29 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。<br>需要下载 40.9 MB 的归档。<br>解压缩后会消耗 185 MB 的额外空间。<br>您希望继续执行吗？ [Y/n] Y</p><p>$ sudo updatedb<br>$ locate Python.h<br>/usr/include/python2.7/Python.h<br>/usr/include/python3.5m/Python.h</p><pre><code>差不多了.安装pip3工具:</code></pre><p>$ add python3-pip<br>[sudo] merlin 的密码：<br>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>将会同时安装下列软件：<br>  libexpat1-dev libpython3-dev libpython3.5-dev python-pip-whl python3-cffi-backend python3-crypto<br>  python3-cryptography python3-dev python3-idna python3-keyring python3-keyrings.alt python3-pyasn1<br>  python3-secretstorage python3-setuptools python3-wheel python3.5-dev<br>建议安装：<br>  python3-crypto-dbg python-crypto-doc python-cryptography-doc python3-cryptography-vectors libkf5wallet-bin<br>  gir1.2-gnomekeyring-1.0 python3-pykde4 doc-base python-secretstorage-doc python-setuptools-doc<br>下列【新】软件包将被安装：<br>  libexpat1-dev libpython3-dev libpython3.5-dev python-pip-whl python3-cffi-backend python3-crypto<br>  python3-cryptography python3-dev python3-idna python3-keyring python3-keyrings.alt python3-pip python3-pyasn1<br>  python3-secretstorage python3-setuptools python3-wheel python3.5-dev<br>升级了 0 个软件包，新安装了 17 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。<br>需要下载 40.8 MB 的归档。<br>解压缩后会消耗 63.2 MB 的额外空间。<br>您希望继续执行吗？ [Y/n] Y</p><p>$ $ which pip3<br>/usr/bin/pip3</p><pre><code>这样就算差不多了, 以后根据自己的需求, 选择安装相应的库即可.## 安装pycharm下载 pycharm</code></pre><p>$ wget <a href="https://download.jetbrains.8686c.com/python/pycharm-community-2017.2.2.tar.gz" target="_blank" rel="external">https://download.jetbrains.8686c.com/python/pycharm-community-2017.2.2.tar.gz</a> -P Desktop/apps</p><pre><code>安装</code></pre><p>$ tar -xzvf Desktop/apps/pycharm-community-2017.2.2.tar.gz -C Software/<br>$ cd Software/pycharm-community-2017.2.2/bin<br>$ ./pycharm.sh</p><pre><code>安装时, 请勾选建立`/usr/local/bin/pycharm`脚本这一项, 然后可以看到</code></pre><p>$ which pycharm<br>/usr/local/bin/pycharm</p><p>$ file /usr/local/bin/pycharm<br>/usr/local/bin/pycharm: Python script, ASCII text executable</p><pre><code>## golang一般而言, 选择apt工具就够了 `sudo apt-get install golang`, 但是为了能够实时更新一下, 可以采用源:</code></pre><p>sudo add-apt-repository ppa:gophers/go<br>sudo apt-get update<br>sudo apt-get install golang-stable </p><h1 id="go通过-mercurial-版本控制工具管理"><a href="#go通过-mercurial-版本控制工具管理" class="headerlink" title="go通过 mercurial 版本控制工具管理"></a>go通过 mercurial 版本控制工具管理</h1><pre><code>我直接安装的:</code></pre><p>$ add golang<br>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>将会同时安装下列软件：<br>  golang-1.7 golang-1.7-doc golang-1.7-go golang-1.7-src golang-doc golang-go golang-src<br>建议安装：<br>  bzr mercurial subversion<br>下列【新】软件包将被安装：<br>  golang golang-1.7 golang-1.7-doc golang-1.7-go golang-1.7-src golang-doc golang-go golang-src<br>升级了 0 个软件包，新安装了 8 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。<br>需要下载 29.5 MB 的归档。<br>解压缩后会消耗 147 MB 的额外空间。<br>您希望继续执行吗？ [Y/n] Y</p><pre><code>之后需要配置一下环境变量:(网上很多配的是错的)</code></pre><h2 id="go-related"><a href="#go-related" class="headerlink" title="go related"></a>go related</h2><p>export GOROOT=/usr/lib/go-1.7<br>export GOBIN=$GOROOT/bin<br>export PATH=$GOBIN:$PATH</p><p>export GOPATH=/home/merlin/Desktop/GOPATH</p><p>###for cross-compling: window or linux;  386 or amd64<br>export GOOS=linux<br>export GOARCH=amd64</p><pre><code>查看一下配置:</code></pre><p>$ go version<br>go version go1.7.4 linux/amd64</p><p>$ source ~/.bashrc</p><p>$ echo $GOPATH<br>/home/merlin/Desktop/GOPATH</p><pre><code>在GOPATH下新建3个目录:(为你的项目)* src 存放源码* pkg 存放编译生成的文件* bin 存放生成的可执行文件## cppman我主业C++, 所以马上来配置一下c++的开发环境.`cppman` 可以实时从cplusplus.com以及cppreference.com上面下载文档的一个小工具. repo的地址是: https://github.com/aitjcize/cppman 可以直接用apt工具安装```shell$ search &quot;cppman&quot;cppman - C++ 98/11 manual pages for Linux, with source from cplusplus.com$ add cppman正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  python3-bs4 python3-html5lib python3-webencodings建议安装：  python3-genshi下列【新】软件包将被安装：  cppman python3-bs4 python3-html5lib python3-webencodings升级了 0 个软件包，新安装了 4 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 321 kB 的归档。解压缩后会消耗 1,861 kB 的额外空间。您希望继续执行吗？ [Y/n] Y# 安装完成之后, 要先从网站上缓存页面才可以.## 切换源$ cppman -s cppreference.comSource set to `cppreference.com&#39;.## 缓存$ cppman -cBy default, cppman fetches pages on-the-fly if corresponding page is not found in the cache. The &quot;cache-all&quot; option is only useful if you want to view man pages offline. Caching all contents will take several minutes, do you want to continue [y/N]?y</code></pre><p>注意它需要装python3, 才行; 但是python是常用的, 所以版本管理还是交给update-alternatives吧.<br>(安装完python3之后再来安装cppman)</p><p>(再缓存<code>cppman -c</code>的时候, 你最好使用一下代理, 否则很容易缓存失败)</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>像boost, thrift虽然都不适用cmake编译, 但是现在很多流行的库, 比如gtest等, 都是用cmake, 而且相对于make的好, 不需要我多说.</p><p>下面就安装一下cmake.</p><p><code>sudo apt-get install</code> 安装的版本往往比较老, 所以一般需要自己去下载, 然后编译安装.</p><p>下载:  <a href="https://cmake.org/download/" target="_blank" rel="external">https://cmake.org/download/</a><br>或者(<a href="https://github.com/Kitware/CMake" target="_blank" rel="external">https://github.com/Kitware/CMake</a>)</p><pre><code># 直接去官网拿压缩包源码$ wget https://cmake.org/files/v3.9/cmake-3.9.1.tar.gz -P Desktop/apps/$ cd Desktop/apps$ tar -xzvf cmake-3.9.1.tar.gz</code></pre><p>编译安装</p><pre><code>$ ./configureCMake has bootstrapped.  Now run make.</code></pre><h1 id="开始编译"><a href="#开始编译" class="headerlink" title="开始编译"></a>开始编译</h1><p>$ make -j4</p><h1 id="开始安装"><a href="#开始安装" class="headerlink" title="开始安装"></a>开始安装</h1><p>$ sudo make install</p><pre><code>可以从安装日志中看到, 主要是这三个工具</code></pre><p>– Installing: /usr/local/bin/cmake<br>– Installing: /usr/local/bin/ctest<br>– Installing: /usr/local/bin/cpack</p><pre><code>最后删除, 安装包.(你不要去下载它的gui客户端呀, 好神经的说)## qt主要包括qtcreator和qt库, 这是它的[官网](https://www.qt.io/download-open-source/), 越来越恶心的官网, 我决定直接用apt工具下载qtcreator, 之后qt核心库再去官网下载.</code></pre><p>add qtcreator<br>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>将会同时安装下列软件：<br>  binfmt-support clang clang-3.8 gdb libbabeltrace-ctf1 libbabeltrace1 libbotan-1.10-1 libc6-dbg<br>  libclang-common-3.8-dev libclang1-3.8 libclang1-3.9 libdw1 libffi-dev libjsoncpp1 libllvm3.8 libobjc-6-dev<br>  libqbscore1.8 libqbsqtprofilesetup1.8 libqt5designercomponents5 libqt5quicktest5 libqt5script5 libtinfo-dev llvm-3.8<br>  llvm-3.8-dev llvm-3.8-runtime qml-module-qtqml-models2 qmlscene qt5-doc qt5-qmltooling-plugins qtbase5-dev-tools<br>  qtbase5-doc qtconnectivity5-doc qtcreator-data qtcreator-doc qtdeclarative5-dev-tools qtdeclarative5-doc<br>  qtgraphicaleffects5-doc qtlocation5-doc qtmultimedia5-doc qtquickcontrols5-doc qtscript5-doc qtsensors5-doc<br>  qtserialport5-doc qtsvg5-doc qttools5-dev-tools qttools5-doc qtwebkit5-doc qtwebkit5-examples-doc qtwebsockets5-doc<br>  qtx11extras5-doc qtxmlpatterns5-dev-tools qtxmlpatterns5-doc<br>建议安装：<br>  gnustep gnustep-devel clang-3.8-doc gdb-doc gdbserver llvm-3.8-doc qtbase5-dev cmake kdelibs5-data subversion<br>下列【新】软件包将被安装：<br>  binfmt-support clang clang-3.8 gdb libbabeltrace-ctf1 libbabeltrace1 libbotan-1.10-1 libc6-dbg<br>  libclang-common-3.8-dev libclang1-3.8 libclang1-3.9 libdw1 libffi-dev libjsoncpp1 libllvm3.8 libobjc-6-dev<br>  libqbscore1.8 libqbsqtprofilesetup1.8 libqt5designercomponents5 libqt5quicktest5 libqt5script5 libtinfo-dev llvm-3.8<br>  llvm-3.8-dev llvm-3.8-runtime qml-module-qtqml-models2 qmlscene qt5-doc qt5-qmltooling-plugins qtbase5-dev-tools<br>  qtbase5-doc qtconnectivity5-doc qtcreator qtcreator-data qtcreator-doc qtdeclarative5-dev-tools qtdeclarative5-doc<br>  qtgraphicaleffects5-doc qtlocation5-doc qtmultimedia5-doc qtquickcontrols5-doc qtscript5-doc qtsensors5-doc<br>  qtserialport5-doc qtsvg5-doc qttools5-dev-tools qttools5-doc qtwebkit5-doc qtwebkit5-examples-doc qtwebsockets5-doc<br>  qtx11extras5-doc qtxmlpatterns5-dev-tools qtxmlpatterns5-doc<br>升级了 0 个软件包，新安装了 53 个软件包，要卸载 0 个软件包，有 5 个软件包未被升级。<br>需要下载 204 MB 的归档。<br>解压缩后会消耗 601 MB 的额外空间。<br>您希望继续执行吗？ [Y/n] Y<br>$ which qtcreator<br>/usr/bin/qtcreator</p><pre><code>之后设置qt库的版本(环境变量), 比如`add libqt4-dev`, 可以在你的`.bashrc`里面, 或者使用`/usr/bin/qtchooser`来设置. 如要需要换最新版本的qt, 可以`sudo apt-get remove qtcreator`进行卸载, 或者purge.## boost玩cpp的, 不装boost?你可以用apt工具去装, 比如:</code></pre><h1 id="一般安装libboost-dev就行"><a href="#一般安装libboost-dev就行" class="headerlink" title="一般安装libboost-dev就行"></a>一般安装libboost-dev就行</h1><p>sudo apt-get install libboost-all-dev<br>sudo apt-get install libboost-dev</p><h1 id="或者sudo-apt-cache-search-boost搜自己想要的库"><a href="#或者sudo-apt-cache-search-boost搜自己想要的库" class="headerlink" title="或者sudo apt-cache search boost搜自己想要的库"></a>或者sudo apt-cache search boost搜自己想要的库</h1><p>sudo apt-get install mpi-default-dev　　#安装mpi库<br>sudo apt-get install libicu-dev　　　　　#支持正则表达式的UNICODE字符集<br>sudo apt-get install python-dev　　　　　#需要python的话<br>sudo apt-get install libbz2-dev     #失败的话 sudo apt-get update试试</p><pre><code>然后日常开发中, 常常用到这个库, 要确定的版本, 最好自己去官网下载安装(linux和vs版都要装).关于安装, 你可以参考一下, 我这篇文章[boost](http://www.merlinblog.site/2017/06/21/boost.html), 下面快速说:下载</code></pre><h2 id="我直接从我的远端服务器拷贝了-boost-1-63-0-7z"><a href="#我直接从我的远端服务器拷贝了-boost-1-63-0-7z" class="headerlink" title="我直接从我的远端服务器拷贝了 boost_1_63_0.7z"></a>我直接从我的远端服务器拷贝了 boost_1_63_0.7z</h2><p>$ scp -r merlin@xxxx:/home/merlin/packages/boost_1_63_0.7z ./apps/<br>$ 7z x boost_1_63_0.7z -o.</p><pre><code>编译安装:</code></pre><p>$ ./bootstrap.sh<br>$ ./b2 –show-libraries<br>The following libraries require building:</p><pre><code>- atomic- chrono- container- context- coroutine- coroutine2- date_time- exception- fiber- filesystem- graph- graph_parallel- iostreams- locale- log- math- metaparse- mpi- program_options- python- random- regex- serialization- signals- system- test- thread- timer- type_erasure- wave</code></pre><h1 id="也就是说-下面编译全是为了上面那些库-下面还是全编译吧"><a href="#也就是说-下面编译全是为了上面那些库-下面还是全编译吧" class="headerlink" title="也就是说, 下面编译全是为了上面那些库(下面还是全编译吧)"></a>也就是说, 下面编译全是为了上面那些库(下面还是全编译吧)</h1><h1 id="如果-b2-–with-atomic-–buildtype-complete-install表示只编译atomic库"><a href="#如果-b2-–with-atomic-–buildtype-complete-install表示只编译atomic库" class="headerlink" title="如果./b2 –with-atomic –buildtype=complete install表示只编译atomic库"></a>如果./b2 –with-atomic –buildtype=complete install表示只编译atomic库</h1><h1 id="注意一下拷贝权限问题"><a href="#注意一下拷贝权限问题" class="headerlink" title="注意一下拷贝权限问题"></a>注意一下拷贝权限问题</h1><p>$ sudo ./b2 –buildtype=complete install</p><pre><code>之后查看一下编译日志:</code></pre><p>Component configuration:</p><pre><code>- atomic                   : building- chrono                   : building- container                : building- context                  : building- coroutine                : building- coroutine2               : building- date_time                : building- exception                : building- fiber                    : building- filesystem               : building- graph                    : building- graph_parallel           : building- iostreams                : building- locale                   : building- log                      : building- math                     : building- metaparse                : building- mpi                      : building- program_options          : building- python                   : building- random                   : building- regex                    : building- serialization            : building- signals                  : building- system                   : building- test                     : building- thread                   : building- timer                    : building- type_erasure             : building- wave                     : building</code></pre><pre><code>之后跟着一大堆common.copy把lib和头文件分别拷贝到了, `/usr/local/include`和`/usr/local/lib`下面.只要不出现`failure`基本可以认定编译, 安装成功了.## log4cpp## rapidxml这个是常用的库, 不过有个坑需要你调整一下. 详细内容不再叙述, 请参考我的文章 [rapidxml](http://www.merlinblog.site/2017/08/22/rapid-xml.html)</code></pre><p>$ wget <a href="https://nchc.dl.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip" target="_blank" rel="external">https://nchc.dl.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip</a><br>$ unzip rapidxml-1.13.zip<br>Archive:  rapidxml-1.13.zip<br>   creating: rapidxml-1.13/<br>  inflating: rapidxml-1.13/license.txt<br>  inflating: rapidxml-1.13/manual.html<br>  inflating: rapidxml-1.13/rapidxml.hpp<br>  inflating: rapidxml-1.13/rapidxml_iterators.hpp<br>  inflating: rapidxml-1.13/rapidxml_print.hpp<br>  inflating: rapidxml-1.13/rapidxml_utils.hpp<br>$ sudo mv rapidxml-1.13 /usr/local/include/rapidxml</p><pre><code>## rapidjson全部是头文件的库, 安装起来也比较简单:</code></pre><p>$ git clone <a href="https://github.com/miloyip/rapidjson.git" target="_blank" rel="external">https://github.com/miloyip/rapidjson.git</a><br>$ cd rapidjson<br>$ cmake .<br>$ sudo make install</p><pre><code>## protobuffer下载</code></pre><p>$ git clone <a href="https://github.com/google/protobuf.git" target="_blank" rel="external">https://github.com/google/protobuf.git</a></p><pre><code>编译安装:</code></pre><p>$ ./autogen.sh<br>$ ./configure<br>$ make<br>$ make check<br>$ sudo make install<br>$ sudo ldconfig # refresh shared library cache.</p><pre><code>(整个过程还是比较顺利的)## thrift## npmnpm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer. 可能你不写JavaScript的东西, 不过这个npm被很多其他软件用到, 所以最好你还是装一下(三兄弟一起).</code></pre><p>checking for nodejs… no<br>checking for node… no<br>checking for npm… no</p><pre><code>下载并安装(不要使用apt工具, 因为版本都不新)</code></pre><p>$ wget <a href="https://nodejs.org/dist/v6.11.2/node-v6.11.2-linux-x64.tar.xz" target="_blank" rel="external">https://nodejs.org/dist/v6.11.2/node-v6.11.2-linux-x64.tar.xz</a> -P  ~/Desktop/apps<br>$ tar -xJvf Desktop/apps/node-v6.11.2-linux-x64.tar.xz -C Software/</p><pre><code>之后配置一下环境变量就可以了:</code></pre><h2 id="node-npm-related"><a href="#node-npm-related" class="headerlink" title="node     npm related"></a>node     npm related</h2><p>export NODE_HOME=/home/merlin/Software/node-v6.11.2-linux-x64<br>export NODE_PATH=$NODE_HOME/lib/node_modules<br>export PATH=$PATH:$NODE_HOME/bin</p><pre><code>测试一下安装工作:</code></pre><p>$ npm -v<br>3.10.10</p><p>$ node -v<br>v6.11.2</p><pre><code>## 开发文档一般使用的就是 glibc-doc 和 manpages-posix-dev.</code></pre><p>$ add glibc-doc<br>$ add glibc-doc-reference<br>$ add manpages-dev<br>$ add manpages-posix<br>$ add manpages-posix-dev</p><pre><code>## 其他软件### gitk一般我熟悉的项目, 我直接用[git-emacs](git clone https://github.com/tsgates/git-emacs.git ):提交等写入操作, 使用git-emacs.</code></pre><p>;;git-emacs<br>(add-to-list ‘load-path “/path/to/git-emacs/“)<br>(require ‘git-emacs)</p><pre><code>如果是别人的项目, 要我接手或者帮忙找错, 那么我直接使用gitk: `M-x gitk`(阅读建议使用 `gitk`)</code></pre><p>add gitk<br>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>将会同时安装下列软件：<br>  libtk8.6 tcl tcl8.6 tk tk8.6<br>建议安装：<br>  git-doc tcl-tclreadline<br>下列【新】软件包将被安装：<br>  gitk libtk8.6 tcl tcl8.6 tk tk8.6<br>升级了 0 个软件包，新安装了 6 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。<br>需要下载 1,757 kB 的归档。<br>解压缩后会消耗 4,101 kB 的额外空间。<br>您希望继续执行吗？ [Y/n] Y</p><p>$ which gitk<br>/usr/bin/gitk</p><pre><code>运行的时候, 切换到相应的库目录里面, 然后`gitk`, 例如我查看别人的库:![]()### htop资源监控器### understand[Scientific Toolworks Understand](http://blog.csdn.net/p942005405/article/details/53639970)源码查看器(和gtags, source in sight类似)## remarkable专门用于写markdown, 导出到pdf的编辑器.</code></pre><h1 id="安装的时候-先把python切换到2-7版本"><a href="#安装的时候-先把python切换到2-7版本" class="headerlink" title="安装的时候, 先把python切换到2.7版本"></a>安装的时候, 先把python切换到2.7版本</h1><p>$ add remarkable<br>正在读取软件包列表… 完成<br>正在分析软件包的依赖关系树<br>正在读取状态信息… 完成<br>将会同时安装下列软件：<br>  gir1.2-javascriptcoregtk-3.0 gir1.2-soup-2.4 gir1.2-webkit-3.0 libjavascriptcoregtk-3.0-0 libqt5xmlpatterns5<br>  libwebkitgtk-3.0-0 libyaml-0-2 python3-markdown python3-pygments python3-yaml wkhtmltopdf<br>下列【新】软件包将被安装：<br>  gir1.2-javascriptcoregtk-3.0 gir1.2-soup-2.4 gir1.2-webkit-3.0 libjavascriptcoregtk-3.0-0 libqt5xmlpatterns5<br>  libwebkitgtk-3.0-0 libyaml-0-2 python3-markdown python3-pygments python3-yaml remarkable wkhtmltopdf<br>升级了 0 个软件包，新安装了 12 个软件包，要卸载 0 个软件包，有 5 个软件包未被升级。<br>需要下载 12.3 MB 的归档。<br>解压缩后会消耗 53.3 MB 的额外空间。<br>您希望继续执行吗？ [Y/n] Y</p><h1 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h1><p>$ which remarkable<br>/usr/bin/remarkable</p><pre><code>配置一下</code></pre><h2 id="remarkable-u-could-add-amp-to-run"><a href="#remarkable-u-could-add-amp-to-run" class="headerlink" title="remarkable (u could add &amp; to run)"></a>remarkable (u could add &amp; to run)</h2><p>alias md=’nohup remarkable’</p><pre><code>然后运行一下, 功能正常</code></pre><p>$ md read.md &amp;</p><pre><code>### vistual studio code我原来是用remarkable打开markdown文件, 后来发现这个vistual studio code越来越强大, 就直接用它了.直接去[官网](https://code.visualstudio.com/)下载deb安装包, 安装即可.</code></pre><p>$ sudo dpkg -i code_1.15.1-1502903936_amd64.deb<br>$ which code<br>/usr/bin/code<br>``</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>当初把 Mac pro 15 卖掉的原因就是, 我已经非常熟悉Ubuntu了, 没必要在改变习惯, 使用homebrew等其他软件, 并且机器的配置文件位置我也习惯了. 所以即便是换系统, 也会和Ubuntu搭边儿, 正好deepin, 感觉不错哦.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      把自己的代码环境, 迁移新的 Deepin 发行版, 记录了一些常用库和工具的安装参考.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux后台开发经验分享(里程碑)</title>
    <link href="www.merlinblog.site/2017/08/30/milestone1.html"/>
    <id>www.merlinblog.site/2017/08/30/milestone1.html</id>
    <published>2017-08-30T08:07:59.000Z</published>
    <updated>2017-09-24T08:04:14.523Z</updated>
    
    <content type="html"><![CDATA[<p>本文总结了我的个人经验, 包括我自己亲身经历的, 后台同学一起讨论的, 网络曾经看到的等等. 写这一篇不同于以往的 <code>经验分享</code> (可能文中的内容不会太详细, 但尽量说清楚).</p><blockquote><p>身边人对于你的影响可能比你的努力更重要</p></blockquote><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>如果你把你学到的知识, 而不是思考问题的方式, 细心&amp;耐心的能力, 健康的身体, 银行的存款, 结交的人缘作为核心竞争力; 那么分享自己所学可能对你有点儿困难.(虽然最初的时候我写博客也只是完全为了记录我成长的过程, 不过渐渐目的已经转变了)</p><blockquote><p><code>谢谢过去那个努力的我</code>  – 大巨变100天(100 days from New Era)</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/new_era_1.png" alt="里程碑"></p><p>下文中的所有内容, 均已成为历史, 这一篇就做一个 <code>里程碑</code> 吧.</p><hr><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h2><p>下面是一些基于当前工作经验, 年限的认识:</p><ul><li>对于c++, go这类稍微偏底层, 并且常用的语言, 一定要了解细节, 深知见底.</li><li>对于python, shell这类脚本或者模型语言, 用好为主</li><li>对于数据结构和算法: 数据结构深入, 算法了解.</li><li>对于操作系统, 如果决心做高级工程师, 业内技术专家linux一定要深入到内核(具体的是内核哪个模块?所有.)</li><li>对于网络编程, 根据工作的不同, 有人工作在应用层,有人工作在传输层和网络层, 甚至是链路层(但是不管这么说, 应用层和网络层是要知道的)</li><li>对于项目管理和人员管理等管理问题, 请入行的第3年再去涉及.</li><li>对于金钱, 抱歉我看到的身边的人30W一大把, 50W是一个坎大多人突破不过去. (自己实力稍弱的时候, 不要 太看重钱)</li><li></li></ul><h2 id="RESTful相关"><a href="#RESTful相关" class="headerlink" title="RESTful相关"></a>RESTful相关</h2><p>本段属于上层协议内容, 感谢土哥的经验交流.</p><h3 id="restful简介"><a href="#restful简介" class="headerlink" title="restful简介"></a>restful简介</h3><p>RESTful 架构, 由于其以资源中心, 依赖http协议和uri, 虽然也会涉及c-s模型, 不过其更多的是强调对于相关资源的crud操作, 并且提供了统一的API形式:</p><ul><li>看Url就知道要什么</li><li>看http method就知道干什么</li><li>看http status  code就知道结果如何</li></ul><p>举几个例子就会发现它非常规范:</p><pre><code>https://api.qzone.com/user/getUserFeedList?from=web https://api.qzone.com?m=user&amp;c=getUserFeedList?from=web https://qzone.com/api/user/getUserFeedList?from=web https://qzone.com?m=api&amp;c=user&amp;a=getUserFeedList?from=web</code></pre><p>HTTP协议形式例如:</p><pre><code>GET /posts HTTP/1.1Accept: application/atom+xml响应：HTTP/1.1 200 OKContent-Type: application/atom+xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;    &lt;title&gt;Posts&lt;/title&gt;    &lt;link href=&quot;http://example.org/posts&quot; rel=&quot;self&quot; /&gt;    &lt;link href=&quot;http://example.org/posts?pn=2&quot; rel=&quot;next&quot; /&gt;    &lt;id&gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6&lt;/id&gt;    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;    &lt;entry&gt;        &lt;title&gt;Post XXX&lt;/title&gt;        &lt;link href=&quot;http://example.org/post-xxx&quot; /&gt;        &lt;id&gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id&gt;        &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;        &lt;content type=&quot;xhtml&quot;&gt;            &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;                &lt;p&gt;This is the post content.&lt;/p&gt;            &lt;/div&gt;        &lt;/content&gt;    &lt;/entry&gt;    &lt;entry&gt;...&lt;/entry&gt;&lt;/feed&gt;</code></pre><h3 id="api返回值经验"><a href="#api返回值经验" class="headerlink" title="api返回值经验"></a>api返回值经验</h3><blockquote><p>针对JSON型API的返回结果设计, 总结下自己的经验</p></blockquote><p>一般的返回结果是怎么样的?</p><pre><code>{    data : { // 请求数据        user_id: 123,        user_name: &quot;tutuge&quot;,        ...    },    msg : &quot;done&quot;, // 请求状态描述，调试用    code: 1001, // 业务自定义状态码    extra : { // 全局附加数据(optional字段)        type: 1,        desc: &quot;秒数信息&quot;    }}</code></pre><p>下面详细解释:</p><ul><li>data字段<br>本次请求结果的数据 data 字段, 其值为对象(字典)或数组(列表)均可以, 根据业务而定. 例如:<pre><code>data: [  {user_id: 123, user_name: &quot;tutuge&quot;},  {user_id: 321, user_name: &quot;zekunyan&quot;},  ...]</code></pre>当然数组, 对象还可以嵌套, 怎么灵活怎么用.(不用担心现有库对于字段的解析问题)</li><li>msg字段<br>该字段是本次请求的业务&amp;状态描述信息, 主要用于调试、测试等, 例如 “done”, “测试缺少参数”. 根据相关开发人员协商即可. </li><li>code字段<br>这是比较有争议的一个字段, 因为Http请求本身已经有了完备的状态码，再定义一套状态码直观上感受却是不对劲。但是实际开发中，确实发现 <code>自定义业务状态码</code> 的必要性，如一次成功的Http status 200的请求，可能由于用户未登录、登录过期而有不同的返回结果和处理方式，所以还是保留了; 权当http协议的详细说明.<br>定义规范根据业务来, 例如按照用户相关、授权相关、各种业务，做简单的分类:<pre><code>// Code 业务自定义状态码定义示例// 授权相关1001: 无权限访问1002: access_token过期1003: unique_token无效...// 用户相关2001: 未登录2002: 用户信息错误2003: 用户不存在// 业务13001: 业务1XXX3002: 业务1XXX// ...</code></pre>最好定义为常量, 当然能够动态解析最好.</li><li><p>extra字段<br>这个纯粹是附加字段(全局的附加数据), 为的是灵活扩展, 比如升级啊, 需求变化等. 由服务端的规则决定并且客户端要及时向用户展示变化, 所以加上了extra字段. 例如:</p><pre><code>// 升级type: 1,show_msg: &quot;恭喜您升级到XXX&quot;// 完成任务type: 2,task_desc: &quot;达成XXX成就&quot;</code></pre></li></ul><p>其实最终还是要看客户端和服务端人员的协商; 服务端人员切不可以为添加一个字段简单没有什么, 就随口答应, 一切都要走流程, 并且避免乱用. 这不仅仅是为了规范, 而是为了让项目不会再将来出现意想不到的 <code>惊喜</code> .</p><p>补充经验:</p><ul><li>命名, 和C语言保持一致就可以了(字段统一小写加下划线)<br>例如:<pre><code>// 字符串user_name, task_desc, date_str, article_title, feed_content 等// 数字user_id, users_count, task_num, xxx_offset 等// 日期login_at, create_date, logout_time 等// 布尔is_done, is_vip, protected, can_read 等// URLuser_avatar_url, thumb_url 等// 数组users, profiles, thumb_imgs 等</code></pre></li><li>设置默认值(空值)<ul><li>数字就是 <code>0</code></li><li>字符串就是空字符串<code>&quot;&quot;</code></li><li>数组就是空数组<code>[]</code></li><li>对象就是空对象{}</li></ul></li><li>bool值, 统一成0和1.<br>由于多种语言不统一, 所以一开始就要做好限定, 而不是<code>true</code>, <code>True</code>, <code>1</code>漫天乱飞.. 在客户端和服务端统一设置常量、宏定义，定义布尔的类型，所有的参数、结果的布尔字段全部做强制约束</li><li>时间处理, 统一使用Unix时间戳, 即GMT/UTC时间戳, 可以用<code>date +%s</code>命令查看, 然后各自客户端根据自己的时区, 显示做转换.<br>例如:<pre><code>// 从服务器接收的时间数据login_at: 1462068610// 根据时区、显示要求转换，如北京时间显示：2016年5月1日下午1点、1天前等</code></pre>(如果用字符串,可以参考<code>YYYY-MM-DDThh:mm:ssTZD</code>格式,保留了时区)</li><li>字符串常量 请用常量文档约束.<pre><code>// 如登录类型，QQ、微信、微博等login_type: &quot;qq&quot;,login_type: &quot;wechat&quot;,login_type: &quot;sina_weibo&quot;,</code></pre></li><li>使用完整的url, 指明网络协议(scheme).</li></ul><h2 id="语言类"><a href="#语言类" class="headerlink" title="语言类"></a>语言类</h2><h3 id="window移植"><a href="#window移植" class="headerlink" title="window移植"></a>window移植</h3><p>windows迁移问题, 自己遇到的, 记录一下:</p><ul><li>缺少最后一行空行, 多余的\r回车符<br><code>dos2unix &lt;file&gt; fromdos &lt;file&gt;</code></li><li>中文注释乱码<br><code>iconv –f gbk –t utf8</code></li><li>不能忍的头文件<br><code>windows.h</code></li><li>不兼容的宏, 库函数<br><code>snprintf()</code>,<code>__FUNCTION__</code>, <code>__FILE__</code>, <code>__LINE__</code></li><li>特殊的宏<br><code>#ifdef WIN_32  #define …  #endif</code></li></ul><h3 id="宽字符问题"><a href="#宽字符问题" class="headerlink" title="宽字符问题"></a>宽字符问题</h3><h3 id="操作大文件"><a href="#操作大文件" class="headerlink" title="操作大文件"></a>操作大文件</h3><p>1、包含所有头文件以前，先定义这些宏：</p><pre><code>#ifndef __USE_FILE_OFFSET64#define __USE_FILE_OFFSET64#endif#ifndef __USE_LARGEFILE64#define __USE_LARGEFILE64#endif#ifndef _LARGEFILE64_SOURCE#define _LARGEFILE64_SOURCE#endif</code></pre><p>一般用 /usr/include/features.h 重定义的:</p><p>32位LINUX使用超过2G的大文件，需要定义很多宏，与文件操作API相关的宏都有这样一些：<br>_FILE_OFFSET_BITS<br>_LARGEFILE_SOURCE<br>_LARGEFILE64_SOURCE<br><strong>USE_FILE_OFFSET64</strong>USE_LARGEFILE<br>__USE_LARGEFILE64</p><p>那么，它们之间的关系究竟是怎么样的呢？<br>终于在linux的头文件 /usr/include/features.h中找到了定义。</p><p>//原来这个文件就是专门让用户定义各种特性的：<br>/*These are defined by the user (or the compiler)<br>to specify the desired environment</p><p>其中几个供用户配置的宏的注释为：<br>_LARGEFILE_SOURCE    Some more functions for correct standard I/O.<br>_LARGEFILE64_SOURCE    Additional functionality from LFS for large files.<br>_FILE_OFFSET_BITS=N    Select default filesystem interface.<br>_GNU_SOURCE        All of the above, plus GNU extensions.<br><strong>USE_LARGEFILE    Define correct standard I/O things.</strong>USE_LARGEFILE64    Define LFS things with separate names.<br>__USE_FILE_OFFSET64    Define 64bit interface as default.<br>*/</p><p>// use前缀的宏定义都先取消掉，说明这些宏不是直接供用户使用的，而是由其他宏的定义衍生这些宏</p><p>#undef    __USE_LARGEFILE</p><p>#undef    __USE_LARGEFILE64</p><p>#undef    __USE_FILE_OFFSET64</p><p>//   _GNU_SOURCE是一张很大的通行证，定义了这个，很多相关的开关都会打开<br>/<em> If _GNU_SOURCE was defined by the user, turn on all the other features.  </em>/</p><p>#ifdef _GNU_SOURCE</p><h1 id="undef-LARGEFILE64-SOURCE"><a href="#undef-LARGEFILE64-SOURCE" class="headerlink" title="undef     _LARGEFILE64_SOURCE"></a>undef     _LARGEFILE64_SOURCE</h1><h1 id="define-LARGEFILE64-SOURCE-1"><a href="#define-LARGEFILE64-SOURCE-1" class="headerlink" title="define _LARGEFILE64_SOURCE    1"></a>define _LARGEFILE64_SOURCE    1</h1><p>#endif</p><p>// 下面是打开各个USE宏的位置</p><p>#ifdef _LARGEFILE_SOURCE</p><h1 id="define-USE-LARGEFILE-1"><a href="#define-USE-LARGEFILE-1" class="headerlink" title="define __USE_LARGEFILE    1"></a>define __USE_LARGEFILE    1</h1><p>#endif</p><p>#ifdef _LARGEFILE64_SOURCE</p><h1 id="define-USE-LARGEFILE64-1"><a href="#define-USE-LARGEFILE64-1" class="headerlink" title="define __USE_LARGEFILE64    1"></a>define __USE_LARGEFILE64    1</h1><p>#endif</p><p>#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64</p><h1 id="define-USE-FILE-OFFSET64-1"><a href="#define-USE-FILE-OFFSET64-1" class="headerlink" title="define __USE_FILE_OFFSET64    1"></a>define __USE_FILE_OFFSET64    1</h1><p>#endif</p><p>总结：<br>使用64位大文件，定义_LARGEFILE64_SOURCE和_FILE_OFFSET_BITS=64这两个宏即可</p><p>2、使用open打开文件的时候，加上O_LARGEFILE标志：<br>int fd = open(“test.dat”, O_RDWR|O_APPEND|O_CREAT|O_LARGEFILE, 0666);<br>read(), write()等与一般的用法一致，无变化。</p><p>3、注意lseek()函数，文件未超过2G的时候，一切工作良好；<br>文件超过2G后，调用返回-1，errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>需要使用lseek64()代替lseek()。很奇怪，定义了宏以后，并未自动将lseek变成lseek64。（知道原因的朋友可以教教我）</p><p>4、注意stat()函数，传入的文件如果在2G内，工作良好；<br>传入的文件如果超过2G，返回-1, errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>应该这样使用：struct stat64 st; stat64(“file”, &amp;st);</p><p>5、为了保险，建议所有操作文件的函数都是用支持64位大文件的。否则当文件超过2G后，难免会出现什么未知的异常</p><h2 id="C-标准库的坑"><a href="#C-标准库的坑" class="headerlink" title="C++标准库的坑"></a>C++标准库的坑</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><pre><code>https://segmentfault.com/a/1190000004933446</code></pre><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="external">知乎大神们对restful的看法</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">http状态码大全</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      一些列工作经验的分享,干货
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="里程碑" scheme="www.merlinblog.site/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>First Agile</title>
    <link href="www.merlinblog.site/2017/08/27/first-about-agile.html"/>
    <id>www.merlinblog.site/2017/08/27/first-about-agile.html</id>
    <published>2017-08-27T03:37:08.000Z</published>
    <updated>2017-09-24T07:26:34.663Z</updated>
    
    <content type="html"><![CDATA[<p>老东家一直有个站会, 在看板(Kan Board)面前阐述一下自己的任务进度. 说实话, 我非常排斥这种东西(虽然我拥护TDD和XP). 后来听京东和支付宝的同学也在说敏捷会议, 敏捷开发, 我这才意识过来:</p><pre><code>哦, 敏捷已经是趋势了.</code></pre><p>开始认真接受 <code>Agile</code> .</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我亲身实践的敏捷, 印象比较深刻的有两部分内容:</p><ul><li>站会的反馈</li><li>(配合SCM)持续集成</li><li>测试驱动</li></ul><p>总结起来, 我所重视的是: <code>参与</code>, <code>协作</code>, <code>持续交付</code> (每个阶段都是可交付的).</p><p>本文先说敏捷, 之后再说我的个人体会.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>敏捷到底是一种软件开发方法, 还是一种技术思想? 到现在我的觉得, 这些已经不再重要, 重要的是, 我们通过 Agile 能够获得什么, 而不是我最初跟风的, 尝试敏捷.</p><h2 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h2><p>主要的内容就这么几句话:</p><pre><code> Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan</code></pre><p>如下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/agile.jpg" alt="agile"></p><p>看得出, 宣言其实是很空洞的, 所以又出现了下面的 <code>12项原则</code> .</p><h2 id="12项原则"><a href="#12项原则" class="headerlink" title="12项原则"></a>12项原则</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/agile_principle.jpg" alt="agile"></p><p>从中可以提取很多关键思想: <code>不断交付</code>, <code>拥抱变化</code>, <code>合作</code>, <code>可工作的软件</code>, <code>简洁为本</code>, <code>定期反思</code> …</p><h2 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h2><p>不管一个产品, 还是一个项目, 整个团队的协作, 参与是最重要的. 所以比起其他一些(重视开发流程, 过程的)方法, Scrum更加注重协作&amp;参与(当然也包括交付, 每一个过程都是可交付的).</p><p>是的, 我这里多次强调了 <code>参与</code> .</p><p>关于这部分理论, 请找专业的资料参考吧, 不要去网上看一些不太专业的转载.</p><h2 id="站会反馈"><a href="#站会反馈" class="headerlink" title="站会反馈"></a>站会反馈</h2><p>每天早上9:30, 会有一个站会, 内容是围绕看板任务, 大家各自汇报一下. 说实话, 效果很差. 因为除非是你的模块, 否则大家对你的进度, 遇到的困难, 没有太多的体会, 也很难给出意见. (何况有时候我都是单独一个项目, 单枪匹马).</p><p>但是在这里, 我却有一些很深刻的体会, 大体可以归纳为: 我们认为重要的, 用户不一定觉得重要.</p><p>这么说呢? 具体解释:</p><p>好比我的模块, 是否需要一个数据库View(视图), 一个Contoller调度模块, 是否要给出应用界面, 表格是竖着展开还是横向排列, 你的意见, 和最终用户的意见可能相差很远, 甚至你觉得重要的, 用户完全不care, 不关注的.</p><p>所以站会反馈, 最好能让用户, 客户参与到团队的开发中; 这里增加一点儿成本, 却省下了后期需求变更, 调整的代价. 好处不言自明.</p><p>也就是宣言中所说的 <code>Customer collaboration over contract negotiation</code>, 客户协作胜过合同谈判.</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>在持续集成方面, 老东家 <code>ZTE</code> 可以说, 做的非常好; 因为面对的北美项目比较多, 所以在集成测试做不好, 不仅会加大人力投入, 还会降低开发效率. 但是就像自动测试一样, 是否应该持续集成关键在于投资回报率和缓解风险. 我想这一点, 不必多解释, 请看下面的要点.</p><p>持续集成的要点:</p><ul><li>统一的代码库</li><li>自动构建</li><li>自动测试</li><li>每个人每天都要向代码库主干提交代码</li><li>每次代码递交后都会在持续集成服务器上触发一次构建</li><li>保证快速构建</li><li>模拟生产环境的自动测试</li><li>每个人都可以很容易的获取最新可执行的应用程序</li><li>每个人都清楚正在发生的状况</li><li>自动化的部署</li></ul><p>个人的经验是:<br>以前我的代码入库前, 至少经历这样的步骤:<br>代码编写完毕, 本地验证通过(包括编译和功能验证), 然后在本地集成(可能是具体的开发板,比如手机), 之后上传代码, 在容器(生产环境)中测试, 而且分两次, 早上和下午(赶上一次就可以了), 之后通过了, 才合入dev分支, 经过几个版本的测试, 没有问题了, 才最终合入master分支. 中间经过了N次自动化测试, 集成, 而且你的提交根本不干预集成.</p><p>这里面相关的技术也很多, Jekins, Gerrit, repo, Docker等.</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>关心团队协作, 用心做产品.</p><p>希望敏捷的路越走越顺吧.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      谈谈自己经历 敏捷开发 的体会
    
    </summary>
    
      <category term="managements" scheme="www.merlinblog.site/categories/managements/"/>
    
    
      <category term="开发管理" scheme="www.merlinblog.site/tags/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>Thrift</title>
    <link href="www.merlinblog.site/2017/08/22/thrift.html"/>
    <id>www.merlinblog.site/2017/08/22/thrift.html</id>
    <published>2017-08-22T00:08:22.000Z</published>
    <updated>2017-09-24T07:22:18.079Z</updated>
    
    <content type="html"><![CDATA[<p>有同行老早就在实践这个库了.毫无疑问, 本文是继 protobuffer 之后, 又要花大力气讲解的一个(FB的)库(而且绝对是值得你花一个晚上自习看看的库). 不过可惜的是, 实际开发中它并不如pb应用广泛, 可能很大一个原因是因为太重了, 而且代码还依赖了外部库boost, libevent等, 相比之下, RESTful的做法就会简单很多.(我不得不说, 花了很多时间在踩开源的坑…最终结论, 于开源来说, Thrift可能不是最好的选择) </p><p>还是强调一些最基本的概念吧:</p><blockquote><p>框架的协议是指传输时候的编码方式(而不是网络协议); 框架的传输方式包括文件, 缓存buffer, 压缩二进制或者文本, 以及其他需要服务器端同步阻塞或者非阻塞操作,多线程或者异步IO支持的方式(因为可能传输方式使用了一些同步或者异步的IO), 传输方式也会(包括)指定传输的网络协议. 服务器类型是指服务器的工作模式, 是同步阻塞处理请求还是非阻塞操作(轮询检查IO-fd), 是否支持多线程模型, 还是异步多路IO.</p></blockquote><p>本篇也作为 <code>跨语言编程实践</code> 的最后一篇, 后期可能会有更新(主要是补充 <code>源码分析</code> 部分).</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>From Wikipedia, the free encyclopedia:</p><blockquote><p>Thrift is an interface definition language and binary communication protocol that is used to define and create services for numerous languages.</p></blockquote><p>wiki上的一句话概括了: 用于使用接口定义语言和二进制通信协议定义并创建跨语言服务的框架.(通信格式是二进制, 和pb一样)</p><p>实际上, 谈thrift更多的也是从服务架构, 传输, RPC上说它的作用(可以简单把RPC理解成非同一进程调用, 非异步网络情况下的阻塞调用), 简单的了解可以说它如何构建服务, 深入的可以分析一下它的rpc调用机制. 总之, 你不仅可以了解它的序列化机制, c-s服务模型, 传输体系, 还能学习它内部代码生成引擎. (看样子是应该不支持协程的)</p><p>(有时间可以学习一下它的源码)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面记录在Ubuntu64上进行编译安装的过程, 我不得不说, 编译安装是个很坑爹的过程, 所有我接触过的开源产品里面, thrift做的支持最差了.<br>安装绝对没有那么顺利, 上述任何过程出错, 请根据相关提示拍错, 下面是我遇到的:</p><p>首先确保你的环境里面安装了 libssl-dev, libtool, flex, bison(即yacc), pkg-config, boost和libevent(a minimal RPC framework), 之后再去安装thrift. 下面是一个详细记录.</p><pre><code># 先安装我缺失的# automake$ sudo apt-get install automake# yacc: command not found$ sudo apt-get install -y byacc# flex: command not found$ sudo apt-get install -y flex# 安装libevent-dev$ sudo apt-get install libevent-dev# 安装ssl$ sudo apt-get install libssl-dev# 下载$ wget http://mirror.bit.edu.cn/apache/thrift/0.10.0/thrift-0.10.0.tar.gz -P Desktop/apps$ tar xzvf thrift-0.10.0.tar.gz$ cd thrift-0.10.0# 配置$ ./configure</code></pre><p>注意一下日志, 如果你还要编译其他语言的, 请注意安装相应的库, 比如我要再去装Go语言支持, 那么我就要在日志中找Go语言相关的依赖库.</p><pre><code>thrift 0.10.0Building Plugin Support ...... : yesBuilding C++ Library ......... : yesBuilding C (GLib) Library .... : yesBuilding Java Library ........ : yesBuilding C# Library .......... : noBuilding Python Library ...... : yesBuilding Ruby Library ........ : noBuilding Haxe Library ........ : noBuilding Haskell Library ..... : noBuilding Perl Library ........ : noBuilding PHP Library ......... : noBuilding Dart Library ........ : noBuilding Erlang Library ...... : noBuilding Go Library .......... : yesBuilding D Library ........... : noBuilding NodeJS Library ...... : yesBuilding Lua Library ......... : noC++ Library:   Build TZlibTransport ...... : yes   Build TNonblockingServer .. : yes   Build TQTcpServer (Qt4) .... : yes   Build TQTcpServer (Qt5) .... : noJava Library:   Using javac ............... : javac   Using java ................ : java   Using ant ................. : /usr/bin/antPython Library:   Using Python .............. : /usr/bin/python   Using Python3 ............. : /usr/bin/python3Go Library:   Using Go................... : /usr/lib/go-1.7/bin/go   Using Go version........... : go version go1.7.4 linux/amd64NodeJS Library:   Using NodeJS .............. : /home/merlin/Software/node-v6.11.2-linux-x64/bin/node   Using NodeJS version....... : v6.11.2If something is missing that you think should be present,please skim the output of configure to find the missingcomponent.  Details are present in config.log.</code></pre><p>但是注意:</p><blockquote><p>你支持的库越多, 后期编译出问题的可能性越大.</p></blockquote><p>最好禁用一些选项, 和自定义一些选项.</p><pre><code>./configure --libdir=/usr/local/lib --without-java --without-python</code></pre><p>编译安装</p><pre><code>$ make -j8 &amp;&amp; make check# 跨语言测试$ sh test/test.sh# 编译$ sudo make install</code></pre><p>查看一下目录, 发现勉强还是安装成功了.</p><pre><code>ls /usr/local/lib | grep libthriftlibthrift-0.10.0.jarlibthrift-0.10.0-javadoc.jarlibthrift-0.10.0.solibthrift.alibthriftc.alibthrift_c_glib.alibthrift_c_glib.lalibthrift_c_glib.solibthrift_c_glib.so.0libthrift_c_glib.so.0.0.0libthriftc.lalibthriftc.solibthriftc.so.0libthriftc.so.0.0.0libthrift.lalibthriftnb-0.10.0.solibthriftnb.alibthriftnb.lalibthriftnb.solibthriftqt-0.10.0.solibthriftqt.alibthriftqt.lalibthriftqt.solibthrift.solibthriftz-0.10.0.solibthriftz.alibthriftz.lalibthriftz.so$ ls /usr/local/include | grep thriftthrift$ which thrift /usr/local/bin/thrift</code></pre><p>(先跑起来再说)</p><p>编译日志里有一大段比较重要:</p><pre><code>If you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR&#39;flag during linking and do at least one of the following:   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable     during execution   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable     during linking   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.</code></pre><p>去检查一下<code>/etc/ld.so.conf</code>是否已经囊括了你安装库的目录.</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>一般的开发流程是这样的(和pb类似):</p><ul><li>规矩需求编写thrift接口定义文件</li><li>使用thrift binary为不同的语言生成代码</li><li>根据需求, 修改生成的代码(主要是Server端骨架代码), 编写实际的业务逻辑</li><li>编译, 集成</li></ul><p>通过IDL, 即thrft描述文件, 对其中定义的<code>数据结构</code>, 如struct等, 以及传输业务逻辑, 根据不同的运行环境构建相应的代码. 至于内部序列化, 压缩, 文本交互, 并发, 这个在其框架内部已经解决, 描述起来就是下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_sequence.jpg" alt=""></p><p>整个过程非常清晰, 只是中间有一些小细节需要注意一下, 比如说thrift文件怎么写才规范, 怎么生成代码, 运行生成的代码加入实际业务逻辑等. 下面给出一个案例.(我习惯用cpp语言, 当然别的语言也有案例, 暂时小的案例用cpp)</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h3><p>按照上面讲的流程, 先跑起来; 为了简单, 我先不管目录结构. 下面的例子, 演示一下rpc.</p><p>先创建必要的目录</p><pre><code>$ mkdir thrift_test$ cd thrift_test$ touch ping.thrift</code></pre><p>ping.thrift的代码如下:</p><pre><code># ping.thrift/** * Thrift files can namespace, package, or prefix their output in various * target languages. */namespace cpp pingtest/** * Defining a class named pinger */service pinger{  /**   * client calls ping method to make sure service process is active or dead   */   void ping()}</code></pre><p>(注意我使用的关键词 <code>service</code>)<br>代码比较简单, 然后就在本目录下生成server端的骨架(框架模板代码):</p><pre><code>$ thrift --gen cpp -o . ping.thrift $ tree -L 2.├── gen-cpp│   ├── ping_constants.cpp│   ├── ping_constants.h│   ├── pinger.cpp│   ├── pinger.h│   ├── pinger_server.skeleton.cpp│   ├── ping_types.cpp│   └── ping_types.h└── ping.thrift1 directory, 8 files</code></pre><p>也就是说服务器端的模板代码全部产品了, 但是这些代码基本不涉及业务, 所以还要写自己的业务server端代码来调用上述框架代码, 但是这里仅仅是演示, 不需要写了, 直接利用<code>pinger_server.skeleton.cpp</code> 这个主文件就好(这个文件你可以改名为server.cpp, 它就是server端的主文件, 含有main函数).</p><pre><code>$ cp gen-cpp/* .$ cat pinger_server.skeleton.cpp</code></pre><p>代码如下: (中间我就加了一句打印)</p><pre><code class="c++">// This autogenerated skeleton file illustrates how to build a server.// You should copy it to another filename to avoid overwriting it.#include &quot;pinger.h&quot;#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using boost::shared_ptr;using namespace  ::pingtest;class pingerHandler : virtual public pingerIf { public:  pingerHandler() {    // Your initialization goes here  }  /**   * client calls ping method to make sure service process is active or dead   */  void ping() {    // Your implementation goes here    printf(&quot;ping\n&quot;);  }};int main(int argc, char **argv) {  //默认9090端口  int port = 9090;  //下面是一些通讯必要的协议等内容  shared_ptr&lt;pingerHandler&gt; handler(new pingerHandler());  shared_ptr&lt;TProcessor&gt; processor(new pingerProcessor(handler));  shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));  shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());  shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());  //创建一个TSimpleServer对象， 虽然效率不高， 但是仅仅做远端检查足够了  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);  server.serve();//开始监听了  return 0;}</code></pre><p>好了, 先把server端可执行文件编译出来:</p><pre><code>$ g++ -g -Wall -std=c++11  -lthrift ./*.cpp -o server</code></pre><p>如果你没有配置环境, 完整的应该是这样:</p><pre><code>g++ -g -Wall -std=c++11 -I/usr/local/include -L/usr/local/lib -lthrift ./*.cpp -o server</code></pre><p>如果不是需要客户端调用, 可以用curl或者nc进行调试, 但是这里是RPC, 不仅仅是通讯或者交换数据, 所以这里客户端要手写 <code>client.cpp</code>. 代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/transport/TSocket.h&gt;#include &lt;thrift/transport/TTransportUtils.h&gt;#include &quot;pinger.h&quot; //使用pingerClient对象using namespace std;using namespace apache::thrift;using namespace apache::thrift::protocol;using namespace apache::thrift::transport;using namespace pingtest;int main(void){  //连接远端服务器  boost::shared_ptr&lt;TTransport&gt; socket(new TSocket(&quot;localhost&quot;, 9090));  boost::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));  boost::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));  pingerClient client(protocol);  try {    transport-&gt;open();    client.ping();//远端调用    transport-&gt;close();  } catch (TException&amp; tx) {    cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; tx.what() &lt;&lt; endl;  }  return 0;}</code></pre><p>编译</p><pre><code>g++ -g -Wall -std=c++11  -lthrift client.cpp ping_constants.cpp pinger.cpp ping_types.cpp  -o client</code></pre><p>运行一下(开两个端口, 先开server, 在开client)</p><pre><code>$ ./server pingping</code></pre><p>server一直运行(死循环), 然后client运行一次, server端打印ping一次.</p><p>远端调用就是这么简单? 其实是骨架代码做了很多, 先不探讨源码(这里只说简单的案例)</p><p>最后补充关于目录组织, makefile, 请按照你们研发经理的要求来.</p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>上面那个仅仅有远端调用, 没有实际的c-s传输数据, 下面这个案例带有数据传递.<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_c_s_1.jpg" alt="数据传递"><br>先写thrift接口文件:</p><pre><code># transfer.thriftnamespace cpp transfertestenum ResponseState{    StateOk = 0,    StateError = 1,    StateEmpty = 2}/*请求时的数据*/struct Request{    1: i32 studentID = 0}/*响应时的数据*/struct Response{    1: i32 studentID = 0,    2: string name,    3: list&lt;string&gt; infos,    4: ResponseState state}/*远端调用*/service TransferService{    Response getStudentInfo(1: Request request); }</code></pre><p>注意 <code>Response getStudentInfo(1: Request request)</code> 原型和生成的代码有区别, 当然你的IDL文件里面写很多crud的servcie都没有关系, 根据你的业务需要来.</p><p>生成框架代码.</p><pre><code>$ thrift --gen cpp transfer.thrift$ cp gen-cpp/* .$ ll总用量 68drwxr-xr-x 3 merlin merlin  4096 9月   2 17:23 .drwxr-xr-x 4 merlin merlin  4096 9月   2 17:11 ..drwxr-xr-x 2 merlin merlin  4096 9月   2 17:22 gen-cpp-rw-r--r-- 1 merlin merlin   305 9月   2 17:23 transfer_constants.cpp-rw-r--r-- 1 merlin merlin   393 9月   2 17:23 transfer_constants.h-rw-r--r-- 1 merlin merlin 12831 9月   2 17:23 TransferService.cpp-rw-r--r-- 1 merlin merlin  9888 9月   2 17:23 TransferService.h-rw-r--r-- 1 merlin merlin  1423 9月   2 17:23 TransferService_server.skeleton.cpp-rw-r--r-- 1 merlin merlin   433 9月   2 17:20 transfer.thrift-rw-r--r-- 1 merlin merlin  7347 9月   2 17:23 transfer_types.cpp-rw-r--r-- 1 merlin merlin  3205 9月   2 17:23 transfer_types.h</code></pre><p>修改<code>TransferService_server.skeleton.cpp</code>代码.</p><pre><code class="c++">// TransferService_server.skeleton.cpp#include &quot;TransferService.h&quot;#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using boost::shared_ptr;using namespace  ::transfertest;class TransferServiceHandler : virtual public TransferServiceIf { public:  TransferServiceHandler() {    // Your initialization goes here  }  void getStudentInfo(Response&amp; _return, const Request&amp; request) {    // Your implementation goes here    printf(&quot;getStudentInfo called\n&quot;);    //处理请求数据， 发送响应给客户端    printf(&quot;client request studentID: %d\n&quot;, request.studentID);    //给Response设置数据    _return.studentID = request.studentID;    _return.name = &quot;merlin&quot;;    _return.infos.push_back(&quot;信息1&quot;);    _return.infos.push_back(&quot;信息2&quot;);    _return.state = ResponseState::StateOk;    printf(&quot;data has benn sent to client\n&quot;);  }};int main(int argc, char **argv) {  int port = 9090;  shared_ptr&lt;TransferServiceHandler&gt; handler(new TransferServiceHandler());  shared_ptr&lt;TProcessor&gt; processor(new TransferServiceProcessor(handler));  shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));  shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());  shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);  server.serve();  return 0;}</code></pre><p>函数<code>void getStudentInfo(Response&amp; _return, const Request&amp; request)</code>原型和我们在thrift里面指定的有区别.</p><p>编译服务端:</p><pre><code>$ g++ -g -Wall -std=c++11 *.cpp -o server -lthrift</code></pre><p>然后在写客户端client.cpp, 发送请求:</p><pre><code class="c++">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/transport/TSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;#include &lt;thrift/protocol/TCompactProtocol.h&gt;#include &quot;TransferService.h&quot; //使用TransferServiceClient对象using namespace ::transfertest; //Request, Responseusing namespace apache::thrift;using namespace apache::thrift::protocol;using namespace apache::thrift::transport;using boost::shared_ptr;int main(int argc, char **argv){  //如果和服务端信息不匹配就报错  boost::shared_ptr&lt;TSocket&gt; socket(new TSocket(&quot;localhost&quot;, 9090));  boost::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));  boost::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));  //设置响应的数据(发给服务端, 其实是rpc)  Request quest;  quest.studentID = 1;  //用于接收服务端信息  Response resp;  //打开连接  transport-&gt;open();  TransferServiceClient client(protocol);  client.getStudentInfo(resp, quest);  //关闭连接  transport-&gt;close();  //输出信息  printf(&quot;get response: ID=%d  name=%s  state=%d\n&quot;, resp.studentID,   resp.name.c_str(), resp.state);  return 0;}</code></pre><p>编译</p><pre><code>$ g++ -g -Wall -std=c++11 -lthrift client.cpp \ transfer_constants.cpp transfer_types.cpp TransferService.cpp -o client</code></pre><p>运行一下, 效果如下:</p><pre><code>$ ./server getStudentInfo calledclient request studentID: 1data has benn sent to client^C##另外一个terminal$ ./clientget response: ID=1  name=merlin  state=0</code></pre><p>这个例子就这样了, 当然官网还有一个类似的, 稍稍复杂的 <a href="https://thrift.apache.org/tutorial/cpp" target="_blank" rel="external">例子</a> , 就不再多说了.</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>本段内容是对 <a href="https://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="external">thrift-wiki</a> 架构部分的剖析.</p><p>总体的架构图如下:<br><img src="http://omotkhw3y.bkt.clouddn.com/Apache_Thrift_architecture.png" alt="架构"></p><p>可以看到, thrift实际跨了两层: 应用层和传输层(有些博文非要把它的那个颜色认为是不同的层, 我也就无话可说了), 也就是我们再网络编程中最长需要打交道的, 并且<code>read/write</code>以下的部分, 即TProtocol, TTransport属于thrift框架的传输体系, 如果不是研究源码, 可以暂时不关注(使用的时候具体选择以下使用哪种类型的传输协议).  实际上研究源码, 发现也就是我们通常需要手工完成的:</p><ul><li>服务器端这里还有一个TProcessor负责读写 消息体等操作(客户端对应TProcessor的是TriftClient)</li><li>服务器端这里还有Tserver, 负责接收Client的请求, 并将请求转换给TProcessor</li><li>编码封装 (TProtocol) 把用户的数据封装成一个 消息体, 通常是二进制的; (注意原来的数据是带有类型的, 消息体的数据只管encode编码字节数)</li><li>字节流转换 (TTransport) 把消息体以字节流的方式发送给底层IO(或者从其接收字节流再转换成消息体), 到底是流式IO还是文件IO; 每一种底层IO对应这里的一种TTransport</li><li>底层IO (socket/file/zip)</li></ul><p>我们真正需要处理(修改)的也就是<code>Input code</code>部分和<code>Service Client</code>.</p><p>如下图:(详细架构)<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_real.jpg" alt=""></p><p>准确说 <code>TProtocol</code>定义了传输协议规范(编码规范-大体上分为二进制和文本方式), <code>TTransport</code>定义了传输数据标准(根据不同的方式把说句做转换), 以及服务器类型, 当然服务器类型不仅仅包含IO类型. </p><p>Processor(或者TProcessor)负责对Client的请求做出响应, 包括 RPC 请求转发(TProcessor.process), 调用参数解析和用户逻辑调用, 返回值写回等处理步骤, 也包括thrift消息结构体的读取和写入. Processor是服务器端从Thrift框架转入用户业务逻辑的关键流程, 你简单理解成这个复杂系统中统一的输入和输出处理即可.(针对详细结构体和远端调用)</p><p>其模块设计, 层次界限非常到位.</p><p>强调一些最基本的概念.</p><blockquote><p>框架的协议是指编码方式; 框架的传输方式包括文件,缓存buffer, 压缩或者需要服务器端同步异步工作支持的IO类型(因为传输方式使用了一些同步或者异步的IO), 传输方式也会指定传输协议. 服务器类型是指服务器的工作模式, 是同步阻塞处理请求还是非阻塞操作, 是否支持多线程模型, 还是异步多路IO.</p></blockquote><h3 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h3><p>Thrift可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本(text)和二进制(binary)传输协议，为节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为多数，有时还会使用基于文本类型的协议，这需要根据项目/产品中的实际需求.<br>常用协议有以下几种: </p><ul><li>BinaryProtocol: 二进制编码格式进行数据传输使</li><li>TCompactProtocol: 高效率的、密集的二进制编码格式进行数据传输</li><li>TJSONProtocol: 使用 JSON 数据编码协议进行数据传输</li></ul><p>wiki中说到的其他的:</p><ul><li>TDebugProtocol(调试时使用的文本格式)</li><li>TDenseProtocol(类似TCompactProtocol, 但不包含 meta info)</li><li>TSimpleJSONProtocol(drops metadata using JSON, 所以只用于只读解析).</li></ul><h3 id="传输标准"><a href="#传输标准" class="headerlink" title="传输标准"></a>传输标准</h3><p>这里的传输标准通俗说就是读写方式, 可能有一些方式需要服务器以同步或者异步的工作形式支持, 也可能有些形式仅用于服务端或者客户端等, 比如下面名字中带有Server字样的, 仅用于服务器端. (不强调Server字样的, 一般既可以用于服务器端也可以用于客户端)</p><p>由于一些语言有限制,或者标准不同, thrift定义的标准在具体语言中可能处理情况不一样.</p><ul><li>TSocket : 使用阻塞式 I/O 进行传输，是最常见的模式(就是简单的阻塞IO: read, write)</li><li>TServerSocket：非阻塞型 socket 传输, 轮询的时候, 没有IO读写就直接返回, 但一旦 accecpt 到, 还是阻塞读写, 即TSocket(即阻塞型 socket).</li></ul><p>wiki里面也谈到了其他种类:(可能不太常用)</p><ul><li>TFDTransport 是非常简单地写数据到文件和从文件读数据，它的 write 和 read 函数都是直接调用系统函数 write 和 read 进行写和读文件</li><li>TSimpleFileTransport 直接继承 TFDTransport，没有添加任何成员函数和成员变量, 算是对TFDTransport的轻量扩展</li><li>TFileTransport - (一些写线程, 一个读线程)以文件的方式传输, 主线程负责将事件入列，写线程将事件入列，并将事件里的数据写入磁盘.(继承自TTransport)</li><li>TBufferedTransport - 带缓存的传输形式(需要使用non-blocking IO)</li><li>TFramedTransport -  带缓存(以帧的)形式传输(要求使用非阻塞IO, 可能因为帧指定了长度; 头4个字节指定了长度; int32_t)</li><li>TMemoryTransport - 这个使用内存做IO(用于程序内部通信用，不涉及任何网络I/O)<ul><li>OBSERVE模式，不可写数据到缓存</li><li>TAKE_OWNERSHIP模式，需负责释放缓存</li><li>COPY模式, 拷贝外面的内存块到TMemoryBuffer</li></ul></li><li>TZlibTransport - 压缩传输需要配合其他传输协议一起.</li></ul><p>(一般用于缓存读写的方式是TMemoryTransport, 没有调用flush方法之前, 不涉及网络)</p><p>还有2个比较特殊的:</p><ul><li>TSSLSocket 继承 TSocket,阻塞型 socket, 用于<code>客户端</code>. (采用 openssl 的接口进行读写数据)<br>checkHandshake()函数调用 SSL_set_fd 将 fd 和 ssl 绑定在一起，之后就可以通过 ssl 的 SSL_read和SSL_write 接口进行读写网络数据</li><li>TSSLServerSocket 继承 TServerSocket, 非阻塞型 socket, 用于<code>服务器端</code>. accecpt 到的 socket 类型都是 TSSLSocket 类型.</li></ul><p>当然, 也提供了基于 <code>HTTP协议</code> 的传输类型: (继承 THttpTransport, 基于Http1.1)</p><ul><li>THttpClient 用于客户端</li><li>THttpServer 用于服务器端<br>两者都调用下一层 <code>TTransport</code> 类进行读写操作, 均用到 TMemoryBuffer 作为读写缓存, 只有调用 flush() 函数才会将真正调用网络 I/O 接口发送数据; 并且这里的TTransport为上层提供的类似多态的方法, 通过TTransport接口可以调用其子类的不同实现. (TTransport 是所有 Transport 类的父类; 而THttpTransport是Transport的子类)</li></ul><h3 id="服务端类型"><a href="#服务端类型" class="headerlink" title="服务端类型"></a>服务端类型</h3><p>根据传输标准的不同, 并发程度的要求, 也有多种不同类型的服务器(也就是服务端的工作模式), 并且生成不同语言代码时, 实现也不一样, 比如说非阻塞IO, Java使用NIO, 而C++借助Lievent库. 根据不同场合选择不同的server类型, 需要对网络模型非常熟悉.</p><p>下面是主要的服务端类型:(源码剖析的时候会再说)</p><ul><li>TSimpleServer : 单线程服务器端使用标准的阻塞式 I/O</li><li>TNonblockingServer : 单线程异步IO(多路轮询检测, 处理读写的时候还是阻塞IO), 该类型Server必须使用TFramedTransport.</li><li>THsHaServer : select轮询 + 线程池工作线程处理读任务, 写任务还是阻塞IO. (半同步半异步)</li><li>TThreadPoolServer : 线程池+标准的阻塞式 I/O</li><li>TThreadedSelectorServer : AcceptThread + SelectorThread + SelectorThreadLoadBalancer(调度器) + ExecutorService(工作线程池)</li></ul><p>(如果看源码, 我局的最后这一种高级方式, 值得一看)</p><p>TSimpleServer 接受一个连接，处理连接请求，直到客户端关闭了连接，它才回去接受一个新的连接。正因为它只在一个单独的线程中以阻塞 I/O 的方式完成这些工作，所以它只能服务一个客户端连接，其他所有客户端在被服务器端接受之前都只能等待. 可以看到TSimpleServer基本只能用于测试.</p><p>TThreadPoolServer 如果有连接请求来了, 那么从线程池中拿一个工作线程来应对网络IO事件, 主线程是非阻塞的, worker线程则是使用阻塞IO. (但是吞吐量是原来的N倍, N为work线程的个数)</p><p>TNonblockingServer 这种模式对应linux网络编程中的select模型; 所以socket都注册到select, 然后一个线程中通过seletor循环监控所有的socket，每次selector结束时，处理所有的处于就绪状态的socket，对于有数据到来的socket进行数据读取操作，对于有数据发送的socket则进行数据发送，对于监听socket则产生一个新业务socket并将其注册到selector中. (如果没有则进行下一次轮询, 如果有, 就必须处理完相关的socket IO才能进行下一次轮询) 该模式比TSimpleServer好的地方在于, 原来是单线程阻塞, 即一旦连接上了, 非要你IO完毕, 我服务端才处理下一个请求. (该模型是, 我都(监听)处理, 你都来吧, 但是真正有IO读写的, select才去调用阻塞IO去处理读写任务)监听的多, 但是真正处理起来还是一个一个顺序执行, 一旦有耗时任务, 效率就不高了.</p><p>THsHaServer类是TNonblockingServer类的子类, 是TThreadPoolServer单线程的部分解决方(引入了一个线程池做优化), 专门进行读业务处理. 也就是原来selector的主线程主要负责写任务, 之后进入下一次轮询(主线程也处理就绪需要accept的socket); 但是读任务全部交给线程池中的工作线程, 不阻塞主线程. 只能说部分优化了, 当并发请求数较大时，且发送数据量较多时，监听socket上新连接请求不能被及时接受(毕竟主线程还是会被写任务阻塞住)。</p><p>TThreadPoolServer模式, 这种模式没有使用select这类异步操作, 而是同步的去判断是否由socket就绪(accept), 对仅仅是处理accept, 没有的话阻塞整个进程在那儿等待, 然后一旦有连接, 不管有没有IO任务, 它都会启动一个专门的线程去处理这个连接上的所有任务(方式是把socket封装成一个新任务交给线程池, 之后工作线程才去从socket拿出请求, 完成具体调用返还客户客户端), 这样得以把主线程空出来继续阻塞等待别的连接请求. 这个缺点就很明显了, 受限于线程池中线程的数量(并发量大于线程池数量时, 能扩展线程数最好, 不能的话, 那么只能进入队列等待了), 并发量不大. (最好你知道有多少个, 最多有多少个客户端会连接的情况)</p><p>TThreadedSelectorServer : 这种模型, 把网络中的任务细致划分. 可谓足够精细, 多个部分协作工作. 如果说上面的都是个人&amp;两三个人, 这个模型就是一个小团队, 请直接看图.<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_thread_selector.jpg" alt=""></p><p>稍微解释一下, 普通的网络编程中成功用例是这么工作的: (服务端)</p><blockquote><p>接受连接请求 –&gt; 检测是否有IO就绪 —&gt; 处理真正的IO操作</p></blockquote><p>但是引入线程池之后, 这个模型变成了:(流程自上而下)</p><ul><li>线程AcceptThread阻塞(或者非阻塞)等待是否由心的连接  (这个是<code>销售顾问</code>, 拿到订单)</li><li>有新的连接就把它交给SelectorThread以检测socket是否就绪(是否由IO读写请求)  (这个是<code>项目经理</code>, 负责拿到的订单项目)</li><li>被accept的连接,需要SelectorThreadLoadBalancer来调度,以免某个SelectorThread压力过大(这个是<code>研发经理</code>, 分派任务)</li><li>SelectorThread读取具体的请求, 但是实际完成耗时IO(或者具体调用)的却是ExecutorService. (这个就是<code>高级工程师</code>)</li></ul><blockquote><p>如果你的场景不需要某种支持高并发的姿态, 就不要浪费资源选择高级模式; 够用就好. 但是还有一句, 如果几种模型的优缺点你不知道, 那么选择最好的总不会错, 直接上TThreadedSelectorServer也没事儿.</p></blockquote><hr><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p>这一部分是阅读其官网文档的总结, 你可以把它看做使用手册.</p><h3 id="传输框架"><a href="#传输框架" class="headerlink" title="传输框架"></a>传输框架</h3><p>该部分请 <code>参考架构部分</code>. (上面)</p><p>主要是协议protocol, transport方式, 以及server类型即可. 协议部分我们在pb里面以及涉及到编码规则内容了,没有必要详细深挖; 主要值得研究的是在 <code>传输方式</code>和<code>服务器类型</code>上, 不同的方式有不同的实现细节, 以及后端思想; 并且效率也可能相差很多.</p><blockquote><p>后期有时间, 可以像Libevent一样, 把TSocket等传输方式, 以及TSimpleServer等服务器类型; 源码剖析一下.</p></blockquote><p>(见下面 <code>源码分析</code> 部分)</p><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><p>越来越多的语言使用package作为代码控制机制, 到具体的语言可能是模块(Python), 包(Java), 或者namespace(Cpp)</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>thrift定义了几大数据类型, 在不同环境中翻译成不同语言时候mapping关系也不大一样; 幸运的是, 这一层抽象被thrift框架处理了, 我们只用关心thrift数据类型即可.</p><p>类型主要包括: 基本类型、结构体和异常类型(异常使用关键字exception)、容器类型、服务(service)类型;</p><p>基本类型:</p><ul><li>bool：布尔值 (true or false), 1 字节</li><li>byte：有符号字节</li><li>i16：16位有符号整型</li><li>i32：32位有符号整型</li><li>i64：64位有符号整型</li><li>double：64位浮点型</li><li>string：未知编码或者二进制的字符串</li></ul><p>结构体:<br>例如:</p><pre><code>struct UserDemo {　　1: i32 id;　　2: string name;　　3: i32 age = 25;　　4： string phone;}</code></pre><p>必须注意:</p><ul><li>struct 不能继承，但是可以嵌套别人，不能嵌套自己</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码是用(和pb一样)</li><li>成员分割符可以是逗号或是分号, 而且可以混用(建议使用分号, C语言习惯)</li><li>字段会有optional和required之分(和pb一样)</li><li>每个字段可以设置默认值(和pb一样)</li><li>同一文件可以定义多个struct; 可以用include包含别的文件的struct定义</li></ul><p>补充说明:</p><ul><li>编码值, 不要随便编; </li><li>字段类型required或者optional(没有赋值则不进行序列化), 不指定则默认是会被序列化的(基本和required相同, 但required会被框架提示)</li></ul><p>容器类型:<br>主要使用编程语言无关的数据结构作为容器, 一般就三个:</p><ul><li>list<t>: 有序表, 允许元素重复</t></li><li>set<t>: 无序表, 不容许元素重复</t></li><li>map<t,t>: 键类型为t, 值类型为t的kv对, 键不容许重复</t,t></li></ul><p>生成的代码中, 不同语言对应的数据结构可能有一些差异, 但是不影响其功能.</p><p>服务类型:<br>就是trift文件中的service, 代码中等价于类或者接口集合(代码中支持继承, 但如果继承这个类, 其方法必须实现), 但接口里面定义的方法不支持重载.<br>由上面的实践来看, 参数一般是const类型, 并且最终生成的代码和你定义的service函数原型可能不一样, 可能会根据具体的语言进行调整(具体规则, 需要参考它的gen代码生成器).</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>Thrift自动生成代码的代码框架被直接硬编码(hardcode)到了代码生成器里(不知道Facebook有没有工具)，因此对生成代码的结构进行修改需要重新编译Thrift，并不是十分方便。如果Thrift将代码结构保存到一个模板文件里，修改生成代码就会相对容易一些。</p><p>自动生成的代码就会遵守一定的命名规则。Thrift中几种主要的命名规则为:</p><pre><code>1.    IDLName + ”_types.h” ：用户自定义数据类型头文件2.    IDLName + ”_constants.h” ：用户自定义的枚举和常量数据类型头文件3.    ServiceName + “.h” ：Server端Processor定义和Client定义头文件----------------------------------------------------------------------------------------4.    ServericeName + ”_” + RPC名称 + “_args” ：服务器端RPC参数解析类---统一参数解析类5.    ServericeName + ”_” + RPC名称 + “_result” ：服务器端RPC返回值打包类6.    ServericeName + ”_” + RPC名称 + “_pargs” ：客户端RPC参数打包类7.    ServericeName + ”_” + RPC名称 + “_presult” ：客户端RPC返回值解析类8.    “process_” + RPC名称：服务器端RPC调用处理函数9.    “send_” + RPC名称：客户端发送RPC请求的方法10.    “recv_” + RPC名称：客户端接收RPC返回的方法</code></pre><p>统一参数解析类和处理方法的设想:<br>客户端和服务器的参数解析和返回值解析, 虽然针对的是同样的数据结构, 但是 thrift 并没有使用同一个类来完成任务, 而是将客户端和服务器的解析类分开. (TProcess和Client)</p><blockquote><p>当 RPC 调用参数含有相同信息并需要进行相同操作的时候, 对参数解析类的集中管理就会变得非常有必要了. 比如在一些用 thrift 实现访问控制的系统中, 每一个 RPC 调用都会加一个参数token作为访问凭证(是否可以访问), 并在每一个用户函数里进行权限检查. 使用 <code>统一的参数解析类接口</code> 的话, 就可以将分散的权限检查集中到一块进行处理. thrift 中有众多的解析类, 这些解析类的接口类似, 但是却没有一个共有的基类. 对参数的集中管理造成了一定的困难. 如果Thrift为解析类建立一个基类, 并把解析类指针放到一个Map中, 这样参数就可以进行集中管理, 不仅可以进一步减小自动生成代码的体积, 也满足了对参数进行统一管理的需求.</p></blockquote><p>下面开始重头戏.</p><hr><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>框架本身有很多精华, 我抽取其中我熟悉的进行分析.</p><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>该部分其实是解释thrift框架如何工作的, 形式上是c-s一次通信的过程; 这个要结合源码起来看(下面图片请在新窗口中打开观看), 不同源码版本可能不一样.</p><p>服务端主要流程如下:</p><blockquote><p>TThreadPoolServer 的 serve() 方法后，server 进入阻塞监听状态，其阻塞在 TServerSocket 的 accept()方法上。当接收到来自客户端的消息后，服务器发起一个新线程处理这个消息请求，原线程再次进入阻塞状态。在新线程中，服务器通过 TBinaryProtocol 协议读取消息内容，调用 HelloServiceImpl 的 helloVoid() 方法，并将结果写入 helloVoid_result 中传回客户端。</p></blockquote><p>过程如下图:(下面的图请单独拉开网页看)<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_call_1.png" alt="server"></p><p>(整理处理流程比较简单, 就是调用过程负责)</p><p>客户端的处理流程如下: (下面的图请单独拉开网页看)</p><blockquote><p>程序调用了 Hello.Client 的 helloVoid() 方法，在 helloVoid() 方法中，通过 send_helloVoid() 方法发送对服务的调用请求，通过 recv_helloVoid() 方法接收服务处理请求后返回的结果。远程rpc调用过程,以及网络传输过程, 全部被封装在框架里了.</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/thrift_call_2.png" alt="client"></p><h3 id="Server工作模式"><a href="#Server工作模式" class="headerlink" title="Server工作模式"></a>Server工作模式</h3><p>但凡后端人员接触这个库, 我觉得最感兴趣的, 一定是server的类型, 即服务器的工作模式. 当然网络编程玩烂的后端人员真正剖析的识货, 也就是见怪不怪了. (不知道我说啥的同学, 可以补一下 apue的9种网络模式或者参考unp 卷1)</p><p>下面主要剖析一下(权做复习):</p><ul><li>TSimpleServer</li><li>TNonblockingServer</li><li>THsHaServer</li><li>TThreadPoolServer</li><li>TThreadedSelectorServer—优先剖析</li></ul><h3 id="连接池实现"><a href="#连接池实现" class="headerlink" title="连接池实现"></a>连接池实现</h3><p>再讲线程相关的内容时, 我连着对象池, 连接池, 线程池一起说了. 请参考本博客里线程池相关内容.</p><p>(谁有时间再来看它的连接池接口代码吧—不懂源码不影响使用流程的)</p><h2 id="对比其他框架"><a href="#对比其他框架" class="headerlink" title="对比其他框架."></a>对比其他框架.</h2><p>看到的RPC框架或者有RPC功能的框架已经算比较多的了, protobuffer, soap, grpc, 甚至libevent也说自己是rpc框架.</p><p>pb更多的是提供了跨语言的序列化和反序列化机制, 而thrift则是在数据结构信息中提供了消息头用来进行RPC, 详细信息可以参考下图:(thrift消息体逻辑结构)</p><p><img src="http://omotkhw3y.bkt.clouddn.com/thrift_rpc.jpg" alt=""></p><p>优点:</p><ul><li>用于搭建大型数据交换及存储的通用工具， 对于大型系统中的内部数据传输相对于 JSON 和 XML 无论在性能、传输大小上有明显的优势.</li><li>拥有比较完整的体系(内嵌完整的RPC层次), 省去了很多手工编码的机会.</li><li>多语言, 多数据类型支持(支持的语言比pb多, 还支持容器数据结构)</li><li>运行开销性能比pb略好(cpu占用率维持在30%以内)<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_load.jpg" alt=""></li></ul><p>缺点:</p><ul><li>框架庞大(IDL借鉴与CORBA, 完成了整个服务端和客户端的架构体系), 排查错误费时间</li><li>thrift是完全静态化的描述文件(生成器是硬编码而不是依据模板来的), 一旦数据结构发生改变, 须重新编辑IDL文件, 代码生成, 再编译载入的流程(和pb相比较弱)</li><li>传输性能上比pb要略差(即使是压缩二进制 TCompactProtocol方式)</li><li>参考资料少啊!</li></ul><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>综合一圈玩下来, 这个库太棒了, 把我从学习网络以来的绝大部分工作全部整合成流程了, 而且效率也不差(参考网友的评测).</p><p>但是就是坑太多! 如果你没有把它大部分源码吃透, 目前还不适合用于实际工程项目(我是指你负责这个项目工程的兜底工作), 并且由于其框架太重, 所以可能学习成本会稍高.</p><p>墨镜王(王家卫导演啦)东邪西毒里有一句话, </p><blockquote><p>“男人看见一座山总想翻过去, 看看山的那一边是什么, 等真正翻过去了, 也没发现有什么好, 说不定山的这一边儿反而更好.”</p></blockquote><p>以后等它成熟了再来, 目前libevent + 手写代码(或者pb), 挺好的. (但是这个 <code>库的学习价值真的很高</code> , 比如说在线程管理上, 它用 boost::shared_ptr 弱引用保证被多个线程接纳的已死对象的清理工作; 并且在保证返回给调用者一定能拿到操作系统创建的线程时使用了弱引用指向自身, 这样在真正拿到线程之前就能保证不被操作系统过早清理掉–过早返回给ThreadMain的调用者是有可能被清理掉的…等等技巧)</p><blockquote><p>这个库没有说完, 以后有时间再回来更新.</p></blockquote><p>好累.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://thrift.apache.org/" target="_blank" rel="external">http://thrift.apache.org/</a></li><li><a href="https://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="external">https://en.wikipedia.org/wiki/Apache_Thrift</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift</a></li><li><a href="http://thrift.apache.org/static/files/thrift-20070401.pdf" target="_blank" rel="external">http://thrift.apache.org/static/files/thrift-20070401.pdf</a></li><li><a href="https://wiki.apache.org/thrift/ThriftInstallation" target="_blank" rel="external">https://wiki.apache.org/thrift/ThriftInstallation</a></li><li><a href="https://wiki.apache.org/thrift/FrontPage" target="_blank" rel="external">https://wiki.apache.org/thrift/FrontPage</a></li><li><a href="http://www.cnblogs.com/cyfonly/p/6059374.html" target="_blank" rel="external">和 Thrift 的一场美丽邂逅</a> 文章有一些地方讲述错误</li><li><a href="http://blog.csdn.net/houjixin/article/details/42779915" target="_blank" rel="external">http://blog.csdn.net/houjixin/article/details/42779915</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      经典的跨语言编程框架Thrift, 有着protobuffer无法匹敌的, 庞大...
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Jni</title>
    <link href="www.merlinblog.site/2017/08/22/jni.html"/>
    <id>www.merlinblog.site/2017/08/22/jni.html</id>
    <published>2017-08-22T00:08:12.000Z</published>
    <updated>2017-09-24T07:21:13.671Z</updated>
    
    <content type="html"><![CDATA[<p>“Java Native Interface” , 最初是在Android NDK编程的时候接触的, 不过个人对于客户端开发一直没有太大的兴趣, 所以自那之后也搁置了很久.</p><p>近期正好总结<code>跨语言编程实践</code>, 那么正好也就写一写, 就当写了一个中文的简要参考手册.</p><p>(参考资料中的第一本书推荐一下)</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>跨语言的调用怎么弄? 这个话题, 太大了, 我倒是可以给你推荐一个框架, 脸书的Thrift; 这里只考虑 Java 和 C 的互相调用的话(调用方向不一样,方式也有稍稍不同, 复杂度也不一样), 就引出了JNI技术(JNI本身是native接口, 但在编程框架中更像一种协议), 专门针对Java和C交互.</p><p>我想最初设计这个框架的人一定考虑了至少3个问题:</p><ul><li>跨语言对象的对接问题</li><li>数据类型规格问题</li><li>调用效率问题</li></ul><p>JNI允许运行在Java虚拟机的Java代码与用其他语言(如C, C++和汇编)编写的库交互, 通过JNI, 可以在native code中完成至少下面的事情:</p><ul><li>创建、检查或者更新java对象</li><li>调用java方法</li><li>捕捉和抛出异常</li><li>加载class和获取class信息</li><li>运行时类型检查</li></ul><p>理论太啰嗦了, 不说了. 下面详细介绍这些技术, 以及常见的开发流程.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="Java主调C代码"><a href="#Java主调C代码" class="headerlink" title="Java主调C代码."></a>Java主调C代码.</h3><p>也就是说实现部分是在C, Java部分就是起到简单的调用.</p><p>根据Java代码, 使用相应的编译器Javap生成本地访问头文件, 然后C代码中引用该头文件, 返回操作结果. Java代码中虚拟机运行时加载相应的本地代码(可能需要LoadLibrary), 从而完成java代码调用C代码.</p><p>流程归纳起来就是:<br>编译,加载,链接本地方法.</p><ul><li>编译:<br>java VM是多线程的 ，所以native libraries应该用多线程编译器来进行编译和链接。例如使用Sun Studio compiler编译器的时候，要为c++代码添加-mt标记；使用 GNU gcc compiler的时候，需添加-D_REENTRANT 或-D_POSIX_C_SOURCE</li><li>加载<br>native库通过System.loadLibrary方法进行加载。如：<br>```c++<br>package pkg;  </li></ul><p>class Cls { </p><pre><code> native double f(int i, String s);  static {      System.loadLibrary(“pkg_Cls”);  } </code></pre><p>} </p><pre><code> 系统会对library名会进行转换，在不同平台上有不同的转换方式，例如，Solaris系统转换pkg_Cls为libpkg_Cls.so，而Win32系统转换pkg_Cls为pkg_Cls.dll* 链接 如果系统不支持动态链接，那么所有本地方法需要预链接到虚拟机，这种情况下，VM已经完成System.loadLibrary了。程序员也可以调用JNI函数RegisterNatives()来注册该类关联的本地方法### C主调Java代码这个相对来说, 应该算作被动调用(需求比较少), C语言回调Java方法.根据Java代码生成相应的C代码的步骤是一样的, `javap -jni 包名.类名`, 然后在本地代码中引入生成的头文件, 然后根据该头文件的函数, 给出函数实现.但是在函数实现中, 就开始利用虚拟机的特性, 开始`反射`的写法了, 比如你的反射可能是这么写的:```javaClass&lt;?&gt; instance = Class.forName(&quot;com.example.Test&quot;);Method declearMethod = instance.getDeclaredMethod(&quot;intMethod&quot;, new Class[]{});declearMethod.invoke(instance.newInstance(), new Object[]{});</code></pre><p>那么在本地代码写法也类似, 先要拿到Class类型, 之后找到方法(ID), 然后再进行调用处理, 核心代码可能是:</p><pre><code class="c++">//在某本地函数体内 jclass jclazz = (*env)-&gt;FindClass(env, &quot;com/example/Test&quot;);jmethodID methodId = (*env)-&gt;GetMethodID(env, jclazz, &quot;intMethod&quot;, &quot;()V&quot;/*方法签名符号,约定参数和返回值*/);(*env)-&gt;CallVoidMethod(env, jobject, methodId); //jobject是本地函数默认的参数</code></pre><p>(如果是返回值的可能要用其他的JNI方法)</p><p>(方法签名可以看下面的规则, 得知其符号规则; 或者使用javap工具通过字节码拿到方法签名<code>javap -s</code>)</p><p>但是值得注意的是C回调Java代码, 是发生在Java代码调用C代码的时候, 发现自己被回调了; 毕竟运行都是在虚拟机的主导下(也就是说没有虚拟机环境是不行的). </p><p>C回调的方法一定要和jobject是同一个类型的(jobject实例所在的类), 如果你在该类的这个本地方法里, 调用其他Java类的方法, 还要增加处理:需要创建相关类的对象(就是拿到局部引用,AllObject或者NewObject方法)或者获取类的信息(静态方法调用GetStaticMethodID(), CallStaicVoidMethod()等), 例如</p><pre><code class="c">//先FindClass 返回一个jclass对象clazz, 并且拿到methodIDjobject obj = (*env)-&gt;AllocObject(env, clazz);(*env)-&gt;CallVoidMethod(env, obj, methodId);</code></pre><p>但是回调的场景, 最好还是放在同一个类吧, 不要跨类方法调用.</p><h2 id="本地方法规范"><a href="#本地方法规范" class="headerlink" title="本地方法规范"></a>本地方法规范</h2><p>Java方法, 如果转换(编译)到本地代码, 对应哪个方式其实是有讲究的, 例如:</p><pre><code class="java">package pkg;  class Cls {     //对应本地方法名: Java_pkg_Cls_f__ILjava_lang_String_2,    //参数列表:JNIEnv *env,jobject obj,jint i,jstring s    native double f(int i, String s); p}</code></pre><p>下面就仔细讲解一下对应的映射或者编译规则.</p><h3 id="命名符号解析"><a href="#命名符号解析" class="headerlink" title="命名符号解析"></a>命名符号解析</h3><p>一个本地方法名有以下几个组成部分：</p><ul><li>前缀Java_</li><li>完整类名（类名中的.用_代替）</li><li>下划线_</li><li>方法名（方法名中的特殊字符需要转义）</li><li>参数签名（非必须，有重载方法的时候才需要），如果有重载的本地方法，需要再添加两个下划线_<em>，然后再添加方法签名（由java字段描述符描述，用</em>代替描述符中的包名分割/符，签名中的特殊字符需要转义）</li></ul><p>关于转义:</p><ul><li>_0XXXX    一个Unicode字符XXXX。注意小写是用来表示非ascii Unicode字符, 如:_0abcd与_0ABCD不相同</li><li><em>1        字符</em></li><li>_2        参数签名中的字符;</li><li>_3        参数签名中的字符[</li></ul><h3 id="类型符号解析"><a href="#类型符号解析" class="headerlink" title="类型符号解析"></a>类型符号解析</h3><p>注意这些规则, 对应的是用在函数或者参数名字上(java和c数据类型对应有另外一套规则)<br>命名中的类型(Java类型对应本地符号)规则, 如下:</p><pre><code>Boolean        ZByte        BChar        CShort        SInt        ILong        J (特殊)Float        FDouble        DVoid        V</code></pre><p>特殊的有数组和对象:</p><pre><code>数组:   &quot;[类型&quot; 表示, 如：int[]-&gt; [I, int[][]-&gt; [[I, Thread[]-&gt; [Ljava/lang/Thread;objects:   以&quot;L&quot;开头, 以&quot;;&quot;结尾, 用&quot;/&quot; 隔开的包及类名. 比如: Ljava/lang/String;   如果是嵌套类, 则用$来表示嵌套, 例 Landroid/os/FileUtils$FileStatus;</code></pre><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>一个Java方法, 编译到native code会自然多出两个参数, 一个代表JNI接口指针类型(Java虚拟机环境), 另外一个是对象实例的引用(通俗来说就是this指针, 当然进程方法可以不用).</p><p>例如:<br>Java代码:</p><pre><code class="java">package pkg;  class Cls {      native double f(int i, String s); }</code></pre><p>编译到C代码就是:</p><pre><code class="c++">/*c和c++在使用JNI接口的时候有点不一致,    请仔细观察通过env调用接口的调用方式 *///C版本jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (     JNIEnv *env,        /* interface pointer */     jobject obj,        /* &quot;this&quot; pointer */     jint i,             /* argument #1 */     jstring s)          /* argument #2 */{     /* Obtain a C-copy of the Java string */     const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0);     /* process the string */     ...     /* Now we are done with str */     (*env)-&gt;ReleaseStringUTFChars(env, s, str);     return ...}//C++版本extern &quot;C&quot; /* specify the C calling convention */  jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (      JNIEnv *env,        /* interface pointer */      jobject obj,        /* &quot;this&quot; pointer */      jint i,             /* argument #1 */      jstring s)          /* argument #2 */ {      const char *str = env-&gt;GetStringUTFChars(s, 0);      ...      env-&gt;ReleaseStringUTFChars(s, str);      return ... }</code></pre><h3 id="对象类型解析"><a href="#对象类型解析" class="headerlink" title="对象类型解析"></a>对象类型解析</h3><p>本地代码中的参数, 才不管你Java类的具体类型, 统一jobject类型;<br>当然也可以对应更细致(也不那么细致):<br><img src="http://omotkhw3y.bkt.clouddn.com/jobject.jpg" alt="jobject"></p><p>java对象引用:</p><ul><li>基本类型（如整型，字符等）在Java和native之间是采用值传递</li><li>Java对象采用的是引用(地址)传递(Java语言本身封装了指针)</li></ul><p>全局引用&amp;弱全局引用, 局部引用:</p><ul><li>局部引用在方法调用的时候有效，在方法调用结束之后会自动释放</li><li>全局引用会一直可用，直到显式地对其进行释放</li><li>弱全局引用跟全局引用的区别是弱全局引用持有的java对象可以被VM进行回收，所以才使用弱全局引用前，我们需要对其进行检测，看它对应的对象是否被回收了</li></ul><p>JNIENV方法:</p><ul><li>返回的Java对象都是局部引用</li><li>可以接受全局引用和全局引用</li></ul><p>native方法: (C方法)</p><ul><li>可以返回局部或者全局引用</li><li>接收的一般是局部引用(Java对象)</li></ul><p>并且JNI允许程序从局部引用创建一个全局引用.</p><p>native代码中的局部的对象, 该怎么释放?</p><ul><li>在方法调用结束之后，我们依赖VM去帮我们释放所有局部引用</li><li>以下几种情况下，我们应该显式地释放局部引用:<ul><li>方法中创建了一个比较大的java对象的，并持有其局部引用，使用完之后，如果接下来都不再需要使用了，如果仍然不对它进行释放的话，在方法结束之前，这个对象都不会进行释放，这样会对资源造成浪费</li><li>JNI会将创建的局部引用都存储在一个局部引用表中，如果这个表超过了最大容量限制，就会造成局部引用表溢出，使程序崩溃。比如在一个循环中创建局部引用，最好在每一轮循环中释放局部引用，否则随着循环次数增加，很可能就内存溢出了</li></ul></li></ul><p>局部引用仅仅在其创建的线程内有效(也就是占用的是本地代码的栈空间), native代码不能跨线程传递局部引用.</p><h3 id="类型别名解析"><a href="#类型别名解析" class="headerlink" title="类型别名解析"></a>类型别名解析</h3><p>上面的jint, 其实是JNI定义的别名(具体对应什么可以自己定义), 对应的可能是标准C中的long, 其实你也可以使用c语言标准中的int类型.</p><p>详细的信息可以参考下面:</p><pre><code>Java 类型   JNI类型别名         描述boolean        jboolean         unsigned char, 8 bitsbyte        jbyte         signed char, 8 bitschar        jchar         unsigned short, 16 bitsshort        jshort         signed short, 16 bitsint        jint         signed long, 32 bitslong        jlong         __int64, signed long long,  64 bitsfloat        jfloat         float, 32 bitsdouble        jdouble         double 64 bitsvoid        void         N/A</code></pre><p><img src="http://omotkhw3y.bkt.clouddn.com/jni.jpg" alt="别名"><br>当然你也可以选择使用或者不用:(默认使用)</p><pre><code>#define JNI_FALSE  0 #define JNI_TRUE   1</code></pre><p>注意到char使用的双字节编码, 而不是单字节编码，所以Java虚拟机的UTF-8字符串不可能有嵌入的空值; 并且不支持标准的四字节编码，用 two-times-three-byte 格式代替</p><h3 id="调用Java方法"><a href="#调用Java方法" class="headerlink" title="调用Java方法"></a>调用Java方法</h3><p>JNI允许native代码访问对象的成员以及调用它的方法，通过两个步骤即可实现访问，比如，我们需要调用cls中的f方法：</p><pre><code class="c">jmethodID mid = env-&gt;GetMethodID(cls, “f”, “(ILjava/lang/String;)D”);//mid可以重复使用jdouble result = env-&gt;CallDoubleMethod(obj, mid, 10, str);</code></pre><p>但是需要注意的是，字段ID或方法ID并不能防止VM卸载该类. 当类被卸载后, 方法ID和字段ID将变成不可用的. 因此，我们需要确保： </p><ul><li>持有class的引用，让它不被卸载，或者 </li><li>重新获取方法id或者字段id</li></ul><p>关于<code>jmethodID</code>:<br>在C中, 字段和方法的 ID 是一个指向结构体的指针:</p><pre><code class="c">struct _jfieldID;                       /* opaque structure */typedef struct _jfieldID* jfieldID;     /* field IDs */struct _jmethodID;                      /* opaque structure */typedef struct _jmethodID* jmethodID;   /* method IDs */</code></pre><h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><pre><code class="c">//方法签名为：(ILjava/lang/String;[I)J long f (int n, String s, int[] arr);</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>JNI不对空指针或非法参数类型等错误进行检测, 因为:</p><ul><li>检查所有可能的错误会降低方法执行的性能</li><li>在很多时候，没有足够的运行时信息去进行检测<br>程序员不得传递一个非法指针或者错误的类型给JNI函数, 否则可能会导致系统异常货虚拟机崩溃.</li></ul><p>JNI允许本地方法抛出处理任何异常，也可以处理Java中抛出的异常，剩下没有处理的异常会继续给VM处理.</p><h3 id="Java部分处理"><a href="#Java部分处理" class="headerlink" title="Java部分处理:"></a>Java部分处理:</h3><p>大多数情况下，JNI提供的方法通过返回错误码或者抛出java异常来处理错误，因此，程序中可以:</p><ul><li>检查JNI函数返回值</li><li>调用 ExceptionOccurred() 方法，获取方法中抛出的异常</li></ul><p>有两种情况下，程序需要优先检测java异常而不是先检测返回码:</p><ul><li>通过JNI调用Java方法的时候，需要ExceptionOccurred()检测是否在Java方法中抛出了异常</li><li>一些访问数组的方法，它不返回错误码，但是会抛出 ArrayIndexOutOfBoundsException 或者 ArrayStoreException异常</li></ul><h3 id="本地部分处理"><a href="#本地部分处理" class="headerlink" title="本地部分处理"></a>本地部分处理</h3><p>有两种方法可以在本地方法中处理异常:</p><ul><li>检测到异常的时候立即返回，异常将会在调用该本地代码的地方抛出</li><li>在本地方法中调用ExceptionClear()清除异常，处理接下来的逻辑</li></ul><p>异常抛出的时，本地方法需清除异常后，才能继续调用其他JNI接口方法.</p><p>有异常发生后，只有以下方法才能被安全调用：</p><pre><code>  ExceptionOccurred()  ExceptionDescribe()  ExceptionClear()  ExceptionCheck()  ReleaseStringChars()  ReleaseStringUTFChars()  ReleaseStringCritical()  Release&lt;Type&gt;ArrayElements()  ReleasePrimitiveArrayCritical()  DeleteLocalRef()  DeleteGlobalRef()  DeleteWeakGlobalRef()  MonitorExit()  PushLocalFrame()  PopLocalFrame()</code></pre><h2 id="JNI接口详解"><a href="#JNI接口详解" class="headerlink" title="JNI接口详解"></a>JNI接口详解</h2><p>花时间阅读那个 <code>jni.h</code>, 以及参考文档.</p><p>JNI函数必须接受一个非空对象，你必须保证传入的参数不为空，JNI函数不需要再对它进行空指针判断.</p><h3 id="返回码说明"><a href="#返回码说明" class="headerlink" title="返回码说明"></a>返回码说明</h3><pre><code class="c">#define JNI_OK          (0)         /* no error */#define JNI_ERR         (-1)        /* generic error */#define JNI_EDETACHED   (-2)        /* thread detached from the VM */#define JNI_EVERSION    (-3)        /* JNI version error */#define JNI_COMMIT      1           /* copy content, do not free buffer */#define JNI_ABORT       2           /* free buffer w/o copying back */</code></pre><h3 id="接口代码说明"><a href="#接口代码说明" class="headerlink" title="接口代码说明"></a>接口代码说明</h3><p>该部分比较多(1000多行), 有一定的注释</p><pre><code class="c">    /**     * 返回本地方法接口的版本     *     * @param env JNI接口指针     *     * @return 高16位返回主版本号，低16位返回次版本号,       如在JDK/JRE 1.6中，返回0x00010006      也有可能返回 JNI_EDETACHED 和 JNI_EVERSION 错误码     */    jint (*GetVersion)(JNIEnv *);    /**     * 从二进制的.class的数据缓冲区中加载类     *     * @param env JNI接口指针     * @param name UTF8编码的需要加载的类的名字     * @param loader 类加载器     * @param buf 包含.class字节码的数组     * @param bufLen 长度     *     * @return class对象或NULL     *     * @throws ClassFormatError 不是有效的class数据     * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口     * @throws OutOfMemoryError 内存不足     * @throws SecurityException 如果该类是属于java包的     */    jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize);    /**     * 用于加载本地定义的类     *     * @param env JNI接口指针     * @param name 完整的包名(&quot;/&quot;代替&quot;.&quot;) 或 数组类型字段描述(&quot;[&quot;开头，紧跟签名描述)，        如&quot;java/lang/String&quot; for java.lang.String,           &quot;[Ljava/lang/Object;&quot; for java.lang.Object[]     *     * @return class对象或NULL     *     * @throws ClassFormatError 不是有效的class数据     * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口     * @throws OutOfMemoryError 内存不足     * @throws NoClassDefFoundError 找不到name对应的class类     */    jclass (*FindClass)(JNIEnv *, const char *);    /**     * 从java.lang.reflect.Method 或 java.lang.reflect.Constructor 获取method ID     *     * @param env JNI接口指针     * @param method java.lang.reflect.Method 或 java.lang.reflect.Constructor对象     *     * @return 方法ID     */    jmethodID (*FromReflectedMethod)(JNIEnv *, jobject);    /**     * 从java.lang.reflect.Field获取field ID     *     * @param env JNI接口指针     * @param field java.lang.reflect.Field对象     *     * @return field ID     */    jfieldID (*FromReflectedField)(JNIEnv *, jobject);    /**     * 从method ID获取 java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象     *     * @param env JNI接口指针     * @param cls 该方法的类对象     * @param methodID 方法ID     * @param isStatic 是否静态方法     *     * @return java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象     *     * @throws OutOfMemoryError 内存不足     */    jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean);    /**     * 如果clazz不是class对象或接口，则返回该class的超类     *     * @param env JNI接口指针     * @param clazz class对象     *     * @return 返回输入类的父类 或 NULL     */    jclass (*GetSuperclass)(JNIEnv *, jclass);    /**     * class1是否可以安全地转换为class2，以下三种情况会返回TRUE     * 1. 当class1和class2是同一个java class的引用     * 2. class1是class2的子类     * 3. class2是class1的某个接口     *     * @param env JNI接口指针     * @param clazz1 class1     * @param clazz2 class2     *     * @return JNI_TRUE or JNI_FALSE     */    jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass);    /**     * 根据 field ID 获取 java.lang.reflect.Field 对象     *     * @param env JNI接口指针     * @param cls 该方法的类对象     * @param fieldID 字段ID     * @param isStatic 是否静态变量     *     * @return java.lang.reflect.Field 对象     *     * @throws OutOfMemoryError 内存不足     */    jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean);    /**     * 抛出异常     *     * @param env JNI接口指针     * @param obj java.lang.Throwable 对象     *     * @return 0：成功， 负数：失败     *     * @throws Throwable     */    jint (*Throw)(JNIEnv *, jthrowable);    /**     * 根据clazz和message构造一个异常对象，并将它抛出     *     * @param env JNI接口指针     * @param clazz java.lang.Throwable的子类     * @param message 错误信息     *     * @return 0：成功， 负数：失败     *     * @throws Throwable     */    jint (*ThrowNew)(JNIEnv *, jclass, const char *);    /**     * 判断是否有异常抛出，在调用ExceptionClear()或java代码处理了exception之前，都可以用这个方法判断是否有异常     *     * @param env JNI接口指针     *     * @return 异常对象 or NULL     */    jthrowable (*ExceptionOccurred)(JNIEnv *);    /**     * 打印异常信息     *     * @param env JNI接口指针     */    void (*ExceptionDescribe)(JNIEnv *);    /**     * 清除所有已抛出的异常     *     * @param env JNI接口指针     */    void (*ExceptionClear)(JNIEnv *);    /**     * 抛出致命错误并且不希望虚拟机进行恢复。无返回值     *     * @param env JNI接口指针     * @param msg 错误信息     */    void (*FatalError)(JNIEnv *, const char *);    /**     * 创建一个新的本地引用帧     *     * @param env JNI接口指针     * @param capacity 容量     *     * @return 0：成功，负数：失败     *     * @throws OutOfMemoryError     */    jint (*PushLocalFrame)(JNIEnv *, jint);    /**     * 弹出当前本地引用帧，释放所有本地引用     *     * @param env JNI接口指针     * @param result     *     * @return     */    jobject (*PopLocalFrame)(JNIEnv *, jobject);    /**     * 为传入的obj创建全局引用，obj可以是全局引用也可以是局部引用。全局引用需要调用DeleteGlobalRef来释放     *     * @param env JNI接口指针     * @param obj 全局或局部引用     *     * @return 全局引用 or NULL(内存不足)     */    jobject (*NewGlobalRef)(JNIEnv *, jobject);    /**     * 释放全局引用     *     * @param env JNI接口指针     * @param globalRef 全局引用     */    void (*DeleteGlobalRef)(JNIEnv *, jobject);    /**     * 释放局部引用     *     * @param env JNI接口指针     * @param localRef 局部引用     */    void (*DeleteLocalRef)(JNIEnv *, jobject);    /**     * 判断两个引用是否同一java对象的引用     *     * @param env JNI接口指针     * @param ref1 引用1     * @param ref2 引用2     *     * @return JNI_TRUE:两个引用指向同一个java对象     */    jboolean (*IsSameObject)(JNIEnv *, jobject, jobject);    /**     * 为传入的ref创建局部引用，ref可以是全局引用也可以是局部引用     *     * @param env JNI接口指针     * @param ref 全局或局部引用     *     * @return 局部引用 or NULL     */    jobject (*NewLocalRef)(JNIEnv *, jobject);    /**     * 确保当前线程可以创建capacity个局部引用。在进入本地方法时，VM确保可以可以创建最少16个局部引用     *     * @param env JNI接口指针     * @param capacity 局部引用个数     *     * @return 0：成功，负数：失败     *     * @throws OutOfMemoryError 内存不足     */    jint (*EnsureLocalCapacity)(JNIEnv *, jint);    /**     * 创建一个新的java对象（不会调用对象的构造方法）     *     * @param env JNI接口指针     * @param clazz 非数组class对象     *     * @return java对象     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*AllocObject)(JNIEnv *, jclass);    /**     * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得     *     * @param env JNI接口指针     * @param clazz 非数组class对象     * @param ... 传递给构造方法的参数     *     * @return java对象 or NULL(对象构造失败)     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*NewObject)(JNIEnv *, jclass, jmethodID, ...);    /**     * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得     *     * @param env JNI接口指针     * @param clazz 非数组class对象     * @param args va_list结构，里面有传递给构造方法的参数     *     * @return java对象 or NULL(对象构造失败)     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list);    /**     * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得     *     * @param env JNI接口指针     * @param clazz 非数组class对象     * @param args 参数数组，里面是传递给构造方法的参数     *     * @return java对象 or NULL(对象构造失败)     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, jvalue *);    /**     * 返回对象对应的class对象     *     * @param env JNI接口指针     * @param obj 非空java对象     *     * @return class对象     */    jclass (*GetObjectClass)(JNIEnv *, jobject);    /**     * 判断obj是否clazz的实例对象     *     * @param env JNI接口指针     * @param obj java对象     * @param clazz class对象     *     * @return     */    jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass);    /**     * 返回非静态方法的method ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 方法名     * @param sig 方法签名     *     * @return 方法ID or NULL     *     * @throws NoSuchMethodError 找不到对应的方法     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *);    /**     * Call&lt;type&gt;Method(JNIEnv *env, jobject obj, jmethodID methodID, ...);调用参数放到可变参数中     * Call&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组     * Call&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);调用参数放入va_list结构中     *     * 以上三组调用接口都是根据 method ID调用java实例方法（非静态方法）的接口，其中method ID是通过GetMethodID()获取的     * 当这些方法用于调用java对象的私有方法或构造函数时，method ID必须从obj的真实类获取，而不应从其某个父类获取     * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同     *     *     * @param env JNI接口指针     * @param obj java对象     * @param methodID 方法ID     * @param args 调用参数     *     * @return java方法返回结果     *     * @throws java方法中可能抛出的异常     */    jobject (*CallObjectMethod)(JNIEnv *, jobject, jmethodID, ...);    jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jboolean (*CallBooleanMethod)(JNIEnv *, jobject, jmethodID, ...);    jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jbyte (*CallByteMethod)(JNIEnv *, jobject, jmethodID, ...);    jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jchar (*CallCharMethod)(JNIEnv *, jobject, jmethodID, ...);    jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jshort (*CallShortMethod)(JNIEnv *, jobject, jmethodID, ...);    jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jint (*CallIntMethod)(JNIEnv *, jobject, jmethodID, ...);    jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jlong (*CallLongMethod)(JNIEnv *, jobject, jmethodID, ...);    jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jfloat (*CallFloatMethod)(JNIEnv *, jobject, jmethodID, ...);    jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jdouble (*CallDoubleMethod)(JNIEnv *, jobject, jmethodID, ...);    jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    void (*CallVoidMethod)(JNIEnv *, jobject, jmethodID, ...);    void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list);    void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    /**     * CallNonvirtual&lt;type&gt;Method(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中     * CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组     * CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中     *     * 以上三组调用接口都是根据 method ID 和 class 调用java实例方法（非静态方法）的接口，其中method ID是基于clazz通过GetMethodID()获取的     * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同     * 注意，和Call&lt;type&gt;Method不同，如果子类重写了父类的方法，Call&lt;type&gt;Method调用的是子类的方法，如果想调用父类的方法，     * 则需要用CallNonvirtual&lt;type&gt;Method，这个方法可以传入父类的class和父类的method id，从而达到调用父类方法的效果     *     *     * @param env JNI接口指针     * @param clazz class对象     * @param obj java对象     * @param methodID 方法ID     * @param args 调用参数     *     * @return java方法返回结果     *     * @throws java方法中可能抛出的异常     */    jobject (*CallNonvirtualObjectMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jboolean (*CallNonvirtualBooleanMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jbyte (*CallNonvirtualByteMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jchar (*CallNonvirtualCharMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jshort (*CallNonvirtualShortMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jint (*CallNonvirtualIntMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jlong (*CallNonvirtualLongMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jfloat (*CallNonvirtualFloatMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jdouble (*CallNonvirtualDoubleMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    void (*CallNonvirtualVoidMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    /**     * 根据class对象获取非静态成员变量的field ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 变量名     * @param sig 变量签名     *     * @return field ID or NULL     *     * @throws NoSuchFieldError 找不到对应的变量ID     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *);    /**     * 根据field id取出对象中相应的变量值，field Id通过GetFieldID()获取     *     * @param env JNI接口指针     * @param obj java对象     * @param fieldID 有效的field id     *     * @return 相应的变量值     */    jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID);    jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID);    jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID);    jchar (*GetCharField)(JNIEnv *, jobject, jfieldID);    jshort (*GetShortField)(JNIEnv *, jobject, jfieldID);    jint (*GetIntField)(JNIEnv *, jobject, jfieldID);    jlong (*GetLongField)(JNIEnv *, jobject, jfieldID);    jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID);    jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID);    /**     * 根据field id为相应的变量设置新的值，field Id通过GetFieldID()获取     *     * @param env JNI接口指针     * @param obj java对象     * @param fieldID 有效的field id     * @param value 要设置的值     */    void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject);    void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean);    void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte);    void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar);    void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort);    void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint);    void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong);    void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat);    void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble);    /**     * 返回静态方法的method ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 方法名     * @param sig 方法签名     *     * @return 方法ID or NULL     *     * @throws NoSuchMethodError 找不到对应的方法     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *);    /**     * CallStatic&lt;type&gt;Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中     * CallStatic&lt;type&gt;MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组     * CallStatic&lt;type&gt;MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中     *     * 以上三组调用接口都是根据 method ID调用java静态方法的接口，其中method ID是通过GetStaticMethodID()获取的     * method ID必须从clazz的真实类获取，而不应从其某个父类获取     * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同     *     *     * @param env JNI接口指针     * @param clazz class对象     * @param methodID 方法ID     * @param args 调用参数     *     * @return java方法返回结果     *     * @throws java方法中可能抛出的异常     */    jobject (*CallStaticObjectMethod)(JNIEnv *, jclass, jmethodID, ...);    jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jboolean (*CallStaticBooleanMethod)(JNIEnv *, jclass, jmethodID, ...);    jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jbyte (*CallStaticByteMethod)(JNIEnv *, jclass, jmethodID, ...);    jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jchar (*CallStaticCharMethod)(JNIEnv *, jclass, jmethodID, ...);    jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jshort (*CallStaticShortMethod)(JNIEnv *, jclass, jmethodID, ...);    jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jint (*CallStaticIntMethod)(JNIEnv *, jclass, jmethodID, ...);    jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jlong (*CallStaticLongMethod)(JNIEnv *, jclass, jmethodID, ...);    jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jfloat (*CallStaticFloatMethod)(JNIEnv *, jclass, jmethodID, ...);    jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jdouble (*CallStaticDoubleMethod)(JNIEnv *, jclass, jmethodID, ...);    jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    void (*CallStaticVoidMethod)(JNIEnv *, jclass, jmethodID, ...);    void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list);    void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    /**     * 根据class对象获取静态成员变量的field ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 变量名     * @param sig 变量签名     *     * @return field ID or NULL     *     * @throws NoSuchFieldError 找不到对应的变量ID     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *);    /**     * 根据field id取出对象中相应的变量值，field Id通过GetStaticFieldID()获取     *     * @param env JNI接口指针     * @param clazz class对象     * @param fieldID 有效的field id     *     * @return 相应的静态变量值     */    jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID);    jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID);    jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID);    jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID);    jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID);    jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID);    jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID);    jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID);    jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID);    /**     * 根据field id为相应的静态变量设置新的值，field Id通过GetStaticFieldID()获取     *     * @param env JNI接口指针     * @param clazz class对象     * @param fieldID 有效的field id     * @param value 要设置的值     */    void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject);    void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean);    void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte);    void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar);    void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort);    void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint);    void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong);    void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat);    void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble);    /**     * 创建一个新的java.lang.String对象     *     * @param env JNI接口指针     * @param unicodeChars 指向Unicode字符串的指针     * @param len Unicode字符串的长度     *     * @return String对象 or NULL     *     * @throws OutOfMemoryError 内存不足     */    jstring (*NewString)(JNIEnv *, const jchar *, jsize);    /**     * 返回java.lang.String的长度（Unicode字符数）     *     * @param env JNI接口指针     * @param string String对象     *     * @return 长度     */    jsize (*GetStringLength)(JNIEnv *, jstring);    /**     * 返回指向Unicode字符数组的指针     * 该指针在调用ReleaseStringchars()前一直有效     * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE     *     * @param env JNI接口指针     * @param string String对象     * @param isCopy 指向boolean的指针     *     * @return 指向字符串的指针 or NULL     */    const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *);    /**     * 通知VM无需再访问chars     * chars是一个指针，通过GetStringChars()     *     * @param env JNI接口指针     * @param string String对象     * @param chars 指向字符串的指针     */    void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *);    /**     * 根据UTF-8编码的字符数组创建一个新的java.lang.String对象     *     * @param env JNI接口指针     * @param bytes 指向UTF-8字符串的指针     *     * @return String对象 or NULL     *     * @throws OutOfMemoryError 内存不足     */    jstring (*NewStringUTF)(JNIEnv *, const char *);    /**     * 返回字符串以UTF-8为编码的字节数     *     * @param env JNI接口指针     * @param string String对象     *     * @return 字符串的UTF-8字节数     */    jsize (*GetStringUTFLength)(JNIEnv *, jstring);    /**     * 返回指向UTF-8编码字符数组的指针     * 该指针在调用ReleaseStringUTFChars()前一直有效     * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE     *     * @param env JNI接口指针     * @param string String对象     * @param isCopy 指向boolean的指针     *     * @return 指向字符串的指针 or NULL     */    const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *);    /**     * 通知VM无需再访问utf     * utf是一个指针，通过GetStringUTFChars()     *     * @param env JNI接口指针     * @param string String对象     * @param utf 指向字符串的指针     */    void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *);    /**     * 获取数组元素个数     *     * @param env JNI接口指针     * @param array java数组对象     *     * @return 数组长度     */    jsize (*GetArrayLength)(JNIEnv *, jarray);    /**     * 创建新的elementClass类型数组，所有元素初始值均设为initialElement     *     * @param env JNI接口指针     * @param length 数组大小     * @param elementClass 数组类型     * @param initialElement 初始值     *     * @return 数组对象 or NULL     */    jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject);    /**     * 获取对象数组中指定index的值     *     * @param env JNI接口指针     * @param array java数组     * @param index 索引     *     * @return 索引对象的对象     *     * @throws ArrayIndexOutOfBoundsException     */    jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize);    /**     * 设置对象数组中指定index的值     *     * @param env JNI接口指针     * @param array java数组     * @param index 索引     * @param value 新的值     *     * @throws ArrayIndexOutOfBoundsException     */    void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject);    /**     * ArrayType New&lt;PrimitiveType&gt;Array(JNIEnv *env, jsize length);     * 创建基本类型数组对象     *     * @param env JNI接口指针     * @param length 数组大小     *     * @return 数组对象 or NULL     */    jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize);    jbyteArray (*NewByteArray)(JNIEnv *, jsize);    jcharArray (*NewCharArray)(JNIEnv *, jsize);    jshortArray (*NewShortArray)(JNIEnv *, jsize);    jintArray (*NewIntArray)(JNIEnv *, jsize);    jlongArray (*NewLongArray)(JNIEnv *, jsize);    jfloatArray (*NewFloatArray)(JNIEnv *, jsize);    jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize);    /**     * NativeType *Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);     * 返回基本类型数组中的数据，通过返回的指针可以访问这些数据，若虚拟机支持pinning，则指针指向原始数组，否则指向原始数组的拷贝     * 返回的指针在Release&lt;PrimitiveType&gt;ArrayElements()调用前一直有效     * 数组用使用结束后，调用Release&lt;PrimitiveType&gt;ArrayElements，并在调用参数中决定是否把修改提交给java     *     * @param env JNI接口指针     * @param array java数组     * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE     *     * @return 指向数组元素的指针 or NULL     */    jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *);    jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *);    jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *);    jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *);    jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *);    jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *);    jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *);    jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *);    /**     * Release&lt;PrimitiveType&gt;ArrayElements     * 通知VM不再需要访问这些数组，根据mode参数的不同，将决定是否把数组的修改复制到源数组     *     * @param env JNI接口指针     * @param array java数组对象     * @param elems 指向数组元素的指针     * @param mode 释放模式，0：把数据复制回源数组并释放elems缓冲区，JNI_COMMIT：把数据复制回源数组但不释放elems缓冲区，JNI_ABORT：不把数据复制回源数组，释放elems缓冲区     */    void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint);    void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint);    void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint);    void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint);    void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint);    void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint);    void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint);    void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint);    /**     * void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);     * 把基本类型数组拷贝到buf中     *     * @param env JNI接口指针     * @param array java数组     * @param start 开始index     * @param len 拷贝长度     * @param buf 目标地址     *     * @throws ArrayIndexOutOfBoundsException     */    void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *);    void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *);    void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *);    void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *);    void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *);    void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *);    void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *);    void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *);    /**     * void Set&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, const NativeType *buf);     * 把buf中的内容拷贝回数组中     *     * @param env JNI接口指针     * @param array java数组     * @param start 开始index     * @param len 拷贝长度     * @param buf 源数据     *     * @throws ArrayIndexOutOfBoundsException     */    void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *);    void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *);    void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *);    void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *);    void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *);    void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *);    void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *);    void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *);    /**     * 为clazz类注册本地方法     *     * @param env JNI接口指针     * @param clazz class对象     * @param methods clazz类中的本地方法，指向方法数组     * @param nMethods 本地方法个数     *     * @return 0：成功， 负数：失败     *     * @throws NoSuchMethodError     */    jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint);    /**     * 取消clazz类本地方法的注册     *     * @param env JNI接口指针     * @param clazz class对象     *     * @return 0：成功， 负数：失败     */    jint (*UnregisterNatives)(JNIEnv *, jclass);    /**     * 进入与obj所引用的Java对象相关联的监控，obj 必须为非空     *     * @param env JNI接口指针     * @param obj java对象 或 class对象     *     * @return 0：成功， 负数：失败     */    jint (*MonitorEnter)(JNIEnv *, jobject);    /**     * 退出与obj所引用的Java对象相关联的监控，obj 必须为非空     * 当前线程必须是与obj所引用的Java对象相关联的监控程序的所有者     * 监控程序次数的计数器减 1。如果计数器的值变为 0，则释放当前线程的监控程序     *     * @param env JNI接口指针     * @param obj java对象 或 class对象     *     * @return 0：成功， 负数：失败     */    jint (*MonitorExit)(JNIEnv *, jobject);    /**     * 获取当前线程关联的Java VM接口     *     * @param env JNI接口指针     * @param vm java VM接口指针     *     * @return 0：成功， 负数：失败     */    jint (*GetJavaVM)(JNIEnv *, JavaVM **);    /**     * 从start index开始，拷贝len个Unicode字符到buf     *     * @param env JNI接口指针     * @param str string对象     * @param start 开始index     * @param len 拷贝长度     * @param buf 目标地址     *     * @throws StringIndexOutOfBoundsException     */    void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *);    /**     * 从start index开始，取出len个Unicode字符转换为UTF-8编码后拷贝到buf     *     * @param env JNI接口指针     * @param str string对象     * @param start 开始index     * @param len 拷贝长度     * @param buf 目标地址     *     * @throws StringIndexOutOfBoundsException     */    void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *);    /**     * 与Get/Release&lt;primitivetype&gt;ArrayElements方法非常相似，在这个方法中VM尽量返回指向原始数组的指针     *     * @since JDK/JRE 1.2     *     * @param env JNI接口指针     * @param array java数组     * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE     *     * @return 指向数组元素的指针 or NULL     */    void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *);    void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint);    /**     * 与Get/ReleaseStringChars方法非常相似，在这个方法中VM尽量返回指向原始字符串的指针     *     * @since JDK/JRE 1.2     *     * @param env JNI接口指针     * @param string String对象     * @param isCopy 指向boolean的指针     *     * @return 指向字符串的指针 or NULL     */    const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *);    void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *);    /**     * 为传入的obj创建弱全局引用     * 弱全局引用不会阻止VM释放所引用的对象，程序中可以通过使用IsSameObject比较弱全局引用和NULL来确认所引用的对象是否被释放     *     * @param env JNI接口指针     * @param obj 全局或局部引用     *     * @return 弱全局引用 or NULL     */    jweak (*NewWeakGlobalRef)(JNIEnv *, jobject);    /**     * 删除弱全局引用     *     * @param env JNI接口指针     * @param obj 弱全局引用     */    void (*DeleteWeakGlobalRef)(JNIEnv *, jweak);    /**     * 判断是否有未处理异常     *     * @param env JNI接口指针     *     * @return JNI_TRUE表示有未处理异常，否则为JNI_FALSE     */    jboolean (*ExceptionCheck)(JNIEnv *);    /**     * 创建并返回java.nio.ByteBuffer对象，该对象引用以address为开始地址，大小为capacity的内存块     *     * @since JDK/JRE 1.4     *     * @param env JNI接口指针     * @param address 开始地址     * @param capacity 内存大小     *     * @return Jjava.nio.ByteBuffer or NULL     *     * @throws OutOfMemoryError     */    jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong);    /**     * 根据java.nio.ByteBuffer对象，获取相应的内存数据并返回开始地址     *     * @since JDK/JRE 1.4     *     * @param env JNI接口指针     * @param buf java.nio.ByteBuffer对象     *     * @return 数据的开始地址 or NULL     */    void *(*GetDirectBufferAddress)(JNIEnv *, jobject);    /**     * 根据java.nio.ByteBuffer对象，获取相应的内存数据的大小     *     * @since JDK/JRE 1.4     *     * @param env JNI接口指针     * @param buf java.nio.ByteBuffer对象     *     * @return 数据大小 or -1     */    jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject);    /**     * 获取java对象的引用类型，可能的返回值有：     * JNIInvalidRefType     * JNILocalRefType：局部引用     * JNIGlobalRefType：全局引用     * JNIWeakGlobalRefType ：全局弱若引用     *     * @since JDK/JRE 1.6     *     * @param env JNI接口指针     * @param obj java对象的引用     *     * @return 引用类型     */    jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject);</code></pre><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>一般用的最多的就是Java调用C的实现, 下面给出了一个非常简单的例子:</p><pre><code class="c">JNIEXPORT jintArray JNICALL Java_com_example_Test_intMethod(JNIENV *env, jobject jobject, jintArray jarray) {  //遍历数组元素, 每个元素+5; 最后返回原数组  int length = (*env)-&gt;GetArrayLength(env, jarray);  int *array = (*env)-&gt;GetINtArrayElements(env,jarray,0);  for(int i=0; i &lt; length; ++i) {      *(array+i) += 5;  }  return jarray;}</code></pre><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>jni本身还是比较简单的, 因为机制比较成熟了. 基本的规则, 本文已经讲了非常多了, 关键还是要熟悉 jni.h 这个文件里的相关API.</p><p>先这样, 以后用到了再来详细搞.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="">《the JNI Programmer’s Guide and Specification》</a>  主要参考资料, 把这本好好读读就可以了</li><li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/</a> 主要参考资料</li><li><a href="">JNI编程指南</a>  网上找的比较偏理论的讲解,80多页</li><li><a href="http://blog.csdn.net/shensky711/article/details/52806794" target="_blank" rel="external">http://blog.csdn.net/shensky711/article/details/52806794</a>  作者写的太乱了</li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      JNI技术, 一种本来是用来写java虚拟机的技术, 后来被NDK玩坏了
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Rapid Json</title>
    <link href="www.merlinblog.site/2017/08/22/rapid-json.html"/>
    <id>www.merlinblog.site/2017/08/22/rapid-json.html</id>
    <published>2017-08-22T00:07:54.000Z</published>
    <updated>2017-09-24T07:20:07.195Z</updated>
    
    <content type="html"><![CDATA[<p>国人自己开发的库, 全部以头文件的形式包含. 在知乎的<a href="https://www.zhihu.com/question/23654513" target="_blank" rel="external">评测</a>也是各种好评.<br>其他的解析工具, 玩玩就可以了, 实际项目中, 还是推荐用 <code>RapidJson</code>.</p><p>本文是关于 rapid-json 的简单讲解和介绍.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/rjson.jpg" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>发现每次都会有一大堆人去说XML和JSON的优缺点, 我觉得也是挺烦的, 下面一句话带过:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;country&gt;  &lt;name&gt;中国&lt;/name&gt;  &lt;province&gt;    &lt;name&gt;黑龙江&lt;/name&gt;    &lt;citys&gt;      &lt;city&gt;哈尔滨&lt;/city&gt;      &lt;city&gt;大庆&lt;/city&gt;    &lt;/citys&gt;  　　  &lt;/province&gt;  &lt;province&gt;    &lt;name&gt;广东&lt;/name&gt;    &lt;citys&gt;      &lt;city&gt;广州&lt;/city&gt;      &lt;city&gt;深圳&lt;/city&gt;      &lt;city&gt;珠海&lt;/city&gt;    &lt;/citys&gt; 　　  &lt;/province&gt;  &lt;province&gt;    &lt;name&gt;台湾&lt;/name&gt;    &lt;citys&gt;      　&lt;city&gt;台北&lt;/city&gt;      　&lt;city&gt;高雄&lt;/city&gt;    &lt;/citys&gt;　  &lt;/province&gt;  &lt;province&gt;    &lt;name&gt;新疆&lt;/name&gt;    &lt;citys&gt;      &lt;city&gt;乌鲁木齐&lt;/city&gt;    &lt;/citys&gt;  &lt;/province&gt;&lt;/country&gt;</code></pre><p>再看json</p><pre><code>{    name: &quot;中国&quot;,    provinces:         [     { name: &quot;黑龙江&quot;, citys: { city: [&quot;哈尔滨&quot;, &quot;大庆&quot;]} },     { name: &quot;广东&quot;, citys: { city: [&quot;广州&quot;, &quot;深圳&quot;, &quot;珠海&quot;]} },     { name: &quot;台湾&quot;, citys: { city: [&quot;台北&quot;, &quot;高雄&quot;]} },     { name: &quot;新疆&quot;, citys: { city: [&quot;乌鲁木齐&quot;]} }    ]}</code></pre><p>XML的可读性稍微好一些, 但是冗余信息多, 体积大; 并且解析方便程度来说, JSON完胜.<br>(但是业界流行程度来说, XML业界广泛认同)</p><p>本文主要介绍RapidJson的使用以及一些心得, 如果你对它的源码也感兴趣的话, 可以参考该 <a href="http://miloyip.com/rapidjson/" target="_blank" rel="external">链接</a><br>(补充, 有人喜欢用 <a href="http://blog.csdn.net/hailong0715/article/details/51942736" target="_blank" rel="external">JsonCpp</a>, 不过还是推荐你用RapidJson吧)</p><p>(虽然有官方教程, 不过觉得那个教程也是非常啰嗦的)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>rapidjson是腾讯的开源json解析框架，用c++实现。由于全部代码仅用header file实现，所以很容易集成到项目中。rapidjson的另一个特点是对json的标准符合程度是100%的(在开启了full precision选项的情况下).</p><p>最重要的: <code>RapidJSON is a JSON parser and generator for C++</code> .</p><p>总之, 业界也有好评, 个人觉得比 JsonCpp 好.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>RapidJSON 是只有头文件的 C++ 库。只需把 include/rapidjson 目录复制至系统或项目的 include 目录中。<br>给出我的参考步骤:</p><pre><code>$ git clone https://github.com/miloyip/rapidjson.git$ cmake .$ sudo make install</code></pre><p>然后, 你的相关库就安装到了 <code>/usr/local/include/</code></p><h2 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h2><p>安装完了, 顺便可以扫一眼, 都有哪些库:</p><pre><code>$ tree -L 2 /usr/local/include/rapidjson/usr/local/include/rapidjson├── allocators.h├── document.h├── encodedstream.h├── encodings.h├── error│   ├── en.h│   └── error.h├── filereadstream.h├── filewritestream.h├── fwd.h├── internal│   ├── biginteger.h│   ├── diyfp.h│   ├── dtoa.h│   ├── ieee754.h│   ├── itoa.h│   ├── meta.h│   ├── pow10.h│   ├── regex.h│   ├── stack.h│   ├── strfunc.h│   ├── strtod.h│   └── swap.h├── istreamwrapper.h├── memorybuffer.h├── memorystream.h├── msinttypes│   ├── inttypes.h│   └── stdint.h├── ostreamwrapper.h├── pointer.h├── prettywriter.h├── rapidjson.h├── reader.h├── schema.h├── stream.h├── stringbuffer.h└── writer.h3 directories, 35 files</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先来些简单的案例, 再说相关的API和机制.</p><p>此简单例子解析一个 JSON 字符串至一个 document (DOM), 对 DOM 作出简单修改, 最终把 DOM 转换(stringify) 至 JSON 字符串.</p><pre><code class="c++">// JSON simple example// This example does not handle errors.#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/writer.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &lt;iostream&gt;using namespace rapidjson;int main() {    // 1. Parse a JSON string into DOM.    const char* json = &quot;{\&quot;project\&quot;:\&quot;rapidjson\&quot;,\&quot;stars\&quot;:10}&quot;;    Document d;    d.Parse(json);    // 2. Modify it by DOM.    Value&amp; s = d[&quot;stars&quot;];    s.SetInt(s.GetInt() + 1);    // 3. Stringify the DOM    StringBuffer buffer;    Writer&lt;StringBuffer&gt; writer(buffer);    d.Accept(writer);    // Output {&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11}    std::cout &lt;&lt; buffer.GetString() &lt;&lt; std::endl;    return 0;}</code></pre><p>注意此例子并没有处理潜在错误, 比如:</p><pre><code class="c++">// 2. Modify it by DOM.   Value&amp; s = d[&quot;stars&quot;];if( s.IsInt() ) {    s.SetInt(s.GetInt() + 1);  }</code></pre><p>编译运行:</p><pre><code>$ g++ -g -Wall -O0 simpledom.cpp -o simpledom -I/usr/local/inlcude/$ ./simpledom{&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11}</code></pre><p>可以简单的得出结论, 解析JSON是围绕 <code>rapidjson::Document</code>, <code>rapidjson::Value</code> 展开的, 关键性头文件:</p><ul><li>rapidjson/document.h</li><li>rapidjson/writer.h</li></ul><hr><p>再来一个实用一点儿的例子:<br>test.json</p><pre><code>{    &quot;dictVersion&quot;: 1,      &quot;content&quot;:      [           {&quot;key&quot;: &quot;word1&quot;, &quot;value&quot;: &quot;单词1&quot;} ,        {&quot;key&quot;: &quot;word2&quot;, &quot;value&quot;: &quot;单词2&quot;} ,        {&quot;key&quot;: &quot;word3&quot;, &quot;value&quot;: &quot;单词3&quot;} ,        {&quot;key&quot;: &quot;word4&quot;, &quot;value&quot;: &quot;单词4&quot;} ,        {&quot;key&quot;: &quot;word5&quot;, &quot;value&quot;: &quot;单词5&quot;}     ]}</code></pre><p>对于这种格式化好的文件的读写, 可以采用流式读写处理:</p><pre><code class="c++">// test.cpp#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &quot;rapidjson/writer.h&quot;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#define psln(x) std::cout &lt;&lt; #x &quot; = &quot; &lt;&lt; (x) &lt;&lt; std::endlvoid testSimpleDoc() {  using std::string;  using std::ifstream;  // read json content into string.  string      stringFromStream;  ifstream    in;  in.open(&quot;test.json&quot;, ifstream::in);  if (!in.is_open())    return;  string line;  while (getline(in, line)) {    stringFromStream.append(line + &quot;\n&quot;);  }  in.close();  // ---------------------------- read json --------------------  // parse json from string.  using rapidjson::Document;  Document doc;  doc.Parse(stringFromStream.c_str());  if (doc.HasParseError()) {    rapidjson::ParseErrorCode code = doc.GetParseError();    psln(code);    return;  }  // use values in parse result.  using rapidjson::Value;  using rapidjson::Type;  using rapidjson::StringBuffer;  using rapidjson::Writer;  Value &amp; v = doc[&quot;dictVersion&quot;];  if (v.IsInt()) {    psln(v.GetInt());  }  Value &amp; contents = doc[&quot;content&quot;];  if (contents.IsArray()) {    for (size_t i = 0; i &lt; contents.Size(); ++i) {      Value &amp; v = contents[i];      assert(v.IsObject());      if (v.HasMember(&quot;key&quot;) &amp;&amp; v[&quot;key&quot;].IsString()) {    psln(v[&quot;key&quot;].GetString());      }      if (v.HasMember(&quot;value&quot;) &amp;&amp; v[&quot;value&quot;].IsString()) {    psln(v[&quot;value&quot;].GetString());      }    }  }  // ---------------------------- write json --------------------  psln(&quot;add a value into array&quot;);  Value item(Type::kObjectType);  item.AddMember(&quot;key&quot;, &quot;word5&quot;, doc.GetAllocator());  item.AddMember(&quot;value&quot;, &quot;单词5&quot;, doc.GetAllocator());  contents.PushBack(item, doc.GetAllocator());  // convert dom to string.  StringBuffer buffer;      // in rapidjson/stringbuffer.h  Writer&lt;StringBuffer&gt; writer(buffer); // in rapidjson/writer.h  doc.Accept(writer);// Accept() traverses the DOM and generates Handler events.  psln(buffer.GetString());}int main(void){  testSimpleDoc();  return 0;}</code></pre><p>编译运行:</p><pre><code>$ g++ -g -Wall test.cpp -o test -I/usr/local/include$ ./test v.GetInt() = 1v[&quot;key&quot;].GetString() = word1v[&quot;value&quot;].GetString() = 单词1v[&quot;key&quot;].GetString() = word2v[&quot;value&quot;].GetString() = 单词2v[&quot;key&quot;].GetString() = word3v[&quot;value&quot;].GetString() = 单词3v[&quot;key&quot;].GetString() = word4v[&quot;value&quot;].GetString() = 单词4v[&quot;key&quot;].GetString() = word5v[&quot;value&quot;].GetString() = 单词5&quot;add a value into array&quot; = add a value into arraybuffer.GetString() = {&quot;dictVersion&quot;:1,&quot;content&quot;:[{&quot;key&quot;:&quot;word1&quot;,&quot;value&quot;:&quot;单词1&quot;},{&quot;key&quot;:&quot;word2&quot;,&quot;value&quot;:&quot;单词2&quot;},{&quot;key&quot;:&quot;word3&quot;,&quot;value&quot;:&quot;单词3&quot;},{&quot;key&quot;:&quot;word4&quot;,&quot;value&quot;:&quot;单词4&quot;},{&quot;key&quot;:&quot;word5&quot;,&quot;value&quot;:&quot;单词5&quot;},{&quot;key&quot;:&quot;word5&quot;,&quot;value&quot;:&quot;单词5&quot;}]}</code></pre><p>从上面两个例子, 就可以看出, 只要你给document对象parse(const char*)一个C串, 那么它就会把解析的内容全部存储在document对象里; <code>Value &amp; v = doc[key];</code> 可以拿到单个对象或者Array(这里的array就像一个list或者数组), 结合Value进行读写, Value类含有 <code>HasMember()</code>, <code>AddMemeber()</code> 之类的方法, 以及和Document类一样重载了 <code>operator[]()</code>, 而<code>v[&quot;key&quot;].GetString()</code>,  <code>v.GetInt()</code> 则可以拿到具体的内容. 上面例子只给出了array如何添加成员, 其实document添加成员, 也是<code>document.AddMember(&quot;key buffer&quot;, &quot;value buffer-object&quot;, document.GetAllocator());</code> , 并且 document 可以是Object, 也可以是Array, 上面这些例子都是Object. </p><p>value[“key”]得到的类型还是Value类型, 当然也可以用v.IsObject()检验:</p><pre><code class="c++">//Document -&gt; ValueValue &amp; v = doc[key];v.GetInt();//对比: value.GetInt()v[&quot;key&quot;].GetString()</code></pre><p>漂亮的输出到屏幕上(格式修正):</p><pre><code class="c++">   #include &quot;rapidjson/prettywriter.h&quot;    StringBuffer sb;    PrettyWriter&lt;StringBuffer&gt; writer(sb);    document.Accept(writer);    puts(sb.GetString());</code></pre><p>运行结果大致是:</p><pre><code>v.GetInt() = 1v[&quot;key&quot;].GetString() = word1v[&quot;value&quot;].GetString() = 单词1v[&quot;key&quot;].GetString() = word2v[&quot;value&quot;].GetString() = 单词2v[&quot;key&quot;].GetString() = word3v[&quot;value&quot;].GetString() = 单词3v[&quot;key&quot;].GetString() = word4v[&quot;value&quot;].GetString() = 单词4&quot;add a value into array&quot; = add a value into arraybuffer.GetString() = {    &quot;dictVersion&quot;: 1,    &quot;content&quot;: [        {            &quot;key&quot;: &quot;word1&quot;,            &quot;value&quot;: &quot;单词1&quot;        },        {            &quot;key&quot;: &quot;word2&quot;,            &quot;value&quot;: &quot;单词2&quot;        },        {            &quot;key&quot;: &quot;word3&quot;,            &quot;value&quot;: &quot;单词3&quot;        },        {            &quot;key&quot;: &quot;word4&quot;,            &quot;value&quot;: &quot;单词4&quot;        },        {            &quot;key&quot;: &quot;word5&quot;,            &quot;value&quot;: &quot;单词5&quot;        }    ]}</code></pre><p>之后如果你想写入文件, 那么就把 <code>sb.GetString()</code> 以文本格式写入文件即可; 或者借助其他的流(下面的例子从stdin和stdout作为流输入和输出):</p><pre><code class="c++">#include &quot;rapidjson/reader.h&quot;#include &quot;rapidjson/prettywriter.h&quot;#include &quot;rapidjson/filereadstream.h&quot;#include &quot;rapidjson/filewritestream.h&quot;#include &quot;rapidjson/error/en.h&quot;using namespace rapidjson;int main(int, char*[]) {    // Prepare reader and input stream.    Reader reader;    char readBuffer[65536];    /*     ifstream    in;     in.open(&quot;test.json&quot;, ifstream::in);     */    FileReadStream is(stdin, readBuffer, sizeof(readBuffer));    // Prepare writer and output stream.    char writeBuffer[65536];    FileWriteStream os(stdout, writeBuffer, sizeof(writeBuffer));    PrettyWriter&lt;FileWriteStream&gt; writer(os);    // JSON reader parse from the input stream and let writer generate the output.    if (!reader.Parse&lt;kParseValidateEncodingFlag&gt;(is, writer)) {        fprintf(stderr, &quot;\nError(%u): %s\n&quot;,      static_cast&lt;unsigned&gt;(reader.GetErrorOffset()),          GetParseError_En(reader.GetParseErrorCode()));        return 1;    }    return 0;}</code></pre><p>总之, 先把流读到字符串, 之后写解析逻辑.</p><h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>其实说到这里, 使用上, 基本没有问题了.</p><p>进一步的深入, 我给的建议是: </p><ol><li>先读一下 <a href="http://rapidjson.org/zh-cn/md_doc_tutorial_8zh-cn.html" target="_blank" rel="external">官方教程</a>.</li><li>然后把源码下面的 example 下面所有的 demo 全部玩一遍.</li></ol><p>教程里面, 拷贝转移以及move()部分, 内存流&amp;文件流部分(包装流效率不高), DOM&amp;SAX部分都是仔细看的, 下面是我的部分笔记:</p><pre><code>Value可以用作表示Object, Array, 甚至简单的stringValue a(kArrayType);Value o(Type::kObjectType);Value s = &quot;str&quot;;如果Value直接写Value v; //NUll此时你并不知道它表示什么.下面这种形式存储的就是指针了(浅拷贝)Value s;s.SetString(&quot;rapidjson&quot;);    // 可包含空字符，长度在编译萁推导s = &quot;rapidjson&quot;;             // 上行的缩写直接赋值, 有时候为了安全, 需要做一下标记: `StringRef(cstr)`const char * cstr = getenv(&quot;USER&quot;);    //注意是 const char *size_t cstr_len = ...;                 // 如果有长度Value s;// s.SetString(cstr);                  // 这不能通过编译s.SetString(StringRef(cstr));          // 可以，假设它的生命周期安全，并且是以空字符结尾的s = StringRef(cstr);                   // 上行的缩写s.SetString(StringRef(cstr, cstr_len));// 更快，可处理空字符s = StringRef(cstr, cstr_len);         // 上行的缩写补充: 和value的直接赋值, AddMember(), PushBack() 都采用转移语义(没有分配内存)这是深拷贝, setString时提供了allocator, 并且指定了长度.//value.GetStringLength() 能获取UTF字符串中如果存在\u000即空字符的情况下的长度//比strlen()强大, 当然如果你不传入长度, 那就默认使用strlen()value.SetString(buffer, len, document.GetAllocator()); 如果value之间, 想深复制, 那么有两种方式:1. 构造中带有allocatorDocument d;Document::AllocatorType&amp; a = d.GetAllocator();Value v1(&quot;foo&quot;);// Value v2(v1); // 不容许Value v2(v1, a); // 制造一个克隆2. 采用copyfromValue v2;v2.CopyFrom(v1, a);对于Value如果是 Object, 它的AddMemeber()比较标准的写法, 即采用的是重置的写法://和Document一样的AddMember(), 注Object是有key, value的pair,并且key一定是字符串Value item(Type::kObjectType);item.AddMember(&quot;key&quot;, &quot;word5&quot;, doc.GetAllocator());Value类型是Array, 注意它的PushBack是移动语义就可以了(即使带了allocator), 当然这是针对非基本类型的数据(String, Object), 即Push进去的元素可以是string类型的value, 或者Object类型的value.push进去的是 string类型或者Object类型也存在临时变量无法赋值给非const引用的, 移动语义问题, 可以类似解决方法: move()返回一个非const引用// 就地 Value 参数contact.PushBack(Value(&quot;copy&quot;, document.GetAllocator()).Move(), // copy string                 document.GetAllocator());// 显式 Value 参数Value val(&quot;key&quot;, document.GetAllocator()); // copy stringcontact.PushBack(val, document.GetAllocator());</code></pre><p>这个时候(把那个几个example玩熟), 对这个库已经很熟悉了.<br>再深入, 就结合他的<a href="rapidjson.org">官网</a>以及源码慢慢琢磨吧.</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>没太多可说的, 写多了就熟悉了.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      总结rapid-json
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Rapid Xml</title>
    <link href="www.merlinblog.site/2017/08/22/rapid-xml.html"/>
    <id>www.merlinblog.site/2017/08/22/rapid-xml.html</id>
    <published>2017-08-22T00:07:21.000Z</published>
    <updated>2017-09-24T07:19:23.399Z</updated>
    
    <content type="html"><![CDATA[<p>本篇不会像 protocol-buffer 那样花很大的力气去讲解, 这里就是关于 Cpp对于解析XML的处理(序列化, 反序列化). 比较 SlimXml, TinyXml, RapidXml 发现, <a href="http://rapidxml.sourceforge.net/" target="_blank" rel="external">Rapid-Xml</a> 这个库性能优势明显.</p><blockquote><p>开源都是有坑的, 最好能自己填坑, 详细内容见文内; RapidXml并不如TinyXml那么稳定, 但谁叫它是Modern C++写的呢</p></blockquote><p>本文是对 Rapid-Xml 实践的讲解和总结.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/rxml.jpg" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>官网上的简介如下:<br>RapidXml is an attempt to create the fastest XML parser possible, while retaining useability, portability and reasonable W3C compatibility. It is an in-situ parser written in modern C++, with parsing speed approaching that of <code>strlen</code> function executed on the same data.</p><p>Integration with your project will be trivial, because entire library is contained in a single header file, and requires no building or configuration.</p><p>The author of RapidXml is <code>Marcin Kalicinski</code> .</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>注意 rapidxml 一个很重要的特性: RapidXml is an in-situ parser, which allows it to achieve very high parsing speed. </p><blockquote><p><code>In-situ</code> means that parser does not make copies of strings. Instead, it places pointers to the source text in the DOM hierarchy.</p></blockquote><p>换句话说:<br>Nodes and attributes produced by RapidXml do not own their name and value strings. They merely hold the pointers to them.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>总共就4个头文件…直接下载吧</p><pre><code class="bash">$ wget https://nchc.dl.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip$ unzip rapidxml-1.13.zipArchive:  rapidxml-1.13.zip   creating: rapidxml-1.13/  inflating: rapidxml-1.13/license.txt    inflating: rapidxml-1.13/manual.html    inflating: rapidxml-1.13/rapidxml.hpp    inflating: rapidxml-1.13/rapidxml_iterators.hpp    inflating: rapidxml-1.13/rapidxml_print.hpp    inflating: rapidxml-1.13/rapidxml_utils.hpp $ sudo mv rapidxml-1.13 /usr/local/include/rapidxml</code></pre><p>看了一下它的源文件, 代码量非常少, 总共不到4000行, 主要逻辑全部集中在 <code>rapidxml.hpp</code> 模板头文件中, 但是除去通用处理类, 比如parse_error, memory_pool等, 真正逻辑也很清晰.</p><p>源码就不分析了, 有时间再补上 (主要看class xml_base, xml_attribute等)</p><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>拿起来就是用(假设你已经知道了DOM解析, SAX解析, NODE, ROOT, Attribute, Document这些概念了).</p><h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析一个C风格的字符串:(zero-terminated string)</p><pre><code class="c++">using namespace rapidxml;xml_document&lt;&gt; doc;    // character type defaults to chardoc.parse&lt;0&gt;(text);    // 0 是默认flag</code></pre><p>菱形语法表示模板参数有默认值了, parse 的模板参数flag必须是一个编译时常量或者常量表达式, 此处的0是默认的.</p><p>doc就是DOM树的根(节点), 表示整个解析后的XML, 也表示整个内存池.</p><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读DOM树, 都需要借助 <code>xml_node</code> 和 <code>xml_attribute</code> 类, 样板代码:</p><pre><code class="c++">cout &lt;&lt; &quot;Name of my first node is: &quot; &lt;&lt; doc.first_node()-&gt;name() &lt;&lt; &quot;\n&quot;;xml_node&lt;&gt; *node = doc.first_node(&quot;foobar&quot;);cout &lt;&lt; &quot;Node foobar has value &quot; &lt;&lt; node-&gt;value() &lt;&lt; &quot;\n&quot;;for (xml_attribute&lt;&gt; *attr = node-&gt;first_attribute();     attr; attr = attr-&gt;next_attribute()){    cout &lt;&lt; &quot;Node foobar has attribute &quot; &lt;&lt; attr-&gt;name() &lt;&lt; &quot; &quot;;    cout &lt;&lt; &quot;with value &quot; &lt;&lt; attr-&gt;value() &lt;&lt; &quot;\n&quot;;}</code></pre><h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><p>Nodes and attributes can be added/removed, and their contents changed. The below example creates a HTML document, whose sole contents is a link to google.com website:</p><pre><code class="c++">xml_document&lt;&gt; doc;//node_element 代表node type的flagxml_node&lt;&gt; *node = doc.allocate_node(node_element, &quot;a&quot;, &quot;Google&quot;);doc.append_node(node);xml_attribute&lt;&gt; *attr = doc.allocate_attribute(&quot;href&quot;, &quot;google.com&quot;);node-&gt;append_attribute(attr);</code></pre><p>还是字符串问题, 上面的代码, 使用的是字符串常量, 所以不用担心字符串声明周期的合法性. 但是添加到node, attribute的string如果是普通变量, 那么在赋值(assign)的时候, 一定要保证string的生命周期和合法性, 毕竟node和string并不是实际存储内容(content), 而只是保留其地址的(浅复制).</p><p>所以这里, 作者推荐了一种做法来保证string的声明周期:</p><pre><code class="c++">xml_document&lt;&gt; doc;char *node_name = doc.allocate_string(name);        // Allocate string and copy name into itxml_node&lt;&gt; *node = doc.allocate_node(node_element, node_name);  // Set node name to node_name</code></pre><p>用内存池技术 <code>memory_pool::allocate_string()</code> , 来保证分配的string和doc的声明周期一致. (注意上面说过了, doc其实就是代表整个XML, 以及XML内存池)</p><h3 id="打印输出"><a href="#打印输出" class="headerlink" title="打印输出"></a>打印输出</h3><p>使用 <code>print()</code> 函数和 <code>operator&lt;&lt;()</code>, 打印 xml_document, xml_node 对象.<br>(头文件 <code>rapidxml_print.hpp</code> )</p><pre><code class="c++">using namespace rapidxml;xml_document&lt;&gt; doc;    // character type defaults to char// ... some code to fill the document// Print to stream using operator &lt;&lt;std::cout &lt;&lt; doc;   // Print to stream using print function, specifying printing flagsprint(std::cout, doc, 0);   // 0 means default printing flags// Print to string using output iteratorstd::string s;print(std::back_inserter(s), doc, 0);// Print to memory buffer using output iteratorchar buffer[4096];                      // You are responsible for making the buffer large enough!char *end = print(buffer, doc, 0);      // end contains pointer to character after last printed character*end = 0;                               // Add string terminator after XML</code></pre><p>稍稍注意下, 我用的1.13版本有点儿坑, <code>-std=c++11</code> 的时候, 还是会出现 “print_node()” 未定义的现象, 需要把它的源码定义 <code>print_node</code> 位置后移.</p><h2 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h2><p>细致的说一下相关的API(类, 函数, 常量等), 实际上作者对于相关API的命名真的非常清晰, 也符合一个从C开始到C++的开发人员的命名风格, 非常不错.</p><p>(总共4个头文件, 我就不指明是哪个头文件了)</p><p>名字空间 <code>rapidxml</code> :</p><pre><code class="c++">enum node_typefunction parse_error_handler(const char *what, void *where)function print(OutIt out, const xml_node&lt; Ch &gt; &amp;node, int flags=0)function print(std::basic_ostream&lt; Ch &gt; &amp;out, const xml_node&lt; Ch &gt; &amp;node, int flags=0)function operator&lt;&lt;(std::basic_ostream&lt; Ch &gt; &amp;out, const xml_node&lt; Ch &gt; &amp;node)constant parse_no_data_nodesconstant parse_no_element_valuesconstant parse_no_string_terminatorsconstant parse_no_entity_translationconstant parse_no_utf8constant parse_declaration_nodeconstant parse_comment_nodesconstant parse_doctype_nodeconstant parse_pi_nodesconstant parse_validate_closing_tagsconstant parse_trim_whitespaceconstant parse_normalize_whitespaceconstant parse_defaultconstant parse_non_destructiveconstant parse_fastestconstant parse_fullconstant print_no_indenting</code></pre><p>特别说明一下 <code>enum node_type</code> :</p><pre><code>node_pi    A PI node. Name contains target. Value contains instructions.node_document    A document node. Name and value are empty.node_element    An element node. Name contains element name. Value contains text of first data node.node_data    A data node. Name is empty. Value contains data text.node_cdata    A CDATA node. Name is empty. Value contains data text.---------------------------------------------------------------        node_comment     A comment node. Name is empty. Value contains comment text.node_declaration    A declaration node. Name and value are empty. Declaration parameters (version, encoding and standalone) are in node attributes.node_doctype 通常用 node_pi替代了    A DOCTYPE node. Name is empty. Value contains DOCTYPE text.</code></pre><p>类模板 <code>rapidxml::memory_pool</code></p><pre><code class="c++">constructor memory_pool()destructor ~memory_pool()function allocate_node(node_type type, const Ch *name=0, const Ch *value=0, std::size_t name_size=0, std::size_t value_size=0)function allocate_attribute(const Ch *name=0, const Ch *value=0, std::size_t name_size=0, std::size_t value_size=0)function allocate_string(const Ch *source=0, std::size_t size=0)function clone_node(const xml_node&lt; Ch &gt; *source, xml_node&lt; Ch &gt; *result=0)function clear()function set_allocator(alloc_func *af, free_func *ff)</code></pre><p>类 <code>rapidxml::parse_error</code>, 一个继承自 std::exception的异常类:</p><pre><code class="c++">constructor parse_error(const char *what, void *where)function what() constfunction where() const</code></pre><p>类模板 <code>rapidxml::xml_document</code> :</p><pre><code class="c++">constructor xml_document()function parse(Ch *text)function clear()</code></pre><p>类模板 <code>rapidxml::xml_node</code> :</p><pre><code class="c++">constructor xml_node(node_type type)function type() const //node有多种类型function type(node_type type)function document() constfunction first_node(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction last_node(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction previous_sibling(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction next_sibling(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction prepend_attribute(xml_attribute&lt; Ch &gt; *attribute)function first_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction last_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction prepend_node(xml_node&lt; Ch &gt; *child)function append_node(xml_node&lt; Ch &gt; *child)function insert_node(xml_node&lt; Ch &gt; *where, xml_node&lt; Ch &gt; *child)function remove_first_node()function remove_last_node()function remove_node(xml_node&lt; Ch &gt; *where)function remove_all_nodes()function append_attribute(xml_attribute&lt; Ch &gt; *attribute)function insert_attribute(xml_attribute&lt; Ch &gt; *where, xml_attribute&lt; Ch &gt; *attribute)function remove_first_attribute()function remove_last_attribute()function remove_attribute(xml_attribute&lt; Ch &gt; *where)function remove_all_attributes()</code></pre><p>注意操作属性也在node里面.</p><p>类模板 <code>rapidxml::xml_attribute</code> :</p><pre><code class="c++">constructor xml_attribute()function document() constfunction previous_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) constfunction next_attribute(const Ch *name=0, std::size_t name_size=0, bool case_sensitive=true) const</code></pre><p>类模板 <code>rapidxml::xml_base</code> :</p><pre><code class="c++">constructor xml_base()function name() constfunction name_size() constfunction value() constfunction value_size() constfunction name(const Ch *name, std::size_t size)function name(const Ch *name)function value(const Ch *value, std::size_t size)function value(const Ch *value)function parent() const</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>大致包括:</p><ul><li>创建一个XML文件</li><li>写,读,修改.</li></ul><p>创建一个XML文件:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;fstream&gt;#include &lt;iterator&gt; //back_inserter#include &quot;rapidxml/rapidxml.hpp&quot;#include &quot;rapidxml/rapidxml_utils.hpp&quot;#include &quot;rapidxml/rapidxml_print.hpp&quot;using document = rapidxml::xml_document&lt;&gt;;using node = rapidxml::xml_node&lt;&gt;;using rapidxml::node_pi;using rapidxml::node_element;int main(void){  document doc;  node *first = doc.allocate_node(node_pi,      doc.allocate_string(&quot;xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;&quot;));  doc.append_node(first);  //该节点作为根节点  node *root = doc.allocate_node(node_element, &quot;config&quot;, NULL);  doc.append_node(root);   //下面节点拥有子节点  node *color = doc.allocate_node(node_element, &quot;color&quot;, NULL);  root-&gt;append_node(color);  color-&gt;append_node(doc.allocate_node(node_element,&quot;red&quot;,&quot;true&quot;));  color-&gt;append_node(doc.allocate_node(node_element,&quot;green&quot;,&quot;true&quot;));  color-&gt;append_node(doc.allocate_node(node_element,&quot;blue&quot;,&quot;true&quot;));  color-&gt;append_node(doc.allocate_node(node_element,&quot;alpha&quot;,&quot;true&quot;));  node *screen = doc.allocate_node(node_element,&quot;screen&quot;,NULL);  screen-&gt;append_node(doc.allocate_node(node_element,&quot;wide&quot;,&quot;640&quot;));  screen-&gt;append_node(doc.allocate_node(node_element,&quot;length&quot;,&quot;480&quot;));  root-&gt;append_node(screen);  //下面节点拥有属性  node *mode = doc.allocate_node(node_element,&quot;mode&quot;, &quot;screen mode&quot;);  mode-&gt;append_attribute(doc.allocate_attribute(&quot;fullscreen&quot;,&quot;false&quot;));  root-&gt;append_node(mode);  //打印试试  std::string text;  rapidxml::print(std::back_inserter(text), doc, 0);  std::cout &lt;&lt; text &lt;&lt; std::endl;  //直接输出到指定流  std::ofstream out(&quot;config.xml&quot;);  out &lt;&lt; doc;  out.close();  return 0;}</code></pre><p>Linux平台下编译, 居然遇到了这样的坑:</p><pre><code>/usr/local/include/rapidxml/rapidxml_print.hpp: In instantiation of ‘OutIt rapidxml::internal::print_node(OutIt, const rapidxml::xml_node&lt;Ch&gt;*, int, int) [with OutIt = std\::back_insert_iterator&lt;std::basic_string&lt;char&gt; &gt;; Ch = char]’:/usr/local/include/rapidxml/rapidxml_print.hpp:390:36:   required from ‘OutIt rapidxml::print(OutIt, const rapidxml::xml_node&lt;Ch&gt;&amp;, int) [with OutIt = std::back_insert_ite\rator&lt;std::basic_string&lt;char&gt; &gt;; Ch = char]’main.cpp:52:51:   required from here/usr/local/include/rapidxml/rapidxml_print.hpp:115:37: error: ‘print_children’ was not declared in this scope, and no declarations were found by argument-dependent lookup \at the point of instantiation [-fpermissive]</code></pre><p>大致上说, <code>print_node</code> 被调用, 同时<code>rapidxml_print.hpp:115:37</code> 的 <code>print_children</code> 未定义.</p><p>然后看看源码, 发现, line 107 行源码是这样的:</p><pre><code class="c++">// Print nodetemplate&lt;class OutIt, class Ch&gt;inline OutIt print_node(OutIt out, const xml_node&lt;Ch&gt; *node, int flags, int indent){  // Print proper node type  switch (node-&gt;type())    {      // Document    case node_document:      out = print_children(out, node, flags, indent);      break;      // Element    case node_element:      out = print_element_node(out, node, flags, indent);      break;      // Data    case node_data:      out = print_data_node(out, node, flags, indent);      break;      // CDATA    case node_cdata:      out = print_cdata_node(out, node, flags, indent);      break;      // Declaration    case node_declaration:      out = print_declaration_node(out, node, flags, indent);      break;      // Comment    case node_comment:      out = print_comment_node(out, node, flags, indent);      break;      // Doctype    case node_doctype:      out = print_doctype_node(out, node, flags, indent);      break;      // Pi    case node_pi:      out = print_pi_node(out, node, flags, indent);      break;      // Unknown    default:      assert(0);      break;    }  // If indenting not disabled, add line break after node  if (!(flags &amp; print_no_indenting))    *out = Ch(&#39;\n&#39;), ++out;  // Return modified iterator  return out;}</code></pre><p>这个 <code>print_node</code> 要调用具体的 <code>print_children</code> 或者 <code>print_element_node</code> 居然放在别人前面, 还没有前置声明.</p><p>修改一下源码(后移<code>print_node</code>函数以及在<code>print_children</code>函数前面防止前置声明), 才编译通过:</p><pre><code class="c++">template&lt;class OutIt, class Ch&gt;inline OutIt print_node(OutIt out, const xml_node&lt;Ch&gt; *node, int flags, int indent);</code></pre><p>运行结果还不错:</p><pre><code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39; ?&gt;&lt;config&gt;    &lt;color&gt;        &lt;red&gt;true&lt;/red&gt;        &lt;green&gt;true&lt;/green&gt;        &lt;blue&gt;true&lt;/blue&gt;        &lt;alpha&gt;true&lt;/alpha&gt;    &lt;/color&gt;    &lt;screen&gt;        &lt;wide&gt;640&lt;/wide&gt;        &lt;length&gt;480&lt;/length&gt;    &lt;/screen&gt;    &lt;mode fullscreen=&quot;false&quot;&gt;screen mode&lt;/mode&gt;&lt;/config&gt;</code></pre><p>同时也生成了 config.xml.</p><p>下面读取该文件同时修改一下内容看看:</p><pre><code class="c++">#include &lt;iostream&gt;#include &quot;rapidxml/rapidxml.hpp&quot;#include &quot;rapidxml/rapidxml_utils.hpp&quot;#include &quot;rapidxml/rapidxml_print.hpp&quot;using namespace rapidxml;void print_info(const char *str){  std::cout &lt;&lt; str &lt;&lt; std::endl;}int main(void) {  //读入内存  file&lt;&gt; fdoc(&quot;config.xml&quot;);  //fdoc.data()即拿到数据字符串  //保存到document对象中(实际上是解析进去的)  xml_document&lt;&gt; doc;  doc.parse&lt;0&gt;(fdoc.data());  //获取根节点  xml_node&lt;&gt; *root = doc.first_node();  //if(root){} //可以做一下检查, 检查节点是否存在  //print_info(root-&gt;name());  //获取根节点的第一个节点color  xml_node&lt;&gt;* node1 = root-&gt;first_node();  print_info(node1-&gt;name());  //node1的子节点  xml_node&lt;&gt;* node11 = node1-&gt;first_node();  print_info(node11-&gt;name());  print_info(node11-&gt;value());  //添加一个颜色 再保存  node1-&gt;append_node(doc.allocate_node(rapidxml::node_element, &quot;yellow&quot;,&quot;false&quot;));  //删除color的子节点, &lt;alpha&gt;true&lt;/alpha&gt;  node1-&gt;remove_node(node11-&gt;next_sibling(&quot;alpha&quot;));  //remove_all_nodes()可以删除根节点的所有子节点  //略  std::string text;  rapidxml::print(std::back_inserter(text),doc,0);  std::cout&lt;&lt;text&lt;&lt;std::endl;  //写回去文件(默认就是文件存在则会覆盖原来的内容，不存在则会新建)  std::ofstream out(&quot;config.xml&quot;, std::ios::out | std::ios::trunc);  out &lt;&lt; doc;  out.close();  return 0;}</code></pre><p>运行结果如下:</p><pre><code>colorredtrue&lt;config&gt;    &lt;color&gt;        &lt;red&gt;true&lt;/red&gt;        &lt;green&gt;true&lt;/green&gt;        &lt;blue&gt;true&lt;/blue&gt;        &lt;yellow&gt;false&lt;/yellow&gt;    &lt;/color&gt;    &lt;screen&gt;        &lt;wide&gt;640&lt;/wide&gt;        &lt;length&gt;480&lt;/length&gt;    &lt;/screen&gt;    &lt;mode fullscreen=&quot;false&quot;&gt;screen mode&lt;/mode&gt;&lt;/config&gt;</code></pre><p>上面, <code>doc.parse&lt;0&gt;(char_buffer)</code>, 不管你从哪里解析, 自定的 <code>char *</code>或者<code>file&lt;&gt; fdoc(&quot;config.xml&quot;)</code>的data(), 总之, 应该检查一下解析失败的情况:</p><pre><code class="c++">string err;try {    //tmpbuf的生命周期必须到解析完      doc.parse&lt;0&gt;((char*)tmpbuf);} catch (rapidxml::parse_error &amp;e) {      err = &quot;parse xml error: &quot;;    err += e.what();    delete []tmpbuf;    //看看是不是返回给上一级调用者捕获}</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>编辑节点:<br>先删除, 后添加, 并且insert是在指定节点前添加</p><pre><code class="c++">xml_node&lt;&gt;* root = doc.first_node();//删除color节点及其子节点.xml_node&lt;&gt;* delnode = root-&gt;first_node(&quot;color&quot;);root-&gt;remove_node(delnode);//找到要插入节点的位置xml_node&lt;&gt;* lnode = root-&gt;first_node(&quot;screen&quot;);//生成节点xml_node&lt;&gt;* mynode=doc.allocate_node(node_element,&quot;address&quot;,&quot;SH&quot;);//添加节点root-&gt;insert_node(lnode,mynode);</code></pre><p>遍历当前节点的所有子节点:</p><pre><code class="c++">rapidxml::xml_node&lt;char&gt; * node = parent_node-&gt;first_node(&quot;node name&quot;);for( ; node != NULL; ) {     //do sth: name(), value()     //更新节点     node = node-&gt;next_sibling();}</code></pre><p>遍历当前节点所有属性:</p><pre><code class="c++">rapidxml::xml_attribute&lt;char&gt; *attr     = node-&gt;first_attribute(&quot;node name&quot;);for( ; attr != NULL; ) {     //do sth    char *value = attr-&gt;value();    attr = attr-&gt;next_attribute();}</code></pre><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>一个简单的小的开源库, 虽然功能不是太强大, 但是完成日常的解析工作, 没有太多问题.</p><p>开源有坑, 记得填坑.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://rapidxml.sourceforge.net/manual.html" target="_blank" rel="external">RAPIDXML Manual</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      summary of server side network programming model
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Protocol Buffer</title>
    <link href="www.merlinblog.site/2017/08/21/protocol-buffer.html"/>
    <id>www.merlinblog.site/2017/08/21/protocol-buffer.html</id>
    <published>2017-08-21T05:50:41.000Z</published>
    <updated>2017-09-24T07:16:04.919Z</updated>
    
    <content type="html"><![CDATA[<p>最初是在 “序列化” 问题时接触到这个库的(作为XML的替代方案), 之后慢慢熟悉, 发现其在数据存储和RPC数据交换领域有大作为, 好比说客户端Java, 服务器端Cpp; 服务器端通信直接一字节对齐, char<em>来char</em>去, 但是Java就复杂很多(ByteBuffer中根据预定的报文格式, 然后逐字节的解析字段), 并且容易出现拼接错误; 而使用SOAP协议(WebService)作为消息报文的格式载体, 由该方式生成的报文是基于文本格式的, 同时还存在大量的XML描述信息，因此将会大大增加网络IO的负担, 解析速度也不快.</p><p>于是, 来了protocol buffer, 简称protobuffer或者pb.</p><p>本文详细地介绍一下我的一些实践和心得.</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>快速说一下它的某个简单使用, 引入话题.</p><p>比如有个电子商务的系统（假设用C++实现），其中的模块A需要发送大量的订单信息给模块B，通讯的方式使用socket.</p><p>假设订单包括如下属性：</p><pre><code>　　时间：time（用整数表示）　　客户id：userid（用整数表示）　　交易金额：price（用浮点数表示）　　交易的描述：desc（用字符串表示）</code></pre><p>如果使用protobuf实现，首先要写一个proto文件（不妨叫Order.proto），在该文件中添加一个名为”Order”的message结构，用来描述通讯协议中的结构化数据。该文件的内容大致如下：<br>(解释一下: .proto文件确定数据协议，数据结构中存在哪些数据，数据类型是怎么样; 该文件就是一个接口规范)</p><pre><code>message Order{  required int32 time = 1;  required int32 userid = 2;  required float price = 3;  optional string desc = 4;}</code></pre><p>关于modifiers的说明:</p><ul><li>required 不可以增加或删除的字段，必须初始化</li><li>optional 可选字段，可删除，可以不初始化</li><li>repeated 可重复字段， 对应到java文件里，生成的是List</li></ul><p>(在protoBuf 3中，optional和required都不需要的了，如果配了两个，protoBuf 编译器还会报错，但是repeated的还是保留的，用来说明该字段是一个list)</p><p>然后，使用protobuf内置的编译器编译 该proto。由于本例子的模块是C++，你可以通过protobuf编译器的命令行参数，让它生成C++语言的“订单包装类”。（一般来说，一个message结构会生成一个包装类）然后你使用类似下面的代码来序列化/解析该订单包装类：</p><pre><code>// 发送方Order order;order.set_time(XXXX);order.set_userid(123);order.set_price(100.0f);order.set_desc(&quot;a test order&quot;);string sOrder;order.SerailzeToString(&amp;sOrder);// 然后调用某种socket的通讯库把序列化之后的字符串发送出去// ......// 接收方string sOrder;// 先通过网络通讯库接收到数据，存放到某字符串sOrder// ......Order order;if(order.ParseFromString(sOrder))  // 解析该字符串{  cout &lt;&lt; &quot;userid:&quot; &lt;&lt; order.userid() &lt;&lt; endl          &lt;&lt; &quot;desc:&quot; &lt;&lt; order.desc() &lt;&lt; endl;}else{  cerr &lt;&lt; &quot;parse error!&quot; &lt;&lt; endl;}</code></pre><p>注: 生成的类中还有其他的序列化API, 比如 <code>ParseFromIstream(&amp;input)</code> 以及 <code>SerializeToOstream(&amp;output)</code> 等.</p><p>有了这种代码生成机制，开发人员再也不用吭哧吭哧地编写那些协议解析的代码了.</p><p>万一将来需求发生变更，要求给订单再增加一个“状态”的属性，那只需要在Order.proto文件中增加一行代码。对于发送方（模块A），只要增加一行设置状态的代码；对于接收方（模块B）只要增加一行读取状态的代码。哇塞，简直太轻松了！</p><p>不说了, 太激动, 请看详情.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>性能好, 效率高(XML解析速度慢, XML冗余信息多空间占用多)</li><li>代码生成机制, 数据解析类自动生成(这个最赞, 你不需要自己去写解析代码了)</li><li>支持向后兼容和向前兼容(得益于约定好的协议, 即使增加字段, 先前的代码也不必改变)</li><li>多语言支持(主流语言Cpp,Java,Python; 前后端语言不一样也没有关系, 协议的处理一致)</li><li>平台无关</li><li>不必学习DOM模型</li></ul><p>性能上和 JSON 拼也是不怕的 <a href="http://cxshun.iteye.com/blog/1974498" target="_blank" rel="external">参考</a></p><p>和 XML，JSON，Thrift相比，Protobuf 有什么不同呢？简单说来 Protobuf 的主要优点就是：简单，快。</p><p>你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。只需使用 Protobuf 对数据结构进行一次描述，即可利用各种不同语言或从各种不同数据流中对你的结构化数据轻松读写。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>应用不够广</li><li>为了提高性能, 导致可读性差(二进制格式)</li></ul><p>正是由于可读性, Protocol Buffer还取代不了XML.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Linux平台 和 Window(VS2015)<br>源码安装: </p><ul><li><a href="http://code.google.com/p/protobuf/downloads/list" target="_blank" rel="external">http://code.google.com/p/protobuf/downloads/list</a></li><li><a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">https://github.com/google/protobuf/releases</a></li></ul><h3 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h3><p>Ubuntu 14, 64bit</p><pre><code>git clone https://github.com/google/protobuf.git</code></pre><p>当然你也可以去release网页下找到相关的包, 在进行编译.</p><p>先确保你及其上有相关的工具集合:</p><ul><li>autoconf</li><li>automake</li><li>libtool</li><li>curl</li><li>make</li><li>g++</li><li>unzip</li></ul><p>然后确保有<code>configure</code>文件, 没有话 <code>./autogen.sh</code> 生成相关脚本(并下载gmock).<br>然后编译安装(可以自己制定位置, 我就默认了)</p><pre><code class="bash">$ ./configure$ make$ make check$ sudo make install$ sudo ldconfig # refresh shared library cache.</code></pre><p>此时 <code>/usr/local/include/google/protobuf</code> 以及 <code>/usr/local/lib</code> 下就有了相应的头文件和库文件, 并且增加了<code>/usr/local/bin/protoc</code>编译器, 此时安装成功.</p><h3 id="windows平台"><a href="#windows平台" class="headerlink" title="windows平台"></a>windows平台</h3><p>这里采用的是VS2015, 操作系统win10 64位.</p><p>在这个<a href="https://github.com/google/protobuf/releases" target="_blank" rel="external">网站</a>找到 <code>protoc-$VERSION-win32.zip</code><br>It contains the protoc binary as well as public proto files of protobuf library.</p><p>这个<a href="https://github.com/google/protobuf/blob/master/cmake/README.md" target="_blank" rel="external">文档</a>记录了相关过程, 这一篇<a href="http://blog.csdn.net/majianfei1023/article/details/45371743" target="_blank" rel="external">文档</a>也可以供您参考</p><h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>主要的使用步骤就是:</p><ol><li>定义你自己的数据结构格式(.pro)源文件</li><li>利用 ProtoBuf 提供的编译器编译源文件</li><li>使用 ProtoBuf C++的 API 读写消息</li></ol><h3 id="简单Demo"><a href="#简单Demo" class="headerlink" title="简单Demo"></a>简单Demo</h3><p>以linux平台为例, 先实践一个简单的:</p><p>定义一个person.pro</p><pre><code>syntax = &quot;proto2&quot;;package lm;message helloworld{   required int32     id = 1;  // ID   required string    str = 2;  // str   optional int32     opt = 3;  //optional field}</code></pre><p>编译:(/usr/local/bin/protoc)</p><pre><code>protoc -I. --cpp_out=. lm.helloworld.proto</code></pre><p>生成了一个头文件和一个源文件:</p><ul><li>lm.helloworld.pb.cc</li><li>lm.helloworld.pb.h</li></ul><p>相当于POJO类或者domain类已经有(并且序列化API也已经有了), 类名 <code>lm::helloworld</code>, 现在可以进行序列化了.</p><p>简单的操作代码如下:<br>(Writer和Reader来对消息进行操作, 序列化和反序列化)<br>writer.cpp</p><pre><code class="c++">#include &quot;lm.helloworld.pb.h&quot;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main(void){  //主要逻辑如下  lm::helloworld msg1;  msg1.set_id(101);   msg1.set_str(&quot;hello&quot;);   // Write the new address book back to disk.   fstream output(&quot;./log&quot;, ios::out | ios::trunc | ios::binary);   if (!msg1.SerializeToOstream(&amp;output)) {     cerr &lt;&lt; &quot;Failed to write msg.&quot; &lt;&lt; endl;     return -1;   }  return 0;}</code></pre><p>reader.cpp</p><pre><code class="c++">#include &quot;lm.helloworld.pb.h&quot;#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;void ListMsg(const lm::helloworld &amp; msg) {   cout &lt;&lt; msg.id() &lt;&lt; endl;   cout &lt;&lt; msg.str() &lt;&lt; endl; } int main(int argc, char* argv[]) {   lm::helloworld msg1;   {     fstream input(&quot;./log&quot;, ios::in | ios::binary);     if (!msg1.ParseFromIstream(&amp;input)) {       cerr &lt;&lt; &quot;Failed to parse address book.&quot; &lt;&lt; endl;       return -1;     }   }   ListMsg(msg1);  return 0;}</code></pre><p>(上面的代码主要用到了 <code>SerializeToOstream</code> 和 <code>ParseFromIstream</code> 两个成员方法)<br>然后编译一下</p><pre><code>main:write readwrite:writer.cpp lm.helloworld.pb.cc         g++ -g -Wall -O0 writer.cpp lm.helloworld.pb.cc \-o write -I. -L/usr/local/lib -lprotobufread:reader.cpp lm.helloworld.pb.cc        g++ -g -Wall -O0 reader.cpp lm.helloworld.pb.cc \-o read -I. -L/usr/local/lib -lprotobufclean:    rm -f read write</code></pre><p>如果你不知道库的具体位置, 那么可以使用<code>pkg-config --cflags --libs protobuf</code>代替后面的 <code>-I</code>等(该工具通过PKG_CONFIG_PATH环境变量指定的地址去找.pc文件, 该文件记录了ProtoBuf安装时头文件和库文件所在的目录, 但是注意, 把<code>PKG_CONFIG_PATH</code>环境变量设置正确, 例如<code>$export PKG_CONFIG_PATH=/usr/local/lib/pkgconfig/</code>)</p><p>运行结果:</p><pre><code>merlin@remote~/test/pb_test$ ./writemerlin@remote~/test/pb_test$ ./read101hello</code></pre><p>总结下来, 其实protocol buffer这个库, 就是解决了你序列化, 或者消息传递时, 需要去写实体类, 以及序列化API的工作, 并且由于消息是语言无关的, 所以又可以跨语言了(当然跨语言时数据类型对接, 还是要在这些API中得到解决的, 这也是该库工作的一部分).</p><p>如果你还没有意识到这个库的重要性, 那么下面涉及到RPC, 序列化的部分, 看看吧:<br><img src="http://omotkhw3y.bkt.clouddn.com/pb_function.png" alt="pb"></p><p>老实说, 初级部分没有太多讲的, 下面看看生成的代码(具体的工程实现细节就不展开了, 只看生成代码的结构, 下面的代码我已经添加了注释):</p><pre><code class="c++">//根据option optimize_for优化类型不同, 可能继承自Message或者MessageLite//MessageLite是Message的父类, Message扩展了反射相关的内容//当 option optimize_for = LITE_RUNTIME;时, 才继承MessageLiteclass helloworld : public ::google::protobuf::Message { /* @@protoc_insertion_point(class_definition:lm.helloworld) */ { public:  helloworld();  virtual ~helloworld();  helloworld(const helloworld&amp; from);  inline helloworld&amp; operator=(const helloworld&amp; from) {    CopyFrom(from);    return *this;  }  inline const ::google::protobuf::UnknownFieldSet&amp; unknown_fields() const {    return _internal_metadata_.unknown_fields();  }  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {    return _internal_metadata_.mutable_unknown_fields();  }  static const ::google::protobuf::Descriptor* descriptor();  static const helloworld&amp; default_instance();  static inline const helloworld* internal_default_instance() {    return reinterpret_cast&lt;const helloworld*&gt;(               &amp;_helloworld_default_instance_);  }  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =    0;  void Swap(helloworld* other);  // implements Message ----------------------------------------------  //下面实现的是Message中的虚函数  //New等同于clone, 创建一个该类的新对象  inline helloworld* New() const PROTOBUF_FINAL { return New(NULL); }  helloworld* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;  //等同于赋值操作符重载（operator=）  void CopyFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FINAL;  void MergeFrom(const ::google::protobuf::Message&amp; from) PROTOBUF_FIeNAL;  void CopyFrom(const helloworld&amp; from);  void MergeFrom(const helloworld&amp; from);  //清空当前对象中的所有数据, 即将所有成员变量置为未初始化状态  void Clear() PROTOBUF_FINAL;  //判断当前状态是否已经初始化  bool IsInitialized() const PROTOBUF_FINAL;  //在给当前对象的所有变量赋值之后, 获取该对象序列化后所需要的字节数  size_t ByteSizeLong() const PROTOBUF_FINAL;  bool MergePartialFromCodedStream(      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;  void SerializeWithCachedSizes(      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }  private:  void SharedCtor();  void SharedDtor();  void SetCachedSize(int size) const PROTOBUF_FINAL;  void InternalSwap(helloworld* other);  private:  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {    return NULL;  }  inline void* MaybeArenaPtr() const {    return NULL;  }  public:  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;  // nested types ----------------------------------------------------  //没有嵌套, 所以这里为空  // accessors -------------------------------------------------------  //下面的是根据字段生成的代码  // required string str = 2;  //字段已经赋值, 返回true  bool has_str() const;  //清除该字段值  void clear_str();  //这个静态成员表示字段 str 的编码值  static const int kStrFieldNumber = 2;  //拿到字段值  const ::std::string&amp; str() const;  //设置字段值  void set_str(const ::std::string&amp; value);  #if LANG_CXX11  void set_str(::std::string&amp;&amp; value);  #endif  void set_str(const char* value);  void set_str(const char* value, size_t size);  ::std::string* mutable_str();  ::std::string* release_str();  void set_allocated_str(::std::string* str);  // required int32 id = 1;  bool has_id() const;  void clear_id();  static const int kIdFieldNumber = 1;  //getter和setter  ::google::protobuf::int32 id() const;  void set_id(::google::protobuf::int32 value);  // optional int32 opt = 3;  bool has_opt() const;  void clear_opt();  static const int kOptFieldNumber = 3;  ::google::protobuf::int32 opt() const;  void set_opt(::google::protobuf::int32 value);  // @@protoc_insertion_point(class_scope:lm.helloworld) private:  void set_has_id();  void clear_has_id();  void set_has_str();  void clear_has_str();  void set_has_opt();  void clear_has_opt();  // helper for ByteSizeLong()  size_t RequiredFieldsByteSizeFallback() const;  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;  ::google::protobuf::internal::HasBits&lt;1&gt; _has_bits_;  mutable int _cached_size_;  ::google::protobuf::internal::ArenaStringPtr str_;  ::google::protobuf::int32 id_;  ::google::protobuf::int32 opt_;  friend struct protobuf_lm_2ehelloworld_2eproto::TableStruct;};// ===================================================================</code></pre><p>上面的代码Message没有嵌套, 还是蛮简单的, 主要使用的是和字段相关的方法(其他序列化方法, 如 SerializeToArray 等, 不在此类中实现). 上目前的 <code>ByteSizeLong()</code> 主要用于序列化到buffer或者array时, 例如:</p><pre><code class="c++">helloworld message;message.set_str(&quot;xxx&quot;);message.set_id(1);message.set_opt(2);size_t length = message.ByteSizeLong();char *buf = new char[length];message.SerializeToArray(buf, length);//读的时候 ParseFromArraydelete []buf;buf = NULL;</code></pre><hr><h3 id="复杂案例"><a href="#复杂案例" class="headerlink" title="复杂案例"></a>复杂案例</h3><p>复杂的案例, 也就是带有嵌套message. 和简单message不同的是, 不能简单的使用set方法设置被嵌套在message内部的内容了, 而是用另外的方法. 下面举一个案例, 如下.<br>.proto文件如下:</p><pre><code>enum UserStatus {  OFFLINE = 0;  ONLINE = 1;}enum LoginResult {  LOGON_RESULT_SUCCESS = 0;  LOGON_RESULT_NOTEXIST = 1;  LOGON_RESULT_ERROR_PASSWD = 2;  LOGON_RESULT_ALREADY_LOGON = 3;  LOGON_RESULT_SERVER_ERROR = 4;}message UserInfo {  required int64 acctID = 1;  required string name = 2;  required UserStatus status = 3;}message LogonRespMessage {  required LoginResult logonResult = 1;   required UserInfo userInfo = 2; //这里嵌套了UserInfo消息}</code></pre><p>生成的关键代码如下:</p><pre><code class="c++">// required .UserInfo userInfo = 2;//下面的成员函数都是因message中定义的UserInfo字段而生成。//这里只是列出和非消息类型字段差异的部分。static const int kUserInfoFieldNumber = 2;inline bool has_userinfo() const;inline void clear_userinfo();inline const ::UserInfo&amp; userinfo() const; //重要inline ::UserInfo* mutable_userinfo(); //重要inline ::UserInfo* release_userinfo(); //重要</code></pre><p>可以看到该类并没有生成用于设置和修改userInfo字段set_userinfo函数，而是将该工作交给了下面的mutable_userinfo函数. 因此每当调用函数之后, Protocol Buffer都会认为该字段的值已经被设置了, 同时 has_userinfo 函数亦将返回true. 在实际编码中, 我们可以通过该函数返回 userInfo 字段的内部指针, 并基于该指针完成userInfo成员变量的初始化工作.<br>而对该字段的操作, 大致如下:</p><pre><code class="c++">LogonRespMessage logonResp;logonResp.set_logonresult(LOGON_RESULT_SUCCESS);//设置枚举//通过mutable_userinfo方法拿到指针UserInfo* userInfo = logonResp.mutable_userinfo();userInfo-&gt;set_acctid(200);userInfo-&gt;set_name(&quot;Tester&quot;);userInfo-&gt;set_status(OFFLINE);//序列化int length = logonResp.ByteSize();char* buf = new char[length];logonResp.SerializeToArray(buf,length);//反序列化LogonRespMessage logonResp2;logonResp2.ParseFromArray(buf,length);printf(&quot;LogonResult = %d, UserInfo-&gt;acctID = %I64d,         UserInfo-&gt;name = %s, UserInfo-&gt;status = %d\n&quot;,    logonResp2.logonresult(),    logonResp2.userinfo().acctid(),    logonResp2.userinfo().name().c_str(),    logonResp2.userinfo().status());delete [] buf;</code></pre><p>如果嵌套中涉及到了 <code>repeated</code>, 例如下面这个案例:</p><pre><code>message BuddyInfo {  required UserInfo userInfo = 1;  required int32 groupID = 2;}message RetrieveBuddiesResp {  required int32 buddiesCnt = 1;  repeated BuddyInfo buddiesInfo = 2;}</code></pre><p>那么它生成代码中, 关于 <code>RetrieveBuddiesResp</code> 部分可能是这样的:</p><pre><code class="c++">class RetrieveBuddiesResp : public ::google::protobuf::MessageLite {public:  RetrieveBuddiesResp();  virtual ~RetrieveBuddiesResp();  // repeated .BuddyInfo buddiesInfo = 2;  static const int kBuddiesInfoFieldNumber = 2;  //返回数组中成员的数量  inline int buddiesinfo_size() const; //重要  //清空数组中的所有已初始化成员, buddiesinfo_size()==0  inline void clear_buddiesinfo();  //返回数组中指定下标所包含元素的引用  inline const ::BuddyInfo&amp; buddiesinfo(int index) const; //重要  //返回数组中指定下标所包含元素的指针(可修改元素)  inline ::BuddyInfo* mutable_buddiesinfo(int index);//重要  //像数组中添加一个新元素(返回值即使新添加元素的指针)  inline ::BuddyInfo* add_buddiesinfo();  //获取buddiesInfo字段所表示的容器(该函数返回的容器仅用于遍历并读取)  inline const ::google::protobuf::RepeatedPtrField&lt; ::BuddyInfo &gt;&amp;  buddiesinfo() const; //重要  //获取buddiesInfo字段所表示的容器指针(该函数返回的容器指针可用于遍历和直接修改)  inline ::google::protobuf::RepeatedPtrField&lt; ::BuddyInfo &gt;*  mutable_buddiesinfo(); //重要};</code></pre><p>对齐操作, 大致上是这样的:</p><pre><code class="c++">  RetrieveBuddiesResp retrieveResp;  retrieveResp.set_buddiescnt(2);  //拿到新元素指针, 然后初始化  BuddyInfo* buddyInfo = retrieveResp.add_buddiesinfo();  buddyInfo-&gt;set_groupid(20);  UserInfo* userInfo = buddyInfo-&gt;mutable_userinfo();  userInfo-&gt;set_acctid(200);  userInfo-&gt;set_name(&quot;user1&quot;);  userInfo-&gt;set_status(OFFLINE);  //下面重复利用了 UserInfo* userInfo    buddyInfo = retrieveResp.add_buddiesinfo();  buddyInfo-&gt;set_groupid(21);  userInfo = buddyInfo-&gt;mutable_userinfo();  userInfo-&gt;set_acctid(201);  userInfo-&gt;set_name(&quot;user2&quot;);  userInfo-&gt;set_status(ONLINE);  //序列化  int length = retrieveResp.ByteSize();  char* buf = new char[length];  retrieveResp.SerializeToArray(buf,length);  //反序列化  RetrieveBuddiesResp retrieveResp2;  retrieveResp2.ParseFromArray(buf,length);  printf(&quot;BuddiesCount = %d\n&quot;,retrieveResp2.buddiescnt());//int32  printf(&quot;Repeated Size = %d\n&quot;,retrieveResp2.buddiesinfo_size());  //通过容器迭代器的方式遍历数组元素的测试代码  //也可以通过( buddiesinfo_size和 buddiesinfo(index) 方式)  //RepeatedPtrField&lt; ::BuddyInfo &gt; &amp;buddiesinfo() const;  RepeatedPtrField&lt;BuddyInfo&gt; *buddiesInfo = retrieveResp2.mutable_buddiesinfo();  RepeatedPtrField&lt;BuddyInfo&gt;::iterator it = buddiesInfo-&gt;begin();  for ( ;it != buddiesInfo-&gt;end(); ++it) {    printf(&quot;BuddyInfo-&gt;groupID = %d\n&quot;, it-&gt;groupid());    printf(&quot;UserInfo-&gt;acctID = %I64d, UserInfo-&gt;name = %s, UserInfo-&gt;status = %d\n&quot;,              it-&gt;userinfo().acctid(),              it-&gt;userinfo().name().c_str(),             it-&gt;userinfo().status());  }  delete [] buf;</code></pre><p>Protocol Buffer仍然提供了很多其它非常有用的功能，特别是针对序列化的目的地，比如文件流和网络流等。与此同时，也提供了完整的官方文档和规范的命名规则，在很多情况下，可以直接通过函数的名字便可获悉函数所完成的工作。</p><hr><h2 id="语言规范"><a href="#语言规范" class="headerlink" title="语言规范"></a>语言规范</h2><h3 id="proto文件"><a href="#proto文件" class="headerlink" title=".proto文件"></a>.proto文件</h3><p> 要通信，必须有协议，否则双方无法理解对方的码流。在protobuf中，协议是由一系列的消息组成的。因此最重要的就是定义通信时使用到的消息格式。</p><h3 id="消息格式"><a href="#消息格式" class="headerlink" title="消息格式"></a>消息格式</h3><p>字段格式<br>字段格式:</p><pre><code>限定修饰符 | 数据类型 | 字段名称 | = | 字段编码值| [字段默认值]</code></pre><ul><li>限定符<br>required\optional\repeated<br>特别说明: repeated表示的字段可以包含0个或多个数据(这一点有别于C++/Java中的数组, 因为后两者中的数组必须包含至少一个元素).<br><code>升级建议</code> : 项目投入运营以后涉及到版本升级时的新增消息字段全部使用optional或者repeated, 尽量不实用required. 如果使用了required，需要全网统一升级，如果使用optional或者repeated可以平滑升级. 不要修改已经存在字段的编码号.  在原有的消息中, 不能移除已经存在的required字段, optional和repeated类型的字段可以被移除, 但是他们之前使用的编码号必须被保留, 不能被新的字段重用.</li><li>数据类型<br>protobuf定义了一套基本数据类型, 这些数据类型, 可以映射到C++\Java等语言的基础数据类型.<br>完整的映射表格如下:<br><img src="http://omotkhw3y.bkt.clouddn.com/pb_types.jpg" alt="types"><br>几乎所有的整型都是, 变长编码; 表示存储的字节数根据数据的大小或者长度而定.<br>例如int32，如果数值比较小，在0~127时，使用一个字节打包, 而并不总是4字节; 甚至大的数字可能占用5个字节.<br>当然message本身也是一种类型(消息可以嵌套消息), 在C++里就表示 object of class.<br>关于fixed32和int32的区别: fixed32的打包效率比int32的效率高, 但是使用的空间一般比int32多. 因此一个属于时间效率高, 一个属于空间效率高. 根据项目的实际情况, 一般选择fixed32, 如果遇到对传输数据量要求比较苛刻的环境, 可以选择int32.<br>枚举值必须大于等于0的整数, 并且使用分号(;)分隔枚举变量而不是C++语言中的逗号(,), 例如:<pre><code class="c++">enum voip_protocol{  H323 = 1;  SIP  = 2;  MGCP = 3;  H248 = 4;}</code></pre></li><li>字段名称<br>protobuf建议字段的命名采用以下划线分割的驼峰式, 例如 first_name. (基本和C语言一样)</li><li><p>字段编码值<br>字段的编码值, 表示不同的字段在序列化后的二进制数据中的布局位置(数字越大越靠后); 根据字段的类型, 一般有对应关系:<br><img src="http://omotkhw3y.bkt.clouddn.com/pb_wiretype.jpg" alt="传输类型"><br>消息中的字段的编码值无需连续, 只要是合法的, 并且不能在同一个消息中有字段包含相同的编码值.<br>根据其内部实现来看, 一般使用在封包和解包时, 你可以把它简单理解成, 编码位置. 不同的编码值, 传输效率是不一样的. 例如编码值的取值范围为 1~2^32, 其中1~15的编码时间和空间效率都是最高的.编码值越大，其编码的时间和空间效率就越低(相对于1-15), protobuf 还建议把经常要传递的值把其字段编码设置为1-15之间的值. </p></li><li><p>默认值<br>默认值. 当在传递数据时，对于required数据类型，如果用户没有设置值，则使用默认值传递到对端。当接受数据时，对于optional字段，如果没有接收到optional字段，则设置为默认值。(一般是反序列化的时候用的, 默认值一般系统指定; 当然你也可以指定, 见上面的编码值对应表)</p></li></ul><h3 id="关于import"><a href="#关于import" class="headerlink" title="关于import"></a>关于import</h3><p> protobuf 接口文件可以像C语言的h文件一个, 分离为多个, 在需要的时候通过 import导入需要对文件. 其行为和C语言的#include或者java的import的行为大致相同, 个人觉得更像Java.</p><h3 id="关于package"><a href="#关于package" class="headerlink" title="关于package"></a>关于package</h3><p>避免名称冲突.可以给每个文件指定一个package名称. 对于java解析为java中的包, 对于C++则解析为名称空间. 例如:</p><pre><code class="java">package ourproject.lyphone;</code></pre><h3 id="Option选项"><a href="#Option选项" class="headerlink" title="Option选项"></a>Option选项</h3><p>在.proto文件中, 还有一些常用选项(示Protocol Buffer编译器帮助我们生成更为匹配的目标语言代码). Protocol Buffer内置的选项被分为以下三个级别:(作用范围不一样)</p><ul><li>文件级别: 这样的选项将影响当前文件中定义的所有消息和枚举</li><li>消息级别: 这样的选项仅影响某个消息及其包含的所有字段</li><li>字段级别: 这样的选项仅仅响应与其相关的字段</li></ul><p>常用的Protocol Buffer选项如下:</p><pre><code>1. option java_package = &quot;com.companyname.projectname&quot;;java_package是文件级别的选项，通过指定该选项可以让生成Java代码的包名为该选项值. 如上例中的Java代码包名为com.companyname.projectname。与此同时，生成的Java文件也将会自动存放到指定输出目录下的com/companyname/projectname子目录中。如果没有指定该选项，Java的包名则为package关键字指定的名称。该选项对于生成C++代码毫无影响。2. option java_outer_classname = &quot;LYPhoneMessage&quot;;java_outer_classname是文件级别的选项，主要功能是显示的指定生成Java代码的外部类名称。如果没有指定该选项，Java代码的外部类名称为当前文件的文件名部分，同时还要将文件名转换为驼峰格式，如：my_project.proto，那么该文件的默认外部类名称将为MyProject。该选项对于生成C++代码毫无影响。注：主要是因为Java中要求同一个.java文件中只能包含一个Java外部类或外部接口，而C++则不存在此限制。因此在.proto文件中定义的消息均为指定外部类的内部类，这样才能将这些消息生成到同一个Java文件中。在实际的使用中，为了避免总是输入该外部类限定符，可以将该外部类 &quot;静态引入&quot; 到当前Java文件中，如：import static com.company.project.LYPhoneMessage.*。3. option optimize_for = LITE_RUNTIME;optimize_for是文件级别的选项，Protocol Buffer定义三种优化级别SPEED/CODE_SIZE/LITE_RUNTIME。缺省情况下是SPEED。* SPEED: 表示生成的代码运行效率高，但是由此生成的代码编译后会占用更多的空间。* CODE_SIZE: 和SPEED恰恰相反，代码运行效率较低，但是由此生成的代码编译后会占用更少的空间，通常用于资源有限的平台，如Mobile。* LITE_RUNTIME: 生成的代码执行效率高，同时生成代码编译后的所占用的空间也是非常少。这是以牺牲Protocol Buffer提供的反射功能为代价的。因此我们在C++中链接Protocol Buffer库时仅需链接libprotobuf-lite，而非libprotobuf。在Java中仅需包含protobuf-java-2.4.1-lite.jar，而非protobuf-java-2.4.1.jar。注：对于LITE_RUNTIME选项而言，其生成的代码均将继承自MessageLite，而非Message。    4. [packed = true]: 因为历史原因，对于数值型的 repeated 字段，如int32、int64等，在编码时并没有得到很好的优化，然而在新近版本的Protocol Buffer中，可通过添加[pack=true]的字段选项，以通知Protocol Buffer在为该类型的消息对象编码时更加高效。如：`repeated int32 samples = 4 [packed=true]`。注：该选项仅适用于2.3.0以上的Protocol Buffer。5. [default = default_value]: optional类型的字段，如果在序列化时没有被设置，或者是老版本的消息中根本不存在该字段，那么在反序列化该类型的消息是，optional的字段将被赋予类型相关的缺省值，如bool被设置为false，int32被设置为0。Protocol Buffer也支持自定义的缺省值，如：optional int32 result_per_page = 3 [default = 10]。</code></pre><h3 id="命令行编译工具"><a href="#命令行编译工具" class="headerlink" title="命令行编译工具"></a>命令行编译工具</h3><p>一般语法是:</p><pre><code>protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto</code></pre><p>简单解释一下:</p><ul><li>protoc为Protocol Buffer提供的命令行编译工具 <code>/usr/local/bin/protoc</code></li><li>–proto_path等同于-I选项，主要用于指定待编译的.proto消息定义文件所在的目录, 或者包含目录该选项可以被同时指定多个</li><li>–cpp_out选项表示生成C++代码,–java_out表示生成Java代码, –python_out则表示生成Python代码, 其后的目录为生成后的代码所存放的目录</li><li>path/to/file.proto表示待编译的消息定义文件路径</li></ul><blockquote><p>对于C++而言，通过Protocol Buffer编译工具，可以将每个.proto文件生成出一对.h和.cc的C++代码文件。生成后的文件可以直接加载到应用程序所在的工程项目中。如：MyMessage.proto生成的文件为MyMessage.pb.h和MyMessage.pb.cc。</p></blockquote><h2 id="动态编译"><a href="#动态编译" class="headerlink" title="动态编译"></a>动态编译</h2><p>运行时编译, 动态解析(该部分对应一些特殊的需求)<br>.proto文件如下:</p><pre><code>package lm;message helloworld{    required int32 id = 1;    required string str = 2;}</code></pre><p>利用compiler 内部的对象:</p><ul><li>MultiFileErrorCollector</li><li>DiskSourceTree</li><li>Importer</li></ul><p>即可完成运行时编译, 详细的代码:</p><pre><code class="c++"> google::protobuf::compiler::MultiFileErrorCollector errorCollector； google::protobuf::compiler::DiskSourceTree sourceTree;  google::protobuf::compiler::Importer importer(&amp;sourceTree, &amp;errorCollector);  sourceTree.MapPath(&quot;&quot;, protosrc);  importer.import(“lm.helloworld.proto”);</code></pre><p>首先构造一个 importer 对象.构造函数需要两个入口参数，一个是 source Tree 对象，该对象指定了存放 .proto 文件的源目录。第二个参数是一个 error collector 对象，该对象有一个 AddError 方法，用来处理解析 .proto 文件时遇到的语法错误. 之后，需要动态编译一个 .proto 文件时，只需调用 importer 对象的 import 方法。</p><p>描述消息: (Package google::protobuf::compiler )</p><ul><li>类 FileDescriptor 表示一个编译后的 .proto 文件；</li><li>类 Descriptor 对应该文件中的一个 Message；</li><li>类 FieldDescriptor 描述一个 Message 中的一个具体 Field<br>三者的组合关系是: FileDescriptor &gt; Descriptor &gt; FieldDescriptor</li></ul><p>例如:</p><pre><code class="c++"> const protobuf::Descriptor *desc =     importer_.pool()-&gt;FindMessageTypeByName(“lm.helloworld”);  const protobuf::FieldDescriptor* field =     desc-&gt;pool()-&gt;FindFileByName (“id”);</code></pre><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>该部分主要了解其两个特征:</p><ul><li>序列化后的信息内容紧凑(这得益于 Protobuf 采用的非常巧妙的 Encoding 方法)</li><li>封包和解包的过程</li></ul><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>关于编码(encode)这一块儿, 怎么样压缩字节存储才最省事儿, 也最容易区分字段field的key-value, 一直是可以改进的领域; 貌似属于科学家研究的问题了. 我这里不展开, 如果展开估计也有一大堆人, 看不懂, 例如:</p><pre><code> 31 30 31 3C 2F 69 64 3E 3C 6E 61 6D 65 3E 68 65  6C 6C 6F 3C 2F 6E 61 6D 65 3E 3C 2F 68 65 6C 6C  6F 77 6F 72 6C 64 3E //一共 55 个字节，这些奇怪的数字需要稍微解释一下，其含义用 ASCII 表示如下： &lt;helloworld&gt;     &lt;id&gt;101&lt;/id&gt;     &lt;name&gt;hello&lt;/name&gt;  &lt;/helloworld&gt;</code></pre><p>其中还涉及到了big, little-endian<br>大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中，这样的存储模式有点儿类似于把数据当作字符串顺序处理：地址由小向大增加，而数据从高位往低位放；这和我们的阅读习惯一致。(从左到右, 地址从低到高)<br>小端模式，是指数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低。</p><p>由于encode和decode涉及到了, 太多的工程细节, 对于实际开发帮助不大, 下面给出一个 <a href="http://shanshanpt.github.io/2016/09/10/protobuf-encode.html" target="_blank" rel="external">Go语言的分析参考</a>.</p><p>但是我不得不说, 即使你看懂了, 看明白了, 真正让你去设计, 还是非常难的, 请量力而行(作为兴趣了解一下还是可以的, 但是作为解决方案参考意义不大).</p><h3 id="封包和解包"><a href="#封包和解包" class="headerlink" title="封包和解包"></a>封包和解包</h3><p>对于XML和JSON的封包和解包.<br>首先一个是二进制存储, 其他的JSON, XML都是文本存储, 原理都不一样; 其次, 我们来了解一下 XML 的封解包过程:</p><blockquote><p>XML 需要从文件中读取出字符串，再转换为 XML 文档对象结构模型。之后，再从 XML 文档对象结构模型中读取指定节点的字符串，最后再将这个字符串转换成指定类型的变量。这个过程非常复杂，其中将 XML 文件转换为文档对象结构模型的过程通常需要完成词法文法分析等大量消耗 CPU 的复杂计算。</p></blockquote><p>好了, XML已经输了.</p><p>protobuf呢?<br>简单的位运算, 速度非常快; 之后存储到c++或者其他语言对应的数据类型中即可. 它只需要简单地将一个二进制序列, 按照指定的格式读取到 C++ 对应的结构类型中就可以了.</p><p>整个解析过程需要 Protobuf 本身的框架代码和由 Protobuf 编译器生成的代码共同完成:</p><ul><li>pb框架:CodedInputStream 类，WireFormatLite 类等提供了对二进制数据的 decode 功能</li><li>pb编译器生成相关语言的类结构代码, 例如lm::Helloworld类的结构 (生成相关类, 一定是编译器在做这件事儿)<br>(之后两者配合, 把读取出来的数据, 赋值给Helloworld类的相应数据成员)</li></ul><h2 id="编写新的Proto编译器"><a href="#编写新的Proto编译器" class="headerlink" title="编写新的Proto编译器"></a>编写新的Proto编译器</h2><p>使用 Google Protocol Buffer 的 Compiler 包，您可以开发出支持其他语言的新的编译器(原生最开始支持 C++, Java, Python)<br>类 CommandLineInterface 封装了 protoc 编译器的前端，包括命令行参数的解析，proto 文件的编译等功能。您所需要做的是实现类 CodeGenerator 的派生类，实现诸如代码生成等后端工作.<br>(该部分属于个高级内容)</p><h2 id="对比Thrift"><a href="#对比Thrift" class="headerlink" title="对比Thrift"></a>对比Thrift</h2><p>大名鼎鼎的 Thrift, 老早就在听外包公司的大佬在说这个<code>脸书</code>的框架, 它和pb对抗起来如何呢?</p><p>protocol buffer 和 thrift对比, 简单来说, <code>没有可比性</code>.</p><p>thrift是全套解决方案, 而protobuffer则仅仅是rpc或者序列化问题的消息解决方案, 两者不在一个级别上. 从框架的复杂性上来说, thrift相对来说比较复杂, 但是功能丰富(全套RPC解决方案,包括序列化机制、传输层、并发处理框架等). pb更加实用, 而thrift更加系统.</p><p>我的另外一篇博文有详细的说 <a href="http://www.merlinblog.site/2017/08/22/thrift.html">thrift</a> .</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>懂了原理以及该库的作用之后, 复杂的案例最多不过帮助你熟悉相关的API; 实际上日常的开发中, 只有在定制化封包, 编码等高级需求中, 才会要求你去了解的实现原理. 好在文本也涉及到了.</p><p>花了好大的力气, 不过总结告一段落了.进一步的学习, 只有源码解析部分了, 有时间了再说.<br>(关于pb2, pb3各自相近的语法, 本文没有说明, 请参考官方文档)</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><h2 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h2><p>pb2的语法:<br><a href="https://developers.google.com/protocol-buffers/docs/proto" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/proto</a></p><p>pb3的语法<br><a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/proto3</a></p><p>Protocol Buffer Basics(C++) :<br><a href="https://developers.google.com/protocol-buffers/docs/cpptutorial" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/cpptutorial</a></p><h2 id="其他参考"><a href="#其他参考" class="headerlink" title="其他参考"></a>其他参考</h2><ol><li><a href="http://mikewang.blog.51cto.com/3826268/1432136" target="_blank" rel="external">http://mikewang.blog.51cto.com/3826268/1432136</a></li><li><a href="http://blog.csdn.net/caisini_vc/article/details/5599468" target="_blank" rel="external">http://blog.csdn.net/caisini_vc/article/details/5599468</a></li><li><a href="http://cxshun.iteye.com/blog/1974498" target="_blank" rel="external">http://cxshun.iteye.com/blog/1974498</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/linux/l-cn-gpb/</a></li><li><a href="http://blog.csdn.net/sheismylife/article/category/1227779" target="_blank" rel="external">http://blog.csdn.net/sheismylife/article/category/1227779</a></li><li><a href="http://blog.csdn.net/hailong0715/article/details/52057873" target="_blank" rel="external">http://blog.csdn.net/hailong0715/article/details/52057873</a></li><li><a href="https://developers.google.com/protocol-buffers/docs/cpptutorial" target="_blank" rel="external">https://developers.google.com/protocol-buffers/docs/cpptutorial</a></li><li><a href="http://blog.csdn.net/hguisu/article/details/20721109" target="_blank" rel="external">http://blog.csdn.net/hguisu/article/details/20721109</a></li><li><a href="http://shanshanpt.github.io/2016/09/10/protobuf-encode.html" target="_blank" rel="external">http://shanshanpt.github.io/2016/09/10/protobuf-encode.html</a></li><li><a href="http://www.cnblogs.com/stephen-liu74/category/442364.html" target="_blank" rel="external">http://www.cnblogs.com/stephen-liu74/category/442364.html</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      google protocolbuffer使用心得
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Gtest</title>
    <link href="www.merlinblog.site/2017/08/20/gtest.html"/>
    <id>www.merlinblog.site/2017/08/20/gtest.html</id>
    <published>2017-08-20T08:58:35.000Z</published>
    <updated>2017-09-24T07:16:11.223Z</updated>
    
    <content type="html"><![CDATA[<p>以前写过一个 <a href="http://www.merlinblog.site/2017/07/06/tdd.html">TDD</a>, 当你的用例全部通过了测试, 你的代码写就写完了.</p><p>如果你只是一个人编码或者只有少数的测试用例, 那么就不会觉得一个个测试去维护的痛苦; 而一个小组的人, 所有人提交上来的代码, 都要先跑一下相关的测试用例, 才能上传, 此时就需要一个自动化的测试框架.</p><p>这方面有CppUnit, Gtest, 不过Gest优势明显. 本文主要总结Gtest(gooel mock暂时不涉及, 文本也不会教你如何去写测试用例). (尽管gtest-runner这种带有GUI的框架, 但是Gtest是其根本)</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>Google test:</p><p>下面简称 gtest, 比较老牌的用于自动化继承测试的框架, 全平台支持.<br>采用成熟框架的好处是不用维护测试框架.</p><p>测试框架, 可以结合CLog系统一起使用吗.</p><p>使用gtest的成熟项目有:</p><ul><li>Chromium</li><li>LLVM</li><li>Protocol Buffers</li><li>Open CV</li></ul><p>使用gtest应该不少于使用cmake的.</p><p>repo地址: <a href="https://github.com/google/googletest" target="_blank" rel="external">https://github.com/google/googletest</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>测试框架帮我们提供了 case 的管理，执行，断言集，运行参数，全局事件工作，所有的这些使得我们只需关注：于对于特定的输入，被测对象的返回是否正常. (但是编写测试用例还是我们自己做). 当然结合单元测试, 还有一些开发方法(Approach to Unit Testing):</p><ul><li>Test-driven development</li><li>Extreme programming</li></ul><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>该部分参考wiki.<br>一般的测试框架的基本架构:(下图中先忽略TestSuite, 下图并不太完整)<br><img src="http://omotkhw3y.bkt.clouddn.com/test_case.jpg" alt=""></p><p>如上图所示，单测框架中通常包括TestRunner, Test, TestResult, TestCase, TestSuite, TestFixture六个组件。</p><ul><li>TestRuner：负责驱动单元测试用例的执行，汇报测试执行的结果, 从而简化测试(主调程序)</li><li>TestFixture：以测试套件的形式提供setUp()和tearDown()方法, 保证两个test case之间的执行是相互独立, 互不影响的.(前置条件)</li><li>TestResult：这个组件用于收集每个test case的执行结果</li><li>Test：作为TestSuite和TestCase的父类暴露run()方法为TestRunner调用</li><li>TestCase：暴露给用户的一个类，用户通过继承TestCase，编写自己的测试用例逻辑</li><li>TestSuite：提供suite功能管理testCase</li><li>Assertions: 断言预测.(预言正确,继续执行; 语言错误,抛出异常,终止执行)</li><li>Test Execution: 独立测试子程序或者套件程序</li><li>Test Result Formatter: 产生人可读的规整日志还是XML.</li></ul><p>正因为相似的体系结构，所以大多数单元测试框架都提供了类似的功能和使用方法。</p><p>那么在单测中引入单元测试框架会带来什么好处，在现有单元测试框架下还会存在什么样不能解决的问题呢？</p><h3 id="优劣势"><a href="#优劣势" class="headerlink" title="优劣势"></a>优劣势</h3><p>优势</p><p>降低编写单元测试的难度:<br>在单元测试中引入单测框架使得编写单测用例时，不需要再关注于如何驱动case的执行，如何收集结果，如何管理case集，只需要关注于如何写好单个测试用例即可；同时，在一些测试框架中通过提供丰富的断言集，公用方法，以及运行参数使得编写单个testcase的过程得到了最大的简化。</p><p>gtest在xUnit架构的基础上增加了很多特性:</p><pre><code>1. Test discovery2. A rich set of assertions (including User-defined)3. Death tests4. Fatal and non-fatal failures5. value/type parameterized tests6. various options for running the tests7. XML test report generation</code></pre><p>当我没有用过的时候, 我也不知道它到底在说啥, 不过用多了就好了.<br>(你可以参考一下docs目录下的相关文档)</p><p>劣势</p><p>单元测试本身不能解决如何编写的问题: (反而增加了系统复杂度)<br>我在单元测试框架中写一个TestCase，与我单独写一个cpp文件在main()方法里写测试代码有什么本质却别吗？用了单元测试框架，并没有解决我在对复杂系统做单测时遇到的问题。<br>没错，对于单个case这两者从本质上说是没有区别的。单元测试框架本身并没有告诉你如何去写TestCase，在这一点上他是没有提供任何帮助的。所以对于一些复杂的场景，只用单元测试框架是有点多少显得无能为力的。</p><p>适用场景有限:<br>使用单元测试框架往往适用于以下场景的测试：单个函数，一个class，或者几个功能相关class的测试，对于纯函数测试，接口级别的测试尤其适用。但是，对于一些复杂场景, 如:</p><ul><li>被测对象依赖复杂，甚至无法简单new出这个对象</li><li>对于一些failure场景的测试</li><li>被测对象中涉及多线程合作</li><li>被测对象通过消息与外界交互的场景<br>(gtest只是一定程度上解决了)<br>单纯依赖单测框架是无法实现单元测试的，而从某种意义上来说，这些场景反而是测试中的重点。以分布式系统的测试为例，class 与 function级别的单元测试对整个系统的帮助不大，当然，这种单元测试对单个程序的质量有帮助；分布式系统测试的要点是测试进程间的交互：一个进程收到客户请求，该如何处理，然后转发给其他进程；收到响应之后，又修改并应答客户；同时分布式系统测试中通常更关注一些异常路径的测试，这些场景才是测试中的重点，也是难点所在。(Mock方法的引入通常能帮助我们解决以上场景中遇到的难题)</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="Linux平台"><a href="#Linux平台" class="headerlink" title="Linux平台"></a>Linux平台</h3><p>下载源码, 编译安装:</p><pre><code class="bash">$ git clone https://github.com/google/googletest$ cmake .$ make $ sudo make install</code></pre><p>当你下载完源码, 进入 <code>googletest目录</code>, 在linux平台下, 只有4个目录是需要的:</p><ul><li>include</li><li>make</li><li>samples</li><li>src</li></ul><p>安装日志大致如下:</p><pre><code>Install the project...-- Install configuration: &quot;&quot;-- Installing: /usr/local/lib/libgtest.a-- Installing: /usr/local/lib/libgtest_main.a-- Installing: /usr/local/include/gtest-- Installing: /usr/local/include/gtest/gtest-typed-test.h-- Installing: /usr/local/include/gtest/gtest-death-test.h-- Installing: /usr/local/include/gtest/gtest-message.h-- Installing: /usr/local/include/gtest/gtest-param-test.h-- Installing: /usr/local/include/gtest/gtest-test-part.h-- Installing: /usr/local/include/gtest/gtest-printers.h-- Installing: /usr/local/include/gtest/gtest_pred_impl.h-- Installing: /usr/local/include/gtest/gtest.h-- Installing: /usr/local/include/gtest/gtest-param-test.h.pump-- Installing: /usr/local/include/gtest/gtest_prod.h-- Installing: /usr/local/include/gtest/internal-- Installing: /usr/local/include/gtest/internal/gtest-param-util-generated.h.pump-- Installing: /usr/local/include/gtest/internal/gtest-tuple.h.pump-- Installing: /usr/local/include/gtest/internal/gtest-internal.h-- Installing: /usr/local/include/gtest/internal/gtest-filepath.h-- Installing: /usr/local/include/gtest/internal/custom-- Installing: /usr/local/include/gtest/internal/custom/gtest-printers.h-- Installing: /usr/local/include/gtest/internal/custom/gtest.h-- Installing: /usr/local/include/gtest/internal/custom/gtest-port.h-- Installing: /usr/local/include/gtest/internal/gtest-type-util.h-- Installing: /usr/local/include/gtest/internal/gtest-linked_ptr.h-- Installing: /usr/local/include/gtest/internal/gtest-death-test-internal.h-- Installing: /usr/local/include/gtest/internal/gtest-param-util-generated.h-- Installing: /usr/local/include/gtest/internal/gtest-tuple.h-- Installing: /usr/local/include/gtest/internal/gtest-string.h-- Installing: /usr/local/include/gtest/internal/gtest-port-arch.h-- Installing: /usr/local/include/gtest/internal/gtest-param-util.h-- Installing: /usr/local/include/gtest/internal/gtest-type-util.h.pump-- Installing: /usr/local/include/gtest/internal/gtest-port.h-- Installing: /usr/local/include/gtest/gtest-spi.h</code></pre><p>主要是安装:<br><code>/usr/local/lib/</code> 库文件 libgtest.a 和 <code>/usr/local/include/gtest</code> 相关头文件.</p><h3 id="window平台"><a href="#window平台" class="headerlink" title="window平台"></a>window平台</h3><p>window平台更加简单, 而且不用你编写makefile文件, 你需要关心两件事儿:</p><ul><li>如果把gtest编译成静态库</li><li>如果在你的单元测试项目中引用</li></ul><p>请去下载　release 版本: <a href="https://github.com/google/googletest/releases" target="_blank" rel="external">https://github.com/google/googletest/releases</a></p><p>下面给出两种方法(都是编译静态库), 它们针对性不同.</p><p>一、 直接利用源码目录中的 msvc 工程<br>首先把源码加压到一个合适的位置, 因为里面的源文件要被引用到的, 打开 <code>D:\googletest-release-1.7.0\msvc\gtest.sln</code> solution文件.<br><img src="http://omotkhw3y.bkt.clouddn.com/gtest_windows.jpg" alt="静态库"></p><p>可以看到, 当你打开这个工程的时候, 里面的4个项目全局是静态库, 话不多说, 编译吧, debug&amp;release版本各一份(用于项目工程的时候, 两份lib都要拷贝). 很幸运, 没有报错.</p><p>(如果报错 <code>error C2977 &quot;std::tuple&quot; too many template arguments</code> 解决方法就是在每隔工程（project）的属性中的C++  –&gt; Preprocessor （预处理）–&gt; preprocessor defination （预处理定义）中增加 <code>_VARIADIC_MAX=10</code>)</p><p>把编译出的release版本的gtest.lib, gtest_main.lib和debug版本的gtestd.lib, gtest_maind.lib 都放到gtest根目录的lib文件夹下(lib和include位于同一级)</p><p>为了方便使用, 配置环境变量 <code>GTEST = D:\Program Files\gtest-1.6.0</code> ; 当然你不配置, 一会儿引用的时候, 选择正确的路径就可以了. 也就是说, 这个工程, 完全就是为了创建这个库的. 后面你再创建项目, 然后引用gtest的头文件和库即可.<br>(这一种也是比较推荐的)</p><p>二、把gtest作为静态库子项目包含进入你的正式项目</p><p>这么做, 可以在unit test项目里面直接引用gtest静态库项目, 和你的主项目, 并且编译release或者debug版本都很方便, 灵活.</p><hr><p>下面我以第一种方式的基础, 测试一下, 是否安装成功.</p><ul><li>新建一个win32控制台项目(解决方案), 选择空项目(不要预编译头), 例如叫”MainProject”, 这个项目里的源码是要被测试的</li><li><p>然后在”MainProject”中添加相关的自己的源码, 下面我给很简单的例子:</p><pre><code class="c++">//sample.h#pragma once  int fun(int a, int b);  /*--------------------*///sample.cpp#include&quot;sample.h&quot;  int fun(int a, int b)    {      return (a-b);    }</code></pre><p>很简单的俩文件.</p></li><li>修改你的MainProject, 不管它原来是哪种类型的项目;测试的时候修改为静态库,并且运行库设置为MTd<br><code>项目属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库</code> 为静态库<code>多线程调试(/MTd)</code></li><li>然后在该解决方案里, 再添加一个项目”GTest”,也是win32控制台项目(不要预编译头), 空项目;</li><li>配置项目”Gtest”的相关头文件和库文件路径, 并引用项目”MainProject”(在添加-&gt;引用里面可以引用).<br><img src="http://omotkhw3y.bkt.clouddn.com/gtest_include.jpg" alt="include"><br><img src="http://omotkhw3y.bkt.clouddn.com/gtest_lib.jpg" alt="lib"><br><img src="http://omotkhw3y.bkt.clouddn.com/gtest_linker_input.jpg" alt="linker_input"><br>当然如果你配置了Gtest环境变量, 可以直接使用 <code>$(Gtest)</code> 进行目录引用</li><li>配置GTest运行库<code>项目属性 -&gt; 配置属性 -&gt; C/C++ -&gt; 代码生成 -&gt; 运行库</code> 为静态库<code>多线程调试(/MTd)</code></li><li>在Gtest中添加相关的测试用例文件吧<br>```c++<br>#include <gtest gtest.h=""><br>#include “../MainProject/sample.h”</gtest></li></ul><p>//包含头文件的时候, 一定注意, 当前是在Gtest的目录下</p><p>TEST(fun, case1)<br>{<br>    EXPECT_LT(-2, fun(1, 2));<br>    EXPECT_EQ(-1, fun(1, 2));</p><pre><code>ASSERT_LT(-2, fun(1, 2));ASSERT_EQ(-1, fun(1, 2));</code></pre><p>}</p><p>int main(int argc, char* argv[])<br>{<br>    ::testing::InitGoogleTest(&amp;argc, argv);<br>    return RUN_ALL_TESTS();<br>}</p><pre><code>运行一下:![run](http://omotkhw3y.bkt.clouddn.com/gtest_run.jpg)补充VStudio的坑:&gt; 在一个vs解决方案中，一个可执行项目依赖多个lib项目的情况下，经常出现此类问题，原因在默认运行时库的引用上。一般情况下，我会首先打开各个项目的属性查看如下选项：项目--属性--配置属性--C/C++--代码生成--运行时库（有/MT，/MTd，/MD，/MDd四个选项, M代表Multi-thead, T代表static, D代表Dynamic）必须查看所有项目使用的库都是相同的，不同的话就修改成相同的吧下面的讲解, 都是基于Linux平台了.## Linux下配置跑一下原生的sample, 然后配置自己的环境.### 原生sample```bash$ cd make$ cat Makefile</code></pre><p>发现这个Makefile是用来编译sample目录下 <code>TESTS = sample1_unittest</code> 的, 所以可以跑一下这个demo:</p><pre><code class="bash">$ makeg++ -isystem ../include -g -Wall -Wextra -pthread -c ../samples/sample1.ccg++ -isystem ../include -g -Wall -Wextra -pthread -c ../samples/sample1_unittest.ccg++ -isystem ../include -I.. -g -Wall -Wextra -pthread -c \            ../src/gtest-all.ccg++ -isystem ../include -I.. -g -Wall -Wextra -pthread -c \            ../src/gtest_main.ccar rv gtest_main.a gtest-all.o gtest_main.oar: creating gtest_main.aa - gtest-all.oa - gtest_main.og++ -isystem ../include -g -Wall -Wextra -pthread -lpthread sample1.o sample1_unittest.o gtest_main.a -o sample1_unittest$ lsgtest-all.o  gtest_main.a  gtest_main.o  Makefile  sample1.o  sample1_unittest  sample1_unittest.o</code></pre><p>运行一下可执行文件即可 <code>./sample1_unittest</code> :</p><pre><code>$ ./sample1_unittestRunning main() from gtest_main.cc[==========] Running 6 tests from 2 test cases.[----------] Global test environment set-up.[----------] 3 tests from FactorialTest[ RUN      ] FactorialTest.Negative[       OK ] FactorialTest.Negative (0 ms)[ RUN      ] FactorialTest.Zero[       OK ] FactorialTest.Zero (0 ms)[ RUN      ] FactorialTest.Positive[       OK ] FactorialTest.Positive (0 ms)[----------] 3 tests from FactorialTest (0 ms total)[----------] 3 tests from IsPrimeTest[ RUN      ] IsPrimeTest.Negative[       OK ] IsPrimeTest.Negative (0 ms)[ RUN      ] IsPrimeTest.Trivial[       OK ] IsPrimeTest.Trivial (0 ms)[ RUN      ] IsPrimeTest.Positive[       OK ] IsPrimeTest.Positive (0 ms)[----------] 3 tests from IsPrimeTest (1 ms total)[----------] Global test environment tear-down[==========] 6 tests from 2 test cases ran. (1 ms total)[  PASSED  ] 6 tests.</code></pre><h3 id="配置环境"><a href="#配置环境" class="headerlink" title="配置环境"></a>配置环境</h3><p>下面配置自己的开发环境, 以便跑自己的用例, 操作步骤如下:</p><ul><li>创建自己的测试目录</li><li>书写自己的makefile文件</li><li>书写自己的测试用例</li></ul><p>创建自己的测试工程目录:</p><pre><code class="bash">$ mkdir -p test/gtest_test$ cd test/gtest_test$ mkdir src out</code></pre><p>其中src目录是书写测试用例的目录, out目录是中间产物编译输出目录; 其中当前目录的 <code>run_test</code> 是唯一的(执行所有测试的)可执行文件.</p><p>创建并编写makefile:<br>(比源码中的makefile精简很多, 因为没有必要重新编译 libgtest_main.a)</p><pre><code class="bash">$ cd test/gtest_test$ touch makefile</code></pre><p>makefile 源码如下:</p><pre><code class="makefile">USER_DIR = .OUT_DIR = $(USER_DIR)/outGTEST_DIR_INCLUDE = /usr/local/includeCPPFLAGS += -isystem -I$(GTEST_DIR_INCLUDE)CXXFLAGS += -g -Wall -Wextra -pthreadTESTS = run_test#gtest lib: libgtest_main.aGTEST_LIB = /usr/local/lib/libgtest.a## our src file ./src/USER_SRCS =$(foreach d,$(USER_DIR)/src,$(wildcard $(d)/*.cpp))OBJS =$(patsubst %.cpp,%.o,$(USER_SRCS)) # %.o#$(warning $(USER_SRCS))#$(warning $(OBJS))###################################################all : $(TESTS)$(TESTS) : $(OBJS)     $(CXX) $(CPPFLAGS) $(CXXFLAGS) $^ -lpthread $(GTEST_LIB) -o $@     mv $^ $(OUT_DIR)# OBJS#$(OBJS) : $(USER_SRCS)./src/%.o : ./src/%.cpp      $(CXX) $(CPPFLAGS) $(CXXFLAGS) -c $&lt; -o $@.PHONY : cleanclean :      rm -f $(TESTS) $(OUT_DIR)/*.o $(OBJS)</code></pre><p>在 src 目录下建立自己的测试用例:</p><p>建立相关的文件</p><pre><code class="bash">$ cd src$ touch sqrt.h sqrt.cpp  sqrt_unittest.cpp</code></pre><p>下面依次编写相关代码:<br>sqrt.h</p><pre><code class="c++">#pragma onceint sqrt(int x);</code></pre><p>sqrt.cpp</p><pre><code class="c++">#include &quot;sqrt.h&quot;//不借助库函数//利用 x*y, 仅当x=y是最大.int sqrt(int x){  if(x&lt;=0) return 0;  if(x==1) return 1;  int small = 0, large = x, tmp = x/2;  /* small----(samll+large)/2----large*/  while(small &lt; large) {    int a = x/tmp;    int b = x/(tmp+1);    if(a==tmp) return a;    if(b==temp+1) return b;    if(tmp&lt;a &amp;&amp; tmp+1&gt;b) {      return tmp;    } else if(tmp&lt;a &amp;&amp; tmp+1&lt;b) {      small = tmp + 1;      tmp = (small + large)/2;    } else {      large = tmp;      tmp = (small + large)/2;    }  }  return -1;}</code></pre><p>sqrt_unittest.cpp<br>(注意文件名, <code>xxx_unittest.cpp</code> 这个文件名并不是固定, 取成别的也无所谓, 只是这样更容易辨认哪一个文件是在测哪个函数而已)</p><pre><code class="c++">#include &quot;sqrt.h&quot;#include &lt;gtest/gtest.h&gt;TEST(SQRTTest, Zero){  EXPECT_EQ(0, sqrt(0));}TEST(SQRTTest, Positive){  EXPECT_EQ(100, sqrt(10000));  EXPECT_EQ(1000, sqrt(1000008));  EXPECT_EQ(99, sqrt(9810));}TEST(SQRTTest, Negative){  int i = -1;  EXPECT_EQ(0, sqrt(i));}int main(int argc, char* argv[]){  ::testing::InitGoogleTest(&amp;argc, argv);  return RUN_ALL_TESTS();}</code></pre><p>编译运行一下:</p><pre><code class="bash">$ makeg++ -isystem -I/usr/local/include -g -Wall -Wextra -pthread -c src/sqrt.cpp -o src/sqrt.og++ -isystem -I/usr/local/include -g -Wall -Wextra -pthread -c src/sqrt_unittest.cpp -o src/sqrt_unittest.og++ -isystem -I/usr/local/include -g -Wall -Wextra -pthread src/sqrt.o src/sqrt_unittest.o -lpthread /usr/local/lib/libgtest.a -o run_testmv src/sqrt.o src/sqrt_unittest.o ./out$ ./run_test [==========] Running 3 tests from 1 test case.[----------] Global test environment set-up.[----------] 3 tests from SQRTTest[ RUN      ] SQRTTest.Zero[       OK ] SQRTTest.Zero (0 ms)[ RUN      ] SQRTTest.Positive[       OK ] SQRTTest.Positive (0 ms)[ RUN      ] SQRTTest.Negative[       OK ] SQRTTest.Negative (0 ms)[----------] 3 tests from SQRTTest (0 ms total)[----------] Global test environment tear-down[==========] 3 tests from 1 test case ran. (0 ms total)[  PASSED  ] 3 tests.</code></pre><p>下面开始进行主要内容介绍.</p><hr><h2 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h2><h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>在包含<code>gtest/gtest.h</code>的源文件中, 要想让Runner运行测试用例, 一般都是这样的套路:</p><pre><code class="c++">#include &lt;gtest/gtest.h&gt;//若干测试//主函数int main(int argc, char* argv[]){  ::testing::InitGoogleTest(&amp;argc, argv);  return RUN_ALL_TESTS();}</code></pre><p>“::testing::InitGoogleTest(&amp;argc, argv)” : 初始化命令行参数(gtest的测试案例允许接收一系列的命令行参数).<br>“RUN_ALL_TESTS()” : 运行所有测试案例.</p><p>关键是要调用 宏函数 <code>RUN_ALL_TEST()</code>.</p><h3 id="断言宏"><a href="#断言宏" class="headerlink" title="断言宏"></a>断言宏</h3><p>断言的宏可以理解为分为两类:</p><ul><li>ASSERT_* 系列的断言，当检查点失败时，退出当前函数(注意:并非退出当前案例)</li><li>EXPECT_* 系列的断言，当检查点失败时，继续往下执行</li></ul><p>例如:</p><pre><code>// int型比较，预期值：3，实际值：Add(1, 2)EXPECT_EQ(3, Add(1, 2));</code></pre><p>假如你的Add(1, 2) 结果为4的话，会在结果中输出:</p><pre><code>error: Value of: Add(1, 2)  Actual: 4Expected:3</code></pre><p>如果想输出更具体的信息, 可以在断言宏的调用后面, 直接输出.</p><pre><code class="c++">for (int i = 0; i &lt; x.size(); ++i){    //出错是, 可以知道x[i], y[i] 但是无法知道 i, 所以添加 &lt;&lt; 输出信息    EXPECT_EQ(x[i], y[i]) &lt;&lt; &quot;Vectors x and y differ at index &quot; &lt;&lt; i;}</code></pre><p>输出</p><pre><code>error: Value of: y[i]  Actual: 4Expected: x[i]Which is: 3Vectors x and y differ at index 2</code></pre><hr><p>下面详细介绍各种宏:</p><p>布尔值检查</p><pre><code>Fatal assertion                  Nonfatal assertion    VerifiesASSERT_TRUE(condition);          EXPECT_TRUE(condition);    condition is trueASSERT_FALSE(condition);      EXPECT_FALSE(condition);    condition is false</code></pre><p>我通常用true的这一组.</p><p>带参数的谓词断言宏:<br>在布尔检查的时候, 没有传入参数, 下面这一组可以传入参数.</p><pre><code>//pred1(val1) returns trueASSERT_PRED1(pred1, val1);    EXPECT_PRED1(pred1, val1);//pred2(val1, val2) returns trueASSERT_PRED2(pred2, val1, val2);  EXPECT_PRED2(pred2, val1, val2);</code></pre><p>(一般最多能传入5个参数)<br>可以看到, 传入参数时, 这里的输出信息也会比较丰富了.</p><p>使用案例:</p><pre><code class="c++">bool MutuallyPrime(int m, int n){    return Foo(m , n) &gt; 1;}TEST(PredicateAssertionTest, Demo){    int m = 5, n = 6;    EXPECT_PRED2(MutuallyPrime, m, n);}</code></pre><p>当失败时，返回错误信息：</p><pre><code>error: MutuallyPrime(m, n) evaluates to false, wherem evaluates to 5n evaluates to 6</code></pre><p>对于这样的宏, 输出信息仍不满意可以使用 <code>XXX_PRED_FORMAT1</code>, 例如:</p><pre><code class="c++">testing::AssertionResult AssertFoo(const char* m_expr, const char* n_expr, const char* k_expr,                   int m,              int n,              int k) {    if (Foo(m, n) == k)        return testing::AssertionSuccess();    testing::Message msg;    msg &lt;&lt; m_expr &lt;&lt; &quot; 和 &quot; &lt;&lt; n_expr &lt;&lt; &quot; 的最大公约数应该是：&quot; &lt;&lt; Foo(m, n) &lt;&lt; &quot; 而不是：&quot; &lt;&lt; k_expr;    return testing::AssertionFailure(msg);}TEST(AssertFooTest, HandleFail){    EXPECT_PRED_FORMAT3(AssertFoo, 3, 6, 2);}</code></pre><p>运行失败时:</p><pre><code>error: 3 和 6 的最大公约数应该是：3 而不是：2</code></pre><p>数值型数据检查:</p><pre><code>Fatal assertion                            Nonfatal assertion            VerifiesASSERT_EQ(expected, actual);        EXPECT_EQ(expected, actual);    expected == actualASSERT_NE(val1, val2);            EXPECT_NE(val1, val2);        val1 != val2ASSERT_LT(val1, val2);            EXPECT_LT(val1, val2);        val1 &lt; val2ASSERT_LE(val1, val2);            EXPECT_LE(val1, val2);        val1 &lt;= val2ASSERT_GT(val1, val2);            EXPECT_GT(val1, val2);        val1 &gt; val2ASSERT_GE(val1, val2);            EXPECT_GE(val1, val2);        val1 &gt;= val2</code></pre><p>就是通常所说的比较值.</p><p>更加进阶的是 浮点数检查:</p><pre><code>//the two float values are almost equalASSERT_FLOAT_EQ(expected, actual);    EXPECT_FLOAT_EQ(expected, actual);//the two double values are almost equalASSERT_DOUBLE_EQ(expected, actual);    EXPECT_DOUBLE_EQ(expected, actual);</code></pre><p>字符串检查:</p><pre><code>the two C strings have the same content:    ASSERT_STREQ(expected_str, actual_str);        EXPECT_STREQ(expected_str, actual_str);the two C strings have different content:    ASSERT_STRNE(str1, str2);    EXPECT_STRNE(str1, str2);//忽略大小写的一般不常用.the two C strings have different content, ignoring case:    ASSERT_STRCASENE(str1, str2);    EXPECT_STRCASENE(str1, str2);the two C strings have the same content, ignoring case:    ASSERT_STRCASEEQ(expected_str, actual_str);    EXPECT_STRCASEEQ(expected_str, actual_str);</code></pre><p><em>STREQ</em>和<em>STRNE</em>同时支持char<em>和wchar_t</em>类型的:</p><pre><code class="c++">TEST(StringTest, StringCmpTest){    char* pszCoderZh = &quot;CoderZh&quot;;    wchar_t* wszCoderZh = L&quot;CoderZh&quot;;    std::string strCoderZh = &quot;CoderZh&quot;;    std::wstring wstrCoderZh = L&quot;CoderZh&quot;;    EXPECT_STREQ(&quot;CoderZh&quot;, pszCoderZh);    EXPECT_STREQ(L&quot;CoderZh&quot;, wszCoderZh);    EXPECT_STRNE(&quot;CnBlogs&quot;, pszCoderZh);    EXPECT_STRNE(L&quot;CnBlogs&quot;, wszCoderZh);    //忽略大小写的    EXPECT_STRCASEEQ(&quot;coderzh&quot;, pszCoderZh);    //EXPECT_STRCASEEQ(L&quot;coderzh&quot;, wszCoderZh);    不支持    EXPECT_STREQ(&quot;CoderZh&quot;, strCoderZh.c_str());    EXPECT_STREQ(L&quot;CoderZh&quot;, wstrCoderZh.c_str());}</code></pre><p>直接返回的宏:</p><ul><li>直接返回成功：SUCCEED();</li><li>FAIL(); //assert 返回失败</li><li>ADD<em>FAILURE(); //expect 返回失败 (EXPECT</em>*即使返回失败, 也继续执行)</li></ul><p>异常检查:</p><pre><code>//抛出指定异常:ASSERT_THROW(statement, exception_type);    EXPECT_THROW(statement, exception_type);//抛出任何异常:ASSERT_ANY_THROW(statement);    EXPECT_ANY_THROW(statement);//不抛出异常:ASSERT_NO_THROW(statement);    EXPECT_NO_THROW(statement);</code></pre><p>例如:</p><pre><code class="c++">int Foo(int a, int b){    if (a == 0 || b == 0)    {        throw &quot;don&#39;t do that&quot;;    }    int c = a % b;    if (c == 0)        return b;    return Foo(b, c);}TEST(FooTest, HandleZeroInput){    EXPECT_ANY_THROW(Foo(10, 0));    EXPECT_THROW(Foo(0, 5), char*);}</code></pre><p>当然还有其他宏, 不过没有必要一个个列举, 具体可以参考文末的参考资料.</p><h3 id="事件化机制"><a href="#事件化机制" class="headerlink" title="事件化机制"></a>事件化机制</h3><p>事件化机制, 一般就是在 Test Case 之前, 或者之后做一些操作.</p><p>总结一下gtest的事件一共有3种:</p><ul><li>全局的, 所有案例执行前后</li><li>TestSuite级别的, 在某一批案例中第一个案例前, 最后一个案例执行后</li><li>TestCase级别的, 每个TestCase前后</li></ul><p>(TestSuite和TestCase都是用TEST_F宏)</p><p>下面一个个讲解一下:</p><p>全局事件.</p><p>要实现全局事件, 必须写一个类, 继承 <code>testing::Environment</code> 类, 实现里面的SetUp和TearDown方法.</p><ul><li>SetUp()方法在所有案例执行前执行</li><li>TearDown()方法在所有案例执行后执行</li></ul><p>但是, 我们还需要告诉gtest添加这个全局事件, 我们需要在main函数中通过 <code>testing::AddGlobalTestEnvironment</code> 方法将事件注册进来(当然可以多个).</p><p>案例:</p><pre><code class="c++">#include &lt;gtest/gtest.h&gt;#include &lt;iostream&gt;class FooEnvironment : public testing::Environment{public:  virtual void SetUp()  {    std::cout &lt;&lt; &quot;Foo FooEnvironment SetUP&quot; &lt;&lt; std::endl;  }  virtual void TearDown()  {    std::cout &lt;&lt; &quot;Foo FooEnvironment TearDown&quot; &lt;&lt; std::endl;  }};bool returnTest(int a){  return a==1?true:false;}TEST(TestSuite, True){  EXPECT_TRUE(returnTest(1));}TEST(TestSuite, False){  ASSERT_TRUE(returnTest(0));}int main(int argc, char* argv[]){  testing::AddGlobalTestEnvironment(new FooEnvironment);  testing::InitGoogleTest(&amp;argc, argv);  return RUN_ALL_TESTS();}</code></pre><p>运行结果:</p><pre><code>[==========] Running 2 tests from 1 test case.[----------] Global test environment set-up.Foo FooEnvironment SetUP[----------] 2 tests from TestSuite[ RUN      ] TestSuite.True[       OK ] TestSuite.True (1 ms)[ RUN      ] TestSuite.Falsesrc/globalpara_unittest.cpp:33: FailureValue of: returnTest(0)  Actual: falseExpected: true[  FAILED  ] TestSuite.False (0 ms)[----------] 2 tests from TestSuite (1 ms total)[----------] Global test environment tear-downFoo FooEnvironment TearDown[==========] 2 tests from 1 test case ran. (1 ms total)[  PASSED  ] 1 test.[  FAILED  ] 1 test, listed below:[  FAILED  ] TestSuite.False 1 FAILED TEST</code></pre><p>特别注意, 继承的是 <code>testing::Environment</code> , 实现 <code>SetUp()</code> 和 <code>TearDown()</code> .</p><p>TestSuite事件</p><p>这种事件是针对特定的TestSuit里面的TestCase的. 需要写一个类，继承testing::Test，然后实现两个 <code>静态</code> 方法:</p><ul><li>static void SetUpTestCase() 方法在第一个TestCase之前执行</li><li>static void TearDownTestCase() 方法在最后一个TestCase之后执行</li></ul><pre><code class="c++">//类的名字就是TestSuite的名字class FooTest : public testing::Test { protected:  static void SetUpTestCase() {    shared_resource_ = new ;  }  static void TearDownTestCase() {    delete shared_resource_;    shared_resource_ = NULL;  }  // Some expensive resource shared by all tests.  static T* shared_resource_;};//注意这里使用的是TEST_F宏TEST_F(FooTest, Test1){    // you can refer to shared_resource here }TEST_F(FooTest, Test2){    // you can refer to shared_resource here }</code></pre><p>因为是针对一个TestSuite里面的所有用例, 所以不用具体的宏, 而是使用的 <code>TEST_F</code> 宏, 但是你可以在<code>TEST_F</code>里面, 再使用具体的宏.</p><p>最后一个 TestCase事件.<br>TestCase事件是挂在每个案例执行前后的, 实现方式和上面的几乎一样, 不过需要实现的是SetUp方法和TearDown方法:</p><ul><li>SetUp()方法在每个TestCase之前执行</li><li>TearDown()方法在每个TestCase之后执行</li></ul><p>也就是说, 其实它还是绑定在 TestSuite 类里面, 即 TestSuite 的那个类要继承 <code>testing::Test</code> , 只不过执行时机是每一个用例跑起来的时候, 执行的不再是相关的静态方法了, 而是<code>Setup</code>和<code>TearDown</code> .</p><p>因为具体的执行还是和TestSuite类有关, 所以当你写测试用例的时候, 还是要写 <code>TEST_F</code> 宏:</p><pre><code class="c++">class FooCalcTest:public testing::Test{protected:    virtual void SetUp()    {        m_foo.Init();    }    virtual void TearDown()    {        m_foo.Finalize();    }    FooCalc m_foo;};TEST_F(FooCalcTest, HandleNoneZeroInput){    EXPECT_EQ(4, m_foo.Calc(12, 16)); }TEST_F(FooCalcTest, HandleNoneZeroInput_Error){    EXPECT_EQ(5, m_foo.Calc(12, 16));}</code></pre><p>注意, 上面demo中 <code>TEST_F</code> 里面的测试并没有太多实在的意义.</p><p>所有的事件, 一般都是做一些资源的分配, 共享, 释放等工作的, 或者共享执行的某一个方法; 只不过它们针对的测试对象, 时间不太一样. (关于事件的使用技巧, 见下文)</p><p>补充:</p><p>TEST与TEST_F之间的区别:</p><p>首先注意, TestSuite事件和TestCase事件都会使用TEST_F宏, 但是需要重写的virtual方法不同:</p><ul><li>SetUp(), TearDown() 适用于TestCase事件(也就是需要在个TestCase执行之前以及之后做事情, 才需要实现这两个方法)</li><li>SetUpTestCase()和TearDownTestCase()针对TestSuite, 也就是只在第一个TestCase之前和最后一个TestCase之后才执行.</li></ul><p>TEST_F比TEST强一些的地方在于TEST_F实际上会生成一个新类(类名用于TEST_F的第一个参数), 该类有SetUp和TearDown函数, SetUpTestCase和TearDownTestCase函数; 根据需求不同, 实现不同的函数.</p><p>同一个TestCase文件中不能混合使用TEST与TEST_F, 也就是说排他.<br>For each TestCase defined with TEST_F(), Google Test will:</p><ul><li>Create a fresh test fixture at runtime (test fixture针对TestSuite中每一个独立的TestCase)</li><li>Immediately initialize it via SetUp()</li><li>Run the test</li><li>Clean up by calling TearDown()</li><li>Delete the test fixture. Note that different tests in the same test case have different test fixture objects, and Google Test always deletes a test fixture before it creates the next one. Google Test does not reuse the same test fixture for multiple tests. Any changes one test makes to the fixture do not affect other tests.</li></ul><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>同一个函数, 多个不同的参数进行调用, 如果没有参数化测试机制, 你的调用可能是这样的.</p><pre><code class="c++">TEST(IsPrimeTest, HandleTrueReturn){    EXPECT_TRUE(IsPrime(3));    EXPECT_TRUE(IsPrime(5));    EXPECT_TRUE(IsPrime(11));    EXPECT_TRUE(IsPrime(23));    EXPECT_TRUE(IsPrime(17));}</code></pre><p>即同一个函数 <code>IsPrime</code> 多次进行调用, 就必须写相应的语句, 但是一旦需要测试的参数范围太大, 那么这么做显然不是了.</p><p>gtest就提供了参数化调用机制, 有了参数化机制, 你的调用可以用一个语句, 完成上面的多次调用.</p><p>首先添加一个类, 继承 <code>testing::TestWithParam&lt;T&gt;</code>, 其中T就是你需要参数化的参数类型, 比如上面的例子, 我需要参数化一个int型的参数:</p><pre><code class="c++">//继承的时候, 要实例化模板参数class IsPrimeParamTest : public::testing::TestWithParam&lt;int&gt;{};</code></pre><p>然后, 再用宏 <code>TEST_P</code> 进行测试: (p代表parameterized)</p><pre><code class="c++">TEST_P(IsPrimeParamTest, HandleTrueReturn){    //拿到具体的参数    int n =  GetParam();    //进行具体的测试    EXPECT_TRUE(IsPrime(n));}</code></pre><p>然后在主函数初始化的时候, 传入参数列表(范围):</p><pre><code class="c++">//testing::Values()生成参数INSTANTIATE_TEST_CASE_P(TrueReturn, IsPrimeParamTest,             testing::Values(3, 5, 11, 23, 17));</code></pre><p>其中第一个参数 <code>TrueReturn</code> 可以任取, 代表参数化测试的名称, 或称之为prefix(实际名称是:prefix/test_case_name.test.name/index, 其中index是参数的编号, 从0开始); 但是第二个必须是参数化的类名; 第三个参数是参数生成器.</p><p>参数生成函数还有:</p><pre><code>//注意名字空间 testing::Range(begin, end[, step]): 范围在begin~end之间, 步长为step, 不包括endValues(v1, v2, ..., vN): v1,v2到vN的值ValuesIn(container) 或 ValuesIn(begin, end) : 从一个C类型的数组或是STL容器或是迭代器中取值Bool() : 取false 和 true 两个值Combine(g1, g2, ..., gN) : 它将g1,g2,...gN进行排列组合.g1,g2,...gN本身是一个参数生成器, 每次分别从g1,g2,..gN中各取出一个值, 组合成一个元组(Tuple)作为一个参数.说明：这个功能只在提供了&lt;tr1/tuple&gt;头的系统中有效.gtest会自动去判断是否支持tr/tuple, 如果你的系统确实支持;而gtest判断错误的话, 你可以重新定义宏GTEST_HAS_TR1_TUPLE=1.</code></pre><p>类型参数<br>不过对于不同数据类型的, 同一调用. (相对同类型不同值的测试, 这个类型化参数复杂一点儿).</p><p>首先定义一个模版类，继承testing::Test,</p><pre><code class="c++">template &lt;typename T&gt;class FooTest : public testing::Test { public:  typedef std::list&lt;T&gt; List;  static T shared_;  T value_;};</code></pre><p>接着我们定义需要测试到的具体数据类型, 比如下面定义了需要测试 char, int 和 unsigned int :</p><pre><code class="c++">typedef testing::Types&lt;char, int, unsigned int&gt; MyTypes;TYPED_TEST_CASE(FooTest, MyTypes);</code></pre><p>然后使用 <code>TYPED_TEST</code> 宏进行测试案例:</p><pre><code class="c++">TYPED_TEST(FooTest, DoesBlah) {  // Inside a test, refer to the special name TypeParam to get the type  // parameter.  Since we are inside a derived class template, C++ requires  // us to visit the members of FooTest via &#39;this&#39;.  TypeParam n = this-&gt;value_;  // To visit static members of the fixture, add the &#39;TestFixture::&#39;  // prefix.  n += TestFixture::shared_;  // To refer to typedefs in the fixture, add the &#39;typename TestFixture::&#39;  // prefix.  The &#39;typename&#39; is required to satisfy the compiler.  typename TestFixture::List values;  values.push_back(n);}</code></pre><p>上面的例子看上去也像是类型的参数化，但是还不够灵活，因为需要事先知道类型的列表。gtest还提供一种更加灵活的类型参数化的方式，允许你在完成测试的逻辑代码之后再去考虑需要参数化的类型列表，并且还可以重复的使用这个类型列表. 下面也是官方的例子:</p><pre><code class="c++">template &lt;typename T&gt;class FooTest : public testing::Test {};TYPED_TEST_CASE_P(FooTest);</code></pre><p>然后使用的是 <code>TYPED_TEST_P</code> 完成具体的测试用例:</p><pre><code class="c++">TYPED_TEST_P(FooTest, DoesBlah) {  // Inside a test, refer to TypeParam to get the type parameter.  TypeParam n = 0;}TYPED_TEST_P(FooTest, HasPropertyA) {   //...  }</code></pre><p>接着使用REGISTER_TYPED_TEST_CASE_P宏注册:</p><pre><code>// 第一个参数是TestSuite的名称, 也是相关类的名称, 后面的参数是TestCaseREGISTER_TYPED_TEST_CASE_P(FooTest, DoesBlah, HasPropertyA);</code></pre><p>接着指定需要的类型列表: (相当于参数生成器)</p><pre><code>typedef testing::Types&lt;char, int, unsigned int&gt; MyTypes;//第一个参数是类型参数化测试的名称, 相当于Prefix, 第二个是参数化类的名称;//第三个参数是自定义的参数生成器INSTANTIATE_TYPED_TEST_CASE_P(My, FooTest, MyTypes);</code></pre><p>总结起来, 这个类型参数化测试是结合的在testing::Test的子类中, 指定的具体的模板参数的特化, 从而在宏 <code>TYPED_TEST_P</code> 完成具体的类型参数测试.</p><p>(相比类型化参数测试, 不同值的参数化测试更加重要一些)</p><h3 id="死亡测试"><a href="#死亡测试" class="headerlink" title="死亡测试"></a>死亡测试</h3><p>某些情况下, 程序会执行奔溃, 但是即使死亡(奔溃), 也应该按照我们预定的方式, 走相应的流程, 这个测试就是看能够在奔溃的时候能否按照预期执行.</p><p>相关的宏:</p><pre><code>statement crashes with the given error:ASSERT_DEATH(statement, regex); EXPECT_DEATH(statement, regex);statement exits with the given error and its exit code matches predicate:ASSERT_EXIT(statement, predicate, regex);EXPECT_EXIT(statement, predicate, regex);</code></pre><p>上面的宏涉及到的正则表达式, 在Linux平台下, 都是POSIX风格的; 而在window下, 则是gtest自己实现的简单正则(意思是少了很多功能). gtest定义两个宏, 用来表示当前系统支持哪套正则表达式风格: </p><ol><li>POSIX风格：GTEST_USES_POSIX_RE = 1 </li><li>Simple风格：GTEST_USES_SIMPLE_RE=1</li></ol><p>下面分别说明一下:<br><code>XXX_DEATH(statement, regex)</code> statement是被测试的代码语句, regex是一个正则表达式, 用来匹配异常时在stderr中输出的内容; 例如下面的例子:</p><pre><code class="c++">void Foo(){    int *pInt = 0; //野指针     *pInt    = 42;}TEST(FooDeathTest, Demo){    EXPECT_DEATH(Foo(), &quot;&quot;);}</code></pre><p>注意, 凡是涉及到死亡测试的, 名字后缀都要带上 “DeathTest”, 就像本例中的 <code>FooDeathTest</code> . 并且gtest会优先运行死亡测试案例.<br>( XXX_DEATH 其实是对 XXX_EXIT 进行的一次包装，XXX_DEATH的 predicate 判断进程是否以非0退出码退出或被一个信号杀死)</p><p><code>XXX_EXIT(statement, predicate, regex)</code>  statement是被测试的代码语句, predicate 在这里必须是一个委托接, 收int型参数并返回bool, 并且只有当返回值为true时, 死亡测试案例才算通过. regex是一个正则表达式，用来匹配异常时在stderr中输出的内容.<br>gtest提供了一些常用的 predicate :</p><pre><code>//如果程序正常退出并且退出码与exit_code相同则返回 truetesting::ExitedWithCode(exit_code)//如果程序被signal_number信号kill的话就返回truetesting::KilledBySignal(signal_number)  // Windows下不支持</code></pre><pre><code>TEST(ExitDeathTest, Demo){    EXPECT_EXIT(_exit(1),  testing::ExitedWithCode(1),  &quot;&quot;);}</code></pre><p><code>XXX_DEBUG_DEATH</code>, debug版本下的死亡测试:</p><pre><code class="c++">#ifdef NDEBUG//release#define EXPECT_DEBUG_DEATH(statement, regex) \  do { statement; } while (false)#define ASSERT_DEBUG_DEATH(statement, regex) \  do { statement; } while (false)//debug  #else#define EXPECT_DEBUG_DEATH(statement, regex) \  EXPECT_DEATH(statement, regex)#define ASSERT_DEBUG_DEATH(statement, regex) \  ASSERT_DEATH(statement, regex)#endif  // NDEBUG for EXPECT_DEBUG_DEATH</code></pre><p>可以看到, 在Debug版和Release版本下, XXX_DEBUG_DEATH的定义不一样. 因为很多异常只会在Debug版本下抛出, 而在Realease版本下不会抛出, 所以针对Debug和Release分别做了不同的处理. 例如:</p><pre><code class="c++">int DieInDebugElse12(int* sideeffect) {    if (sideeffect) *sideeffect = 12;#ifndef NDEBUG    GTEST_LOG_(FATAL, &quot;debug death inside DieInDebugElse12()&quot;);#endif  // NDEBUG    return 12;}TEST(TestCase, TestDieOr12WorksInDgbAndOpt){    int sideeffect = 0;    // Only asserts in dbg.    EXPECT_DEBUG_DEATH(DieInDebugElse12(&amp;sideeffect), &quot;death&quot;);    #ifdef NDEBUG    // opt-mode has sideeffect visible.    EXPECT_EQ(12, sideeffect);    #else    // dbg-mode no visible sideeffect.    EXPECT_EQ(0, sideeffect);    #endif}</code></pre><p>死亡测试的运行方式:</p><ul><li>testing::FLAGS_gtest_death_test_style = “fast”; (默认方式)</li><li>testing::FLAGS_gtest_death_test_style = “threadsafe”;</li></ul><p>(可以为单个测试设置, 或者main函数中为所有的死亡测试设置) 例如:</p><pre><code class="c++">TEST(MyDeathTest, TestOne) {  testing::FLAGS_gtest_death_test_style = &quot;threadsafe&quot;;  // This test is run in the &quot;threadsafe&quot; style:  ASSERT_DEATH(ThisShouldDie(), &quot;&quot;);}TEST(MyDeathTest, TestTwo) {  // This test is run in the &quot;fast&quot; style:  ASSERT_DEATH(ThisShouldDie(), &quot;&quot;);}int main(int argc, char** argv) {  testing::InitGoogleTest(&amp;argc, argv);  testing::FLAGS_gtest_death_test_style = &quot;fast&quot;;  return RUN_ALL_TESTS();}</code></pre><p>总的来说, 死亡测试主要是对奔溃结果进行检查; 借助<code>XXX_DEATH(statement, regex)</code>, <code>XXX_EXIT(statement, predicate, regex)</code> 可以很简单的编写相关的死亡测试.</p><h3 id="运行参数"><a href="#运行参数" class="headerlink" title="运行参数"></a>运行参数</h3><p>通过, 命令行给相关测试传递运行参数(毕竟最后生成的就是一个可行性文件), 或者运行测试的时候给定命令行选项(例如以XML形式输出测试结果)等. gtest为我们提供了一系列的运行参数(环境变量、命令行参数或代码里指定), 使得我们可以对案例的执行进行一些有效的控制.</p><p>前面提到，对于运行参数，gtest提供了三种设置的途径：</p><ul><li>系统环境变量</li><li>命令行参数</li><li>代码中指定FLAG</li></ul><p>优先级原则是:</p><pre><code>命令行参数 &gt; 代码中指定FLAG &gt; 系统环境变量</code></pre><p>(其实是由于后设置的会覆盖最开始的; 所以产生了上面的优先级顺序)</p><p>测试程序的入口, 都会处理这些命令行参数.</p><pre><code class="c++">int main(int argc, char* argv[]){    testing::InitGoogleTest(&amp;argc, argv);    return RUN_ALL_TESTS();}</code></pre><p>也可以使用 <code>可以使用testing::GTEST_FLAG</code> 这个宏来设置相关的FLAG, 比如相对于命令行参数 <code>--gtest_output</code>, 可以使用 <code>testing::GTEST_FLAG(output) = &quot;xml:&quot;</code> 来设置. </p><p>同时推荐将这句放置 InitGoogleTest 之前, 这样就可以使得对于同样的参数, 命令行参数优先级高于代码中指定, 即:</p><pre><code class="c++">int main(int argc, char* argv[]){    testing::GTEST_FLAG(output) = &quot;xml:&quot;;    testing::InitGoogleTest(&amp;argc, argv);    return RUN_ALL_TESTS();}</code></pre><p>指定系统环境变量的方式.</p><p>如果设置系统环境变量给gtest参数, 必须注意的是:</p><ul><li>系统环境变量全大写, 比如对于–gtest_output，响应的系统环境变量为: GTEST_OUTPUT</li><li>有一个命令行参数例外, 那就是–gtest_list_tests, 它是不接受系统环境变量的.(只是用来罗列测试案例名称)</li></ul><p>(个人不建议, 使用环境变量的方式; 这样会扰乱开发环境)</p><p>三种方式中, 最推荐运行时指定, 其他方式总会有这样或者那样的问题(比如代码中设置FLAG, 有些异常就是捕获不到).</p><p>参数列表<br>好比我现在已经编译了一个google test的测试执行文件, 那么给定相关的参数会得到不同的效果, 其中可以使用的参数如下:</p><pre><code>./run_test --helpThis program contains tests written using Google Test. You can use thefollowing command line flags to control its behavior:Test Selection:  --gtest_list_tests 将不会执行里面的测试案例，而是输出一个案例的列表      List the names of all tests instead of running them. The name of      TEST(Foo, Bar) is &quot;Foo.Bar&quot;.  --gtest_filter=POSTIVE_PATTERNS[-NEGATIVE_PATTERNS] 根据给定的表达式,选择运行的案例      Run only the tests whose name matches one of the positive patterns but      none of the negative patterns. &#39;?&#39; matches any single character; &#39;*&#39;      matches any substring; &#39;:&#39; separates two patterns.  --gtest_also_run_disabled_tests 禁止的测试是指, 名称中添加DISABLED前缀      Run all disabled tests too. 例如:    // Tests that Foo does Abc.    TEST(FooTest, DISABLED_DoesAbc) {  }    class DISABLED_BarTest : public testing::Test {  };    // Tests that Bar does Xyz.    TEST_F(DISABLED_BarTest, DoesXyz) {  }Test Execution:  --gtest_repeat=[COUNT] 设置案例重复运行次数      Run the tests repeatedly; use a negative count to repeat forever.  --gtest_shuffle      Randomize tests&#39; orders on every iteration.  --gtest_random_seed=[NUMBER]      Random number seed to use for shuffling test orders (between 1 and      99999, or 0 to use a seed based on the current time).Test Output:  --gtest_color=(yes|no|auto) 默认是彩色输出      Enable/disable colored output. The default is auto.  --gtest_print_time=0 输出命令行时是否打印每个测试案例的执行时间, 默认是不打印的      Don&#39;t print the elapsed time of each test.  --gtest_output=xml[:DIRECTORY_PATH/|:FILE_PATH]      Generate an XML report in the given directory or with the given file      name. FILE_PATH defaults to test_details.xml.  --gtest_stream_result_to=HOST:PORT      Stream test results to the given server.Assertion Behavior:  --gtest_death_test_style=(fast|threadsafe)      Set the default death test style.  --gtest_break_on_failure 调试模式下，当案例失败时停止，方便调试      Turn assertion failures into debugger break-points.  --gtest_throw_on_failure 当案例失败时以C++异常的方式抛出      Turn assertion failures into C++ exceptions.  --gtest_catch_exceptions=0 是否捕捉异常(默认是不捕捉异常的)      不捕捉的话, 可能会弹出一个对话框(阻碍测试);       所以有时候还是要捕捉一下, 就设置一个非0值.      Do not report exceptions as test failures. Instead, allow them      to crash the program or throw a pop-up (on Windows).Except for --gtest_list_tests, you can alternatively set the correspondingenvironment variable of a flag (all letters in upper-case). For example, todisable colored text output, you can either specify --gtest_color=no or setthe GTEST_COLOR environment variable to no.For more information, please read the Google Test documentation athttps://github.com/google/googletest/. If you find a bug in Google Test(not one in your own code or tests), please report it to&lt;googletestframework@googlegroups.com&gt;.</code></pre><p>XML 报告的输出格式如下:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;testsuites tests=&quot;3&quot; failures=&quot;1&quot; errors=&quot;0&quot; time=&quot;35&quot; name=&quot;AllTests&quot;&gt;  &lt;testsuite name=&quot;MathTest&quot; tests=&quot;2&quot; failures=&quot;1&quot;* errors=&quot;0&quot; time=&quot;15&quot;&gt;    &lt;testcase name=&quot;Addition&quot; status=&quot;run&quot; time=&quot;7&quot; classname=&quot;&quot;&gt;      &lt;failure message=&quot;Value of: add(1, 1)  Actual: 3 Expected: 2&quot; type=&quot;&quot;/&gt;      &lt;failure message=&quot;Value of: add(1, -1)  Actual: 1 Expected: 0&quot; type=&quot;&quot;/&gt;    &lt;/testcase&gt;    &lt;testcase name=&quot;Subtraction&quot; status=&quot;run&quot; time=&quot;5&quot; classname=&quot;&quot;&gt;    &lt;/testcase&gt;  &lt;/testsuite&gt;  &lt;testsuite name=&quot;LogicTest&quot; tests=&quot;1&quot; failures=&quot;0&quot; errors=&quot;0&quot; time=&quot;5&quot;&gt;    &lt;testcase name=&quot;NonContradiction&quot; status=&quot;run&quot; time=&quot;5&quot; classname=&quot;&quot;&gt;    &lt;/testcase&gt;  &lt;/testsuite&gt;&lt;/testsuites&gt;</code></pre><p>即使使用<code>--gtest_filter</code> 参数过滤时, 输出的xml报告中还是会包含所有测试案例的信息, 只不过那些不被执行的测试案例的status值为“notrun”.</p><h2 id="内部实现"><a href="#内部实现" class="headerlink" title="内部实现"></a>内部实现</h2><p>内部的关键技术是什么?<br>主要宏注册.一个没有反射(reflection)的测试框架, 必须多做一些工作, 让框架知道相关测试类&amp;用例的存在.那就是宏注册, 以往的CppUnit, CxxTest要么是人工写(每添加一个测试, 就要进行相应的宏注册), 要么是写专门的(Python,Perl)脚本, 通过这个脚本扫描自己编写的文件, 生成一些新的文件. 但是boost::test和gtest则是通过展开宏进行宏注册, 也就是放在预处理阶段.</p><p>主要是宏注册, 然后继承testing::Test类, 之后通过工厂方法创建TestInfo, 并注册给框架gtest.cc里的<code>MakeAndRegisterTestInfo()</code>有一句 <code>GetUnitTestImpl()-&gt;AddTestInfo（xx）</code> , 之后让TestRunner进行调用.</p><pre><code class="c++">//namespace internal:TestInfo* MakeAndRegisterTestInfo(    const char* test_case_name,    const char* name,    const char* type_param,    const char* value_param,    TypeId fixture_class_id,    SetUpTestCaseFunc set_up_tc,    TearDownTestCaseFunc tear_down_tc,    TestFactoryBase* factory) {  TestInfo* const test_info =      new TestInfo(test_case_name, name, type_param, value_param,                   fixture_class_id, factory);  GetUnitTestImpl()-&gt;AddTestInfo(set_up_tc, tear_down_tc, test_info); //关键  return test_info;}</code></pre><p>简单说一下.</p><p>先写一个简单的测试文件:</p><pre><code class="c++">#include &lt;gtest/gtest.h&gt;TEST(TestSuite, Negative){    EXPECT_EQ(1,1);}</code></pre><p>然后用g++展开一下, </p><pre><code>g++ -E main.cpp -o main.i -I/usr/local/include</code></pre><p>得到结果如下(展开的代码非常多, 6万多行, 找到TestSuite_Negative_Test; 最好过滤掉带井号的行)</p><pre><code class="c++"># 2 &quot;main.cpp&quot; 2class# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3: public ::testing::Test { public:# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3() {} private: virtual void TestBody(); static ::testing::TestInfo* const test_info_ __attribute__ ((unused));# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3(# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3const &amp;); void operator=(# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3const &amp;);};::testing::TestInfo* const# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3::test_info_ = ::testing::internal::MakeAndRegisterTestInfo(# 3 &quot;main.cpp&quot;&quot;TestSuite&quot;# 3 &quot;main.cpp&quot; 3,# 3 &quot;main.cpp&quot;&quot;Negative&quot;# 3 &quot;main.cpp&quot; 3, __null, __null, ::testing::internal::CodeLocation(&quot;main.cpp&quot;, 3), (::testing::internal::GetTestTypeId()), ::testing::Test::SetUpTestCase, ::testing::Test::TearDownTestCa\se, new ::testing::internal::TestFactoryImpl&lt;# 3 &quot;main.cpp&quot;TestSuite_Negative_Test# 3 &quot;main.cpp&quot; 3</code></pre><p>差不多已经看到我说的那个样子了(当然你也可以尝试定义自己的宏函数, 宏类; 个人觉得意义不大, 还不如直接去看别人的源码写分析).</p><p>关于gtest源码内容一览:</p><ul><li>预处理技术分析(我已经简单分析了)</li><li>自动调度机制</li><li>结果统计机制</li><li>监听机制</li><li>断言使用方法和解析</li><li>自定义输出技术</li><li>死亡测试技术</li><li>私有属性-方法测试</li><li>参数填充技术</li><li>模板类测试技术</li></ul><p>以后有时间, 单独开贴再写(主要是在预处理部分, <code>.i</code>文件), <a href="">Gtest源码剖析</a></p><p>搞懂了Gtest内部实现, 其实自己也可以尝试着写相关的测试框架(这部分纯属扩展).</p><h2 id="研发测试"><a href="#研发测试" class="headerlink" title="研发测试"></a>研发测试</h2><p>在Google, 质量并不等于测试. “质量不是被测试出来的” 这句老话是再正确不过了. 虽然质量并不是测试出来的, 但我们有同样的证据表明, 没有测试, 你不可能开发出任何有质量的东西. 一个人怎么可能在没有测试的情况下认定你的工程具有高质量?</p><p>对于这种难题，最简单的解决办法就是: 禁止对开发工作开方便之门，以独立自由之精神进行测试。<code>测试和开发工作需要同步进行</code>. 编写一点, 测试一点. 再编写一点, 再测试一点. 更好的方法是制定测试计划或者你开发之前先把计划做好.  (<code>但是这对开发人员的要求很高</code>)</p><p>测试并不是一个独立的工作, 它是开发工作的一部分, 伴随着整个开发过程. 质量不等于测试, 为了质量, 需要你把开发工作和测试结合到一起, 搅拌它们, 直到分不清你我为止.</p><blockquote><p>在Google，这是我们明确的目标：把开发和测试融合，你不能单独进行任何一项工作。做一点，测试一点。再做一点，再测试一点。关键就是看谁在做测试。因为在Google，专职测试人员是出奇的少，所以唯一可行的方法就是使用开发人员。还有比这些实际开发了这些程序的人员更合适做测试的吗? 还有比程序的作者更适合去发现bug的吗? 是谁具有更多的愿望在程序第一次写出时避免bug? Google之所以安排这么少的专职测试人员的原因就是，开发者负责质量。事实上，坚持使用大型测试机构的团队通常会开发出有问题的东西。测试机构庞大，这是一个信号表明编码/测试工作的融和有问题。增加测试人员并不能解决任何问题。这就是说，质量措施更多的应该是一种预防行为，而不是一种发现过程。<code>质量属于开发问题，而不是测试问题</code>。通过把测试工作一定程度的融合到开发过程中，我们极大的降低了一些本来被认为会写很多有问题的代码的人的出错机会。我们不仅避免了大量的客户方的问题，我们还非常有效的降低了测试人员提出的、其实不是bug的bug。在Google，测试工作的目标就是检查这些预防工作是否在有效的运行。测试工程部一直在寻找这种作为bug创造者的软件工程师和作为bug预防者的测试软件工程师之间的联合能达到的效果的证据，一旦这个方法出现问题，他们就会拉响警笛。</p><p>　这种开发和测试的结合随处可见，从代码审查注释上写的“你的测试呢?”到厕所里的给开发者的最好的测试实践方法的宣传画——这是我们臭名昭著的厕所测试指导方针。测试是开发工作中是必不可少的，开发和测试的联姻是孕育质量的过程。软工就是测试者，测试软工就是测试者，测试工程师就是测试者。</p></blockquote><p>个人点评: 关于作者所说的, “这是我们明确的目标：把开发和测试融合，你不能单独进行任何一项工作。做一点，测试一点。再做一点，再测试一点。关键就是看谁在做测试”, 我想这是一个非常理想的情况, 实际上当前的许多大公司也没有做到, 其实也很难做到. 但是有理想总是好的, 慢慢靠近也不错.</p><p>其实可以参考一下TDD和XP或者敏捷等开发方法, 里面也有涉及到相关内容.</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>当初玩gtest也是因为tdd的原因, 毕竟一个认真负责的开发者, 就应该保证自己代码的质量, 编码和测试是分不开的.</p><p>本文又花了很大的篇幅,  记录了整个Gtest的探索过程(当然还有源码剖析一部分没有写后续补上), 希望这些时间没有白费.</p><p>当然最后也强烈推荐一下 <code>测试驱动开发方法</code>, 即 <a href="http://www.merlinblog.site/2017/07/06/tdd.html">tdd</a> .</p><p>(btw: gtest中有很重要的一部分, 是和google mock相关的, 这里没有谈到; 以后专门再说)</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>玩转Google开源C++单元测试框架Google Test系列  (不过它是window平台, 我选用的是linux平台)</li><li>官方文档(docs目录): Primer.md , AdvancedGuide.md , FAQ.md</li><li><a href="http://baidutech.blog.51cto.com/4114344/743740/" target="_blank" rel="external">http://baidutech.blog.51cto.com/4114344/743740/</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      推荐自动化测试框架GoogleTest
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
      <category term="开发管理" scheme="www.merlinblog.site/tags/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>多线程进程调试问题</title>
    <link href="www.merlinblog.site/2017/08/14/debug-multi-thread.html"/>
    <id>www.merlinblog.site/2017/08/14/debug-multi-thread.html</id>
    <published>2017-08-13T16:59:56.000Z</published>
    <updated>2017-09-24T07:14:19.171Z</updated>
    
    <content type="html"><![CDATA[<p>调试多线程不一定用 <code>gdb</code> , 也可以用mdb(modular debugger)等其他工具(<a href="http://nptltracetool.sourceforge.net" target="_blank" rel="external">nptl trace tools</a> 也是不错的工具) 当然我看到的高手调试, 不用工具, 直接加打印语句, 跑程序, 甚至面码. (不得不说, 高手其实是懒得学习使用别人的工具的…)</p><p>这里就单独拎出来总结一下 <code>多线程</code>, <code>多进程</code>的调试问题.</p><p>注: modula-3 supports user-space thread breakpoints.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/threadmap.jpg" alt="post-cover"></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最常见的用GDB的方式, 莫过于:</p><ul><li>All-Stop Mode:    All threads stop when GDB takes control</li><li>Non-Stop Mode:    Other threads continue to execute</li><li>Background Execution:         Running your program asynchronously</li><li>Thread-Specific Breakpoints:      Controlling breakpoints</li><li>Interrupted System Calls:    GDB may interfere with system calls</li><li>Observer Mode:    GDB does not alter program behavior</li></ul><p>其他gdb的调试问题, 可以参考我的文章 <a href="http://www.merlinblog.site/2017/06/24/three-major-tools-of-linux.html">linux下3大件儿</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="调试多线程"><a href="#调试多线程" class="headerlink" title="调试多线程"></a>调试多线程</h2><p>如果你程序是多线程的话，你可以定义你的断点是否在所有的线程上，或是在某个特定的线程。<br>GDB很容易帮你完成这一工作:</p><pre><code>break &lt;linespec&gt; thread &lt;threadno&gt;  break &lt;linespec&gt; thread &lt;threadno&gt; if ...</code></pre><p>说明:</p><ul><li>linespec指定了断点设置在的源程序的行号。</li><li>threadno指定了线程的ID，注意，这个ID是GDB分配的，你可以通过“info threads”命令来查看正在运行程序中的线程信息。如果你不指定thread <threadno>则表示你的断点设在所有线程上面。</threadno></li><li>if表示你还可以为某线程指定断点条件, 例如: (gdb) break frik.c:13 thread 28 if bartab &gt; lim</li></ul><p>当你的程序被GDB停住时，所有的运行线程都会被停住。这方便你你查看运行程序的总体情况。而在你恢复程序运行时，所有的线程也会被恢复运行(哪怕主进程是被在单步调试)。</p><p>thread命令介绍:</p><ul><li>info threads   显示当前可调试的所有线程，GDB为其分配的ID，后面操作线程的时候会用到这个ID (前面有*的是当前调试的线程)</li><li>thread ID   切换当前调试的线程为指定ID的线程</li><li>thread apply ID1 ID2 command   让一个或者多个线程执行GDB命令command</li><li>thread apply all command   让所有被调试线程执行GDB命令command</li><li>set scheduler-locking off|on|step 估计是实际使用过多线程调试的人都可以发现，在使用step或者continue命令调试当前被调试线程的时候，其他线程也是同时执行的，怎么只让被调试程序执行呢？通过这个命令就可以实现这个需求。<ul><li>off 不锁定任何线程，也就是所有线程都执行，这是默认值</li><li>on 只有当前被调试程序会执行</li><li>step 在单步的时候，除了next过一个函数的情况以外，只有当前线程会执行<br>*</li></ul></li></ul><p>注意next其实也是借助break和continue实现的行为.</p><p>(GDB关于线程的实现思路要结合源码看, 需要一定技术水平, 我就不说了)</p><p>最后介绍一下我最近遇见的一个多线程调试和解决:</p><p>调试多线程程序不正常, info threads看不到多线程的信息.  用命令 <code>maintenance print target-stack</code> 看一下target的装载情况, 发现target “multi-thread”没有被装载, 用gdb对gdb程序调试发现在函数 <code>check_for_thread_db</code> 在调用 libthread_db中的函数 “td_ta_new” 的时候, 返回了TD_NOLIBTHREAD, 所以没有装载target “multi-thread”.<br>也就是说, libpthread可能有问题, 检查一下环境发现 libpthread是被strip过的(影响了td_ta_new函数对于libpthread符号信息的获取). 改换一个包含富含信息的(比如debug版本的)libpthread库到lib目录下, 问题解决了.</p><h2 id="调试多进程"><a href="#调试多进程" class="headerlink" title="调试多进程"></a>调试多进程</h2><p>最先想到的就是 attach. attach: 用gdb调试一个正在运行中的进程 <code>gdb &lt;program&gt; PID</code> .</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      summary of server side network programming model
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
      <category term="线程" scheme="www.merlinblog.site/tags/%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>C++网络库(轮子)大杂烩</title>
    <link href="www.merlinblog.site/2017/08/12/network-in-cpp.html"/>
    <id>www.merlinblog.site/2017/08/12/network-in-cpp.html</id>
    <published>2017-08-12T05:04:09.000Z</published>
    <updated>2017-09-24T07:09:23.835Z</updated>
    
    <content type="html"><![CDATA[<p>从最初的 <code>libevent</code> 及其升级版本 <code>libev</code> , 到昨天的 <code>Boost::asio</code> , C++中的网络库还真不少.</p><p>当然像ACE那种大库, 我就不说了, 太大了, 也很复杂.</p><p>本文基于过去的linux网络编程知识, 以及相应的库, 源码, 一个个说一说, 并且给出一个bench mark.</p><p>(当然也会说到开发难度)<br><a id="more"></a></p><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>先说说为啥标准库中没有网络库?</p><p><img src="http://omotkhw3y.bkt.clouddn.com/cppnetwork.jpg" alt=""></p><p>libevent, libev, asio, IOCP, reactor, proactor等</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>ACE是一个大型的中间件产品，代码20万行左右，过于宏大，一堆的设计模式，架构了一层又一层，使用的时候， 要根据情况，看你从那一层来进行使用。支持跨平台。<br>Boost的ASIO是一个异步IO库，封装了对Socket的常用操作，简化了基于socket程序的开发。支持跨平台。</p><p>libevent是一个C语言写的网络库， 官方主要支持的是类Linux 操作系统， 最新的版本添加了对windows的IOCP的支持。由于IOCP是异步IO，与linux下的POLL模型，EPOLL模型，还有freebsd的KQUEUE等这些同步模型在用法上完全不一致，所以使用方法也不一样，就好比ACE中的Reactor和Proactor模式一样， 使用起来需要转变思路。如果对性能没有特别的要求， 那么使用libevent中的select模型来实现跨平台的操作， select模型可以横跨windows， linux， unix，solaris等系统。<br>libev是一个c语言写的，只支持linux系统的库，我以前研究的时候只封装了EPOLL模型， 不知道现在的新版有没有改进。使用方法类似libevent， 但是非常简洁，代码量是最少的一个库，也就几千行代码。显然这样的代码跨平台肯定是无法支持的了， 如果你只需要在linux下面运行，那用这个库也是可以的。</p><p>ACE网络库在使用中，一直对其中的内存管理搞得一头雾水，分配的内存需要在哪里释放都不知道，ACE不愧是一个做研究用的库， 可以说里面的封装把设计模式这本书中列出的模式都在代码里面实现了一番，用起来感觉是在用Java一样，如果你想使用ACE作为你的网络库， 千万不要仅仅把它当成一个网络库使用， 你要把它当成一个框架来使用，如果你只想用它的网络库， 那大可不必用ACE， 因为它太庞大了，学习起来太费劲。但是你把它当成一个框架来用，你会感觉用的还真爽，该有的东西都有，比如线程池，内存池，定时器，递归锁等，都很方便的。Boost的ASIO，在内存管理方面要直观的多。下面简单地与ACE做个比较。</p><p>1.层次架构：<br>ACE底层是C风格的OS适配层，上一层基于C++的wrap类，再上一层是一些框架（Accpetor, Connector，Reactor，Proactor等），最上一层是框架上服务。<br>Boost.ASIO与之类似，底层是OS的适配层，上一层一些模板类，再上一层模板类的参数化（TCP/UDP），再上一层是服务，它只有一种框架为io_service。<br>livevent在不同的操作系统下，做了多路复用模型的抽象，可以选择使用不同的模型，通过事件函数提供服务。</p><p>2.涉及范围：<br>ACE包含了日志，IPC，线程池，共享内存，配置服务，递归锁，定时器等。<br>ASIO只涉及到Socket，提供简单的线程操作。<br>libevent只提供了简单的网络API的封装， 线程池， 内存池， 递归锁等均需要自己实现。</p><p>3.设计模式：<br>ACE主要应用了Reactor，Proactor等。<br>而ASIO主要应用了Proactor。<br>libevent为Reactor模式</p><p>4.线程调度：<br>ACE的Reactor是单线程调度，Proactor支持多线程调度。<br>ASIO支持单线程与多线程调度。<br>libevent的线程调度需要自己来注册不同的事件句柄。</p><p>5.事件分派处理：<br>ACE主要是注册handler类，当事件分派时，调用其handler的虚挂勾函数。实现ACE_Handler / ACE_Svc_Handler / ACE_Event_handler等类的虚函数。<br>ASIO是基于函数对象的hanlder事件分派。任何函数都可能成为hanlder，少了一堆虚表的维护，调度上优于ACE。<br>libevent基于注册的事件回调函数来实现事件分发。</p><p>6.发布方式：<br>ACE是开源免费的，不依赖于第3方库， 一般应用使用它时，以动态链接的方式发布动态库。<br>ASIO是开源免费的，依赖Boost，应用使用时只要include头文件，不需动态库。<br>libevent为开源免费的，一般编译为静态库进行使用。</p><p>7.可移植性：<br>ACE支持多种平台，可移植性不存在问题，据说socket编程在linux下有不少bugs。<br>ASIO支持多种平台，可移植性不存在问题。<br>libevent主要支持linux平台，freebsd平台， 其他平台下通过select模型进行支持， 效率不是太高。</p><p>8.开发难度：<br>基于ACE开发应用，对程序员要求比较高，要用好它，必须非常了解其框架。在其框架下开发，往往new出一个对象，不知在什么地方释放好。<br>基于ASIO开发应用，要求程序员熟悉函数对象，函数指针，熟悉boost库中的boost::bind。内存管理控制方面。</p><p>基于libevent开发应用，相对容易， 具体大家可以参考memcached这个开源的应用，里面使用了libevent这个库。</p><p>其他参考: </p><ul><li><a href="http://blog.csdn.net/earbao/article/details/10934261" target="_blank" rel="external">http://blog.csdn.net/earbao/article/details/10934261</a></li><li><a href="http://blog.csdn.net/csfreebird/article/details/49283743" target="_blank" rel="external">http://blog.csdn.net/csfreebird/article/details/49283743</a></li></ul><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      谈一谈接触到的网络库及其特性, 都是轮子, 轮子.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Asio</title>
    <link href="www.merlinblog.site/2017/08/11/Asio.html"/>
    <id>www.merlinblog.site/2017/08/11/Asio.html</id>
    <published>2017-08-11T14:46:30.000Z</published>
    <updated>2017-09-24T07:02:51.195Z</updated>
    
    <content type="html"><![CDATA[<p>以前在说epoll和libevent的时候, 就谈到了异步IO的封装, 现在专门说说异步网络编程, 主要结合ASIO来说.</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>大概就这个样子<br><img src="http://omotkhw3y.bkt.clouddn.com/overview.gif" alt=""></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      异步网络编程asio库, 不过效率上可能还不如libevent, 真不骗你
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="boost" scheme="www.merlinblog.site/tags/boost/"/>
    
  </entry>
  
  <entry>
    <title>下半生你想怎么过？</title>
    <link href="www.merlinblog.site/2017/07/30/what-u-want.html"/>
    <id>www.merlinblog.site/2017/07/30/what-u-want.html</id>
    <published>2017-07-30T15:15:00.000Z</published>
    <updated>2017-09-24T06:52:04.119Z</updated>
    
    <content type="html"><![CDATA[<p>“子君我问你，生活的意义是什么”　(《我的前半生》俊生问子君)<br>然后子君就回答了: 我的生活意义不是你赋予我的么？家庭美满，白头偕老… <code>然后就...</code><br><img src="http://omotkhw3y.bkt.clouddn.com/myhalflife.jpg" alt=""></p><p>你有没有曾经停下来想一下，我接下来的生活到底该怎么过? 生活的意义是别人赋予和定义的么？你是那种光生存就用尽全部力气的人么？</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>离职差不多５天了，手里几个offer还没有过期，不过我现在还没有心情和心思再回到工作，一方面手里还有一笔钱(没有买车)，所以撑一段时间不会有太多问题; 第二方面父母催着会武汉发展(家里有房子, 也有人可以照顾你了)，也给我描绘了一些蓝图，说实话，我自己也有些心动。</p><p>那么你有没有想想过自己该怎么生活呢？<br>(王老师给我指出了两个方向, 一个是高级工程师&amp;技术专家, 一个是项目经理&amp;总工; 但是这两个目标都不是短期内能完成的, 少说还需要3-5年, 多则6-8年)</p><p>借着几天休息(8-10月是今年招聘的下半场，我在等更好的机会)，读书，运动，会朋友，请教前辈(老工程师, 架构师, 总监和老板), 今天和下午和朋友喝了点酒, 晚上跑步, 又和妹子视频了一会儿, 妹子其中有这样一句话, 特别让我在意: <code>别人都跑4,5公里, 就你这个神经病非要跑７公里</code>. 我想, 估计我就是比较奇怪吧. </p><p>之后突然想明白一件事儿：性格这个东西很难改变的，既然过去父母说我“争强好胜到什么时候呀？”，老师说我“只能用aggressive形容你”.</p><p>那么为什么非要改变性格呢？ <code>有时候，知道自己的优势，那么发挥它不是更好么？</code></p><p>本文记录了我思维挣扎的过程, 也希望看到本文的人, 也能从本文收获到 <code>“follow ur heart”</code>的真谛.</p><p>如果朋友再问我，what u want?  我现在可以毫不犹豫和不后悔的告诉他： <code>I wanna the best.</code></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="理想生活"><a href="#理想生活" class="headerlink" title="理想生活"></a>理想生活</h2><p>所谓的理想生活状态?</p><p>我曾一度以为有一个良好的生活状态是这样的:</p><ul><li>6点起床, 在家里做早点吃卫生点儿; 然后开车出门, 到公司大概8点20左右; 马上投入一天专注的工作;</li><li>下班一般会在7点到7点半之间, 之后去健身房健身游泳; </li><li>之后到家差不多9点半; 对今天做一个大致的总结, 然后进行一些阅读活动进行充电;</li><li>11点半左右睡觉</li><li>礼拜六礼拜天, 参加线下活动或者和朋友聚聚, 或者带着妹纸压马路, 逛商场.</li></ul><p>看吧, 很规律的生活, 很丰富十足的生活.</p><p>但是过去两年的经验, 这种生活, 我得到快乐了么?</p><p>没有, 我甚至时常后悔, 自己花费的时间不值; 浪费了宝贵的时间.</p><p>后来我反思, 如果总是按照这样的历程 rules 后者 routine , 我几乎很难做出成绩; 因为我看到了身边一流的人是怎么在做; 虽然作息时间也是很规律的, 但是大部分时间是投给了自己感兴趣的事业.</p><p>当然保持这样的生活最好, 如果你真的想做些什么, 那么就多投入点儿时间在自己喜欢做的事情上面, 以免将来后悔. 因为理想的生活, 是追随自己的内心的; 而不是写出来的 schedule 或者剧本. </p><p>(当然克制自己任性弱点的一面也是非常必须的)</p><p>理想的生活, 不后悔.</p><h2 id="安稳的生活"><a href="#安稳的生活" class="headerlink" title="安稳的生活"></a>安稳的生活</h2><p>安稳的生活是你所求?</p><p>我的父母自打我工作开始就告诉我, 结婚比工作重要, 人一辈子最大的&amp;最重要的事情就是家庭; 而我始终不能同意这种观点, 因为每个阶段所应该重视的事情是不一样的.</p><ul><li>上学的时候, 因为你要为将来做打算, 所以大部分时间要投入在学习的修习中, 并且由于大学时间还是很充裕, 追个女神也是可以有的.</li><li>刚开始工作, 22-30岁之间, 正是为未来积累人生经验, 财富的时候, 如果这个时候不进行努力, 那么30岁之后就会非常尴尬和被动.(当然在这个阶段的后半段, 我们可能会结婚)</li><li>30岁的男人差不多已经结婚了, 这个时候, 孩子也出生了, 那么你会非常感谢, 那个在年轻阶段, 非常拼搏的你;</li></ul><p><code>所有人最终其实是在为自己的工作, 因为每个人的未来只属于你自己.</code></p><p>所以我也会建议, 在你最能锻炼能力, 积累财富和人脉的阶段, 一定要强迫自己, 锻炼自己, 逆人性, 走出自己的舒适区, 拒绝父母提供的还是比较优厚的条件.说起话来容易, 但是实施起来就没那么容易; 因为比别人投入更多, 而且是坚持投入(哦, 注意一周锻炼3次), 这个非常困难.</p><p>说到底, 安稳的生活到底是不是你所求, 在我而言, 现阶段肯定不是.</p><h2 id="Win-Or-Home"><a href="#Win-Or-Home" class="headerlink" title="Win-Or-Home"></a>Win-Or-Home</h2><p>人生除了娶妻生子, 追到自己喜欢的女神, 之外就是要活的有个样子: <code>物质和精神均独立</code>.</p><pre><code>* 不在乎别人的看法, 有着自己完善的，独立的价值观.* 物质上, 不过分依赖物质生活; (我属于叔本华唯意流派)</code></pre><p>(车就是个代步工具，不买５系也不太表你没有能力,买了也说明不了什么; 关键是正确的看待外物事件和精神世界)</p><p>既然走出来了, 那么就要坚定的走下去, 更加聪明的走下去, 更加努力的走下去, 结合自己的性格, 追随自己内心真实的想法(同时考虑好为此付出的代价).</p><p>至此，下半生不在迷茫, 因为我已经知道我 <code>这个年龄段应该保持的生活状态</code> .<br>(每个阶段利用好每个阶段的资本, 这也重要)</p><p>每个人都有很多烦心事儿, 但那绝对不是我们逃避内心真实想法的借口.</p><blockquote><p>坚持实行想要的东西, 千万不要给自己的未来留下叹息和后悔!!!</p></blockquote><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>违背自己的内心，改变自己的性格是非常难的，也是非常痛苦的；如果你性格上优劣势，那最好改变一下，如果性格可以在某些环境下为你带来优势，那么就发现它, 发挥它！</p><p><code>勇敢做自己</code>: 人活着, 除了房子, 车子, 女人等一切可以比拼的内容, 更重要的, 要活出样子, 让自己顺心(觉得自己做的不够好, 赚的不够多, 就是不顺心), 让那些曾经看不起你的, 现在看不起你的人后悔.</p><blockquote><p>我还是我, 喜欢古典音乐，喜欢探戈，喜欢汽车，喜欢自然，调皮又精致的妹纸. Now fight for my life!</p></blockquote><p>如果要是觉得自己可以, 那么就应该 “The Best or Nothing”  (Mercedes Benz的广告词)</p><blockquote><p>不论做什么, 将来都不要后悔!</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      找到自己的目标并且不再后悔
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>探究一下STL常用算法</title>
    <link href="www.merlinblog.site/2017/07/29/stl-algorithm.html"/>
    <id>www.merlinblog.site/2017/07/29/stl-algorithm.html</id>
    <published>2017-07-29T05:41:45.000Z</published>
    <updated>2017-09-24T06:48:40.167Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>以前学习STL的时候, 只是把常用的(容器)算法说了一下, 大部分算法都是一笔带过的. 现在就专门把这些 <code>算法</code> 全部说一说 (熟悉的过程是螺旋式的渐进, 同样的东西今天再嚼嚼) .</p></blockquote><p>如果你是初学者, 不妨参考一下我上传的 <a href="https://github.com/WizardMerlin/stl_life" target="_blank" rel="external">学习记录</a></p><p><img src="http://omotkhw3y.bkt.clouddn.com/algorithms.jpg" alt="post-cover"></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="常用算法汇总"><a href="#常用算法汇总" class="headerlink" title="常用算法汇总"></a>常用算法汇总</h2><p>按照传统的可变序列和非可变序列的分类方法可能不太好, 下面按照功能分类.</p><ul><li>查找算法, 大致13个, 常用的有 adjacent_find, binary_search, count, count_if, equal_range(), find(), find_if.</li><li>排序算法, 大致有14个, 常用的有 merge, sort, random_shuffle, reverse</li><li>拷贝替换删除, 大致有15个, 常用的有 copy, replace, replace, swap</li><li>算数和生成算法, 大致10个, 常用的有 accumulate, fill</li><li>集合算法, 4个, set_union(), set_intersection(), set_difference</li><li>遍历算法, for_each, transform</li></ul><p>remove_if算法</p><pre><code class="c++">std::vector&lt;int&gt; c { 1,2,3,4,5,6,7 };int x = 5;c.erase(std::remove_if(c.begin(), c.end(), [x](int n) { return n &lt; x; } ), c.end());v.erase(std::remove_if(v.begin(), v.end(), [x](int n) { return n &lt; x; } ), v.end());</code></pre><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://en.cppreference.com/w/cpp/algorithm" target="_blank" rel="external">http://en.cppreference.com/w/cpp/algorithm</a><br>(cppreference的参考手册)</li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      为了方便快速模板编码, 比如yassinep, 专门说说STL中的算法,
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
      <category term="stl" scheme="www.merlinblog.site/tags/stl/"/>
    
      <category term="算法" scheme="www.merlinblog.site/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>time-in-cpp</title>
    <link href="www.merlinblog.site/2017/07/29/time-in-cpp.html"/>
    <id>www.merlinblog.site/2017/07/29/time-in-cpp.html</id>
    <published>2017-07-29T00:00:04.000Z</published>
    <updated>2017-09-21T02:28:34.122Z</updated>
    
    <content type="html"><![CDATA[<p>习惯用的使用c-style的时间, 导致有时候在cpp程序中看着很别扭.</p><p>网上的有些文章看的实在是太敷衍, 索性自己写一篇吧.</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>本文以如下方式展开:</p><ul><li>时间相关的概念</li><li>Linux C中常用时间编程方式和手段</li><li>现代C++时间编程的方式和惯例</li></ul><p>(代码, 命令环境Ubuntu 14)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="UTC"><a href="#UTC" class="headerlink" title="UTC"></a>UTC</h3><p>Coordinated Universal Time,  即GMT(Greenwich Mean Time); 把格林威治标准时间作为标准时间.<br>比如, 中国内地的时间与UTC的时差为+8, 也就是UTC+8, 美国是UTC-5.</p><h3 id="CST"><a href="#CST" class="headerlink" title="CST"></a>CST</h3><p>CST: 中部标准时间, 这个时间是要分时区的. 一般看到的是:</p><ul><li>CST China Standard Time</li><li>CST Cuba Standard Time</li></ul><pre><code class="bash">$ dateTue Jul 29 08:07:51 CST 2017</code></pre><h3 id="DST"><a href="#DST" class="headerlink" title="DST"></a>DST</h3><p>Daylight Saving Time, 又称“日光节约时制”和“夏令时间”，是一种为节约能源而人为规定地方时间的制度，在这一制度实行期间所采用的统一时间称为“夏令时间”。一般在天亮早的夏季人为将时间调快一小时，可以使人早起早睡，减少照明量，以充分利用光照资源，从而节约照明用电。</p><p>根据时区不同, 也不有不同算法调整, 具体可以参考man手册 <code>man gettimeofday</code> .</p><pre><code class="c">#include &lt;sys/time.h&gt;int gettimeofday(struct timeval *tv, struct timezone *tz); //第二个参数一般传入NULLstruct timezone {       int tz_minuteswest;     /* minutes west of Greenwich */       int tz_dsttime;         /* type of DST correction */};</code></pre><h3 id="Epoch"><a href="#Epoch" class="headerlink" title="Epoch"></a>Epoch</h3><p>1970年1月1日0:0:0 UTC(世界标准时间)<br>相当于计时起始时间.</p><h3 id="CalendarTime"><a href="#CalendarTime" class="headerlink" title="CalendarTime"></a>CalendarTime</h3><p><code>日历时间</code> 是用 “从一个标准时间点到此时的时间经过的秒数” 来表示的时间, 它是一个相对时间. (距离时间起点经过的时间)</p><p>这个标准时间点对不同的编译器来说会有所不同, 但对一个编译系统来说, 这个标准时间点是不变的, 该编译系统中的时间对应的日历时间都通过该标准时间点来衡量, 所以可以说日历时间是”相对时间”, 但是无论你在哪一个时区, 在同一时刻对同一个标准时间点来说, 日历时间都是一样的.</p><p>下面的命令可以查看自1970年1月1日0:0:0 UTC(世界标准时间)到现在的秒数:</p><pre><code class="bash">$ date +%s</code></pre><p>然后把这些时间按照我们的年月日换算就可以算出现在的日历时间:</p><pre><code class="bash">$ date -d @秒数</code></pre><h3 id="ClockTick"><a href="#ClockTick" class="headerlink" title="ClockTick"></a>ClockTick</h3><p>时钟计时单元(而不把它叫做时钟滴答次数), 一个 <code>clock tick</code> 不是 CPU 的一个时钟周期, 而是系统的一个基本计时单位(时钟中断的间隔时长).</p><h3 id="Second"><a href="#Second" class="headerlink" title="Second"></a>Second</h3><p>时间单位:</p><ul><li>millisecond 毫秒 ms 1e-3秒</li><li>microsecond 微秒 us 1e-6秒</li><li>nanosecond 纳秒 ns 1e-9秒</li><li>picosecond 皮秒 ps 1e-12秒</li></ul><p>我一般记忆到纳秒:</p><p>1秒是1000毫秒, 100万微妙, 10亿纳秒.</p><hr><p>下面总结编程中需要用的时间内容, 一般是为了</p><ul><li>具体某个函数调用</li><li>统计进程运行时间</li><li>获取系统时间</li><li>profile/性能测试</li></ul><hr><h2 id="C部分"><a href="#C部分" class="headerlink" title="C部分"></a>C部分</h2><p>在Linux C下有两个重要的头文件, <code>time.h</code>, <code>sys/time.h</code>, 主要还是使用 <code>time.h</code>.</p><h3 id="结构体定义"><a href="#结构体定义" class="headerlink" title="结构体定义"></a>结构体定义</h3><p>常用的结构体或定义:</p><ul><li>time_t 统计秒数(注意范围)</li><li>clock_t 时钟单位值(一般用于统计程序运行时间)</li><li>timeval 时间间隔(一般用于gettimeofday, 定时器之类函数参数上)</li><li>tm 正规时间格式, 分解时间(broken-down time)</li></ul><p>你不要关心具体的实现或者定义, 但是知道最好(可能你需要在time_t和tm之间进行转换).</p><p>下面说一下: (环境Ubuntu 64)</p><ul><li>time_t的定义:<br>```c<br><strong>STD_TYPE </strong>TIME_T_TYPE __time_t;      /<em> Seconds since the Epoch.  </em>/</li></ul><p>#define <strong>TIME_T_TYPE           </strong>SLONGWORD_TYPE</p><p>#define __SLONGWORD_TYPE        long int</p><p>//微妙suseconds_t 也是long int </p><pre><code> (他和tm结构体完全不一样)一看就是记录的当前时间秒数, 但是各个编译器厂商记录该时间的定义可能不太一样, 在Visual C++中采用了__time64_t数据类型来保存日历时间, 相应的通过 `_time64()`来获取日历秒数(这样表示的大小更大了)* timeval的定义: (`man gettimeofday`) ```cstruct timeval {       time_t      tv_sec;     /* seconds */       suseconds_t tv_usec;    /* microseconds */};struct timezone {       int tz_minuteswest;     /* minutes west of Greenwich */       int tz_dsttime;         /* type of DST correction */};</code></pre><p> 如果你使用<time.h>则要手动加宏:</time.h></p><pre><code class="c">#include &lt;time.h&gt;#define __need_timeval 1</code></pre><p> 不加宏, 直接用</p><pre><code class="c"># include &lt;sys/time.h&gt;</code></pre><p> 小的测试:</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;sys/time.h&gt;#include &lt;time.h&gt; //ctimeint main(void){  struct timeval tv;  gettimeofday(&amp;tv, NULL);  printf(&quot;%s \n&quot;, ctime(&amp;tv.tv_sec) );  return 0;}</code></pre><ul><li><p>tm 的定义</p><pre><code>       struct tm {             int tm_sec;         /* seconds */             int tm_min;         /* minutes */             int tm_hour;        /* hours */             int tm_mday;        /* day of the month */             int tm_mon;         /* month */             int tm_year;        /* year */             int tm_wday;        /* day of the week */             int tm_yday;        /* day in the year */             int tm_isdst;       /* daylight saving time */         };</code></pre><p>值得注意的是, glic可能有自己的实现, 也就是说还有更多的字段. 其他详细信息可以参考 <code>man ctime</code> 里的说明.</p></li><li>clock_t 定义:<pre><code class="c">#ifndef _CLOCK_T_DEFINED  typedef long clock_t;#define _CLOCK_T_DEFINED  #endif</code></pre>还定义了一秒有多少个 <code>时钟单元</code> :<pre><code class="c">#define CLOCKS_PER_SEC ((clock_t)1000)</code></pre></li></ul><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>定义在 <code>time.h</code> 中的重要函数:</p><ul><li>extern clock_t clock(time_t *__timer);  //查看进程运行时间</li><li>extern time_t time(time_t *__timer); //获取当前系统时间(你拿到的是秒数)</li><li>extern char <em>ctime(__const time_t </em>__timer); //把秒数转换成当前时间格式字符串</li><li>extern char <em>asctime(const struct tm </em>tm); //作用同上, 参数不同</li><li>extern struct tm <em>gmtime(__const time_t </em>__timer);//作用同上, 不过返回是UCT格式结构体</li><li>extern struct tm <em>localtime(const time_t </em>__timer); //作用同上, 不过是当前时区格式结构体</li><li>extern time_t mktime(struct tm *__time); //得到当前时间秒数</li><li>extern double difftime(time_t time1, time_t time0); //计算时间差, 可以自己算</li></ul><p>还有一个提取 <code>struct tm</code> 时间结构体某一项的函数:(类似 sprintf 这种格式化输出)</p><pre><code class="c">//特别注意, 这个函数返回的 buf 没有\0结尾.//并且在存储相关内容之前, 长度不够, 那么返回值为0, 且buf未定义.extern size_t strftime(char *buf,                        size_t max,                        const char *format,                       const struct tm *tm);</code></pre><p>format 的取值如下:</p><pre><code class="c">/*   %a 星期几的简写    %A 星期几的全称    %b 月分的简写    %B 月份的全称    %c 标准的日期的时间串    %C 年份的后两位数字    %d 十进制表示的每月的第几天    %D 月/天/年    %e 在两字符域中，十进制表示的每月的第几天    %F 年-月-日    %g 年份的后两位数字，使用基于周的年    %G 年分，使用基于周的年    %h 简写的月份名    %H 24小时制的小时    %I 12小时制的小时   %j 十进制表示的每年的第几天    %m 十进制表示的月份    %M 十时制表示的分钟数    %n 新行符    %p 本地的AM或PM的等价显示    %r 12小时的时间    %R 显示小时和分钟：hh:mm    %S 十进制的秒数    %t 水平制表符    %T 显示时分秒：hh:mm:ss    %u 每周的第几天，星期一为第一天 （值从0到6，星期一为0）   %U 第年的第几周，把星期日做为第一天（值从0到53）   %V 每年的第几周，使用基于周的年    %w 十进制表示的星期几（值从0到6，星期天为0）   %W 每年的第几周，把星期一做为第一天（值从0到53）    %x 标准的日期串    %X 标准的时间串    %y 不带世纪的十进制年份（值从0到99）   %Y 带世纪部分的十制年份    %z %Z 时区名称，如果不能得到时区名称则返回空字符。   %% 百分号*/</code></pre><p>一个小demo: (12进制显示当前时间)</p><pre><code class="c">char str[100] = {0};//memset(str, 0, 100);struct tm *tm_ptr = localtime(time(NULL));strftime(str, 100, &quot;It is now : %I %p&quot;, pt);str[strlen(str)] = &#39;\0&#39;;//输出strprintf(&quot;%s\n&quot;, str);</code></pre><p>注意:</p><ul><li>注意 <code>clock()</code> 函数, 返回的是 <code>usr time + system time</code>, 即用户时间+内核时间, 返回的时间(始终计数器值)需要转换成秒, 可以用下面的公式:<br>```c<br>//result / CLOCKS_PER_SECOND; //1毫秒, 时钟计数器+1, 即调用clock()函数返回的值就加1</li></ul><p>void elapsed_time()<br>{<br>   printf(“Elapsed time:%u secs./n”, clock()/CLOCKS_PER_SEC);<br>} </p><pre><code> 当然你可以计算某一个调用, 某一个循环化了多长时间:(但是精度到毫秒) ```c long    i = 10000000L; //把i减至0花了多长时间 clock_t start = clock();   while( i-- ); clock_t finish = clock(); double duration = (double)(finish - start) / CLOCKS_PER_SEC;</code></pre><ul><li><code>asctime</code> 和 <code>ctime</code> 将时间以固定的格式显示出来，两者的返回值都是char*型的字符串, 但是参数不同</li><li>注意 <code>gmtime()</code> 以及 <code>localtime</code> 是可以把 time_t 转换成 tm 的; 这两个函数涉及到了tm, 也就不仅仅只有时间, 还有日期了</li><li>注意 <code>mktime()</code> 可以把 tm 当前时间格式, 转换成 time_t 当前时间秒数</li><li>注意 <code>time</code> 拿到的是当前时间的秒数, 见到某平台的库实现 <code>_time64()</code> 也不必惊慌</li></ul><p>完整的定义可以查看 man 手册:</p><pre><code class="c">    #include &lt;time.h&gt;       char *asctime(const struct tm *tm);       char *asctime_r(const struct tm *tm, char *buf);       char *ctime(const time_t *timep);       char *ctime_r(const time_t *timep, char *buf);       struct tm *gmtime(const time_t *timep);       struct tm *gmtime_r(const time_t *timep, struct tm *result);       struct tm *localtime(const time_t *timep);       struct tm *localtime_r(const time_t *timep, struct tm *result);       time_t mktime(struct tm *tm);/*--------------------------------------------------------------*/       #include &lt;time.h&gt;       size_t strftime(char *s, size_t max, const char *format,                       const struct tm *tm);</code></pre><p>定义在sys/time.h中的重要函数</p><pre><code class="c">       #include &lt;sys/time.h&gt;       int gettimeofday(struct timeval *tv, struct timezone *tz);       int settimeofday(const struct timeval *tv, const struct timezone *tz);</code></pre><h3 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h3><pre><code class="c++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;time.h&gt;#include &lt;string.h&gt; //memsetint main(void){  /*    time_t timep;    time_t *timep_ptr = (time_t*)malloc(sizeof(time_t));    timep = time(timep_ptr); //读取时间, 秒数    printf(&quot;ctime returns %s\n&quot;, ctime(&amp;timep)); //转换成字符串输出    printf(&quot;ctime returns %s\n&quot;, ctime(timep_ptr));  */  //推荐  time_t timep;  time(&amp;timep);  printf(&quot;ctime returns %s\n&quot;, ctime(&amp;timep)); //转换成字符串输出  printf(&quot;local time: %s\n&quot;, asctime(localtime(&amp;timep)) );  printf(&quot;gmt time: %s\n&quot;, asctime(gmtime(&amp;timep)) );  //查看时区  char buf[128];  memset(buf, 0, 128);  printf(&quot;globe time: &quot;);   //strftime(buf, 128, &quot;%Z&quot;, gmtime(&amp;timep)); //获取时区信息  strftime(buf, 128, &quot;%Z&quot;, localtime(&amp;timep)); //获取时区信息  printf(&quot;%s\n&quot;, buf);  return 0;}</code></pre><h2 id="Cpp部分"><a href="#Cpp部分" class="headerlink" title="Cpp部分"></a>Cpp部分</h2><p>已经看到了, 如果你去使用C库 <code>time.h</code>, 那么时间操作都是够用的; 但是在C++里一般用 <code>ctime</code>, 如下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/ctime.jpg" alt=""></p><p>其实是没有差距的, 如果你要用 <code>ctime</code> 这个头文件的话(注意, 加上命名空间 <code>std::</code> ).</p><p>但是C++不仅仅包含 <code>C-style date and time library</code> , 这里还从Boost库里引入了 <code>chrono</code> 库:</p><blockquote><p>The chrono library, a flexible collection of types that track time with varying degrees of precision (e.g. std::chrono::time_point)</p></blockquote><p>chrono库包含3个内容:</p><ul><li>durations (std::chrono::duration类模板, 就相当于一个自带时间单位的时间间隔)</li><li>clocks (three clock types)<ul><li>system_clock类 (该类的is_steady属性为false, 会随着系统时间而改变)</li><li>steady_clock类 (不会因为你修改系统时间而改变)</li><li>high_resolution_clock类 (一般是上面两种的宏定义, 具体看平台)</li></ul></li><li>time points (time_point类模板)–时间点</li></ul><p>其中比较有用的就是 system_clock, 相当于原来clock()函数扩展成了一个类, 和 time_point 模板类(可以以system_lock时钟为计时单位参数), 以及计算时间价格的方法的封装类模板 duration. (其实你可以看到, 都是原来时间函数的封装, 以面向对象的姿态展现)</p><p>使用起来, 真的是太方便了, 下面给出一个简单的综合案例:<br>(统计函数调用时间的, 和我们上面c库中clock用法类似)</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;chrono&gt;#include &lt;ctime&gt;long fibonacci(unsigned n){    if (n &lt; 2) return n;    return fibonacci(n-1) + fibonacci(n-2);}int main(){    /*    //原来的写法     clock_t start = clock();     while( i-- );     clock_t finish = clock();     double duration = (double)(finish - start) / CLOCKS_PER_SEC;    */    //using namespace std::chrono;    //以system_clock为计时类型的时间点    //time_point&lt;system_clock&gt; start, end;    std::chrono::time_point&lt;std::chrono::system_clock&gt; start, end;    //start = system_clock::now();    start = std::chrono::system_clock::now();    std::cout &lt;&lt; &quot;f(42) = &quot; &lt;&lt; fibonacci(42) &lt;&lt; std::endl;    end = std::chrono::system_clock::now();    std::chrono::duration&lt;double&gt; elapsed_seconds = end-start;    //time_point 转换成 time_t    std::time_t end_time = std::chrono::system_clock::to_time_t(end);    std::cout &lt;&lt; &quot;finished computation at &quot; &lt;&lt; std::ctime(&amp;end_time)              &lt;&lt; &quot;elapsed time: &quot; &lt;&lt; elapsed_seconds.count() &lt;&lt; &quot;s\n&quot;;}</code></pre><p>下面一个个仔细说:</p><hr><h3 id="duration"><a href="#duration" class="headerlink" title="duration"></a>duration</h3><p>　　<br><code>std::chrono::duration</code> 表示一段时间间隔, 用来记录时间长度(这个时候你可以在模板参数里指定计时单位, 默认是秒), 其原型如下:</p><pre><code class="c++">template&lt;class Rep, class Period = std::ratio&lt;1&gt;&gt; class duration;//默认秒做时间单位</code></pre><ul><li>第一个模板参数 Rep 是一个数值类型(一般是int, 多少秒, 分等),表示时钟个数;</li><li><p>第二个模板参数是一个默认模板参数std::ratio，它的原型是:</p><pre><code class="c++">template&lt;std::intmax_t Num, std::intmax_t Denom = 1&gt; class ratio;</code></pre><p>它表示每个时钟周期的秒数, 其中第一个模板参数 Num 代表分子, Denom代表分母, 分母默认为1, ratio代表的是一个分子除以分母的分数值, 比如 <code>ratio&lt;2&gt;</code> 代表一个时钟周期是两秒, ratio<60>代表了一分钟, ratio<60*60>代表一个小时, ratio<60*60*24>代表一天. 而ratio<1, 1000="">代表的则是1/1000秒即一毫秒, ratio<1, 1000000="">代表一微秒, ratio<1, 1000000000="">代表一纳秒.<br>标准库为了方便使用, 就定义了一些常用的时间间隔, 如时、分、秒、毫秒、微秒和纳秒, 在chrono命名空间下, 它们的定义如下:</1,></1,></1,></60*60*24></60*60></60></p><pre><code class="c++">//在windows平台, 这里的Rep是 整型(不一定是int,可能是int64)typedef duration&lt;Rep, ratio&lt;3600,1&gt;&gt; hours; //std::ratio&lt;3600&gt;typedef duration&lt;Rep, ratio&lt;60,1&gt;&gt; minutes; //std::ratio&lt;60&gt;typedef duration&lt;Rep, ratio&lt;1,1&gt;&gt; seconds; //std::ratio&lt;1&gt;typedef duration&lt;Rep, ratio&lt;1,1000&gt;&gt; milliseconds;typedef duration&lt;Rep, ratio&lt;1,1000000&gt;&gt; microseconds;typedef duration&lt;Rep, ratio&lt;1,1000000000&gt;&gt; nanoseconds;//当然你也可以完全自己定义, 比如说我定义半分钟typedef duration&lt;long, ratio&lt;30&gt;&gt; halfminutes;</code></pre><p>之后你直接使用这些定义好的单位即可(不用再直接使用duration), 例如:</p><pre><code class="c++">//线程睡眠std::this_thread::sleep_for(std::chrono::seconds(3)); //休眠3秒std::this_thread::sleep_for(std::chrono::milliseconds (100)); //休眠100毫秒</code></pre><p>但是注意和 <code>std::</code> 名字空间区分, 例如 <code>std::nano</code>; <code>std::chrono::</code> 下一般是全拼写.</p></li></ul><p>其他一些重要的方法:</p><ul><li><p>count()</p><pre><code class="c++">constexpr rep count() const;//获取时钟(单位)个数, 与单位无关</code></pre><p>例如:<br>```c++<br>#include <chrono><br>#include <iostream><br>int main(void)<br>{<br>std::chrono::milliseconds ms{3}; // 3 milliseconds<br>// 6000 microseconds constructed from 3 milliseconds<br>std::chrono::microseconds us = 2*ms;<br>// 30Hz clock using fractional ticks<br>std::chrono::duration<double, 30="" std::ratio<1,="">&gt; hz30(3.5);</double,></iostream></chrono></p><p>std::cout &lt;&lt;  “3 ms duration has “ &lt;&lt; ms.count() &lt;&lt; “ ticks\n”</p><pre><code>  &lt;&lt;  &quot;6000 us duration has &quot; &lt;&lt; us.count() &lt;&lt; &quot; ticks\n&quot;  &lt;&lt;  &quot;3.5 30Hz duration has &quot; &lt;&lt; hz30.count() &lt;&lt; &quot; ticks\n&quot;;       </code></pre><p>}</p></li></ul><p>/<em> output:<br>3 ms duration has 3 ticks  //count = 3<br>6000 us duration has 6000 ticks //count =6000<br>3.5 30Hz duration has 3.5 ticks //cout = 3.5</em>/</p><pre><code> 并且注意上面的赋值 `us = 2*ms` , 大单位毫秒赋值给微妙是可以的, 但是反过来产生小数就不行了, 这个时候需要自己定义了: ```c++ typedef duration&lt;double, ratio&lt;1,1000&gt;&gt; my_millseconds;//毫秒 std::chrono::microseconds us(3);//微妙 my_millseconds ms = 2us; //微妙转换给毫秒, 产生小数</code></pre><p> 也可以用来计算时间间隔: (直接加减)</p><pre><code class="c++"> std::chrono::minutes t1( 10 ); std::chrono::seconds t2( 60 ); std::chrono::seconds t3 = t1 - t2; //大单位赋值给了小单位, 没有小数产生 std::cout &lt;&lt; t3.count() &lt;&lt; &quot; second&quot; &lt;&lt; std::endl; std::cout &lt;&lt; chrono::duration_cast&lt;chrono::minutes&gt;( t3 ).count()       &lt;&lt;&quot; minutes&quot; &lt;&lt; std::endl;</code></pre><ul><li><p>duration_cast()<br>不同单位类型转换, 但是它只会简单的取整, 例如</p><pre><code class="c++">seconds s(30); //30秒, 转换成分, 是0.5分, 结果下面却输出0auto m = duration_cast&lt;minutes&gt;(s); // 0cout &lt;&lt; m &lt;&lt; endl; //duration对象可以直接输出seconds s(301);cout &lt;&lt; duration_cast&lt;minutes&gt;(s)&lt;&lt; endl; //5</code></pre><p>最好是拿小单位去接收大单位的值, 因为不会有小数部分, 也就不存在被忽略.</p></li><li><p>其他转换<br>对已经存在的duration对象进行其他单位的转换操作(而不是简单的小数截断)<br>```c++<br>//c++17标准<br>floor() //取上限<br>seil() //去下限<br>round() //四舍五入</p><p>//注意使用的时候按照类模板的方式(比Boost中更加丰富的模板参数)<br>template <class toduration,="" class="" rep,="" period=""><br>constexpr ToDuration floor(const duration<rep, period="">&amp; d);<br>``</rep,></class></p></li><li><p>最大最小单位数.<br>也就是某个计时单位的最大最小值. 一般取决于 <code>Rep</code>的类型.</p><pre><code class="c++">//duration 类的成员函数static constexpr duration max(); //返回最大的计时单位个数static constexpr duration min(); //返回最小的计时单位个数static constepr duration zero(); //返回0个单位的时间间隔//例如://static constexpr duration min();  //duration类的成员方法//它返回 std::chrono::duration(std::chrono::duration_values&lt;rep&gt;::min())//而在std::chrono::duration_values类中的成员方法 min()返回//returns std::numeric_limits&lt;Rep&gt;::lowest()</code></pre></li></ul><h3 id="clock"><a href="#clock" class="headerlink" title="clock"></a>clock</h3><p>时钟, duration相当于一个自带单位的时间间隔统计, 那么时钟就是制定计时的仪器; (时间点time_point 记录具体的时间戳, 也是需要时钟的) .这个封装类, 一是要提供计时手段, 另外第一个重要的作用就是用来获取当前时间, 以及实现time_t和time_point的相互转换.</p><p>包含三种不同的时钟:</p><ul><li>system_clock 从系统获取的时钟(但是系统时间可以被修改)</li><li>steady_clock 不能被修改的时钟(从开机开始计算)</li><li>high_resolution_clock 高精度时钟(实际上是system_clock或者steady_clock的别名)</li></ul><p>steady_clock可以获取稳定可靠的时间间隔, 后一次调用now()的值和前一次的差值是不因为修改了系统时间而改变, 它保证了稳定的时间间隔.</p><p>主要方法:</p><ul><li>通过 now() 获取当前时间:<pre><code class="c++">std::chrono::system_clock::time_point t1 = std::chrono::system_clock::now();//等价于std::chrono::time_point&lt;system_clock&gt; t1 = std::chrono::system_clock::now();</code></pre></li><li>通过 to_time_t() 可以将一个 time_point 转换为ctime. (记录时长从 duration 变成 long int)<pre><code class="c++">std::time_t now_c = std::chrono::system_clock::to_time_t(time_point);printf(&quot;%s\n&quot;, ctime(&amp;now_c));</code></pre></li><li>通过from_time_t()来将一个 ctime 转换成 time_point</li></ul><h3 id="time-point"><a href="#time-point" class="headerlink" title="time_point"></a>time_point</h3><p>具体的时间点, 具体的某个时刻, 相对于epoch的经过的时间单位的统计. time_point表示一个时间点, 用来获取1970.1.1以来的秒数和当前的时间, 可以做一些时间的比较和算术运算, 可以和ctime库结合起来显示时间. time_point 必须要 clock 来计时, time_point 有一个函数 <code>time_from_eproch()</code> 用来获得1970年1月1日到 time_point 时间经过的 duration. 例如:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;ratio&gt;#include &lt;chrono&gt;//计算过了多少天int main (void){  using namespace std::chrono;  typedef duration&lt;int, std::ratio&lt;60*60*24&gt;&gt; days_type; //天  //auto now = system_clock::now();  time_point&lt;system_clock&gt; now( system_clock::now());  time_point&lt;system_clock, days_type&gt; today = time_point_cast&lt;days_type&gt;(now);  std::cout &lt;&lt; today.time_since_epoch().count() &lt;&lt; &quot; days since epoch&quot; &lt;&lt; std::endl;  return 0;}</code></pre><p>比较重要的方法就是:</p><ul><li>duration time_since_epoch() const;<br>案例代码如下:<br>```c++<br>#include <iostream><br>#include <chrono><br>#include <ctime></ctime></chrono></iostream></li></ul><p>int main(void)<br>{</p><p>  using namespace std::chrono;</p><p>  time_point<system_clock> p2, p3;</system_clock></p><p>  p2 = system_clock::now();<br>  p3 = p2 - hours(24); //昨天的此刻<br>  std::cout &lt;&lt; “yesterday, hours since epoch: “<br>        &lt;&lt; duration_cast<hours>(<br>                 p3.time_since_epoch()).count()<br>        &lt;&lt; std::endl;</hours></p><p>  std::cout &lt;&lt; “hours since epoch: “<br>        &lt;&lt; duration_cast<hours>(<br>                 p2.time_since_epoch()).count()<br>        &lt;&lt; std::endl;<br>  return 0;<br>}</hours></p><pre><code>* time_point_cast 把 time_point 从一种类型的 duration 转换成另一种单位类型的duration . 定义如下: ```c++template &lt;class ToDuration, class Clock, class Duration&gt;time_point&lt;Clock, ToDuration&gt; time_point_cast(                                 const time_point&lt;Clock, Duration&gt; &amp;t);</code></pre><p> 其实现也非常简单:</p><pre><code class="c++">return time_point&lt;Clock, ToDuration&gt;(duration_cast&lt;ToDuration&gt;(t.time_since_epoch()))</code></pre><p> 使用案例:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;chrono&gt;using Clock = std::chrono::high_resolution_clock;using Ms = std::chrono::milliseconds;using Sec = std::chrono::seconds;//使用TimePoint, 要指定duration, 例如Ms或者Sectemplate&lt;class Duration&gt;using TimePoint = std::chrono::time_point&lt;Clock, Duration&gt;;inline void print_ms(const TimePoint&lt;Ms&gt;&amp; time_point) {    std::cout &lt;&lt; time_point.time_since_epoch().count() &lt;&lt; &quot; ms\n&quot;;}int main() {    TimePoint&lt;Sec&gt; time_point_sec(Sec(4));    // implicit cast, no precision loss    //(大单位向小单位转换)    TimePoint&lt;Ms&gt; time_point_ms(time_point_sec);    print_ms(time_point_ms); // 4000 ms    time_point_ms = TimePoint&lt;Ms&gt;(Ms(5756));    // explicit cast, need when precision loss may happens    // 5756 truncated to 5000    time_point_sec = std::chrono::time_point_cast&lt;Sec&gt;(time_point_ms);    //调用的时候, 大单位向小单位赋值    print_ms(time_point_sec); // 5000 ms}</code></pre><h3 id="综合案例-1"><a href="#综合案例-1" class="headerlink" title="综合案例"></a>综合案例</h3><p>实现一个简单的 timer 计时器(一般采用steady_clock).</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;ratio&gt;#include &lt;chrono&gt;using namespace std;using namespace std::chrono;//默认以毫秒为单位class Timer final{ private:  typedef high_resolution_clock clock_type;  typedef milliseconds duration_type;  typedef long int64_t;  time_point&lt;clock_type&gt; m_begin; public:  Timer() : m_begin(clock_type::now()) {}  ~Timer() = default;  void restart() { m_begin = clock_type::now(); }  //默认输出毫秒  int64_t elapsed() const  {    /*return std::chrono::duration::round&lt;duration_type&gt;      (clock_type::now() - m_begin).count();      //编译器不支持 C++17                 */    return duration_cast&lt;duration_type&gt;(clock_type::now() - m_begin).count();    //直接返回 duration对象 也可以直接cout输出  }  //下面采用重载, 而不是模板参数, 避免用户传参麻烦  //微秒  int64_t elapsed_micro() const  {    return duration_cast&lt;microseconds&gt;(                 clock_type::now() - m_begin).count();  }  //秒  int64_t elapsed_seconds() const  {    return duration_cast&lt;seconds&gt;(clock_type::now() - m_begin).count();  }};void fun(){  for(int i = 0; i &lt; 100; i++) {    cout &lt;&lt; &quot;hello word&quot; &lt;&lt; endl;  }}int main(){  Timer t; //开始计时  fun();  cout&lt;&lt;t.elapsed_micro()&lt;&lt;endl; //打印微秒()  cout&lt;&lt;t.elapsed()&lt;&lt;endl; //打印fun函数耗时多少毫秒  cout&lt;&lt;t.elapsed_seconds()&lt;&lt;endl; //打印秒  return 0;}</code></pre><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>C++这套库, 虽然只有三个clock, time_point, duration, 熟悉起来还是要花一段时间的.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      编程中需要注意的时间相关的问题
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>Muduo</title>
    <link href="www.merlinblog.site/2017/07/29/deep-in-muduo-framework.html"/>
    <id>www.merlinblog.site/2017/07/29/deep-in-muduo-framework.html</id>
    <published>2017-07-28T16:45:48.000Z</published>
    <updated>2017-09-24T06:43:01.931Z</updated>
    
    <content type="html"><![CDATA[<p>TODO</p><p><img src="http://omotkhw3y.bkt.clouddn.com/chenshuo1.jpg" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p><a href="http://blog.csdn.net/qq_30968657/article/category/6854276" target="_blank" rel="external">主要参考</a></p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      陈硕前辈的推荐, 老实说, 我不知道这个库工业上应用情况如何
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
