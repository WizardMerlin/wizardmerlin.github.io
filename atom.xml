<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Merlin&#39;s Blog</title>
  
  <subtitle>Alfred, I did find someone..</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="www.merlinblog.site/"/>
  <updated>2017-10-15T01:33:08.924Z</updated>
  <id>www.merlinblog.site/</id>
  
  <author>
    <name>Merlin Yu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>谈一谈个人修养</title>
    <link href="www.merlinblog.site/2017/10/15/talk-on-self-cultivation.html"/>
    <id>www.merlinblog.site/2017/10/15/talk-on-self-cultivation.html</id>
    <published>2017-10-14T23:57:02.000Z</published>
    <updated>2017-10-15T01:33:08.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><blockquote><p>一直以来我都忽略了一个东西, 直到前几天和哲学老师聊天, 才意识到, 那就是修养问题.</p></blockquote><p>老师说我: <strong>个性鲜明,人格丰富,但有时候总是给人一种不舒服的感觉</strong>. <code>给人一种很舒服的感觉?</code> 这到底什么呢? 是说一个人方和圆的事情么?</p><p>回想之前老大(人超nice), 以及之前的部门经理的种种事迹, 终于明白了: 哦, 是<code>修养</code>需要提升(只不过老师说的很委婉).</p><blockquote><p>一个人敢怒敢言, 往往不能很隐忍, 不能很包容, 甚至做人做事儿, 会有很自私的一面.</p></blockquote><p>我回想自己以前的一些行为, 貌似就是这样.<br><img src="http://omotkhw3y.bkt.clouddn.com/care-self.png" alt=""><br>无怪, 家人给我的 ipad mini 上刻了这样的字. (虽然那个时候很气愤, 什么意思嘛!) 然而今天回过头想想, <strong>意识到问题还不算晚</strong>. </p><h1 id="不给人添麻烦"><a href="#不给人添麻烦" class="headerlink" title="不给人添麻烦"></a>不给人添麻烦</h1><p>这个和我们软件开发中所提倡的<code>不作恶</code>有写类似,但也有着本质的区别; 一个是理工的, 一个是人文的.</p><p>关于这一点, 我个人水平有限, 只能说<code>只可意会, 不可言谈</code>, 因为实在太微妙了.</p><h1 id="不轻视他人"><a href="#不轻视他人" class="headerlink" title="不轻视他人"></a>不轻视他人</h1><p>这个其实很难, 因为和一个人性格有关. 有才的人往往是桀骜不驯, 不从众, 也难于融入大众的.</p><p>就像我们现在这个<code>信息爆炸, 大家都很忙</code>的时代, 能坚持写博客的, 其实都是小众.</p><p>我上大学的时候, 有些教授(我熟悉的), 就是互相看不起的…听起来很酸, 但是确实存在, 也没有理由去不承认.</p><p>我想, 如果有可能, 我们更多的是<code>应该看到别人的优点</code>.</p><h1 id="人生观求同存异"><a href="#人生观求同存异" class="headerlink" title="人生观求同存异"></a>人生观求同存异</h1><p>这个东西和价值观&amp;世界观不同, 相比而言, <code>人生观没有太重要</code>. </p><p>比如说, 我有的同学就想交50个女友之后再确定稳定关系(原话是, 我这辈子一定要睡50个女人, 呵呵, 现实好残酷, 原话不好听啊), 你说这人有错么?<br>我不知道, 反正我不认同. </p><p>还有(女)同学, 就想毕业之后, 两年内结婚, 然后相夫教子…</p><blockquote><p>what else can i say ?</p></blockquote><p><strong>人生观求同存异</strong>, 因为人生观不同太正常了, 还是可以一起玩耍的.</p><h1 id="价值观-世界观包容"><a href="#价值观-世界观包容" class="headerlink" title="价值观/世界观包容"></a>价值观/世界观包容</h1><blockquote><p>这个和人生观不一样, 价值观很重要.<br><strong>价值观不同, 一定不能一起玩耍</strong>; 但是可以一起公事. 毕竟, 可能你也要养家户口.</p></blockquote><p>有些人, 比如卖假酒的同学(我高中有同学家里开洗脚店的, 呵呵呵, 正规不正规, 你说呢?), 的确比你有钱, 比你能接触更多的资源, 比你更加享受.</p><p>但是, 这些人, 根本没有羡慕的必要(不管法律是否制裁他们). 实际上, 世界之大, 有些事情, 根本就是无可奈何. 你没有任何办法的.<br>(有些人会来说, <code>任何</code>未免太过绝对了吧? 我借用经济学中的一句话:<strong>市场的边界大不过信息所能到达的地方</strong>, 见识有限, 抱歉了)</p><p>所以我说, 世界观/价值观包容, 其实也是说, 独善其身, 知善恶荣辱. (这也是诱惑出现, 一个人是否能够把持的根本原因吧)</p><h1 id="待人有礼"><a href="#待人有礼" class="headerlink" title="待人有礼"></a>待人有礼</h1><p>细微处, 见家教.<br>不说太多, 这一点我在几个学妹身上, 看到的太多(当然有些纯粹的, 与我关系好, 所以表现的很<code>女汉子</code>)</p><h1 id="不允诺"><a href="#不允诺" class="headerlink" title="不允诺"></a>不允诺</h1><p>这和我的<code>言出必行</code>原则有差别, 这里主要是说: <strong>如果一件事儿, 要承担责任, 无论大小;最好不要允诺, 逃不过去的, 也要小心允诺, 注意言辞</strong></p><h1 id="不强求-不责怪"><a href="#不强求-不责怪" class="headerlink" title="不强求,不责怪"></a>不强求,不责怪</h1><p>这里包括, 不与人强行争论.</p><p>不责怪, 有些人有时候, 确实很过分, 但是这种人离远一点儿, 不要试图去责怪他们, 没有任何收益的.</p><h1 id="克制情绪"><a href="#克制情绪" class="headerlink" title="克制情绪"></a>克制情绪</h1><p>有些时候, 特别你作为前辈的时候, 有新来的实习生. 或者你作为实习生, 有同样的实习生, 老是问你一些很<code>愚蠢</code>的问题, 这个时候真的很烦躁的.</p><p>但是今非昔比, 随着年龄的增长, 阅历的增长, 见得市面也多了, 别人对你的要求, 或者你自己对自己的要求也要提高.</p><blockquote><p>人不是一步长成的, 所以渐渐学会, 抑制怒火, 至少(最低要求)不当众释放情绪, 能克制自己</p></blockquote><p>比如<code>李笑来</code>会说, 这是一个人的心智问题, 我却觉得, 这是成长中的<code>修养问题</code>. 我的父亲脾气就非常好, 人缘也超级好; 但母亲就…</p><p>总之, 这个方面很重要; 人总有傻x的时候, 这样想就会好一点. 克制, 然后慢慢适应.</p><h1 id="不泄露他人隐私"><a href="#不泄露他人隐私" class="headerlink" title="不泄露他人隐私"></a>不泄露他人隐私</h1><p>毫无顾忌的说别人的可能是隐私的事情(甚至把他人的私人电话随意透露给别人), 这个要注意一下.</p><p>可能你不在意的事情, 别人其实很在意.</p><h1 id="谦让"><a href="#谦让" class="headerlink" title="谦让"></a>谦让</h1><p>习惯了, 有问题直接解决, 不考虑太多的理工科学生呢, 真的要注意一下. 特别有老前辈的场合.</p><p>这一点儿, 是最重要的, 不要给人<code>不舒服的感觉</code>. </p><p>有才的人, 注意场合展示才华.</p><h1 id="稳重"><a href="#稳重" class="headerlink" title="稳重"></a>稳重</h1><p>这一点我深有体会. 在和复旦大学, 张江校区的同学合作的项目的时候, 我方(单位)带队的是和部门经理同级别的项目经理. 这个人大我15岁上下(至少大一轮). 做事儿就很稳重. 不慌不忙, 从容淡定. </p><p>每次开会, 提前去, 开灯, 开空调, 配置投影仪, 茶水等; 走的时候最后走, 关灯关机器等. 而且, 即使这样, 工作细致, 有条理(不是说我没有条理), 而是他给人一种有条不紊的感觉, 一切都有费心, 但自己本职工作也做的很好.</p><p>出了状况, 比如说, 我司的代码, 除非领导同意, 否则肯定不能共享给校方的, 但是双方会在这一点上有分歧, 亦或者项目中的一些佐料代码(生产代码, 比如前期训练需要的测试代码和数据)没有公开, 导致项目周期延后了好几天.</p><p>他从来不当面说事情严重, 或者不严重. 自己心里有数, 然后汇报给领导, 我们面前基本不说(有时候会说项目时间紧张, 催催我们).</p><blockquote><p>不慌, 不乱; 好像从来都是很镇定自若的样子. </p></blockquote><p>(我没有一次看到他发脾气, 但是我知道, 有些问题肯定是会很生气的, 但是没有看到它生气.)</p><h1 id="注意言语"><a href="#注意言语" class="headerlink" title="注意言语"></a>注意言语</h1><blockquote><p>不必记住<code>良言一句三冬暖</code>, 但是一定要记住<code>恶语伤人二月寒</code>.</p></blockquote><p>我说一个实际的例子, 刚开始工作的时候, 老大是技术出身的, 其实为人做事儿, 也是欠火候的(貌似刚被提拔上来).</p><p>那个时候, 我刚出学校, 在这里实习; 手中有三星, 中兴等(小公司就不说了)的offer, 再加上学校里面, 老师啊, 系主任都比较照顾, 自己也心高气傲.</p><p>有一次回外部门的邮件, 说话言语上, <code>太天真</code>, 暴露了内部项目的进度. 这个时候, 老大就非常生气, 当众羞辱了我, 搞的我一上午就很郁闷. </p><p>抱歉, 郁闷还不足以形容我当时的程度, 因为我当然就调查好了, 他家住哪, 开的什么车, 晚上一般什么时候走…</p><blockquote><p>刚出来的时候, 身上是鲜红色的, 真的一点不夸张; 那情景我现在记忆尤新; 我说错了什么话, 我都记得.</p></blockquote><p>事情过去那么久, 我依然不会忘记, 从中得到的教训也很多, 其中很重要的一点:</p><blockquote><p>一句恶语, 可能让一个人记住你一辈子</p></blockquote><p>所以直到现在, 即便是非常亲密的朋友, 我也不说一句恶语; 有的只是建议或者提醒, 或者开玩笑. (但是情绪克制方面, 还很差, 特别忙又出乱子的时候)</p><p><strong>言语,说话技巧方面的内容很多, 以后再补充吧</strong></p><hr><p>最后(因为已经写了很长了)</p><blockquote><p>如果你面对的是小人, 请积极动用智慧; 在不影响个人修养, 不违背个人原则的情况下, 使用智慧.</p></blockquote><p>以上种种, 不能说我个人有问题, 而是说<code>理工科思维</code>的原因导致的:</p><blockquote><p>一个人过度的心思放在<code>技能知识储备&amp;研究</code>上, 他和人打交道方面显然没有HR那种能言善辩, 懂得更多的方法和技巧</p></blockquote><p>这一点可从惠普老师身上看粗来(推脱成功,哈哈哈), 后期刻意训练很重.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      90后的我们, 已经到了挑到梁的时候; 看到95后的朋友, 才明白我也到了做前辈的时候哦.
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>网络编程部分汇总</title>
    <link href="www.merlinblog.site/2017/10/13/network-base.html"/>
    <id>www.merlinblog.site/2017/10/13/network-base.html</id>
    <published>2017-10-13T04:18:43.000Z</published>
    <updated>2017-10-15T02:22:47.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文主要记载一些网络基础知识, 但这些知识不是纯碎的理论研究, 而是为了后面<code>传输层</code>/<code>应用层</code>网络编程服务的.</p><blockquote><p>2017年10月更新了本文: <code>nagle算法</code> + <code>delayed ack算法</code> + <code>重新整理排版</code></p></blockquote></blockquote><p><strong>该文是我写的网络编程的第一篇文章</strong>, 改版了, 成为<code>最后一篇</code>, <strong>作为总结</strong>.</p><p>大致上已经整理了以下内容:(链接都是我站内的链接)</p><ul><li>网络理论基础部分 (本文)</li><li>基础套接字编程, <a href="http://www.merlinblog.site/2017/06/11/basic-socket-model.html">链接</a></li><li>本地套接字, <a href="http://www.merlinblog.site/2017/06/20/ipc-unix-domain-socket.html">链接</a></li><li>TCP 专题, <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">链接</a>, 以及 <a href="http://www.merlinblog.site/2017/06/19/sub-and-adhere-package.html">流解析(粘包问题)</a></li><li>UDP 专题, <a href="http://www.merlinblog.site/2017/06/19/udp-model.html">链接</a></li><li>IO 模型, <a href="http://www.merlinblog.site/2017/06/04/network-io.html">链接</a></li><li>Epoll专题, <a href="http://www.merlinblog.site/2017/06/13/why-not-epoll.html">链接</a></li><li>服务端模型演变, <a href="http://www.merlinblog.site/2017/06/19/server-side-model-again.html">链接</a></li><li>proto buffer 库, <a href="http://www.merlinblog.site/2017/08/21/protocol-buffer.html">链接</a></li><li>thrift 库, <a href="http://www.merlinblog.site/2017/08/22/thrift.html">链接</a></li><li>libevent 库, <a href="http://www.merlinblog.site/2017/07/29/libevent.html">链接</a></li><li>asio, <a href="http://www.merlinblog.site/2017/08/11/asio.html">链接</a></li><li>muduo, 陈硕大神的库, 值得研究学习, <a href="http://www.merlinblog.site/2017/07/29/deep-in-muduo-framework.html">链接</a></li><li>网络常用工具, nc, dd, tcpdump, ping, traceroute等, <a href="http://www.merlinblog.site/2017/08/23/net-work-tools.html">链接</a></li></ul><p>大部分知识来自于书籍(unp 1, unix高级编程, 以及 linux系统编程上下册), 腾讯后端的同学的交流, 我的一些个人思考, 最后靠谱网友的博客.</p><blockquote><p>这些整理记录了我的成长(完善知识体系), 也希望为看到的人带来帮助, 至少节约一些时间(<code>于我个人而言, 写作是一种乐趣</code>)</p></blockquote><p>补充上层协议: (2017/9月整理)</p><ul><li>http协议, <a href="">链接</a></li><li>https协议, <a href="">链接</a></li></ul><a id="more"></a><hr><p><img src="http://omotkhw3y.bkt.clouddn.com/net.jpg" alt="post-cover"></p><p><strong>由于网络理论比较多, 我只捡去编程或者面试中可能涉及的内容: 以 TCP/IP 协议簇为主，也会有应用层和数据链路层的简单介绍</strong></p><p>TCP/UDP/HTTP</p><h1 id="分层模型"><a href="#分层模型" class="headerlink" title="分层模型"></a>分层模型</h1><p>这里有两种模型, </p><ul><li>学术界的OSI模型</li><li>工业&amp;商业界的TCP/IP四层模型</li></ul><p>大致对比如下:</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-7.png" alt=""></p><p>协议本身并没有太多分别, 只是大家的认可度不一样罢了,<br>试想你自己发明一套, 比如IP_MY协议, 大家都不遵守, 这种约定有何意义?<br>所以即便是都用于互联网, TCP/IP四层模型协议更被开发者所接受, OSI 7层模型只是带过.</p><h2 id="OSI模型"><a href="#OSI模型" class="headerlink" title="OSI模型"></a>OSI模型</h2><p>OSI 模型中，网络被分为七层，由底层向高层依次是：物理层，数据链路层，网络层，传输层，会话层，表示层和应用层。</p><p><strong>物理层</strong> 处于 OSI 七层模型的最底端，它的主要任务是将比特流与电子信号进行转换。<br><strong>数据链路层</strong> 处于 OSI 七层模型的第二层，它定义了通过通信介质相互连接的设备之间，数据传输的规范。<br><strong>网络层</strong> 处于OSI参考模型的第三层网络层的主要作用是实现终端节点间的通信。IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)<br><strong>传输层</strong> 处于 OSI 七层模型的第四层, 主要作用是实现应用程序之间的通信。<br><strong>会话层</strong> 处于 OSI 七层模型的第五层, 利用传输层提供的服务，使应用建立和维持会话，并能使会话获得同步。<br><strong>表示层</strong> 处于 OSI 七层模型的第六层, 表示层是处理所有与数据表示及运输有关的问题，包括转换、加密和压缩。(字符集数据格式等处理)<br><strong>应用层</strong> 处于 OSI 七层模型的第七层, 这是最高层, 也是网络应用程序直接使用的协议, 它利用下层协议完成网络通信, 根据用途不同, 种类也不一样.</p><h2 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h2><p>为了实践编码方便, 理所应当采用了简化的四层模型, 即TCP/IP四层模型, 业界俗称为TCP/IP协议族.</p><p>下面也以规模性作为重点记录.</p><h2 id="各层要点"><a href="#各层要点" class="headerlink" title="各层要点"></a>各层要点</h2><p>TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp,等等我们熟悉的协议。而第二层则是传输层，著名的TCP和UDP协议就在这个层次。第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-in.png" alt=""></p><p>TCP/IP协议通信的过程其实就对应着数据入栈与出栈的过程。入栈的过程，数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。出栈的过程，数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。(以太网帧协议是头尾, 注意1500字节, 后面还会出现)</p><p>完整的以 <strong>HTTP</strong>为例子:<br><img src="http://omotkhw3y.bkt.clouddn.com/network-in1.png" alt=""></p><p><strong>网络接口层</strong> :<br>物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。 数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer.png" alt=""></p><p>主要作为围绕 MAC 地址展开:</p><ul><li>封装成帧: 把网络层数据报加头和尾，封装成帧,帧头中包括源MAC地址和目的MAC地址。</li><li>透明传输: 零比特填充、转义字符。</li><li>可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。</li><li>纠错处理: (CRC):接收者检测错误,如果发现差错，丢弃该帧。</li></ul><p>个人觉得, 一般谈到 网络接口层, 主要是2个概念再反复说:</p><ul><li>MAC 地址<br>MAC 地址是被烧录到网卡 ROM 中的一串数字，长度为 48 比特，它在世界范围内唯一(不考虑虚拟机自定义 MAC 地址)。由于 MAC 地址的唯一性，它可以被用来区分不同的节点，一旦指定了 MAC 地址，就不可能出现不知道往哪个设备传输数据的情况。</li><li><p>交换机仔细原理(转发表)<br>交换机是一种在数据链路层工作的网络设备，它有多个端口，可以连接不同的设备。交换机根据每个帧中的目标 MAC 地址决定向哪个端口发送数据，此时它需要参考“转发表”<br>转发表并非手动设置，而是交换机自动学习得到的。当某个设备向交换机发送帧时，交换机将帧的源 MAC 地址和接口对应起来，作为一条记录添加到转发表中。</p><p>当然交换机还有其他作用, 就不多说了.</p></li></ul><p>交换机自学过程的原理(端口MAC联系过程):<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer3.png" alt=""></p><blockquote><p>关于分组交换, 通常我们只是在IP网络层才会去谈分组交换(1480); 传输层谈报文交换; 物理层谈电路交换.</p></blockquote><p>实际山, 从涉及MTU问题这里, 分组交换就已经涉及到了.<br>分组交换是指将较大的数据分割为若干个较小的数据，然后依次发送。使用分组交换的原因是不同的数据链路有各自的最大传输单元(MTU: Maximum Transmission Unit)。</p><p><code>MTU</code>, 根据<code>协议性质</code>&amp;<code>网络性质</code>&amp;<code>操作系统(内核协议栈)实现</code>等因素的不同而不同, 通常认为这也是 TCP/IP分节传输或者设置buffer的依据.<br>关于 MTU 争议很多, 具体可以见下面 <strong>MTU问题</strong>部分.</p><p>最后补充, 数据链路层协议工作在物理介质相互连接的端点之间, 范围有限.</p><hr><p><strong>网络层</strong><br>数据链路层的作用在于实现同一种数据链路下的包传递，而网络层则可以实现跨越不同数据链路的包传递。(也就是说, 从这一层才涉及跨网络)</p><p>这一层内容比较多, 但是主要谈IP协议相关, 其他顺带谈一下.</p><p>IP协议是网络层的一个重要协议，网络层中还有ARP(获取MAC地址)和ICMP协议(数据发送异常通知)IP协议是TCP/IP协议的核心，所有的TCP，UDP，ICMP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议: TCP或UDP要做的事情(ICMP也起到了异常通知的作用)。</p><p><strong>IP协议</strong> : (主要说<code>ipv4</code>, 因为ipv6也就我们中国再说, 看看世界上其他国家, 根本不鸟的, 题外话)</p><ul><li>地址部分</li><li>路由部分</li><li>分包重组部分</li><li>ip协议头(首部)</li></ul><p>寻址部分:<br>IP地址是一种在网络层用于识别通信对端信息的地址。它有别于数据链路层中的MAC地址，后者用于标识同一链路下不同的计算机。<br>IP地址由32位正整数表示，为了直观的表示，我们把它分成4个部分，每个部分由8位整数组成，对应十进制的范围就是0-255。</p><p>比如<code>172.20.1.1</code>可以表示为：<code>10101100 00010100 00000001 00000001</code>。<br>转换规则很简单，就是分别把四个部分的十进制(0-255)与8位二进制数字进行转换。</p><p>IP地址由两部分组成：<code>网络标识</code>和<code>主机标识</code>。</p><ul><li>网络标识用于区分不同的网段，相同段内的主机必须拥有相同的网络表示，不同段内的主机不能拥有相同的网络标识</li><li>主机标识用于区分同一网段下不同的主机，它不能在同一网段内重复出现</li></ul><p>32位IP地址被分为两部分，<strong>到底前多少位是网络标识呢？</strong><br>一般有两种方法表示：<code>IP地址分类</code>、<code>子网掩码</code>。</p><p><strong>IP地址分类</strong> :<br>IP地址分为四个级别，分别为A类、B类、C类和D类。分类的依据是IP地址的前四位：</p><ul><li>A类IP地址是第一位为“0”的地址。A类IP地址的前8位是网络标识，用十进制标识的话0.0.0.0-127.0.0.0是A类IP地址的理论范围。另外我们还可以得知，A类IP地址最多只有128个(实际上是126个，下文不赘述)，每个网段内主机上限为2的24次方，也就是16，777，214个主机。</li><li>B类IP地址是前两位为“10“的地址。B类IP地址的前16位是网络标识，用十进制标识的话128.0.0.0-191.255.0.0是B类IP地址的范围。B类IP地址的主机标记长度为16位，因此一个网段内可容纳主机地址上限为65534个。</li><li>C类IP地址是前三位为“110”的地址。C类IP地址的前24位是网络标识，用十进制标识的话192.0.0.0-223.255.255.0是C类IP地址的范围。C类地址的后8位是主机标识，共容纳254个主机地址。</li><li>D类IP地址是前四位为“1110”的地址。D类IP地址的网络标识长32位，没有主机标识，因此常用于多播。</li></ul><p>简单记忆如下:<br>A类IP地址: 0.0.0.0~127.0.0.0<br>B类IP地址: 128.0.0.1~191.255.0.0<br>C类IP地址: 192.168.0.0~239.255.255.0</p><p>这类分类方法往往导致, 小网段不够, 大网段有余. 例如C类网段, 最多254台主机, 如果是255台怎么办? B类的上限是65534个, 明显浪费. 如果控制B类网址的上限数目? 因为B类网址, 说是以<code>10</code>开头, 前16位为网络号, 但是具体是多少真正在用就不一定了.</p><p>那么就<code>不对网络号规定位数?</code>, 但是这样就根本没有办法解析IP地址了, 因为不知道前多少位是网络号, 此时就演变出了<code>子网掩码</code>, 用子网掩码来解释子网占了多少位, 而剩余的主机号占了多少位.</p><p><strong>子网掩码</strong> :<br>IP地址分类的本质是区分网络标识和主机标识，另一种更加灵活、细粒度的区分方法是使用子网掩码。</p><p>它也是32位的, 只不过用其中 1 的数量表示子网, 即网络号的部分, 剩余的表示主机位.</p><p>子网掩码的方式, 涵盖并对应了 <code>IP</code>分类的方式, 但是又比<strong>规定死位数</strong>要灵活.</p><p>例如, B类网址, 即以10开头的网络号, 它本来网络号规定是16位, 可以容纳65534台, 现在通过子网掩码, 可以规定它的网络号是26位, 而不是规定死的16位, 可以容纳64台主机(出去主机号全0表示本子网, 全1表示广播外, 实际容纳62台)<br><img src="http://omotkhw3y.bkt.clouddn.com/network-sub.png" alt=""></p><p>但注意一下, 缺省情况下, 子网掩码和IP分类保持一致:<br>A类地址的缺省子网掩码为255.0.0.0,B类为255.255.0.0,C类为255.255.255.0。</p><p><strong>路由部分</strong></p><p>路由控制(Routing)是指将分组数据发送到目标地址的功能，这个功能一般由路由器完成。<br>路由器中保存着<code>路由控制表</code>(存储转发表)，它在路由控制表中查找目标IP地址对应的下一个路由器地址。下图描述了这一过程：<br><img src="http://omotkhw3y.bkt.clouddn.com/net-work-route.png" alt=""></p><p>由图中也可看出路由器连接着两个子网, 并且在路由表中进行范围或者最佳匹配.</p><p>路由控制表可以由管理员手动设置，称为静态路由控制，或者路由器可以和其他路由器互换信息比即使自动刷新路由表，这个信息交换的协议并没有在IP协议中定义，而是由一个叫做“路由协议”的协议管理。</p><p><strong>实际传输过程中, 数据包也会在路由器这里拆包并封包再转发, 因为要重新填写下一跳路由地址</strong></p><p>路由控制这有会有两个问题:</p><ul><li>转发成环问题(不存在相关的IP地址)<br>IP首部解决这个问题</li><li>分割与重组<br>IP受限于链路层的MTU, 过大的数据就要分组, 远端主机再重组(首部中的标志和偏移)</li></ul><p>分组和重组, 也会涉及 MTU, 请参考<code>其他部分</code>的<code>MTU路径发现</code>.</p><p>由于<code>环</code>和<code>分组</code>问题都依赖于<code>IP首部</code>结构, 下面就说说.</p><p><strong>IP首部</strong><br>即 ip协议头(20字节), 这里有很多设计讲究.<br><img src="http://omotkhw3y.bkt.clouddn.com/ipheader.png" alt=""></p><p>8位的TTL字段(解决环的问题, 不可能让你无限传下去)<br>这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。<br>这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。</p><p>其他部分介绍:(从上往下一层层看)</p><ul><li>总长度(Total Length)：表示IP首部与数据部分总的字节数，该段长16比特，所以IP包的最大长度为65535字节(2^16)。虽然不同数据链路的MTU不同，但是IP协议屏蔽了这些区别，通过自己实现的数据分片功能，从上层的角度来看，IP协议总是能够以65535为最大包长进行传输。<br>(上层看不到下层的MTU限制)</li><li>16位标识（ID：Identification）：用于分片重组。属于同一个分片的帧的ID相同。但即使ID相同，如果目标地址、源地址、上层协议中有任何一个不同，都被认为不属于同一个分片。</li><li>标志（Flags）：由于分片重组，由3个比特构成。<br>第一个比特未使用，目前必须是0。<br>第二个比特表示是否进行分片，0表示可以分片，1表示不能分片。在路径MTU发现技术中就用到了这个位。<br>第三个比特表示在分片时，是否表示最后一个包。1表示不是最后一个包，0表示分配中最后一个包。<br>*片偏移（FO: Fragment Offset）：由13比特组成，表示被分片的段相对于原始数据的位置。它可以表示8192(2^13)个位置，单位为8字节，所以最大可以表示8 x 8192 = 65536字节的偏移量。</li><li>协议： 表示IP首部的下一个首部属于哪个协议。比如TCP协议的编号为6，UDP编号为17.</li><li>首部校验和：用于检查IP首部是否损坏</li><li>可选项：仅在试验或诊断时用，可以没有。如果有，需要配合填充（Padding）占满32比特。</li></ul><p><strong>ARP及RARP协议</strong> :<br>(非重点, 我以前电脑中过arp病毒, 所以印象深刻)<br>ARP (Address Resolution Protocol)是根据IP地址获取 MAC 地址的一种协议。(因为最终确定一台计算机的不是IP, 而是Mac地址, 硬件地址)<br>如果目标主机处在同一个数据链路上，那么可以直接得到目标主机的 MAC 地址，否则会得到下一条路由器的 MAC 地址。</p><p>ARP（地址解析）协议是一种解析协议，详细说明即: ARP 请求和 ARP 响应。<br>首先，源主机会通过广播发送一个 ARP 请求包：“我要与 IP 地址为 xxx 的主机通话，谁知道它的 MAC地址？”。<br>数据链路上的所有主机都会收到这条消息并检查自己的 IP 地址，如果与 ARP 请求包中的 IP 地址一致，主机就会发送 ARP 响应包：“我就是 IP 地址为 xxx 的主机，我的 MAC 地址是：xxxx”。<br><img src="http://omotkhw3y.bkt.clouddn.com/network-arp.png" alt=""></p><p>但是反复查询效率很低, 也是不推荐的做法; 通常的做法是把获取到的 MAC 地址缓存一段时间。(一旦源主机向目标地址发送一个数据包，接下来继续发送多次的概率非常大，因此这种缓存非常容易命中)</p><p>当主机要发送一个IP包的时候，会首先查一下自己的ARP高速缓存（就是一个 IP-MAC 地址对应表缓存）。</p><p>如果查询的 IP－MAC 值对不存在，那么主机就向网络发送一个ARP协议广播包，这个广播包里面就有待查询的IP地址，而直接收到这份广播的包的所有主机都会查询自己的IP地址，如果收到广播包的某一个主机发现自己符合条件，那么就准备好一个包含自己的 MAC 地址的ARP包传送给发送ARP广播的主机。而广播主机拿到ARP包后会更新自己的ARP缓存（就是存放IP-MAC对应表的地方）。发送广播的主机就会用新的ARP缓存数据准备好数据链路层的的数据包发送工作。</p><p>当下一次发送 ARP 请求或超过一定时间后，缓存都会失效，这保证了即使 MAC 地址与 IP 地址的对应关系发生了变化，数据包依然能够被正确的发往目标地址。</p><p>RARP协议的工作与此相反，不做赘述。</p><blockquote><p>只用IP是不行的, 只用Mac是非常低效的.</p></blockquote><p>其中用意个人体会吧, arp和rarp协议有其存在的必要性.</p><p><strong>NAT 和 NAPT 技术</strong> :<br>NAT (Network Address Translator) 是一种用于将局域网中的私有地址转换成全局 IP 地址的技术。</p><p>在连接上无线路由器的时候，如果检查一下设备的 IP 地址，也许你会发现是类似于 192.168.1.1 这样的局域网 IP 地址。那不同网段中，IP 地址都是 192.168.1.1 的主机改如何通信呢？</p><p>下图描绘了 NAT 的工作原理：</p><p>局域网中 IP 地址为 10.0.0.10 的主机向全局 IP 地址 163.221.120.9 发送数据。NAT 路由器将数据包的源地址修改成自己的全局 IP 地址：202.244.174.37。同理，接收数据时，路由器把目标地址 202.244.174.37 翻译成内网地址：10.0.0.10</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-nat.png" alt=""><br>路由器只有一个对外的全局 IP 地址，如果有多个内网主机都向外部通讯怎么办呢？这时就要使用 NAPT 技术，它和 NAT 从原理上类似，但它可以转换 TCP 和 UDP 端口号。</p><p>使用 NAPT 技术时，不同的内网 IP 被转换成同一个公共 IP 地址，也就是路由器对外显示的全局 IP 地址，但是被附加不同的端口号以示区分：</p><p><img src="http://omotkhw3y.bkt.clouddn.com/network-napt.png" alt=""><br>不管是 NAT 还是 NAPT，都需要路由器路由器内部维护一张自动生成的地址转换表。以 TCP 为例，建立 TCP 连接首次握手的 SYN 包发出时会生成这个表，关闭连接时会发出 FIN 包，收到这个包的应答时转换表被删除。</p><p><strong>ICMP协议</strong> :<br>这也是IP层的一个重要协议, 主要负责异常/错误通知.</p><p>IP协议并不是一个可靠的协议，它不保证数据被送达，那么，自然的，保证数据送达的工作应该由其他的模块来完成。<br>其中一个重要的模块就是ICMP(网络控制报文)协议。</p><blockquote><p>当传送IP数据包发生错误。比如主机不可达，路由不可达等等，ICMP协议将会把错误信息封包，然后传送回给主机。<br>给主机一个处理错误的机会，这也就是为什么说建立在 IP 层以上的协议是可能做到安全的原因。</p></blockquote><p>该协议有一个重要应用, <code>ping</code> 命令, 具体可以参考下面 <code>其他部分</code>.<br>哦, 还有一个TTL检测工具, <code>traceroute</code> 也需要借助它.</p><hr><p><strong>传输层</strong></p><p>这里已经不仅仅是理论了, 而且有大量的code实践, 可以单独参考我的其他文章:</p><ul><li>tcp: <a href="http://www.merlinblog.site/2017/06/19/how-about-tcp.html">how-about-tcp</a></li><li>udp: <a href="http://www.merlinblog.site/2017/06/19/udp-model.html">udp model</a></li></ul><hr><p><strong>应用层</strong></p><p>这里谈一些其他的协议, 比如常见的 HTTP, HTTPS, DNS等, 当然, 也有人专门花一本书的时间,去写一个应用协议, 呵呵呵.</p><p><strong>DNS</strong> : Domain Name System，域名解析系统<br>因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。</p><p>以解析域名： www.ietf.org为例：<br><img src="http://omotkhw3y.bkt.clouddn.com/network-dns.png" alt=""><br>根服务器其实并不知道 www.ietf.org 的 IP 地址，但是它知道 itef.org 域名服务器的地址，所以它把这条查询请求转发给 itef.org 域名服务器。DNS请求被逐层下发，直到找到对应的 IP 地址为止。</p><blockquote><p>DNS协议运行在UDP协议之上，使用端口号53</p></blockquote><p>应用层, 我接触的,最主要的还是 HTTP, HTTPS协议, 由于比较重要, 我还是单独成文了.</p><p><strong>HTTP</strong> :</p><p>TODO, </p><p><strong>HTTPS</strong> :<br>TODO</p><h1 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h1><h2 id="MTU-相关问题"><a href="#MTU-相关问题" class="headerlink" title="MTU 相关问题"></a>MTU 相关问题</h2><p>其实这这个MTU指的是链路层的数据区, 并不包括链路层的首部和尾部的18个字节.<br><img src="http://omotkhw3y.bkt.clouddn.com/network-linklayer1.png" alt=""></p><p>上面已经说了</p><blockquote><p><code>MTU</code>, 根据<code>协议性质</code>&amp;<code>网络性质</code>&amp;<code>操作系统(内核协议栈)实现</code>等因素的不同而不同, 通常认为这也是 TCP/IP分节传输或者设置buffer的依据.</p></blockquote><p>也就是说, 这个东西(<code>链路层的MTU(最大传输单元)</code>)会和操作系统(Unix, Linux, windows), 和 TCP分节(MSL, max sgement length), 网络类型(以太网, ASDL)会扯上关系: </p><ul><li>如果只谈 以太网 最大传输单元, 那么就是 1500 字节</li><li>如果谈IP数据报的数据区长度, 最大为1480字节</li><li>如果说TCP packet 最大长度, 那么 window是, 1500-20-20=1460(减掉ip, tcp头部各20字节), linux/mac/unix则还要减去12字节 tcp time stamp, 即1448字节</li><li>如果说udp, UDP数据报的首部8字节,所以UDP数据报的数据区最大长度为1472字节</li></ul><p>强调一下, 这里说的是<strong>最大</strong>, <code>最小为64字节</code> (以太网最大数据帧1500+14+4=1518字节, 头14字节, 尾CRC校验位4字节)<br>大于MTU, 这个时候发送方IP层就需要分片(fragmentation). 把数据报分成若干片,使每一片都小于MTU.而接收方IP层则需要进行数据报的重组.</p><p>用于ping时, 一般就是1500-20-8 = 1472, ipv4中icmp协议头为8字节, 但是ipv6中可能是4也可能是8.</p><h3 id="MTU-路径发现"><a href="#MTU-路径发现" class="headerlink" title="MTU 路径发现"></a>MTU 路径发现</h3><p>但是 MTU 不是一成不变的, 它会根据网络的性质, 通信状态进行一些列的调整, 例如Internet上的标准MTU值为 576. 其实也有一部分原因是, IP一旦丢包整段都要舍弃, 所以分小包减少丢包的概率.</p><p>MTU路径发现, 就是解决办法:<br>主机会首先获取整个路径中所有数据链路的最小MTU，并按照整个大小将数据分片。<br>传输过程中的任何一个路由器都不用进行分片工作(但路由器有这个能力)。</p><blockquote><p>为了找到路径MTU，主机首先发送整个数据包，并将IP首部的禁止分片标志设为1.这样路由器在遇到需要分片才能处理的包时不会分片，而是直接丢弃数据并通过ICMP协议将整个不可达的消息发回给主机。<br>主机将ICMP通知中的MTU设置为当前MTU，根据整个MTU对数据进行分片处理。如此反复下去，直到不再收到ICMP通知，此时的MTU就是路径MTU。</p></blockquote><p>还是以udp为例子:(1500-20-8=1472的理论值)<br><img src="http://omotkhw3y.bkt.clouddn.com/net-work-udp-mtu.png" alt=""></p><h3 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h3><p>TCP中谈论的更多的是, MSS (maximum segment size) 最大分节大小<br>一般为了避免分节, 也会进行相关的协商或者探测, 取网络的最小值.<br>撇开系统因素(比如linux/unix下可能会有tcp time stamp部分), 一般是:<br>ipv4 1500-20-20 = 1460 字节<br>ipv6 1500-20-40 = 1440 字节</p><h2 id="大小端问题"><a href="#大小端问题" class="headerlink" title="大小端问题"></a>大小端问题</h2><p>编写一个程序， 看一下主机字节序是<code>little-endian</code>还是<code>big-endian</code>.</p><p>下面给出一种简单的方案:</p><pre><code class="C++">#include &lt;stdio.h&gt;int main(){    int a = 0x1122;    char *b = (char*)&amp;a; //取低8位    if(*b == 0x11){        printf(&quot;BE\n&quot;);    }else{        printf(&quot;LE\n&quot;);    }    printf(&quot;%d\n&quot;, *b==0x22); //1    return 0;}</code></pre><p>当然你用联合union也挺好：</p><pre><code class="C++">#include &lt;stdio.h&gt;int main(){    typedef union {        int num;        char num_low8;    } NUM;    NUM number;    number.num = 0x1122;    if(number.num_low8 == 0x11){        printf(&quot;BE\n&quot;);    }else{        printf(&quot;LE\n&quot;);    }    printf(&quot;%d\n&quot;, number.num_low8==0x22); //1    return 0;}</code></pre><p>注意：操作系统读写内存都是从低地址到高地址。</p><blockquote><p>一般本地主机是小端，但是网络字节序就是大端了</p></blockquote><p>这个时候涉及到转换问题，一般是IP地址的转换(端口可能也需要)，有相应的函数htons()、ntohs()、htonl()、ntohl() ,<br>并且像protobuf库也有相关的API, asio库直接就封装好了, 什么都不用管.</p><h2 id="Ping原理"><a href="#Ping原理" class="headerlink" title="Ping原理"></a>Ping原理</h2><p>ping可以说是ICMP的最著名的应用，是TCP/IP协议的一部分。利用“ping”命令可以检查网络是否连通，可以很好地帮助我们分析和判定网络故障。</p><p>例如：当我们某一个网站上不去的时候。通常会ping一下这个网站, 如果丢包研究就是网络问题, 如果其他连接不可达, 就会出现超时或者主机拒绝连接等信息。</p><p>它利用ICMP协议包来侦测另一个主机是否可达, 原理如下:</p><blockquote><p>用类型码为0的ICMP发请求, 收到请求的主机则用类型码为8的ICMP回应</p></blockquote><p>用于ping时, MTU一般是1500-20-8 = 1472, ipv4中icmp协议头为8字节, 但是ipv6中可能是4也可能是8.</p><h2 id="Traceroute原理"><a href="#Traceroute原理" class="headerlink" title="Traceroute原理"></a>Traceroute原理</h2><p>这个工具比较强大, 给的选项也比较多, 通常是来检查跳(hop)数.<br>Traceroute是用来侦测主机到目的主机之间所经路由情况的重要工具，也是最便利的工具。</p><p>原理: (改变ttl数, 借助icmp反馈)</p><blockquote><p>它收到到目的主机的IP后，首先给目的主机发送一个TTL=1的UDP数据包，而经过的第一个路由器收到这个数据包以后，就自动把TTL减1，而TTL变为0以后，路由器就把这个包给抛弃了，并同时产生 一个主机不可达的ICMP数据报给主机。<br>主机收到这个数据报以后再发一个TTL=2的UDP数据报给目的主机，然后刺激第二个路由器给主机发ICMP数据 报。<br>如此往复直到到达目的主机</p></blockquote><p>这样，traceroute就拿到了所有的路由器IP.</p><h1 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h1><ol><li><a href="">《图解TCP/IP》</a></li><li><a href="http://www.cnblogs.com/hjslovewcl/archive/2011/07/18/2314316.html" target="_blank" rel="external">http://www.cnblogs.com/hjslovewcl/archive/2011/07/18/2314316.html</a></li><li><a href="http://www.choudan.net/2014/09/12/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4-%E4%B8%80.html" target="_blank" rel="external">http://www.choudan.net/2014/09/12/%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%82%B9%E6%BB%B4-%E4%B8%80.html</a></li><li><a href="https://juejin.im/post/598ba1d06fb9a03c4d6464ab" target="_blank" rel="external">https://juejin.im/post/598ba1d06fb9a03c4d6464ab</a></li><li><a href="https://www.zhihu.com/question/21064101" target="_blank" rel="external">https://www.zhihu.com/question/21064101</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)                                                                                                  </p><p>Saturday, 11. March 2017 04:09PM </p>]]></content>
    
    <summary type="html">
    
      个人是比较喜欢研究网络问题的, 最初可能是为了玩更多高大上配置的服务器, 之后就是为了弄清楚编程中遇到的问题以及其原因.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>领域信息系统开源构想</title>
    <link href="www.merlinblog.site/2017/10/12/domain-specific-system.html"/>
    <id>www.merlinblog.site/2017/10/12/domain-specific-system.html</id>
    <published>2017-10-12T08:21:08.000Z</published>
    <updated>2017-10-15T00:16:55.636Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一直以来我获取行业调研报告的途径都是券商的网站, 比如中金所, 建投等, 后来朋友建议你可以试试Python爬虫</p></blockquote><h1 id="尴聊"><a href="#尴聊" class="headerlink" title="尴聊"></a>尴聊</h1><p>机缘巧合, 朋友正在考虑要不要去<code>七牛</code>上海这边工作时, 我就存储的问题咨询了一下他, 为啥七牛, 又拍运的存储后台可以做的这么好.<br>其实呢, 我心里是有一定的见解的, 大致上由于其服务器分布位置以及网络供应商的合作, 没想到这个<strong>未来架构师</strong>的<code>老男人</code>开始大谈特谈架构问题.</p><p>他推荐了一篇文章, 我找了一个有用的架构图(单人使用的工具系统, 有必要这么复杂么?)<br><img src="http://omotkhw3y.bkt.clouddn.com/design.gif" alt=""></p><p>其实我是不太懂架构, 或者是不想懂; 上学那会儿我还会憧憬一下架构师, 可是经过2年多的工作, 我的兴趣点, 长处渐渐明确, 其实也应该是由于看到了架构师在单位内部尴尬的位置&amp;处境, 怎么说呢, 不说架构师, 反正就是, 死活不想做架构师. (希望5年内可以做领域专家)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>后端信息系统, 我其实死没有考虑这个的, 我希望要的是一个可以搜集数据, 分析数据, 然后适当分析数据的系统(当然主要的分析数据能力在我, 人类专家知识).</p><blockquote><p>但是当前没有太详细的构想; python 爬虫? + 可视化? 以及我要的<code>领域&amp;行业调研报告</code>? 有点乱.</p></blockquote><p>总之, 这个事情, <strong>先记录一下, 之后有时间, 仔细思考和实践</strong>, 作为了mini-project or side-project.</p><p>TODO</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      希望明年6月份前可以拉几个同学一起开发一下和这个系统
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
      <category term="python" scheme="www.merlinblog.site/categories/codings/python/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>抓紧时间, 突破!</title>
    <link href="www.merlinblog.site/2017/09/29/cherish-time.html"/>
    <id>www.merlinblog.site/2017/09/29/cherish-time.html</id>
    <published>2017-09-29T06:49:52.000Z</published>
    <updated>2017-10-13T17:54:37.195Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>有很多的问题的答案, 其实就在前辈的回答中, 在前辈的思考, 经历中; 可惜有些人偏偏要自己再重复一遍, 比如说过去我, (苦笑)</p><blockquote><p>一定要看看下面, 侯捷老师的演讲词</p></blockquote></blockquote><p>也是在今年在一场说走就走的冲动下, 我才有机会去思考, 去做自己真正想做的事情, 也体会到<code>珍惜你可以自由支配的时间</code>的重要性.</p><p>过去的经历, 大致是5年内(应该是大学二年级), 我和父母的矛盾一直很大, 很激化.</p><p><code>也因为这样浪费的很多时间</code>, 直到今天, 我的父母虽然开始支持我, 但也只是部分支持我. 我曾经在急需在关键点的时刻需要抢跑或者抓住机会, 父母有能力却不帮助我, 也没有试图理解我. 事实上却是观点冲突太大了, 父母的意思是, 我太小不懂事, 外面碰了壁, 多摔摔就知道他们是对的了. 这样时间一直过, 一连错了至少三次重大的机会, 包括那次去三星电子的机会.</p><p>时间过去那么久, 我也从最初的埋怨父母, 变得知道理解和懂得父母的用心. 但是价值观不同, 或者性格不同是不会变的, 换句话说, 本质上的矛盾很难根本上的根除, 除非我成家或者妥协了. 我想真的没有时间再去纠结或者顾忌这些了.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/hj.jpg" alt="post-cover"></p><p>因为困难而被打趴下的人很多, 在窘迫面前坚持不下去的, 放眼一大片. 可是, <code>开弓没有回头箭</code>, 即便以后还是会碰壁, <code>即便是碰了南墙, 我也不回头, 我要翻过去</code>.</p><blockquote><p>不知不觉的磨合以及埋怨, 会让你浪费好几年的时间, 好几次的重要机会, 想做的事情也没有做成. </p></blockquote><p>其实, <code>和父母的矛盾</code>不仅仅让我明白珍惜时间的重要性, 更重要的我知道, 如果没有父母的资助, 很多事情, 你要准备很长一段时间才可能有机会.</p><blockquote><p>是的, 没有选择的日子太苦了, 尤其上学那会儿, 明明那么多想做的事儿.</p></blockquote><p><strong>没有经历过痛苦和折磨, 或者有那么一段刻骨铭心的深刻记忆, 我想我现在也不会这么加倍珍惜时间吧.</strong> 所以<code>感谢过往痛苦的经历</code>吧.</p><p>有能力和机会做自己想做的事情的话, 请加倍珍惜!</p><p>哪么现在该怎么做?</p><ul><li><code>抢跑</code>很重要(有些机会错过很难再来)</li><li><code>坚持</code>很重要(有些路是跳着走的, 但更多的路是一步一个脚印, 一步一个台阶走的)—见侯捷老师原话<pre><code>练琴很辛苦， 音阶训练枯燥无比， 但如果稍加坚持， 也许你得到了赞美， 也就发掘了兴趣。很多人说兴趣不能当饭吃，错，兴趣可以当饭吃。出问题的不在&quot;兴趣何方&quot;， 而在“能否坚持”。</code></pre></li><li><code>独立思考</code>很重要</li><li><code>老师</code>很重要(见陈硕大师的回答)<pre><code>如果你在名校, 你的老师可能会问你指出一些古董书籍中的一些不必要过度深究的问题, 为你省下很多时间;如果你没有老师, 你知道去啃经典教材, 其中有些过时的东西, 你也不知道, 比如unp卷1中的一些篇章.</code></pre></li></ul><p>及时的意识到当前的限制因素, 然后根据限制因素, <code>做原则以内的调整</code>, 我的优势明显, 其实劣势也很明显:</p><p>相比去<code>滴滴</code>的同学, 不论是在金钱回报, 还是在成长上, 我可能都要落后一些或者一大截. </p><blockquote><p>是的, 我已经错过了<code>抢跑</code>的机会. </p></blockquote><p>现在要做的只有扬长避短, 我称之为<code>快速突破</code>, 目标超越80%, 剩下20%交给30岁之后, 也就是我说, 还有5年不到的时间.</p><p>但是意识到问题所在, 就不用怕, 开动脑筋, 想想自己过去做过的那么多准备和努力. 还有超车的机会:</p><ul><li>谨慎做好选择, 这个非常重要; 宁缺毋滥</li><li>坚持下去, 闯过, 突破相应的难关 (这个非常难, 你没经历过的话, 可能不会动; 这期间太孤独, 很多不被理解)</li><li><code>坚持独立思考</code>, 现在信息复杂, 很多<code>好心人</code>他们的观点其实没有太多的帮助(但有一定的参考价值, 供你分析), 反而为你带来了迷茫</li></ul><blockquote><p>珍惜自己的时间, 做自己要做的事情, 好坏不回头</p><blockquote><p>我现在每每遇到难题, 都会这样暗示自己: <code>if u wanna it, u just go and get it no matter how(difficult) and what others&#39; saying about it.</code></p></blockquote></blockquote><p>当然, 侯捷老师当前在<code>华科</code>讲话那几条也不错, 我就摘抄一下吧: (转载from豆瓣, 请Google)</p><pre><code>程序人生－－侯捷在华中科技大学的演讲 如果你不曾听过侯捷的名字，不曾知道侯捷做的事情，你不可能有兴趣走入会场。因此，各位远道而来，我窃以为，无非想看看侯捷本人，听听他说话。如果你期盼在这种场合听到某某技术的剖析，某某趋势的发展，肯定你会失望。我不是趋势专家，对此也毫无兴趣。台上说话和台下聊天不同，我不能也不敢讲我没有心得没有研究的话题。&quot;程序人生&quot; 这个话题旨在让大家对一个你感兴趣的人（侯捷我）的学习历程有些了解，或许从中给你一些灵感或激励。我在一个被昵称为“ 少林寺”（台湾工研院）的地方，磨练三年。后半期因为发现了自己浓烈的兴趣与不错的天赋，决定转向技术写作与教育这条路。30岁之后的我， 行事常思“ 贡献度”，我知道自己在技术写作与教育这条路上能够走得比程序开发更好，所以决定把自己摆在最适当的位置。一口食物，放在嘴里是佳肴，吐出来就成了秽物。天生我材必有用，每个人都应该仔细思考，自己真正的兴趣和才能在哪里。很多人都问，30岁之后做不动程序员了怎么办。30年正是英年，体力和智力和成熟度都正达到巅峰，怎么会做不动程序？想往管理阶层走当然很好，那就努力充实自己，并且扪心自问，你做管理快乐吗？要知道，人事绝对比机器让你更焦头烂额。如果你决定争取一个粥少僧多的职位，就不要再问“ 怎么办”。还能怎么办？努力以赴呀。比赛还没开始就问输了怎么办，这不像话，你注定要输。技术养成阶段，对我影响最大的一件事是，我自动请缨做一套公用程序库，目标给全部门乃至全所使用。这使我学习到技术的整理、文件（documents）的撰写、人际的沟通。重要的不在具体实作，而在多方培养了正确观念。如果你问我，对于程序，我最重视什么？我最重视可读性（含说明文件）、维护性、复用性，完整性。这些其实是一体多面。转向技术写作后，我的生活和待在业界没有什么改变，只不过业界的产出是软体，我的产出是书籍和文章。写一本书和规划一个专案（project）没什么两样。但是，专心于技术写作之后，从此我有绝对的自由钻研我最感兴趣的“ 技术本质” 与“ 技术核心”。我周遭的朋友，但凡表现不凡者，都有非凡的资料整理功夫。如今网络发达，资讯爆炸，硬盘又便宜，资料整理功夫更显重要。没有经过自己整理的资料，形同垃圾。许多人喜欢上网“ 收集” 一大堆电子书、电子文档。你得想个办法把这些庞大的资料化为你的图书馆，而不是搁在硬盘角落里做为安慰或炫耀。书籍也一样，买来要看，安慰自己或炫耀他人都没有任何意义。当然，一旦你到达某种层次，以及某种经济能力，你买书不见得马上看，不见得整本看。我有个私人小图书馆，其中的书有许多还没看，当初购买是准备随时参考用的，也有些是当做学习的目标，摆着准备有空时看。今年是我写作的第1 0 个年头。我认为自己确实走上了一条最适合我的路，尤其今天这么热烈的场面，实在令我情绪激昂。我不会忸怩作态地不愿承认我的作品给别人带来帮助，然而我要说，作者和读者是相互激励相互影响的，我们彼此进入了一个良性循环。没有优秀的读者，就没有优秀的作者。艺术家可能不是这样，但电脑技术写作，或更缩小范围地说，我，是这样。因此，我要衷心感谢那些给我鼓舞、给我勘误、给我赞美、给我批评的热情读者。下面回答几个常被提出来的问题。一、 如何学习大哉问。学习需要明师。但是明师可遇不可求，所以退而求其次你需要好书，并尽早建立自修的基础。迷时师渡，悟了自渡，寻好书看好书，就是你的自渡法门。切记，徒学不足以自行，计算机是实作性很强的一门科技，你一定要动手做，最忌讳眼高手低。学而不思则罔，思而不学则殆，一定要思考、沉淀、整理。整理的功夫我要特别强调。许多人一味勇往直前，追求最新技术发展，却忽略了整理沉淀的功夫。如果知识不能深刻内化为你的思想，那么这份知识很快会离你而去。二、 科班与非科班, 名校与非名校各位身为名校学生，身为科班生，从来不必在乎这个问题，那是饱人不知饿人饥。这个题目上我是50比50， 我出身名校，但非科班。虽然我从来没有被这个问题所惑，但的确有许多年轻学子为此辗转反侧，苦恼不已。学历和背景只是一个证明，证明你曾经经历过某种考验，证明你曾经经历过某种训练。但并不保证考验后或训练后的质量。你所处的环境如果极重视出身，这是你无能为力的— — 毛主席要废除封建，千百年来的人心却难以废除。但是不要气馁，你总有机会证明你的能力。上天不会不给任何人至少一个机会，关键在于机会来时你准备好了没有。三、升学（ 考研）与就业先升学好还是先就业好？未曾深刻对发问者的个人背景做一番了解与分析，就遽然给答案，是不负责任的骗子。我只能说，以我的经验和我的观察，如果你能够先就业再继续深造，就业所得的各种经验会对你的治学方式带来很大的帮助。就连你的人生历练，都会对你和你的指导教授的相处带来帮助─ 这可是件大事， 影响你3~6年的生活。（注：台湾硕士生两年，博士生四年，大陆硕士生三年，博士生三年）四、培养自信心嘴巴无法培养自信心，手才能够。只要切切实实地动手做点东西，你的自信心就会逐渐建立起来。随着自信心的建立，你就再也不会问&quot;C++还有前途吗&quot;、 &quot;Java还有前途吗&quot;、“VB还有前途吗”这种问题。下面是我给同学的七个勉励：1.乐趣linux操作系统的创造者 linus 最近出了一本自传：《Just for Fun 》，简体版译名为《乐者为王》。如果我来译，我就译为《一切只为乐趣》。是的，兴趣才能使你乐在其中，乐在其中你才会产生热情，热情才能使你卓越。要忠于自己的兴趣。有人问，怎样才能找到自己的兴趣，如果我有答案，我就可以开一个“ 卡内基兴趣开发中心”，成为全球首富。这种问题不会有明确答案的，你的兴趣要别人来帮你开发，咄咄怪事。你可以多方尝试，但是首先要有起码的坚持。练琴很辛苦，音阶训练枯燥无比，但如果稍加坚持，也许你得到了赞美，也就发掘了兴趣。很多人说兴趣不能当饭吃，错，兴趣可以当饭吃。出问题的不在 “兴趣何方”， 而在“能否坚持”。2 . 坚持我在今年四月份给新竹交通大学资讯系一个演讲，题目是：唯坚持得成功。我自己才能平庸，但我很能坚持。我的这种个性在朋友之间是被称道的。坚持并不代表一定成功，不过坚持本身就是一种美好的情操。所谓谋事在人，成事在天，只要坚持，我们总可以心安理得地说：那美好的战我打过了。人生最后要的不就是心安理得吗？3 . 格调做事不但要坚持，而且要坚持高格调。格调使人高贵。俗世成功不保证格调，格调也不保证俗世成功，但是格调使人拥有尊严，使人获得尊敬。我在台湾，观察计算机书籍的写作与出版，对于格调特别有所感触。有些作者与出版社，并不在乎格调，也不在乎贡献，只在乎生意，只在乎利润。生意要做，利润要赚，传道还需道粮嘛，但是金钱绝不能摆在第一位，否则生意和利润都不会长远。因金钱而结合的，终将因金钱而分手而结束。关于这个，台湾有许多活生生的例子，可为大陆出版社借鉴。4 . 谦虚与教养再怎么开明的师长前辈，也许可以接纳年轻人的飞扬跋扈，也许可以接受年轻人的无理取闹，但当他真正需要帮手或真正要培养人才时， 他一定特别考虑谦虚有教养的年轻人。没有什么是不能挑战的， 但是做为挑战者，你要言之有物、言之有理。毛主席说， &quot;没有调查就没有发言权&quot;， 这话说的真好。5 . 气势气势和先前说到的谦虚，两间之间不好拿捏，拿捏尺寸属于艺术范畴。圆熟的人生历练，才能把两者调理得恰到好处。我的想法是：做人要谦虚，做事要有气势。这次来内地演讲，接触读者，网上很多的评语是：他很谦虚。为什么这么说？难道侯捷曾经给人不谦虚的印象吗？是因为我文章中的气势吗？谦虚和气势，并不是两条平行线。6 . 勤奋爱迪生说， &quot;成功是百分之一的天才加上百分之九十九的努力&quot;。道理非常清楚，我没有什么引申。你问任何一位你认为成功的人他是否勤奋，看看他怎么说。我有一位大学同学，跳舞打牌爱吃爱玩，但是每次微积分考试都比我好。我比他勤奋，他比我聪明。天赋使然，别在上面钻牛角尖（我曾经钻得很痛苦）。要知道，人生的成绩单和学校的成绩单没有必然关联。人生很长，要看长远，要计久长。7 . 超越自己的&quot;局限&quot;清华一位同学问我，最佩服哪些程序员，我一时答不上来。经过同学的引导，我说了几个名字。同学又问我，我佩服的都是些外国人吗？我略略想了一下说是。同学（似乎）失望地坐了下来。事实上，在那个突然的问题中，我的思考迷了路。我的回答并不真正代表我的心意。我从来没有想过谁是我最佩服的程序员。在我的生活中那是一个不存在的话题。技术不是真理，我没有崇拜过哪一位程序员或技术大师。我知道大陆有着地位极为崇高（近乎民族英雄）的程序员，他们的事迹对来自台湾地区的我而言，总是有着一层陌生。当然， 传奇令人神往，我也爱听他们的事迹。至于台湾，从来没有知名的程序员，台湾不曾走过这样一个个人英雄时代。现在，我要修正我在清华的回答。我真正佩服的，是那些超越自己局限的人——任何人，不只是程序员。&quot;局限&quot; 是你的家庭、你的环境加在你身上的先天桎梏，谁能摆脱先天桎梏，谁便是人生勇者，值得最大的尊敬与佩服。如果我的读者之中有人佩服我，我希望那是因为我对技术写作的执着以及对年轻学子的关怀，不是因为我的技术。再且，我的技术也只普通而已。任重而道远我为什么有机会在华中科技大学和同学们有这么热烈的一次接触？原因是我的书在华中科技大学出版社出版，而他们追求质量的态度，对作者的尊重，令我感动。当我拿到《Essential C++》简体版，我大吃一惊，制作质量完全不逊于繁体版。我告诉我的编辑，侯捷所有后续书籍秉此办理。这几天，仔细了解《深入浅出MFC》一波三折的出版过程后，真正体会到，没有优秀的后援，好书终究到不了读者手上，那么，作者再多的质量、坚持、格调，终是一场空。    身为一个自由作家，没有任何理由我需要在乎计算器技术书籍的整体发展。我把自己的书写好，已经很对得起我的社会责任。然而我诚恳告诉各位，计算机技术书籍的整体发展和侯捷个人的发展，两者在我心中有相同的比重。前者说小了，影响大家的求知，说大了，影响国家的IT产业。读者对于这方面的殷切期待，在侯捷网站上的读者来函中一再出现。昨天我从周老师手上又获得几封读者来信，其中一封言词诚恳，不卑不亢，特别令我感动，我把它念出来与大家分享。信中对我个人的谬赞，不敢当。</code></pre><p>(但是侯捷老师年轻的时候, 都在专攻术业, 到三十岁才开始想明白一些事情, 哈哈, 我想我比他早了5年时间)</p><blockquote><blockquote><p>如果你决定争取一个粥少僧多的职位，就不要再问”怎么办”。还能怎么办？ 努力以赴呀。比赛还没开始就问输了怎么办，这不像话，你注定要输。<br>我真正佩服的，是那些<code>超越自己局限</code>的人——任何人，不只是程序员。</p></blockquote></blockquote><p>请再读一遍他的演讲稿吧, 那里面深刻处理几个常见的问题(虽然有一些观点, 现在的我有一些不认同…)</p><blockquote><p>谨以此篇纪念过去对我帮助很大的<code>侯捷</code>大师的(译)作品, 也为我自己突破3.0阶段开路.</p></blockquote><hr><p>2017年9月29号, 再次重返上海的第7日<br>几个朋友多次邀我国庆出去玩, 都拒绝了, 也没有具体解释原因, 顺其自然吧</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      谨以此篇纪念过去对我帮助很大的侯捷大师的(译)作品, 也为我自己突破3.0阶段开路.
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>在家装修有感</title>
    <link href="www.merlinblog.site/2017/09/20/experience-when-doing-house-up.html"/>
    <id>www.merlinblog.site/2017/09/20/experience-when-doing-house-up.html</id>
    <published>2017-09-20T14:06:03.000Z</published>
    <updated>2017-09-29T09:27:03.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>it’s not about love, it’s all about life and work. 要说的是不感情， 而是做人做事的态度; (当然老爸也和我谈了一些经验)</p></blockquote><p>本文也感谢父母, 为了拼搏解决了<code>他们觉得是问题的问题</code>(虽然这不是我想要的, 但依旧), 感谢.</p><h1 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h1><p>父母借着监工装修的理由把我喊回家了， 母亲还是没有改变， 苦口婆心劝我回家发展， 不要再<code>玩电脑</code>了(至今我妈妈只知道我在电信行业, 不知道我是码农,或者软件工程师), 而父亲则是有一些改变， 从退让变为了支持. 与家里人冲突很大，和父母的观念完全格格不入，直到今天，我仍旧不能判别谁对谁错。或者根本没有对错。 </p><p>监工的日子短暂而又枯燥， 但是经历和体会却是良多. </p><blockquote><p>要做一件事情，先要进行逻辑梳理，确认是基于哪些事实(类别)，再逐个解决问题.(<code>黑天鹅</code>除外)</p></blockquote><p>第二个层面, 要说做事儿的态度的原因, 是<code>歉信君</code>的一篇博文, <a href="http://www.cnblogs.com/kenshinobiy/p/4876788.html" target="_blank" rel="external">为什么给的待遇很丰厚，我的90后员工还是要走？</a>, 试图解释一下, <code>我作为90后的工作态度</code>, 见下文, 细说.</p><hr><p>下面分成4个部分来说：</p><ul><li>房子和发展</li><li>做事情的态度</li><li>兴趣和工作</li><li>坚持还是退让</li><li>老板的激励原则</li></ul><h2 id="房子"><a href="#房子" class="headerlink" title="房子"></a>房子</h2><h3 id="房子和个人价值"><a href="#房子和个人价值" class="headerlink" title="房子和个人价值"></a>房子和个人价值</h3><p><code>在我这个年龄</code>， 房子对于我似乎是可有可无的。 </p><p>为什么这么说呢？ </p><p>因为我并不是一个安分的人， 像我的某些同学所说的那样“白天有酒喝， 晚上有奶摸， 此生足以”。 我心里还是有我想做的事儿。 一方面我想提升自己的能力， 追求才华， 想把自己变得更有用，让自己的价值得以体现； 另一方面， 我还存在一定的虚荣心（当然， 现在已经好太多了）, 想进一步拉开和同学的差距, 至少将来不能是个垃圾吧.</p><p>但是父母早早就给我在筹划这个事情。 学妹说，“知足吧， 得了便宜还卖乖就是矫情了”。 我只能说， “知我心者， 谓我心忧； 不知我者谓我何求”。</p><p>就像<code>叔本华</code>说的， <strong>一个人过度依赖外物的话, 就会在那些东西失去的时候变得空虚和孤独， 很多时候要反求于内心</strong>。 </p><blockquote><p>有钱就住大点儿的房子， 没有那么多财力， 小点儿的未尝不可；<br>如果父母那一辈不够努力， 没有给你积累财富， 也不用过分气馁或者埋怨， 租房住也未尝不可（但最好为你的下一代积累一点儿），</p><p>我现在在上海租房住， 和房东， 和住户们未尝不开心了。</p></blockquote><p>房子给女人带来的是安定， 给男人的意义， 个人觉得没有那么大.</p><p>并且<code>拿房子来说明自己的成功与否的人， 我个人是不认同的</code>， 因为我遇见过太多的牛人，有才华的人， 对物质生活的追求其实是非常少的。</p><h3 id="房子和发展"><a href="#房子和发展" class="headerlink" title="房子和发展"></a>房子和发展</h3><p>废话不多说， 先上图再说.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/deco2.jpg" alt=""> <img src="http://omotkhw3y.bkt.clouddn.com/deco5.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/deco3.jpg" alt=""> <img src="http://omotkhw3y.bkt.clouddn.com/deco4.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/deco1.jpg" alt=""> <img src="http://omotkhw3y.bkt.clouddn.com/deco6.jpg" alt=""></p><p>拿到房子的时候， 其实大致上的建筑面积是改变不了的； 然后主要支撑结构的位置也改变不了的。 <code>这就像我们的人生其实也是非常局限的</code>， 这不仅仅是说人生的长度， 更说的是<code>如果不从外部扩展， 只在内部开拓的话， 发展是有限的</code>。</p><blockquote><p>当然有的人会说， 有限的空间争取无限的可能， 利用空间的才能不一样， 同样的面积造就的精彩程度也不一样. </p></blockquote><p>这个道理当然没有错， 就像我们上学的时候， 即便是一样的努力， 最后的成果也是不一样的， 抛开运气因素不说， 每个人学习能力不一样， 这也是客观事实。</p><p>但是， 一个人的力量是有限的， 这一点你也不能否则。 不管一个人怎么开拓， 他始终要借助外力， <code>这就好像一个人不能不进食一样， 他自身也要成功， 需要外部能量</code>。</p><p>就像<code>卡内基</code>先生所说的一样， 一个人在事业上的发展只有15%是依靠自身的技能， 其他85%是依赖和别人的 <strong>交流合作</strong>。</p><p>而落实到我们金融IT业(<code>FinTec</code>)， 其实个人技能点， 一般3-5年差不多就能点亮80%了， 其余的20%如果你决心要成为技术专家才需要话另外5-7年去钻研； 而如果你能体会到自身的局限， <code>懂得合作</code>， 那么即便你的个人能力最终不如那些专家， 但是最终创造的个人价值也好， 社会价值也好， 或者赚取的财务也好， 都不一定会比那些个人专家少。（技术都是花时间， 熬时间，慢慢钻研的； 当然也和机遇平台相关）</p><p>也就是说:</p><blockquote><p>想要发展的个更好， 就要在<code>理解自身局限和长处的同时, 努力向外扩展</code>。</p></blockquote><h2 id="做事情的态度"><a href="#做事情的态度" class="headerlink" title="做事情的态度"></a>做事情的态度</h2><p>看工人们装修， 摆弄， 即便是偶尔搭搭手， 也是比较枯燥的。 什么原因呢？ 不是因为他和我利益不相干， 也不是因为我完全不懂（毕竟也不需要我懂）， <code>而是我不感兴趣</code>。</p><p>回想我当初辞职时候的毅然决然， 除了不想养老之外， 可能也有一部分原因是觉得很枯燥。</p><blockquote><p>而老爸晚饭的时候， 问我装修的事情怎么样， 我并没有意识到，<code>这其实是在对上级汇报工作</code></p></blockquote><p>然后老板和我说了一些对待工作的态度, 其中有一些还是深受启发的。</p><ul><li>不要觉得有些事情烦躁， 没有成就感， 简单枯燥就不去做， 那样不仅是没有耐心的表现， 也是成不了大才的；<br>如果那是个必须经历和忍受的过程， 那你就要坚持下来， 毕竟和你想法一样， 受不了枯燥的人， 不是少数</li><li>工人和老板的利益， 员工和公司的利益不总是一致的； 所以需要监管和激励。</li><li>假如你是装修师傅， 你如何保证这个主顾以后有生意还会找你或者推荐你？ <code>无论为谁做事情， 为自己也好， 为公司也好， 都要尽心尽责</code>。<br>我在这个岗位， 做这件事儿， 只要当前还是我负责的， 我就要做好； 即便是不想做了， 这一单也要做好了， 后面再说别的；<br>这不是工作的事， <code>是一个人态度和修养的问题</code>; </li></ul><h2 id="兴趣和工作"><a href="#兴趣和工作" class="headerlink" title="兴趣和工作"></a>兴趣和工作</h2><p>老爸和我说的多事家庭和工作，以及装修的事儿。 不过我自己私底下也思考了兴趣和工作。</p><p>如果你现在已经对工作游刃有余， 那么如果这工作也是你的兴趣， 那么请深挖； </p><blockquote><p>如果这工作不是你的兴趣， 也没有关系， 因为工作和兴趣扯在一起的时候， 我通常认为这是悲剧的开始， 就像你喜欢吃牛肉， 但是天天吃， 迟早也腻了。</p></blockquote><p>我们一生中大致上会经历一种或者两种状态：</p><ul><li>为自己家里的产业打拼， 然后交棒退休</li><li>为老板工作，然后在合适的时候自己干或者跟着合适的人干</li></ul><p>但是无论是哪一种情况， 我个人的思考和建议是， <code>工作和兴趣最好不要扯在一起</code>(你想做的事儿, 就是你的工作, 那又不一样了)。<br>因为一旦涉及利益， 即便你不思考(不往这方面想)， 也不能否认这样的兴趣已经不能是实实在在的兴趣( pure pleasure )了.</p><p>工作和兴趣的关系, 侯捷大师, 有一段演讲稿说的很好, 原话我记不清楚了, 大致是说:</p><pre><code>练琴很辛苦, 可是一旦取得一定的成果, 就变得有意思; 兴趣的培养在于能不能坚持下去.</code></pre><h2 id="坚持和退让"><a href="#坚持和退让" class="headerlink" title="坚持和退让"></a>坚持和退让</h2><p>某些时候， 到底是该坚持， 还是该退让， 真的很难说的清楚， 而能够说清楚的是，<code>时间永远是往一个方向走， 而且不再回头</code>。</p><p>我一直坚持 <code>The Best Or Nothing</code> 的观念， 这种想法的本身就是一种很极端， 很倔强， 不做退让的价值观。</p><p>但是偶然看到母亲变老的样子， 我不仅问自己， 到底当初那个信誓旦旦的说 <code>Win Or Home; All or None</code> 的我， 到底是对还是错？</p><p>行文之时， 我在武汉金融港， 而两天后， 我又要回到上海。</p><blockquote><p>或许坚持和退让， 很久之前， 我就做好了选择， 而且还没有打算改变选择。– <code>其实我们心里早早就有了答案</code>.</p></blockquote><p> 本次大修正之后， 几年内我都将不再休息， 而是全身心在<code>上海</code>投入, 工作和成长, 突破。</p><blockquote><p>let it be / So be it. 顺其自然吧。</p></blockquote><p>感谢那些所有一直关注和帮助我的人, 衷心感谢.</p><h2 id="激励原则"><a href="#激励原则" class="headerlink" title="激励原则"></a>激励原则</h2><p>关于歉信君的博客, 这里引用一下: (指出他文章中, 我认为有一些出入的地方)</p><blockquote><p><em>很显然，相较于长辈和前辈们，90后成长于殷实的年代，生存和生理上的、安全的两层需要被轻易满足，所以基于此的薪酬、稳定等因素已经失效了。社交上的认可、他人和自我的尊重、以及一种自我成就感，才是需要优先考虑的。如果一份工作不能拿出去在朋友圈晒、如果工作成果不能让顾客和老板真诚表扬、如果由于公司或者上司的支持力度不够而不能做到最好，那么这份工作对于他们的激励是远远不够的。</em></p></blockquote><p>我想说, 这对于<code>虚荣心强</code>的大部分我们90后是适用的, 但<code>不适用工作2-3年的人</code>, 比如说我, 因为我现在基本已经克服虚荣心问题了, 也不会轻易向上司许诺任何事情.</p><p>说出去的话就要负责, 不是能轻易许诺的. 这一点可以参考我的 <a href="http://www.merlinblog.site/2017/09/05/lessons-history.html">经验教训</a> 一文.</p><p>但是下面这一点, 他说对了:</p><blockquote><p><em>有一些是兼职的实习生和试用期的员工，他们在工作安全感和稳定性上欠佳，福利待遇上也有所不如。所以相应的激励因素就是提供转正的机会，以及提供一些职业技能培训的课程。</em></p></blockquote><p>心理学家亚伯拉罕·马斯洛将人类的需要分为了五层，分别是：</p><ul><li>生存和生理需求</li><li>安全需求</li><li>情感和归属的需求</li><li>尊重的需求</li><li>自我实现的需求</li></ul><p>有些人说 <code>马斯洛需求</code>模型是不准确的, 比方说, <code>JP摩根的父亲</code>就说过, <code>人类的多种需求是同时存在的</code>, 但是我想说, 是的, 但是<strong>马斯洛基本是对的</strong>.</p><p>我以自己的亲身体会来说, 当初我父母不支持我去上海, 毕业的时候, 一分钱没有给我, 连路费也米有; 那个时候借着老师, 学姐的力量, 我在实习的薪水, 不, 工资(wage)中, 硬是抗了下来. 那个时候, 我脑子里没有别的概念, 只有<code>钱</code>, 怎么样拿到更多的钱在上海生存下来. (但你说我那个时候, 没有自我实现的需求么? 其实有的, 只是它一点儿也不重要)</p><p>所以我的观点是, </p><blockquote><p><code>满足80%的主要需求就好</code>, 另外的是要靠自己突破自己的局限的; </p><blockquote><p>如果你要追求极致, 那不是奖励的问题, 而是自身的问题, 换句话说, <code>这是你自己对自己的要求, 与外界无关</code></p></blockquote></blockquote><p>用老东家的观点, 另外20%就顺其自然吧.</p><hr><p>好了, 废话说了这么多, 不说了, 装修工作, 就这样吧; 希望以后的工作越来越顺心.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      装修有什么好说的? 好无聊的博主... 我想, 我要说一说做事的态度.
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>C++最终篇</title>
    <link href="www.merlinblog.site/2017/09/14/c-plus-plus-final.html"/>
    <id>www.merlinblog.site/2017/09/14/c-plus-plus-final.html</id>
    <published>2017-09-14T05:28:09.000Z</published>
    <updated>2017-10-05T23:02:35.042Z</updated>
    
    <content type="html"><![CDATA[<p>这里集中说一说, 就当汇总吧; <code>以后C++更新的新内容全部在此</code>. 更新列表, 如下:</p><table><thead><tr><th>时间</th><th>内容</th></tr></thead><tbody><tr><td>2017-8-26</td><td>初稿:C++标准文档</td></tr><tr><td>2017-9-14</td><td>更新:C++17新特性(参考《程序员杂志》,2017.09期)</td></tr><tr><td>2017-10-03</td><td>技术就是条无底洞, 尤其C++, 我不了解的内容还有很多; 遂修改部分言论</td></tr></tbody></table><hr><blockquote><p>在今天这语言百花齐放的年代, C++标准的制定又<code>被资金限制</code>推迟, 一直是在追着时代跑(已经完全不能领先于时代了)</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/cpp_all1.jpg" alt="post-cover"></p><blockquote><p>C++的著作, 非常多, 鱼龙混杂. 我当年走了不少弯路; 实际上很多书可以不读.</p></blockquote><h1 id="经典著作"><a href="#经典著作" class="headerlink" title="经典著作"></a>经典著作</h1><p>我在最开始写 <code>Modern C++</code> 的时候, 就推荐过好基本书, 这里在集中说一说.</p><p>入门我一共推荐了2本: (入门你看看《C++编程语言-十周年版》也是不错的, C++本加尼写的)</p><ul><li>《C++语言演化》</li><li>《C++ Primer(5e)》  (不要看第四版)</li></ul><p>我一共推荐4本C++的额外读物:</p><ul><li>《Effective Modern C++》</li><li>《Effective C++ 第三版》(相比第二版有很多新东西)</li><li>《More Effective C++》</li><li>《Effective STL》</li></ul><p>后面3本是经典, 需要细读.</p><p>由于我不是专门研究或者参与语法研究, 我其实不太喜欢语法来语法去, 也比较讨厌硬是把给个主题都写一遍的书, 比如<code>《Think In C++》</code>.<br>(纯粹的浪费大好的青春, 年华)</p><p>还有一些, 比如<code>《Inside C++ Object Mode》</code>, 我只能说, 如果你还在上学, 请务必读一读; 如果已经工作, 呵呵, 你好闲啊.</p><h1 id="标准文档"><a href="#标准文档" class="headerlink" title="标准文档"></a>标准文档</h1><p>C++真正正式公布的标准只有三个：C++98、C++03、C++11:</p><ul><li>C++98是第一个正式的C++标准</li><li>C++03是在C++98上面进行了小幅度的修订</li><li>C++11则是一次全面的<code>大进化</code>（之前称C++11为C++0x，以为会在08~09年公布，没想到拖到了11年, 原因?<code>缺钱</code>啊）<br>(你看它的标准文档就知道了, 前两个版本都是2.7M左右, C++11直接变成了14M)<blockquote><p>现在貌似C++17标准也快了, 据说9月就会去开会讨论啥的. 不过C++标准的跳票也没准, 就像官方所说的, 缺乏资金推动.</p></blockquote></li></ul><p>下面给出标准库的文档, 可以参考我的github库:<br>C++98 (1998年)<br><a href="https://github.com/WizardMerlin/Gate/tree/master/appendix/98.pdf" target="_blank" rel="external">https://github.com/WizardMerlin/Gate/tree/master/appendix/98.pdf</a></p><p>C++03 (2003年)<br><a href="https://github.com/WizardMerlin/Gate/tree/master/appendix/03.pdf" target="_blank" rel="external">https://github.com/WizardMerlin/Gate/tree/master/appendix/03.pdf</a></p><p>C++11 (2011年)<br><a href="https://github.com/WizardMerlin/Gate/tree/master/appendix/11.pdf" target="_blank" rel="external">https://github.com/WizardMerlin/Gate/tree/master/appendix/11.pdf</a></p><blockquote><p>如果有时间, 这些文档是值得好好读读的, 而且是<code>一手资料</code></p></blockquote><h1 id="C-17"><a href="#C-17" class="headerlink" title="C++17"></a>C++17</h1><blockquote><p>C++17是语言小修改（相对C++14，大概20几条）、标准库增加比较多（大概200多条）。</p><blockquote><p>C++20将会是可以和C++11可以媲美的大发展。</p></blockquote></blockquote><p>程序员杂志上《深入应用C++11》的作者给出了介绍, C++17其实主要是把Boost已经运用成熟的特性, 比如<code>any</code>, <code>optional</code>, <code>filesystem</code>等引入.<br>还有一些简化代码的机制, 比如<code>nested namespace</code>, <code>if init</code>, <code>dedution guide</code>等; 当然还增加了<code>并行算法</code>.</p><p>下面挑选我认为比较有意义的, 记录一下.</p><h2 id="来自Boost"><a href="#来自Boost" class="headerlink" title="来自Boost"></a>来自Boost</h2><p>类型擦除的三个:</p><ul><li>std::any</li><li>std::optional</li><li>std::variant</li></ul><p>其中, <code>std::optional</code>一般用于返回值(返回不确定值), 而<code>std::any</code>, <code>std::variant</code>则用于存储任意类型的值, 只是在转换回来时, std::any,<br>需要使用<code>std::any_cast&lt;类型&gt;</code>, 而 std::variant 则用 std::get即可, 当然你用<code>std::visit(functor, arg)</code>也可以.</p><p>std::filesystem<br>基本和boost中的一致, 用来处理文件和目录, 比如:</p><pre><code class="C++">namespace fs = std::filesystem;std::string path = &quot;C:\\test&quot;;for(auto&amp; p : fs::directory_iterator(&quot;test&quot;)){    std::cout &lt;&lt; p &lt;&lt; std::endl;}</code></pre><h2 id="简化代码"><a href="#简化代码" class="headerlink" title="简化代码"></a>简化代码</h2><p>这里最显著的就是, 嵌套的命名空间, 例如C++11会这么写:</p><pre><code class="C++">namespace A{    namespace B    {        namespace C        {            struct Foo{};            //...        };    };};</code></pre><p>然后C++17就直接这么搞:</p><pre><code class="C++">namespace A::B::C{    struct Foo{};    //...};</code></pre><p>static_assert<br>原来的静态断言, 你必须制定错误提示, 现在不用了, 直接给单个参数就好了, 下面是对比</p><pre><code class="C++">static_assert(false, &quot;sth. wrong&quot;); //C++11static_assert(false); //C++17, let compiler do message</code></pre><p>条件初始化<br>在if语句里面初始化相关判断的变量, 之后if代码块执行完毕, 自动析构; 多好. 直接看例子吧: (举锁的例子)</p><p>C++11我们这么写的一段代码:</p><pre><code class="C++">std::mutex mtx;std::vector&lt;int&gt; v;{    std::lock_guard&lt;std::mutex&gt; lock(mtx);    if(v.empty()) {        v.emplace_back(1);                      }}</code></pre><p>凸出来的一段<code>{ }</code>代码块, 好看么? 再看看C++17, 直接起飞:</p><pre><code class="C++">std::mutext mtx;std::vector&lt;int&gt; v;if(std::lock_guard&lt;std::mutex&gt; lock(mtx); v.empty()){    v.emplace_back(1);}</code></pre><p>演绎推导deduction guide<br>有人还是很羡慕 <code>JAVA的菱形语法</code>, 但是C++17可以直接省略泛型, 编译时会自动推导:</p><pre><code>std::pair p(1,1.5);</code></pre><p>直接推导为</p><pre><code class="C++">std::pair&lt;int, double&gt; p(1, 1.5);</code></pre><p>也就是说, 进行了隐式推导.</p><blockquote><p>当然你可以去写<code>显示推导</code>表达式, 个人认为比较麻烦, 除非你在写框架, 需要定义大量模板</p></blockquote><p><code>capture *this</code><br>lambda表达里面捕获外部的值, 以<code>值传递</code>的方式, 还是有的, 比如说, 在main线程里面, 你给A线程传递一个值, 这个时候传引用么? 可以么? 就怕真到A线程执行的时候, main线程已经改变这个值了, 要想保证A线程拿到的, 就是你main线程, 开启A线程时传递的值, 怎么办? <code>值传递</code>啊.</p><pre><code class="C++">[=, copy=*this]{}   //C++11[=, *this]{}        //C++17</code></pre><blockquote><p>还有一些其他的特性, 感觉<code>小修补</code>, 还不错.</p></blockquote><h2 id="算法部分"><a href="#算法部分" class="headerlink" title="算法部分"></a>算法部分</h2><p>std::search算法, 有点类似<code>std::find_first_of</code>, 但是它比find_first_of 更加适用于查找子串, 因为这个算法是以子串整体为单位.</p><p>再有就是<code>并行算法</code>.</p><blockquote><p>说并行算法, 我们说的最多的就是, 你开俩线程, 累加一个数组的前半部分和后半部分</p></blockquote><p>现在有了并行算法, 比如你拿<code>std::reduce</code>这个并行算法, 代替原来的 <code>std::accumulate</code> 求和, 性能直接翻翻, 还多.</p><blockquote><p>但是并行算法, 因为是标准指出的, 就看编译器怎么实现, 怎么去支持了…</p></blockquote><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><p>其他部分, 再说吧, 小修小补, 还行吧, <code>以后在说?</code></p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      以后全部的C++文章就在这里落脚了, C++17也在这里更新.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>HTTPS相关</title>
    <link href="www.merlinblog.site/2017/09/08/network-base-https.html"/>
    <id>www.merlinblog.site/2017/09/08/network-base-https.html</id>
    <published>2017-09-08T04:08:57.000Z</published>
    <updated>2017-10-15T02:40:23.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>加密传出相关的内容, 专门总结一下 https协议.</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/network-https.png" alt="post-cover"></p><p>TODO 待上传.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>《图解HTTP》 人民邮电出版社</li><li><a href="http://www.jianshu.com/p/072a657337ae" target="_blank" rel="external">http://www.jianshu.com/p/072a657337ae</a></li><li><a href="https://github.com/jasonGeng88/blog/blob/master/201705/https.md" target="_blank" rel="external">https://github.com/jasonGeng88/blog/blob/master/201705/https.md</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      在 《图解HTTP》 这本书后半部分, 讲述了 https.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>HTTP相关</title>
    <link href="www.merlinblog.site/2017/09/07/network-base-http.html"/>
    <id>www.merlinblog.site/2017/09/07/network-base-http.html</id>
    <published>2017-09-07T02:06:35.000Z</published>
    <updated>2017-10-15T02:37:26.648Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>其实我日常工作中, 接触 HTTP 的内容不是很多, 但是懂 HTTP 协议也是必须的.</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/network-http.jpg" alt="post-cover"></p><p>当然 HTTP 的内容虽然不难, 但是确实很多; 然而拿一本书去说, 就有点儿过分了吧, 比如《图解HTTP》.<br><em>如果不是京东需要凑单, 我肯定不买这本书</em></p><p>选项&amp;配置很多, 所以下面是大纲级别的介绍, 以及其核心内容的阐述.</p><blockquote><p>如果后续相关工作, 与其有关(可能性很小), 再回来详细&amp;仔细梳理总结.</p></blockquote><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="模型定位"><a href="#模型定位" class="headerlink" title="模型定位"></a>模型定位</h2><p>或者说与其他模型的关系</p><p>##版本信息</p><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><p>post, get请求<br>cookie和session<br>传输问题<br>http报文<br>http首部选项<br>状态码</p><p>TODO 待整理上传.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li>《图解HTTP》 人民邮电出版社</li><li><a href="http://www.jianshu.com/p/6e7521041e92" target="_blank" rel="external">http://www.jianshu.com/p/6e7521041e92</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      本文主要讲解和总结一下HTTP相关的内容
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>经验教训汇总</title>
    <link href="www.merlinblog.site/2017/09/05/lessons-history.html"/>
    <id>www.merlinblog.site/2017/09/05/lessons-history.html</id>
    <published>2017-09-05T02:10:08.000Z</published>
    <updated>2017-09-24T07:55:57.607Z</updated>
    
    <content type="html"><![CDATA[<p>本文不记载我经历过的事情, 但是记载我遇到过的 <code>教训</code> &amp;成长, 以及 <code>遗憾</code> . 此篇是<code>最终篇</code>, 以后个人教训全部更新在这里.</p><blockquote><p>本文长期更新(最近一次2017年9月)</p></blockquote><a id="more"></a><p>修身, 修心, 积累财富, 一个不能少. 你说呢?</p><p>更新时间表:</p><ul><li>2017-07-20 17:50:08 大巨变之后</li><li>2017-09-05 10:10:09 重返上海</li></ul><p>本文最新更新主题: </p><blockquote><p>言出必行, 信守承诺, 并且不再轻易&amp;随意承诺.</p></blockquote><hr><h2 id="初心"><a href="#初心" class="headerlink" title="初心:"></a>初心:</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/history.jpg" alt=""></p><p>实习结束时, 我的<code>初心</code>.</p><hr><h2 id="2015-2017"><a href="#2015-2017" class="headerlink" title="2015-2017"></a>2015-2017</h2><p>两年内我遇到的问题, 可能是所有年轻人遇到的问题, 对于外物表象太多在乎, 消费习惯也不好. </p><p>痛定思痛, 总结如下:</p><ul><li>生活应该 “极简” . 人的欲望, 愿望小了, 那么对于外界的依赖也就少了, 得到快乐也就相对容易了. 简谱的生活, 像很多长辈一样, 并不是一件很羞耻的事情. 很多懂事儿比较玩的同龄人可能到40岁才明白, 简单的真谛.</li><li>负债有风险. 不管是用于投资, 经营, 甚至是消费, 负债就相当于把你的未来提前透支了; 不说是一种危险的做法, 但至少是不保险的做法. 有时候需要根据具体的情况具体分析, 但是有一条, 应该死守的规则: 绝对不能去负债消费</li><li>虚荣心, 面子对于个人的生活, 家庭的和睦没有半点儿作用; 并且虚荣心还会牵制一个人, 令他的思想, 行动不自由, 很多时候会做出愚蠢的事情; 也不要在乎别人的评论, 做好自己, 过好你的生活</li></ul><p>简言之:</p><pre><code>* 生活应该简谱, 从简.* 虚荣心有害, 不要在乎别人怎么说, 做好你自己(这本身就很难)</code></pre><p>而今进入2017年下半场, 南开和交大的同学, 也陆续要毕业, 心里也不再焦躁了; </p><p>我们的人生本来就不是一个模子刻出来的, 大家有自己要走的路, 做好你自己, 足矣.</p><hr><h2 id="2017-2018"><a href="#2017-2018" class="headerlink" title="2017-2018"></a>2017-2018</h2><p><code>易经</code> 中有6个境界, 感觉我当前正处于 <code>跃龙</code> 的年纪, 一直很骄傲, 自傲有才华, 希望进入2017下半年~2018年, 可以学会: 谦虚, 谦让.</p><h3 id="2017年9月"><a href="#2017年9月" class="headerlink" title="2017年9月"></a>2017年9月</h3><pre><code>言出必行, 真的很难! 所以不要轻易许诺, 任何人.</code></pre><p>追求完美的时候, 是最看一个人品性的时候. 当你遇到别人以前从未遇到的困难, 网上找不到任何相关的资料的, 或者走了很长一段时间看不到结果, 甚至自己都开始怀疑自己的时候, 坚持 &amp; 不妥协, 不退让, 真的很难. 但是不管这么说, 如果自己说过的话, 许诺的承诺, 就一定要实现. 然后记住, <code>不要轻易许下承诺</code>, 因为未来的不可控性太强了.</p><hr><p>修身, 修心, 积累财富, 一样不能少. 控制”意欲”的同时, 提高”认识力”.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      我过去所得到的教训
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Mustang</title>
    <link href="www.merlinblog.site/2017/09/04/mustang.html"/>
    <id>www.merlinblog.site/2017/09/04/mustang.html</id>
    <published>2017-09-04T09:55:16.000Z</published>
    <updated>2017-09-24T07:34:38.147Z</updated>
    
    <content type="html"><![CDATA[<p>老东家的部门经理给说了很多人生经验, 我觉得最重要的是他说的四个字 <code>顺其自然</code> (let it be),  但是有时候自己有选择的时候, 也要注意好跟随自己的意志.顺气自然的意思是, <code>在自己能力范围以内, 做到最好</code> . 星爷不是说了么, “做人如果没有梦想, 那啥咸鱼.” 平坦的路, 让爱走的人去走; 我走一条独特点儿的.</p><blockquote><p>就像编程环境的配置一样, 一定要让自己的觉得舒服. 关注自身的需求和成长.</p></blockquote><p>本文说的是我 <code>选车</code> , 其实也是思考自身的过程. 适合的不是我想要的, 想要的不适合我. 顺气自然吧.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/%E9%87%8E%E9%A9%AC.png" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>最近一直有打算买车, 毕业的时候, 父母也说过”回家就给你配一台宝马”, 可是我知道, 父母其实还是希望我在武汉安家(以车把我绑定在一个安定舒适的环境里面, 找对象之后很快就结婚, 生孩子啥的). 我的同学里面有人渴望这种生活, 但是他们不知道, 这种生活其实是非常乏味无趣的.</p><p>下面讲述一下, 我对自己现状, 能力的评估, 选车过程.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="人生不止一辆车"><a href="#人生不止一辆车" class="headerlink" title="人生不止一辆车"></a>人生不止一辆车</h2><p>刚毕业的时候, G家里就给配了车, 那个时候很羡慕, 但是G是女孩子, 自己能力不够, 家里给补贴很正常. 但是作为男生的话, 要我找家里开口要, 呵呵. 真心做不到. 那个时候手里有3W(家里给的)左右, 心里心高气傲, 想买最好的, 比如 <code>Benz AMG</code> 系列. (那个时候, G应该是一台普通的大众轿车, 猜的, 具体没有看到她的数据)</p><p>一年后, 手里有14W了, 可是那个心里对未来的预期, 对自己的评估还是不够, 还是决定要买最好.</p><p>两年后, 今天, 差不多27W了, 身边的同事有换<code>雅阁</code>的, 有买本田高端系列<code>讴歌</code>的. 这个时候, 也就是现在, 我在考虑自己将来到底想做什么的时候, 我在想是不是应该买陈润生那种<code>5系</code>. 不过那车当前的售价, 我还是承受不起(全部自己承担的话).</p><p>你看到, 两年的时间, 我的心是变来变去; 一方面说明我的财力在变, 另外一方面, 也说明了我对于自己的认知再改变.</p><p>或者说, 我经历的多了, 也更加成熟了.</p><p>其实人生中重要的事情, 远没有那么纠结, G以前跟我说了这样一句话<code>你一生又不是只买一辆车</code>. 考虑到当前的现状, 考虑到未来的可能, 无论如何, 我也想说.</p><blockquote><p>人生应该浪费在美好的事物上</p></blockquote><p>就像编程环境的配置一样, 你一定要让自己的觉得舒服. </p><blockquote><p>任何选择都是有风险有代价的. 也没有一辆完美的车.</p></blockquote><h2 id="备选"><a href="#备选" class="headerlink" title="备选"></a>备选</h2><p>下面是我的一些备选考量, 以及其优缺点.</p><ul><li>2018凯美瑞混动<br>怎么说呢? 买混动为了省油但是最终算下来, 根本不省钱. 但是这台车有一个特点, 就是技术先进(丰田的混动系统), 环保. 而且在我的财力承受范围内.<br>不好的是, 这台车, 没有任何的挑战, 激情. 感觉不是太喜欢, 也不能说不喜欢. 总感觉买了这台车, 心里感觉怪怪的, 总是有一些落差.</li><li>大众途观L 380TSi 自动四驱豪华版  28.98(两驱版本25.98)<br>这种考虑, 纯碎是因为我那个走不出舒适区的自我在思考. 人人都想过安逸的生活. 我也有这样的一面. 想着, 如果过几年我结婚了, 孩子也很快出生了. 那么需要一台家用车, 大, 实用, 那么一台大众的SUV是最好不过了. 可是啊, 不是别人喜欢SUV, 你就去跟风. 这个基本术语末选项. </li><li>福特Mustang 2.3T 性能版 (注意是 50周年纪念版, 不是2017版)<br>这个是一眼我的就看上了的. 平民跑车. 作为一个敢于追求自我的人, 如果有能力, 就要勇敢尝试和挑战, 并实践. 虽然豪华品牌的跑车, 我是买不起的; 虽然野马V8的旗舰我也买不起. 但是做任何选择, 都不要让自己后悔. 只是这台车, 对于我平时的生活, 工作, 都没有任何帮助. 纯碎是心里想要.</li></ul><p>为什么不考虑BBA?<br>我的预算在30~40W之间, 而BBA的车, 如果不是50W往上走, 选择BBA, 在我心里觉得这人有点儿可怜. 就是… 实在点儿吧. 纯属于自己意见(言语不当之处, 还请多多包涵). 因为有些大佬更专注家庭, 其实以性价比作为考量, 除了选择两田, 也会选择BBA. 萝卜青菜各有所爱, 求同存异.</p><h2 id="详细剖析"><a href="#详细剖析" class="headerlink" title="详细剖析"></a>详细剖析</h2><p>主要剖析 <code>野马</code> 和 <code>凯美瑞</code> .</p><p>还剖析个啥, 日本车,特别是丰田, 那技术牛的很, 马自达都快喊丰田爸爸了; 福特车我一般对其变速箱, 发动机没有太大的信心. 但是野马是一辆情怀车, 更是一辆<code>平民跑车</code>.</p><p>不剖析了, 直接上图(图片来自网络).</p><blockquote><p>小马驹</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/mustang_front.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang_rear.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang_side.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/mustang1.jpg" alt=""></p><p>确实非常喜欢. 平民跑车, 样子果然不错; 就是, 不实用.</p><blockquote><p>Camery</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/camery1.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery1_1.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery1_2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery2.jpg" alt=""><br><img src="http://omotkhw3y.bkt.clouddn.com/camery3.jpg" alt=""></p><p>日常家用, 首选, 而且不容易坏, 三大件儿都好.</p><h2 id="需求match"><a href="#需求match" class="headerlink" title="需求match"></a>需求match</h2><p>其实考虑了很多问题:</p><ul><li>我的钱够不够?</li><li>买车属于投资还是消费?</li><li>是否值得?</li><li>需要一辆代步车么? </li><li>需要省油么? </li><li>为什么买车?(用途)</li><li>日常使用的方便程度?</li><li>如果经常坏怎么办?</li></ul><p>工作起来, 我就像个疯子, 住在公司旁边, 一心全在项目上; 所以买车代步不过是个笑话. 没有家庭, 所以基本也没有什么负担, 所以省钱省油也是净扯. 至于丰田的车开不坏, 福特的车爱断轴, 这些谣言就像早期德系品牌宣传日系车皮薄一样. 买车属于消费, 买了之后就只有贬值的分. 钱基本还是够的.</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><blockquote><p><code>凯美瑞</code>是目前最适合我的车, 但不是我最想要的车;<br><code>野马</code>是我最想要的车, 但却不是目前最适合我的车.</p></blockquote><p>苦笑, 等时机成熟吧. <code>革命尚未成功, 同志还需努力</code>.</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>两年的时间, 同学中有人抽时间去上海交大, 南开读了研, 而我积累的了许多工作经验和社会经验.</p><blockquote><p>这一条路, 一旦走出来, 轨迹势必就不一样了. 尽全力吧, 否则很危险!</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/%E6%88%90%E9%95%BF%E6%9B%B2%E7%BA%BF.jpg" alt=""></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://v.autohome.com.cn/v-100569.html#pvareaid=2042227" target="_blank" rel="external">http://v.autohome.com.cn/v-100569.html#pvareaid=2042227</a></li><li><a href="http://v.autohome.com.cn/v-34389.html#pvareaid=2042227" target="_blank" rel="external">http://v.autohome.com.cn/v-34389.html#pvareaid=2042227</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      小伙你网络库的源码都研究完了么, 就跑这儿若无其事的看车?
    
    </summary>
    
      <category term="musings" scheme="www.merlinblog.site/categories/musings/"/>
    
    
      <category term="思考" scheme="www.merlinblog.site/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title>Merlin&#39;s Emacs</title>
    <link href="www.merlinblog.site/2017/08/31/my-emacs.html"/>
    <id>www.merlinblog.site/2017/08/31/my-emacs.html</id>
    <published>2017-08-31T07:59:14.000Z</published>
    <updated>2017-09-24T07:31:45.671Z</updated>
    
    <content type="html"><![CDATA[<p>最开始(刚开始工作的时候)接触的 IDE 其实是 SourceInsight . 那时候很多 android 框架的源码要看, 要分析, 也一度想要购买正版 SI. 后来机缘巧合单位的老前辈推荐我用 emacs, 从此踏上一条不归路.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/emacs_ecb.png" alt=""></p><p>本文主要记载我的emacs配置文件, 以及配置方法. 先给一个图吧. 中间可能有一些复杂，但是按照从简单到复杂的步骤其实还好; 想要省心省力, 不折腾的同学, 可以去购买一些商业的IDE, 节省了配置的时间.</p><p>(效率上取决于对于IDE的熟悉情况, 个人以为emacs没有上限)</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>每当别人像我展示它的 <code>vim</code> 的时候, 我都是不屑的.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/vim.png" alt=""></p><p>但是渐渐的, 如果有初学者问我要不要深入emacs, 我都会建议它: 最好不要, vistual studio code, qtcreator等都是不错的选择. 因为这东西会让你投入大量的时间折腾, 而且一旦习惯了快捷键操作, 效率是很高, 不过换一种没有配置的环境, 就会感觉很不习惯的.</p><blockquote><p>Emacs 就是一个坑, 一个永远挖不完坑, 会上瘾的.</p></blockquote><p>闲话不多说, 马上来正文. 效率Up Up Up!</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>根据自己的用途，一步步配置环境，下面按照顺序叙述：</p><ul><li>配置基本faces和主题</li><li>配置按键</li><li>配置语言支持</li><li>配置hightlight</li><li>配置ibuffer</li><li>配置dropdownlist</li><li>配置gdb</li><li>配置autosave</li><li>配置session</li><li>配置showhide</li><li>配置tabbar</li><li>配置symbol-overlay (f8,f9)</li><li>配置cscode</li><li>配置autocomplete和yasippet</li><li>配置cedet</li><li>配置ecb</li></ul><blockquote><p>中途还有一些个人使用习惯，不过多解释，只贴代码</p></blockquote><h2 id="明确用途"><a href="#明确用途" class="headerlink" title="明确用途"></a>明确用途</h2><p>我使用emacs, 主要是在远程shell到服务器以及linux环境下做开发的(但不是所有的内容, 什么看网页啊, 看视频啊, 写邮件啊则不是), 归纳起来如下:</p><ul><li>linux下的终端操作, 即shell中命令操作(所有命令)</li><li>c/c++开发, 包括代码的编写(各种补全, 提示等), 测试用例的编写, 调试, 日志输出, doc输出</li><li>研究源码, 这个需求和上面有一定的区别, 研究源码的时候更加关注架构层次, 模型, 甚至详细的调用关系</li><li>linux下的shell脚本编写, 可能包括一部分python脚本</li><li>org-mode 文档的编写</li><li>git 日志查看以及提交(可能会结合gitk)</li></ul><p>(我写 Java 和 Python 应用程序统统使用IDE, JetBrain的开发环境; 一般不写QT代码, 界面无感)</p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>中途的半成品<br><img src="http://omotkhw3y.bkt.clouddn.com/emacs_tmp.jpg" alt=""> </p><p>最终配置差不多就是这个样子:<br><img src="http://omotkhw3y.bkt.clouddn.com/emacs-done.jpg" alt=""></p><pre><code class="lisp">;;;;;;;;;;;;;;;;;;;;;;;;;;;;;From Merlin deepin15.4;;;;;;;;;;;;;;;;;;;;;;;;;;;; File name: ` ~/.emacs &#39;    ;;; ---------------------;;;;;; If you need your own personal ~/.emacs;;; please make a copy of this file;;; an placein your changes and/or extension.;;;;;; Copyright (c) 2017 deepin 15.4.1;;;;;; Author: Merlin Yu, &lt;wizardmerlin945@gmail.com&gt; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; 配置上, 除了基本配置外， 插件包可以采用自动管理；不过我还是采用 手动方式;; (具体的版本&amp;加强包可能自动下载不到);;(load-file &quot;/home/merlin/.emacs.d/lisp/cedet/cedet-1.1/common/cedet.el&quot;);;自动包管理;;(require &#39;merlin-init-autopackage);;;;; 手动方式(即下面自动递归添加~/.emacs.d/lisp内的包);;(add-to-list &#39;load-path &quot;~/.emacs.d/lisp&quot;)(defun add-subdirs-to-load-path (dir)  &quot;Recursive add directories to &#39;load-path&#39;.&quot;  (let ((default-directory (file-name-as-directory dir)))    (add-to-list &#39;load-path dir)   (normal-top-level-add-subdirs-to-load-path)))(add-subdirs-to-load-path &quot;~/.emacs.d/lisp&quot;);;;;;;;;;;;;;;;;;;;;基本配置;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;配置基本的facet和主题(load &quot;merlin-init-ui&quot;);;配置基本并且常用的设置(load &quot;merlin-init-base&quot;);;配置高效的快捷键(这个要在相关的扩展插件之后);;也包括开发语言相关的(load &quot;merlin-init-key&quot;);; 配置语言模式(load &quot;merlin-init-language-mode&quot;);;;;;;;;;;;;;;;;;;;手动配置的各种插件;;;;;;;;;;;;;;;;;;;;;;;;;;;;更好的自动保存插件(load &quot;merlin-init-autosave&quot;);;配置高亮当前行(load &quot;merlin-init-hl-line&quot;);; 配置高亮查找(load &quot;merlin-init-symbol-overlay&quot;);;配置自动补全(load &quot;merlin-init-autocomplete&quot;);; 代码折叠(本来希望依靠cedet的, 结果它不靠谱)(load &quot;merlin-init-showhide&quot;);;配置tab栏(注意只有图形化界面可以使用);;(load &quot;merlin-init-tabbar&quot;);;不要配置tabbar了, 给ecb腾出快捷键(terminal使用场景偏多);;配置shell(load &quot;merlin-init-shell&quot;);;配置gdb(load &quot;merlin-init-gdb&quot;);;配置书签 (我一般不使用书签, 寄存器);;(load &quot;merlin-init-bookmark&quot;);;配置 cscope(load &quot;merlin-init-cscope&quot;);;配置git;;(load &quot;merlin-init-git&quot;);;配置cedet(load &quot;merlin-init-cedet&quot;);;;配置ecb(load &quot;merlin-init-ecb&quot;);;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not yet---begin::::::::::;;;ediff;;;dried;;;doxygen;;compile;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;not yet---end::::::::::;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;配置浏览器(load &quot;merlin-init-browser&quot;);;ibuffer;;不同于系统自带的buffer, 它会单独打开一个buffer, 作为buffer的管理页面(load &quot;merlin-init-ibuffer&quot;);;保存session（下次启动的时候会在最近打开的菜单栏中显示）;;(load &quot;merlin-init-session&quot;);;配置desktop.el(每次启动的时候自动加载上次没有关闭的);;这个东西必须放在最后， 确保其可以正确辨别文件所需要的模式(load &quot;merlin-init-desktop&quot;)</code></pre><h3 id="参考gihub"><a href="#参考gihub" class="headerlink" title="参考gihub"></a>参考gihub</h3><p>代码太多了， 我直接上传了 <a href="">github</a></p><h2 id="补充配置"><a href="#补充配置" class="headerlink" title="补充配置"></a>补充配置</h2><p>一些有用的，但是我个人又没有配置的</p><p>在配置yasnippet的时候，注意到了他的已经知道的模板</p><pre><code>yasnippet:高效设置:C++ mode(c++独有的)acl            cni          delete              ffo              gnn     ita              mrg         operator[]        psc     rpl      std_colon   tfmacm            cnt          delete[]            fil              gnr     iterator         msm         operator+         pst     rtc      sth         thisajf            const_[]     doc                 fin              gtest   ltr              mxe         operator+=        ptc     rte      sti         throwalo            constructor  d_operator          fixture          ignore  lwr              namespace   operator_istream  ptn     rvc      sto         trmano            cout         d_operator[]        fln              ihp     lxc              nno         operator_ostream  public  rvr      str         tryassert         cpb          d_operator[]_const  fnd              ihu     map              ns          ostream           rci     shf      sts         trywbeginend       cpi          d_operator_istream  fne              inline  member_function  nth         pack              rmc     spt      stv         ucpboost_require  cpn          d_operator_ostream  fni              io      mkh              nxp         phh               rmf     srh      swr         uprcerr           cpp          dynamic_casting     fori             ipr     mme              oit         ppt               rmi     srn      template    uqecin            cpy          enum                fre              ipt     mne              operator=   private           rmv     srt      test case   usingclass          cstd         eql                 friend           iss     module           operator==  protected         rpc     sstream  test_main   vectorclass11        d+=          erm                 fun_declaration  isu     mpb              operator!=  prp               rpi     std      test_suiteC mode (主要是添加一些头文件)assert  compile  define  malloc  packed  printf  stdio  stdlib  string  union  unistdcc mode(c,c++共有的)case  else              fopen  for_n                 if     inc    main  member_description  printf  switch   typedefdo    file_description  for    function_description  ifdef  inc.1  math  once                struct  ternary  while</code></pre><h2 id="备忘"><a href="#备忘" class="headerlink" title="备忘"></a>备忘</h2><p>这里记录一下，算是一个我自己的备忘吧.</p><p>Emacs中的按键不计其数，也可以自行设定，因为按键表示相应的lisp函数的快捷方式. 改坏了怎么办?, 把.meacs文件删除就好了.</p><h3 id="启动参数"><a href="#启动参数" class="headerlink" title="启动参数"></a>启动参数</h3><p>emacs的启动参数:</p><pre><code>emacs -q   (安静启动, 不执行.emacs文件)emacs -u joe  (使用joe用户的.emacs启动)emacs --debug-init (调试模式启动)emacs -nw  (terminal 中启动)emacs practice.b --insert myfile  (启动practice.b文件, 并把myfile插入到打开的buffer中)emacs --insert myfile (把myfile插入到临时的buffer中)emacs +15 practice.b (打开文件,并定位到15行; 注意, 如果是输入的数字长于文件的总长度, 那么就会定位到文件结尾)</code></pre><h3 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h3><p><code>C-h t</code> 查看教程, 该教程看完, 用熟悉;  初次之外可以查看 info 手册:</p><p><code>C-h i</code> , 之后使用m+关键词查看, d返回, 回车是选中, 还可以使用u和l:翻页和返回上次浏览的地方)</p><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>使用man手册</p><ul><li><code>M-x woman</code></li><li><code>M-x man</code></li><li>然后输入相关的关键字</li></ul><p>我一般使用 <code>M-x man</code>.<br>对于man手册的支持, emacs的woman还要去解析man文件(<code>/usr/share/man</code>), 感觉比较坑爹; </p><h3 id="基本按键"><a href="#基本按键" class="headerlink" title="基本按键"></a>基本按键</h3><ol><li>C-x i  插入文件(在已打开的文件内插入文件)</li><li>C-x, C-w 另存为</li><li>C-x u 撤销(C-/)</li><li>C-x h 全部选中 (这个后面详细说)</li><li>C-% 查找替换(C-s以及C-r是查找)</li><li>C-x b 选中命名的buffer</li><li>C-x, C-b 列出所有buffer</li><li>M-x, kill-buffer  杀死buffer, 快捷键 C-x k</li><li>C-v 向下翻页 (C-u 8 C-v 向下翻8页)</li><li>M-v 向上翻页</li><li>C-k 删除一行</li><li>C-h m 查看当前模式(terminal可能)</li><li>C-x C-q 设置或者取消只读模式</li><li>格式代码(缩进)<br>C-x h TAB 格式化选中的代码<br>C-c,C-q 对整个函数进行缩进 (光标应该在函数内, 并且需要再源码mode以内)<br>选中区域,  M-x untabify, 将 TAB 字符转换为空格<br>选中区域, M-x indent-region, 对齐文本块</li><li>注释:<br><code>M-;</code> 在该行的末尾添加注释符号(当然选中块之后也就可以注释整个block)<br><code>C-c C-c</code> 对一块代码进行注释;<br>取消注释用命令 <code>uncomment-region</code> (其实用undo也可以)</li><li>折叠代码(我个人设置的是 <code>M+,</code>)</li><li>标记和调整(我个人设置的是<code>C-c m</code>, <code>C-c j</code>)</li><li>括号间跳转：(括号和函数间跳转)<br>括号之间来回跳转的时 候按 C-M-f 和 C-M-b.<br><code>C-M-a</code>   移动到当前函数的开始(如果和系统的快捷键冲突, 那么就多加一个shift键盘)<br><code>C-M-e</code>   移动到当前函数的结尾<br>(注意可以把C-M-a, C-M-e合并到C-M-f和C-M-b中, 我通常采取的策略是使用%进行跳转)</li><li>标记移动和全选:<br>标记整个页面 <code>c-x,c-p</code> (实际上这里多是整个buffer, 而不是整个frame)<br>标记整个缓冲区 c-x h (常用)<br>标记整个段落 m-h (通常没有用-而是用c-m-h)<br><code>c-space</code> 设置标记(如果冲突就多加一个shift 或者使用 c-@) 然后移动光标, 就会从标记的位置选中移动选中区域<br><code>c-x c-x</code> 快速返回移动前的光标位置(互换插入点和文本标记的位置)<br><code>c-m-h</code> 快速选中一个函数 (如何按键有冲突, 可以多加一个shift)</li><li>大小写转换(默认是被禁止)–注意是C-x开始<br>downcase-region (<code>C-x C-l</code>) ;; 选定区域全部改为小写<br>upcase-region (<code>C-x C-u</code>)   ;; 选定区域全部改为大写<br>可以直接在.emacs文件中设置:<pre><code>(put &#39;downcase-region &#39;disabled nil)(put &#39;upcase-region &#39;disabled nil)</code></pre>只是转换一个单词的话, 可以用 <code>M-u</code> 和 <code>M-l</code>, 它会把从光标开始的后面一个单词变成大写或者小写.</li></ol><h3 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h3><p>frame, 缓冲区, 窗口的关系:<br>整个窗口在Emacs中叫做frame, 图形界面下的Emacs可以打开多个frame. 每个frame从上到下分成3部分，分别是缓冲区,状态栏和回显区(一般工具栏隐藏) 缓冲区是编辑的主区域, 但是在这里操作的还不是真正的文件, 而是文件的一个缓存(buffer)。只有执行写入操作时，才会将buffer的内容写入到文件. 缓冲区可以分成多个区域, 缓冲不同的内容. 这些区域在Emacs中成为”窗口”.</p><ol><li>C-x 1 只保留当前窗格</li><li>C-x 0 关闭当前窗格</li><li>C-x 2 切割为等宽半高的两个窗格</li><li>C-x o 切换到另一个窗格   (窗口相关的可以参考, 参考ibuffer.el扩展)</li></ol><p>缓冲区之下是状态栏，显示当前的一些状态信息，比如图中从左至右依次为:</p><pre><code>-UU-:----F1  tmp            Bot L31    (Fundamental) -------</code></pre><p>解释:</p><ul><li><code>UU</code>: 当前的文件编码是UTF-8, 如果是GBK会显示c</li><li><code>**</code>: 文件状态，**表示未保存，–表示可写，%%表示只读(C-x, C-q)</li><li><code>tmp</code>: 是当前编辑的文件的名称</li><li>All: 表示当前缓冲区已经显示文件的所有内容(Bot,表示处于文件的末尾处)</li><li>L31: 当前光标所在的行数</li><li>fundamental: 当前的模式</li></ul><h3 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h3><p>模式:</p><ul><li>主要模式: 当前主要模式只有一种<br>fundamental-mode: 缺省的 Emacs 模式，拥有最少设置和绑定<br>text-mode：编辑文本的基本模式<br>c-mode：用于编辑程序源代码 (以及其他源码模式)<br>lisp-interaction-mode:用于编辑和编译 Lisp 代码<br>ptex-mode：用于编辑 TeX 文档</li><li>次要模式 : 可以组合到主要模式中(次要模式可以有多种), 如果输入的模式包含在当前模式中, 对于主要模式, 会清空所有的次要模式<br>abbrev-mode：用于生成和使用缩写<br>auto-fill-mode：用于自动文字回绕、填充较长的行和段落<br>line-number-mode：显示当前行号(默认在状态栏上显示的就是)<br>overwrite-mode：覆盖模式, 代替默认的插入模式<br>以及其他插件模式</li></ul><h3 id="矩阵操作"><a href="#矩阵操作" class="headerlink" title="矩阵操作"></a>矩阵操作</h3><p>(C-x r 开头; 和寄存器, 书签有重合)</p><p>这里可以补充一个矩形操作:(矩阵操作, 其实就是列模式)<br>其实我并没有觉得矩形剪切和复制时多么棒的东西, 平时用到的标记剪切其实也不错.</p><p>主要就是下面几个命令:(先用C-space或者C-@设一个mark, 移动光标到另一点; 剪切的其实是对角线围成的矩形)</p><pre><code>C-x r k 剪切一个矩形块C-x r y 粘贴一个矩形块  C-x r d 删除一个矩阵块C-x r c 清除一个矩形块(使其变成空白) C-x r o 插入一个矩形块(打开当前的矩形区块，使用空白字符填充整个区域，并将该矩形区块的所有文本移动到右边)C-x r t 在选定区域的所有列前插入样的字符</code></pre><p>(没有复制啊? 我说你傻啊, 先剪切, 然后undo, 然后粘贴)</p><p>Keystrokes             Command name                                             Action<br>C-x r  k                kill-rectangle                                  Delete a rectangle and store it.<br>C-x r  d                delete-rectangle                                Delete a rectangle and do not store it.<br>C-x r  y                yank-rectangle                                  Insert the last rectangle killed<br>C-x r c                 clear-rectangle                                 Using spaces, blank out the area marked as a rectangle and do not store it.<br>C-x r o                 open-rectangle                                  Insert a blank rectangle in the area marked.<br>C-x r r r               copy-rectangle-to-register                  Copy rectangle to register r (where r is any character) .<br>C-x r i r               insert-register                                 Insert rectangle from register r (where r is any character).<br>（none)                 delete-whitespace-rectangle             if a rectangle includes initial whitespace, deletes it, narrowing rectangle.<br>C-x r t string          Enter string-rectangle                      Change contents of marked rectangle to string (if string is narrower<br>                                                                    or wider than rectangle, dimensions change accordingly).<br>(none)                  string-insert-rectangle                     Prompts for string and inserts rectangle.</p><hr><p>不满意的话, 还可以使用 <code>cua-mode</code> . (我个人不用)</p><p>除了emacs本身支持的列模式外，emacs还可以通过cua-mode支持一种可视化的列模式。在cua-mode下，按[C-return]会进入 cua rectangle模式。<br>在这个模式下可以通过鼠标点击确认起点，然后通过光标键来选中一个rect范围，这个rect会用另外的颜色显示出来。 直接输入字符: 在每行前(或后)都插入这个字符.</p><pre><code>[M-a]: 将rect中的文字左对齐  [M-b]: 用空格(tabs或者spaces)替换所有rect中的字符  [M-c]: 去掉所有行左侧的空格  [M-f]: 用单个字符替换所有rect中的字符(提示输入一个字符)  [M-i]: 对每行中第一个找到的数字进行加1操作(自动把0x开头的当作十六进制数字)  [M-k]: 剪切rect  [M-l]: 把rect中的内容全部转换为小写  [M-m]: 拷贝rect  [M-n]: 用一串自增的数字替换rect中的每一行(这个功能可以用来给每行编号)  ### 非常好用的功能  [M-o]: rect的内容右移，选中的rect用空格填充  [M-r]: 用字符串替换符满足正则表达式的字符串  [M-R]: 上下反转  [M-s]: 把rect中的每一行替换为一个字符串(提示输入)  [M-t]: 把rect整个替换为一个字符串(提示输入)  [M-u]: 把rect中的内容全部转换为大写  [M-|]: 对rect执行一个shell命令</code></pre><p>我个人一般最多用到矩阵模式.</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><p>(这里的命令注意和矩阵相区别一下)<br>在多个文件中逛的时候，我们常常需要快速切换到先前访问的某个位置. 因此, 我们需要把文件及其光标位置暂时存放在某个地方. (一般我们都会根据register进行一定封装, 从而进行来回的跳转) 简单说, 这里的寄存器(register), 就是保存一些位置信息(光标位置, 文件信息等)</p><p>最基本的用法(和我定义的C-c,m以及C-c,j比起来作用弱一点儿)<br>将当前光标所在位置保存入一个register中:<br><code>C-x r SPACE + register名</code> (一个字符, 比如a吧), 然后我们就可以到处瞎逛，若要回到保存的register a位置，我们可以输入: <code>C-x r j a</code></p><p>当然你可以定义好多个寄存器名字(位置)</p><pre><code>M-x view-register    查看某一个registerM-x list-registers   查看所有的register</code></pre><p>在进行矩阵操作的时候, 中间有两个命令: 保存到寄存器, 并存寄存器中恢复</p><pre><code>C-x s X                 copy-to-register                          将选定区域保存到寄存器 XC-x r r r               copy-rectangle-to-register                Copy rectangle to register r (where r is any character) .C-x r i r               insert-register                           Insert rectangle from register r (where r is any character).</code></pre><p>通常来说, 我个人不会使用这么原始的方式(偶尔可能会用), 一般使用其他更加高级的标记方式,比如我自己定义的 <code>C-.</code>以及 <code>C-,</code> .<br>比如ctags, etags, gtags, 或者csope等都是比较好的选择.   (我个人一般使用csope)</p><p>比如说 etags:<br>在代码目录中运行 <code>etags -R</code><br>如果要向现有tags表中添加，则运行 <code>etags -a</code><br>访问tag文件的话: <code>M-x visit-tags-table</code> , 常用的快捷键如下:</p><pre><code>M-.       访问tag C-u M-.   访问下一个tag M-*       返回</code></pre><h3 id="书签"><a href="#书签" class="headerlink" title="书签"></a>书签</h3><p>保存缓冲区中位置的另一种工具(注意一下和矩阵操作的快捷键)<br>这些 Emacs 书签 的工作方式与寄存器相同，但是它们的标签可以超过一个字符长，而且它们比寄存器更为持久：如果保存了书签，那么您可以在两个不同的会话之间使用它们。它们将一直保留下来，直到您删除它们。正如它们的名称所表示的，对于保存您在缓冲区中的位置，以便您稍后可以返回到该位置（通常是在以后的 Emacs 会话期间），使用书签是非常方便的。</p><p>不过多介绍了:</p><pre><code>C-x r m Bookmark               bookmark-set              设置一个名为 Bookmark 的书签C-x r l                           bookmarks-bmenu-list        列出所有已保存的书签C-x r b Bookmark                      bookmark-jump              跳转至名为 Bookmark 的书签中所设置的位置(实际上是恢复书签)未定义                          bookmark-delete                  删除一个书签未定义                                         bookmark-save            将所有的书签保存到书签文件中(这样下次启动就可以跨越session了)</code></pre><p>注意, 自从emacs24, 退出的时候 书签是自动保存在相关文件中的:</p><ul><li>In emacs 24.x, bookmark file is at ~/.emacs.d/bookmarks.</li><li>In emacs 23.x, bookmark file is at ~/.emacs.bmk.<br>你也可以自己设置:<pre><code>(setq bookmark-save-flag 1) ; everytime bookmark is changed, automatically save it(setq bookmark-save-flag t) ; save bookmark when emacs quits(setq bookmark-save-flag nil) ; never auto save.</code></pre></li></ul><p>当然你可以设置在每次启动的时候, 自动载入书签:</p><pre><code>(require &#39;bookmark)(bookmark-bmenu-list)(switch-to-buffer &quot;*Bookmark List*&quot;)</code></pre><p>(我个人使用desktop插件, 所以不写该句)</p><p>当然你可以进行设置一些快捷键:</p><pre><code>(global-set-key [(f9)] &#39;list-bookmarks)(global-set-key [(f10)] &#39;bookmark-set)</code></pre><p>在list bookmark之后(相当于打开了bookmark文件), 可以使用下列命令在列表中操作:</p><p>Type d to mark the current item for remove.<br>Type x to remove all D marked ones. (执行)<br>Type r to rename current item’s title.<br>Type s to save the change.</p><p>现在有了 desktop, 书签显得比较鸡肋.</p><h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><p>下面说说我cscope的配置: (cscope和ecb功能上有一定重合)<br>GNU Emacs默认自带etags的支持, 但是不如cscope强大, cscope本身是一个独立软件, (建立索引之后)而且非常强大.</p><p>可以独立安装:</p><pre><code>$ which cscope/usr/local/bin/cscope$ file cscope/contrib/xcscope/cscope-indexer cscope/contrib/xcscope/cscope-indexer: POSIX shell script, ASCII text executable</code></pre><p>在外部使用:</p><p>要使用 cscope, 先建索引, 假设所有的头文件和h都在src下面</p><pre><code>find src/ -type f -iname &quot;*.h&quot; &gt;  cscope.files (这里创建)find src/ -type f -iname &quot;*.cpp&quot; &gt;&gt; cscope.files （这里是&gt;&gt;追加）</code></pre><p>(把所有符号都追加到一个文件可以加快建立索引文件的速度, 但是不利于之后展开文件)</p><pre><code>#!/bin/shfind . -name &quot;*.h&quot; -o -name &quot;*.c&quot; -o -name &quot;*.cc&quot; &gt; cscope.filescscope  -Rbkq -i cscope.files</code></pre><p>其他选项解释:</p><ul><li>-R: 在生成索引文件时, 搜索子目录树中的代码</li><li>-b: 只生成索引文件, 不进入cscope的界面</li><li>-q: 生成cscope.in.out和cscope.po.out文件，加快cscope的索引速度</li><li>-k: 在生成索引文件时, 不搜索/usr/include目录</li><li>-i: 如果保存文件列表的文件名不是cscope.files时，需要加此选项告诉cscope到哪儿去找源文件列表。可以使用“-”，表示由标准输入获得文件列表</li><li>-I dir: 在-I选项指出的目录中查找头文件</li><li>-u: 扫描所有文件, 重新生成交叉索引文件</li><li>-C: 在搜索时忽略大小写</li><li>-P path: 在以相对路径表示的文件前加上的path, 这样你不用切换到你数据库文件所在的目录也可以使用它了</li></ul><p>使用命令 <code>cscope -Rbkq</code>,  产生文件如下:</p><pre><code>cscope.in.outcscope.out  //基本的符号索引cscope.po.out</code></pre><p>注意一下, k在生成索引文件时, 不搜索/usr/include目录;  此时初始化和建立索引已经完成了, 之后就可以利用命令进行查找了.</p><p>在emacs里面使用:<br>当然在emacs程序里, 也可以进行初始化和建立索引(如果所有的源代码以及子目录都是在同一个目录下面的). </p><pre><code>;; C-c s a 初始化目录( 设定初始化的目录，一般是你代码的根目录);; C-c s I 对目录中的文件建立列表索引(生成 Cscope 的数据库)(cscope-set-initial-directory) 这一步最重要</code></pre><p>一般使用 <code>C-c s I</code> 就可以了, 对应 <code>cscope-set-initial-directory</code> . 如果源代码全部处于同一个目录下面，现在就可以使用了. (个人习惯还是喜欢再外部使用cscope -bkqR)</p><p>注意:</p><p>如果源代码有多层目录，或者其他地方还有附加的源代码，则需要 <code>cscope-indexer</code> 脚本. 把那个脚本拷贝到系统 PATH 里面去(如 /usr/bin/).</p><pre><code>$ sudo chmod u+x cscope-indexerexport PATH=$PATH:~/.emacs.d/lisp/cscope/contrib/xcscope</code></pre><p>然后在根目录, 建立索引</p><pre><code>$ cscope-indexer -r</code></pre><p>只要执行 C-c s I(cscope-index-files), 即`` 就可以生成 Cscope 的数据库, 接下来就可以使用了.<br>xcscope默认的快捷键都是绑定到 C-c s 的前缀上面, 更详细的使用说明请参见 xcscope.el 文件头部的注释.</p><p>我个人使用的是默认绑定: (必须要建立完索引)</p><ul><li>C-c s s         Find symbol. 寻找符号(查找C语言符号，即查找函数名、宏、枚举值等出现的地方)</li><li>C-c s d         Find global definition. 寻找全局定义—一般用这个来查找具体的定义</li><li>C-c s g         Find global definition (alternate binding). 寻找符号, 变量的定义</li><li>C-c s G         Find global definition without prompting.</li><li>C-c s c         Find functions calling a function. 看看指定函数被哪些函数所调用</li><li>C-c s C         Find called functions (list functions called<pre><code>          from a function).  看看指定函数调用了哪些函数</code></pre></li><li>C-c s t         Find text string.  查找字符串</li><li>C-c s e         Find egrep pattern. 正则表达式查找</li><li>C-c s f         Find a file. 寻找文件</li><li>C-c s i         Find files #including a file.  看看指定的文件被哪些文件include<br>```</li></ul><p>下面是在搜索到的结果之间切换用的快捷键:(一般不用, 直接跳转到窗口)</p><pre><code>C-c s b         Display *cscope* buffer.C-c s B         Auto display *cscope* buffer toggle.C-c s n         Next symbol.C-c s N         Next file.C-c s p         Previous symbol.C-c s P         Previous file.C-c s u         Pop mark.</code></pre><p>将光标停在函数名上, 按C-c s d, 回车, 即可以查询相关的定义.<br> xcscope.el 原来定义如下: </p><pre><code>;; * Keybindings:;;;; All keybindings use the &quot;C-c s&quot; prefix, but are usable only while;; editing a source file, or in the cscope results buffer:;;;;      C-c s s         Find symbol.;;      C-c s d         Find global definition.;;      C-c s g         Find global definition (alternate binding).;;      C-c s G         Find global definition without prompting.;;      C-c s c         Find functions calling a function.;;      C-c s C         Find called functions (list functions called;;                      from a function).;;      C-c s t         Find text string.;;      C-c s e         Find egrep pattern.;;      C-c s f         Find a file.;;      C-c s i         Find files #including a file.;;;; These pertain to navigation through the search results:;;;;      C-c s b         Display *cscope* buffer.;;      C-c s B         Auto display *cscope* buffer toggle.;;      C-c s n         Next symbol.;;      C-c s N         Next file.;;      C-c s p         Previous symbol.;;      C-c s P         Previous file.;;      C-c s u         Pop mark.;;;; These pertain to setting and unsetting the variable,;; `cscope-initial-directory&#39;, (location searched for the cscope database;;  directory):;;;;      C-c s a         Set initial directory.;;      C-c s A         Unset initial directory.;;;; These pertain to cscope database maintenance:;;;;      C-c s L         Create list of files to index.;;      C-c s I         Create list and index.;;      C-c s E         Edit list of files to index.;;      C-c s W         Locate this buffer&#39;s cscope directory;;                      (&quot;W&quot; --&gt; &quot;where&quot;).;;      C-c s S         Locate this buffer&#39;s cscope directory.;;                      (alternate binding: &quot;S&quot; --&gt; &quot;show&quot;).;;      C-c s T         Locate this buffer&#39;s cscope directory.;;                      (alternate binding: &quot;T&quot; --&gt; &quot;tell&quot;).;;      C-c s D         Dired this buffer&#39;s directory.</code></pre><p>如果你喜欢自定议案件的话, 提供自定义按键参考:</p><pre><code>(define-key global-map [(control f3)]  &#39;cscope-set-initial-directory)(define-key global-map [(control f4)]  &#39;cscope-unset-initial-directory)(define-key global-map [(control f5)]  &#39;cscope-find-this-symbol)(define-key global-map [(control f6)]  &#39;cscope-find-global-definition)(define-key global-map [(control f7)]  &#39;cscope-find-global-definition-no-prompting)(define-key global-map [(control f8)]  &#39;cscope-pop-mark)(define-key global-map [(control f9)]  &#39;cscope-next-symbol)(define-key global-map [(control f10)] &#39;cscope-next-file)(define-key global-map [(control f11)] &#39;cscope-prev-symbol)(define-key global-map [(control f12)] &#39;cscope-prev-file)(define-key global-map [(meta f9)]     &#39;cscope-display-buffer)(define-key global-map [(meta f10)]    &#39;cscope-display-buffer-toggle)</code></pre><h3 id="搜索和替换"><a href="#搜索和替换" class="headerlink" title="搜索和替换"></a>搜索和替换</h3><p>由于我使用了插件 symbol-overlay, 所以一般是借助f8标记和操作标记， 和 <code>M-r</code>重命名, <code>M-s</code>切换到isearch.</p><p>下面是可能涉及到的查找:<br><code>C-%</code> 查找替换<br><code>C-s</code> 以及 <code>C-r</code>是递归查找<br><code>M-x grep-find</code>, 已经设置快捷键为f3<br> <code>find . -type f -exec grep --color -nH -e &quot;content&quot; {} +</code></p><p>下面可以详细说一下技巧， 因为查找&amp;替换实在用的太多了:</p><p>Emacs中的搜索包括增量搜索和一般搜索。增加搜索是每次在前一次搜索的结果基础上继续搜索。在增量搜索时，如果上一次搜索之后进行了其他操作，则需要连续按两次快捷键才能召回关键词. 可以选中区块后在区块内进行搜索.</p><p>增量查找:<br>C - s向下查找<br>C - r向上查找<br>按下C - s后输入要搜索的词，emacs会即时显示当前光标后第一个搜索到的结果，按C - s会跳到下一个结果，按C - r会跳到上一个结果.<br>按Enter结束查找或按C - g取消查找回到原来的地方。<br>按下C - s 或 C - r后, 按M - p显示上一个搜索词, M - n显示下一个搜索词。类似C - p是上一行，C - n下一行.<br>按下C - s或 C - r后, 输入要查找的词的头几个字, 然后按C - w 会补全当前位置的单词.</p><p>查找替换:<br>按M - %启动查找替换，输入要被替换的词，回车，然后输入要替换的词，再回车。<br>被替换的词会高亮起来，这时，</p><ul><li>输入y替换并跳到下一个</li><li>^ 返回上一个替换点</li><li>输入n忽略并跳到下一个</li><li>输入q结束，输入！替换剩下的全部</li></ul><p>C - r 进入修改<br>(我一般重构的时候， 使用插件， M-r进行全部改名, M-s回归递归查找)</p><p>取消搜索<br>C-g 取消搜索，光标返回搜索前的位置<br>RET结束搜索，光标停留在当前位置。</p><p>Ocuur模式<br>有时候想列出匹配的全面模式，而不是在文档中浏览，这个可以使用occur这个函数。<br>例子：M - x occur RET 关键词 RET<br>这时emacs会新开一个窗口来列出匹配的行<br>(实际上再 M-s之后, 案件M-s o即可达到同样的效果)</p><h3 id="模式-1"><a href="#模式-1" class="headerlink" title="模式"></a>模式</h3><p>写代码的cc-mode(cc-mode 可以用来写 C/C++/Java/Obj-C)</p><p>使用cc-mode:<br><code>M-x c-set-style</code>, 然后选择cc-mode</p><pre><code>M-x customize 定制界面等M-x customize-themes 定制主题等</code></pre><h3 id="文件编码"><a href="#文件编码" class="headerlink" title="文件编码"></a>文件编码</h3><p>文件编码方面, 一般linux下都采用utf-8即可, 或者设置 <code>(prefer-coding-system &#39;utf-8)</code> .</p><p>但是如你在gbk环境下, 比如你的windows7设置的是gdk, 那么此时应该设置gbk环境编码(否则读入文件时的解释编码和系统编码不一致, 肯定乱码了)</p><pre><code>(setq file-name-coding-system &#39;gbk)(set-terminal-coding-system &#39;gbk)(set-keyboard-coding-system &#39;gbk)(setq locale-coding-system &#39;gbk)(set-selection-coding-system &#39;gbk)(set-clipboard-coding-system &#39;ctext)(set-clipboard-coding-system &#39;gbk)(set-terminal-coding-system &#39;gbk)(set-buffer-file-coding-system &#39;gbk)(modify-coding-system-alist &#39;process &quot;.&quot; &#39;gbk)(setq default-process-coding-system &#39;(gbk . gbk))</code></pre><h3 id="tabbar"><a href="#tabbar" class="headerlink" title="tabbar"></a>tabbar</h3><p>关于 tabbar 的再一次调整:</p><p>要达到的效果是什么呢?<br>是要在一个 buffer 里面移动, 而不会切换到被的分组.<br>键位的设定时我特意改用了tabbar-backward-tab和tabbar-forward-tab 代替tabbar-backward和tabber-forward.<br>效果是使用M-left/right的时候移动不会跨组, 也就是只能在当前分组内移动, 这样好很多.<br>中间一段设置把标签栏左边的那些按钮都取消掉了.</p><p>原来是不分组, 最后发现还是要根据主模式分组比较好.(即下面的代码全部作废)</p><pre><code>(require &#39;tabbar)  (tabbar-mode)  (global-set-key (kbd &quot;&lt;M-up&gt;&quot;)    &#39;tabbar-backward-group)  (global-set-key (kbd &quot;&lt;M-down&gt;&quot;)  &#39;tabbar-forward-group)  (global-set-key (kbd &quot;&lt;M-left&gt;&quot;)  &#39;tabbar-backward-tab)  (global-set-key (kbd &quot;&lt;M-right&gt;&quot;) &#39;tabbar-forward-tab)  (setq   tabbar-scroll-left-help-function nil   ;don&#39;t show help information   tabbar-scroll-right-help-function nil   tabbar-help-on-tab-function nil   tabbar-home-help-function nil   tabbar-buffer-home-button (quote ((&quot;&quot;) &quot;&quot;)) ;don&#39;t show tabbar button   tabbar-scroll-left-button (quote ((&quot;&quot;) &quot;&quot;))   tabbar-scroll-right-button (quote ((&quot;&quot;) &quot;&quot;)))  (defun my-tabbar-buffer-groups ()    &quot;Return the list of group names the current buffer belongs to.  Return a list of one element based on major mode.&quot;    (list     (cond      ((or (get-buffer-process (current-buffer))           ;; Check if the major mode derives from `comint-mode&#39; or           ;; `compilation-mode&#39;.           (tabbar-buffer-mode-derived-p            major-mode &#39;(comint-mode compilation-mode)))       &quot;Process&quot;       )      ((string-equal &quot;*&quot; (substring (buffer-name) 0 1))       &quot;Emacs Buffer&quot;       )      ((eq major-mode &#39;dired-mode)       &quot;Dired&quot;       )      (t       &quot;User Buffer&quot;       ))))  (setq tabbar-buffer-groups-function &#39;my-tabbar-buffer-groups)</code></pre><h3 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h3><p>一般都是激活多窗口调试模式:</p><pre><code>+----------------------------------------------------------------------+|                               GDB Toolbar                            |+-----------------------------------+----------------------------------+| GUD buffer (I/O of GDB)           | Locals buffer                    ||                                   |                                  ||                                   |                                  ||                                   |                                  |+-----------------------------------+----------------------------------+| Source buffer                     | I/O buffer (of debugged program) ||                                   | (comint-mode)                    ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  ||                                   |                                  |+-----------------------------------+----------------------------------+| Stack buffer                      | Breakpoints buffer               || RET      gdb-frames-select        | SPC    gdb-toggle-breakpoint     ||                                   | RET    gdb-goto-breakpoint       ||                                   | D      gdb-delete-breakpoint     |+-----------------------------------+----------------------------------+</code></pre><p>窗口说明:</p><ul><li>GDB Toolbar        - GDB 操作Toolbar</li><li>GUD buffer         - 执行操作的buffer</li><li>Locals buffer      - 本地变量名和值的表示buffer</li><li>Source buffer      - 表示sourcecode的buffer</li><li>IO/ buffer         - 表示程序的输入输出的buffer</li><li>Stack buffer       - 运行停止的时候，调用关系的表示buffer</li><li>Breakpoints buffer - breakpoints断点的表示buffer</li><li>buffer崩溃的时候、通过’M-x gdb-restore-windows’返回原状态</li></ul><p>当然你可以尝试关闭某些窗口.</p><pre><code>(setq gdb-use-separate-io-buffer t) ; 不需要&quot;IO buffer&quot;时，则设为nil</code></pre><p>一般会把 <code>gdb-many-windows</code> 设置为激活状态, 实际上也可以用 <code>gdb-restore-windows</code> 恢复单个布局.</p><p>我个人的习惯是, 把所有的其他窗口只是作为观察窗口, 其实还是依赖主窗口, 设置相关命令, 一方面, 这个可以减少快捷键的记忆; 另外一方面, 不和单独在terminal中使用产生冲突, 其实也不错. (gud是主窗口)</p><p>快捷键命令</p><ul><li>添加断点    gud-break    C-x C-a C-b 或 C-x <spc></spc></li><li>删除断点    gud-remove    C-x C-a C-d</li><li>运行/继续程序    gud-go        无</li><li>单步执行，无视函数        gud-next    C-x C-a C-n</li><li>单步执行，进入函数        gud-step    C-x C-a C-s</li><li>跳出当前函数            gud-finish    C-x C-a C-f</li><li>运行到光标所在语句        gud-until    C-x C-a C-u</li><li>继续运行程序            gud-cont    C-x C-a C-r</li></ul><h3 id="Autocomplete"><a href="#Autocomplete" class="headerlink" title="Autocomplete"></a>Autocomplete</h3><p>自动补全的拆建有很多, 但是真正能够TAB键玩的溜的只有 Auotocomplete .</p><p>autocomplete在使用上, 不用刻意去按键M-/, 而是在你写代码的时候, 就可以完成提示, 并且选择的话, 一直TAB就行, 之后就可以直接在后面接着写其他的代码. (按回车可以选中所选的)</p><p>具体的快捷键:</p><ul><li>TAB, C-i    ac-expand    Completion by TAB</li><li>RET, C-m    ac-complete    Completion by RET</li><li>down, M-n    ac-next        Select next candidate</li><li>up, M-p       ac-previous    Select previous candidate</li><li>C-?, f1    ac-help            Show buffer help</li></ul><p>To stop completion, simply use C-g.</p><h3 id="magit"><a href="#magit" class="headerlink" title="magit"></a>magit</h3><p>emacs中使用git虽然很好, 但是, 无疑来说, 又会增加许多负担, 当前还是使用terminal或者gitk吧. 具体可以考虑使用 magit 插件.</p><h3 id="speedbar"><a href="#speedbar" class="headerlink" title="speedbar"></a>speedbar</h3><p>就是一个文件列表， 一般再ecb中有集成.</p><p>M-x speedbar 就可以启动它(相关于一个文件目录, 可以在多个文件中切换), 我个人设置的快捷键是 f4 .</p><h3 id="ediff"><a href="#ediff" class="headerlink" title="ediff"></a>ediff</h3><p>一个相当于beyond compare的组件: <code>M-x ediff</code>. </p><h3 id="dired"><a href="#dired" class="headerlink" title="dired"></a>dired</h3><p>emacs下一个强大的文件管理器, 大多数切换到 shell 的场景被它取代: <code>M-x dired</code>.</p><h3 id="游戏"><a href="#游戏" class="headerlink" title="游戏"></a>游戏</h3><p><code>M-x tetris</code>, 俄罗斯方块.</p><h3 id="hideshow"><a href="#hideshow" class="headerlink" title="hideshow"></a>hideshow</h3><p>代码折叠与展开, 这个插件有用, 不过要进行一定的调整.</p><pre><code>;;配置代码折叠;(load-library &quot;hideshow&quot;)  ;(add-hook &#39;java-mode-hook &#39;hs-minor-mode)  ;(add-hook &#39;perl-mode-hook &#39;hs-minor-mode)  ;;(add-hook &#39;php-mode-hook &#39;hs-minor-mode)  ;(add-hook &#39;emacs-lisp-mode-hook &#39;hs-minor-mode)  (add-to-list &#39;hs-special-modes-alist             &#39;(c-mode &quot;[\n\t ]*{&quot; &quot;}&quot; &quot;/[*/]&quot; nil hs-c-like-adjust-block-beginning))(add-to-list &#39;hs-special-modes-alist             &#39;(c++-mode &quot;[\n\t ]*{&quot; &quot;}&quot; &quot;/[*/]&quot; nil hs-c-like-adjust-block-beginning))(define-key global-map (kbd &quot;M-,&quot;) &#39;hs-toggle-hiding)</code></pre><p>我一般设置的是 <code>M-,</code> 用于折叠和展开.</p><h3 id="窗口恢复"><a href="#窗口恢复" class="headerlink" title="窗口恢复"></a>窗口恢复</h3><p>原生没有设置案件对窗口误操作的undo, 所以我设置了一下按键:</p><pre><code>C-x 4 u 窗口undoC-x 4 r 窗口redo</code></pre><h3 id="doxygen"><a href="#doxygen" class="headerlink" title="doxygen"></a>doxygen</h3><p>这个设置起来不太麻烦, 但是我还是喜欢在shell中使用, 毕竟它可以生产图, shell操作更加方便.</p><h3 id="cedet"><a href="#cedet" class="headerlink" title="cedet"></a>cedet</h3><p>给Emacs安装CEDET是最烦恼的过程之一, 由于这个插件太大了, 所以出错的几率也比较打.</p><p>CEDET包含以下几个部分: </p><ul><li>Semantic - Parser Infrastructure for Emacs</li><li>EDE -      File manager/ Makefile generator</li><li>SRecode -  Template manager/ code generator</li><li>COGRE -    Connected Graph Editor</li></ul><p>emacs自带的cedet为1.0版本, 不能与ecb配合使用, 所以要下载并安装它的最新版本(LAST) <code>cedet1.1</code> . 安装的时候, 请仔细阅读源码目录的 <code>INSTALL</code> 文件, 我直接下载的解压缩后的文件.</p><pre><code>$ git clone https://github.com/emacs-pkg-mirrors/cedet.git</code></pre><p>根据它<a href="http://cedet.sourceforge.net/setup.shtml" target="_blank" rel="external">官网</a>的步骤, 一点儿不靠谱. 请仔细阅读源码目录的 <code>INSTALL</code> 文件!!!</p><ul><li>Step 1 : Download CEDET from the Sourceforge downloads page. </li><li>Step 2 : unpack CEDET</li><li>Step 3 : make EMACS=emacs</li><li>Step 4 : Configure CEDET in your .emacs file by adding code like this.</li></ul><p>主要代码</p><pre><code>-----------;; Load CEDET.;; See cedet/common/cedet.info for configuration details.;; IMPORTANT: For Emacs &gt;= 23.2, you must place this *before* any;; CEDET component (including EIEIO) gets activated by another ;; package (Gnus, auth-source, ...).(load-file &quot;~/cedet-VERSION/common/cedet.el&quot;);; Enable EDE (Project Management) features(global-ede-mode 1);; Enable EDE for a pre-existing C++ project;; (ede-cpp-root-project &quot;NAME&quot; :file &quot;~/myproject/Makefile&quot;);; Enabling Semantic (code-parsing, smart completion) features;; Select one of the following:;; * This enables the database and idle reparse engines(semantic-load-enable-minimum-features);; * This enables some tools useful for coding, such as summary mode,;;   imenu support, and the semantic navigator(semantic-load-enable-code-helpers);; * This enables even more coding tools such as intellisense mode,;;   decoration mode, and stickyfunc mode (plus regular code helpers);; (semantic-load-enable-gaudy-code-helpers);; * This enables the use of Exuberant ctags if you have it installed.;;   If you use C++ templates or boost, you should NOT enable it.;; (semantic-load-enable-all-exuberent-ctags-support);;   Or, use one of these two types of support.;;   Add support for new languages only via ctags.;; (semantic-load-enable-primary-exuberent-ctags-support);;   Add support for using ctags as a backup parser.;; (semantic-load-enable-secondary-exuberent-ctags-support);; Enable SRecode (Template management) minor-mode.;; (global-srecode-minor-mode 1)</code></pre><p>编译时遇到的问题:</p><p>`makeinfo is missing on your systeme, 即makeinfo未找到命令, 此时有两种方案:</p><ul><li>make EMACS=emacs MAKEINFO=echo  即不编译doc</li><li>make MAKEINFO=/usr/bin/makeinfo</li></ul><p>安装 <code>makeinfo</code>, 它包含再<code>texinfo</code>包中</p><pre><code>$ search apt-fileapt-file - search for files within Debian packages (command-line interface)cabal-debian - Create a debianization for a cabal package#利用apt-file查看某个文件属于哪个包, 再安装包$ add apt-file$ sudo apt-updateapt$ apt-file search bin/makeinfotexinfo: /usr/bin/makeinfo$ search exinfotexinfo - Documentation system for on-line information and printed output$ add texinfo$ add install-info</code></pre><p>在 <a href="http://sourceforge.net/projects/cedet/" target="_blank" rel="external">http://sourceforge.net/projects/cedet/</a>  下载 cedet1.1 .</p><pre><code>In end of data:semantic-tag-file.el:207:1:Warning: the function ‘ede-toplevel’ is not known    to be defined.Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)Eager macro-expansion failure: (invalid-function class-p)In toplevel form:semantic-idle.el:42:1:Error: Invalid function: class-pIn semantic-tag-customize:semantic-custom.el:210:22:Warning: ‘toggle-read-only’ is an obsolete    function (as of 24.3); use ‘read-only-mode’ instead.Makefile:61: recipe for target &#39;semantic&#39; failed</code></pre><p>总之编译的时候, 就是会遇到各种各样的问题. 一定要简单安装cedet, 它真的太复杂了(我安装它也只是为了安装ecb).</p><h3 id="ecb"><a href="#ecb" class="headerlink" title="ecb"></a>ecb</h3><p>这个代码浏览器, 比较实用. 配置好了普通编写代码, 跑测试用例的界面大概是这样的:</p><pre><code>   ------------------------------------------------------------------   |              |                                                 |   |  Directories |                                                 |   |              |                                                 |   |--------------|                                                 |   |              |                                                 |   |  Sources     |                                                 |   |              |                                                 |   |--------------|                   Edit-area                     |   |              |   (can be splitted in several edit-windows)     |   |  Methods     |                                                 |   |              |                                                 |   |--------------|                                                 |   |              |                                                 |   |  History     |                                                 |   |              |                                                 |   ------------------------------------------------------------------   |                                                                |   |            Persistent Compilation-window (optional)            |   |                                                                |   ------------------------------------------------------------------</code></pre><p>我一般设置如下快捷键：</p><ul><li>f5 启用ecb</li><li>f6 禁用ecb</li><li>control + f5 显示ecb窗口</li><li>control + f6 隐藏ecb窗口</li><li>C-c 0-4 分别是还原，以及最大化某个窗口</li><li>M-方向键, 切换到某个窗口</li><li>选定某个窗口的某个展开标记(即加号减号) 方向键左代表折叠, 方向键右代表展开.</li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>学些emacs, 手册中遇到的(可能)生词:</p><ul><li>overlap 交叠 </li><li>likewise 相似的</li><li>opposite 相反的 </li><li>interspersed 穿插 </li><li>parallel 并行 </li><li>repeated 重复</li><li>paraphrase 释义 </li><li>terminal终端 </li><li>get rid of 摆脱</li><li>contiguous 邻近的 </li><li>incremental 增量  </li><li>for reference 仅供参考 </li><li>sufficient 足够</li><li>command               命令</li><li>scrolling             滚动</li><li>numeric argument      数字参数</li><li>yank                  召回,剪切</li><li>echo area             回显区</li><li>mode line             状态栏</li><li>incremental search    渐进式搜索</li></ul><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>有些插件真坑爹…编译安装都烦, 莫名其妙的问题, 浪费了好长时间.</p><p>首先 emacs 还是很强大的, 然而不得不说, 由于平台的严谨, 以及开后和后续支持的缺乏, 对于emacs的兼容性造成了很大的调整. 如果和visual studio code相比, 其兼容性明显不好. 而且这种情况如果没有更多的人参与和带动, 不说emacs会死, 至少可以说, 能玩的起来的都是神了.</p><p>唯一的希望是, emacs的兼容性可以好起来(各种插件的稳定性慢慢变好一些).</p><hr><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/guide-zh.org" target="_blank" rel="external">一年成为 Emacs 高手</a></li><li><a href="http://www.gnu.org/software/emacs/tour/" target="_blank" rel="external">A Guided Tour of Emacs</a></li><li><a href="https://zhuanlan.zhihu.com/p/26068894" target="_blank" rel="external">emacs按键绑定方式介绍</a></li><li><a href="https://github.com/wolray/symbol-overlay" target="_blank" rel="external">emacs高亮插件推荐</a></li><li><a href="http://www.cnblogs.com/logicbaby/archive/2011/10/19/2217253.html" target="_blank" rel="external">emacs项目路径设置</a></li><li><a href="http://blog.csdn.net/lujun9972/article/details/46002881" target="_blank" rel="external">woman参考</a></li><li><a href="http://www.gnu.org/software/emacs/manual/html_node/emacs/Query-Replace.html" target="_blank" rel="external">查找替换参考</a></li><li><a href="http://emacser.com/ann77/Emacs/EmacsSearch.html" target="_blank" rel="external">查找汇总</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html" target="_blank" rel="external">书签和寄存器</a><br>(文中有一处错误:删除书签的命令是 M-x bookmark-delete而不是C-x bookmark delete)</li><li><a href="http://emacser.com/emacs-gdb.htm" target="_blank" rel="external">gdb参考</a></li><li><a href="https://github.com/auto-complete/auto-complete/blob/master/doc/manual.md" target="_blank" rel="external">autocomplete参考</a></li><li><a href="https://magit.vc/" target="_blank" rel="external">magit参考</a></li><li><a href="http://www.emacswiki.org/cgi-bin/wiki/HideShow" target="_blank" rel="external">hideshow</a></li></ol><p>这一些列文档差不多一共有7篇, 讲的比较啰嗦, 可以自行参考一下:</p><ul><li><a href="https://www.ibm.com/developerworks/cn/education/aix/emacs1/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/emacs1/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/emacs2/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/emacs2/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs3/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs3/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs4/index.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/education/aix/au-emacs5/index.html" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/education/aix/au-emacs5/index.html</a></li></ul><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      刚好换新的环境,顺便把emacs环境重新修正一下
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Deepin Linux</title>
    <link href="www.merlinblog.site/2017/08/31/deepin.html"/>
    <id>www.merlinblog.site/2017/08/31/deepin.html</id>
    <published>2017-08-31T05:45:39.000Z</published>
    <updated>2017-10-09T10:54:29.170Z</updated>
    
    <content type="html"><![CDATA[<p>以前的老系统, 由于系统太老, 有时候安装软件真的非常不适合. 我个人开发一直使用linux(Ubuntu64), 主要用terminal(emacs -nw). 所以要换一个稳定, 新一点儿的系统; 考虑了ubuntu麒麟, 16, 17, 不得不说, 一点儿也不好用, 支持的非常差. 原版的ubuntu也是, 系统有时动不动就内部错误(Ubuntu可能会突然告诉你已经不提供软件更新了, 请升级到17.04; 然后你升级的时候又引来内部错误).<br>正好 <code>武汉深之度</code> 开发的 <code>deepin</code> 近来大家伙好评不断, 所以, 我就来试试. </p><blockquote><p>趁此机会, 把原来的所有 <code>开发环境</code> 切换到 deepin (旧 ubuntu 仅用于发布博客).<br>(如果有机会, 以后也想为它贡献代码)</p></blockquote><a id="more"></a><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>为什么换deepin? 原系统 和 deepin对比如下, 不多解释了.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/deepin1.jpg" alt=""></p><p>(好吧还是说一下,它的这个<code>terminal</code>太棒了;后期发现和emacs有些键可能冲突, 改以下就好了)</p><p>真正一个好的环境, 仅仅从一个技术人员触发, 至少具备3点:</p><ul><li>开发舒服(效率高和个人水平有关)</li><li>看源码舒服(特别是源码庞大, 调用复杂时)</li><li>debug舒服</li></ul><h2 id="安装deepin"><a href="#安装deepin" class="headerlink" title="安装deepin"></a>安装deepin</h2><p>这里我装的是虚拟机.</p><p>电脑的原配操作系统win10专业版, 所以一般不改变, 主要工作环境全部放在虚拟机里面, 一来编程对机器要求不是太高, 而来虚拟机文件也方便在电脑间移植.</p><p>虚拟机里安装deepin很简单: 原来怎么安装ubuntu_amd64, 这里就怎么装deepin, 并且操作习惯也不用改, 和debain系列一致.</p><p>安装完, 先升级一下系统 <code>sudo apt-get dist-upgrade</code> 或者可能也需要 <code>sudo apt-get update</code> 和 <code>sudo apt-get upgrade</code>.</p><p>下面开始安装主要工作软件以及环境配置.</p><hr><h2 id="emacs"><a href="#emacs" class="headerlink" title="emacs"></a>emacs</h2><p>最先安装的就是emacs, 不然后面很捉急.</p><pre><code class="bash">$ sudo apt-get install emacs25#安装完毕之后$ emacs --versionGNU Emacs 25.1.1Copyright (C) 2016 Free Software Foundation, Inc.GNU Emacs comes with ABSOLUTELY NO WARRANTY.You may redistribute copies of GNU Emacsunder the terms of the GNU General Public License.For more information about these matters, see the file named COPYING.</code></pre><p>不过我使用的时候, 一般都是不带界面的emacs, 习惯了; 所以去加一个alias.</p><p>现在<code>.bashrc</code>结尾面添加一个语句(<code>$ nano .bashrc</code>)</p><pre><code class="shell">if [ -f ~/.merlin_bash ]; then    . ~/.merlin_bashfi</code></pre><p>保存之后建立一个<code>.merlin_bash</code>文件:</p><pre><code class="bash"># here we confiure some alias and environment info # 1. alias# 2. environmen path# my aliasalias ll=&#39;ls -l&#39;alias la=&#39;ls -A&#39;alias l=&#39;ls -CF&#39;alias em=&#39;emacs -nw&#39;</code></pre><p>(重新打开以下终端或者source .bashrc)<br>现在可以使用emacs了, 还不错哦.</p><p>关于emacs的配置, 请看我的另外一篇 <a href="http://www.merlinblog.site/2017/08/31/my-emacs.html">文章</a>.</p><p>如果你不配置<code>emacs</code>, 基本呵呵, 不配置除非你是神(要求你水平非常高), 不然很难用的顺手.</p><blockquote><p>以后的所有配置,都在.merlin_bash文件中.</p></blockquote><h2 id="rm绑定"><a href="#rm绑定" class="headerlink" title="rm绑定"></a>rm绑定</h2><p>rm命令已经引起无数次灾害了(深受其害!!), 这东西不处理不行. 如果在UI界面放入Trash, 那么会在<code>~/.local/share/Trash/</code>的两个子目录进行如下操作:</p><ul><li>把具体的文件放入files目录</li><li><p>info目录里以文件相同的filename保存删除的信息</p><pre><code>[Trash Info]Path=/home/merlin/Desktop/test/ideaIC-2017.2.3.tar.gzDeletionDate=2017-08-31T17:15:09</code></pre><p>所以我们的rm命令可以简单的用来把东西移动到Trash目录, 但不写入Info信息(而是添加尾缀时间戳), 以此区分是用rm命令删除的, 代码很简单(要考虑一下连续重复删除同一个文件, 删除的目录和文件同名等情况):<br>```</p><h2 id="rm-related"><a href="#rm-related" class="headerlink" title="rm related"></a>rm related</h2><p>trash()<br>{<br>TRASH_DIR=”/home/merlin/.local/share/Trash/files”<br>RF=”-rf”<br>R=”-r”<br>F=”-f”</p><p>if [ “$1” == ${RF} -o  “$1” == ${R} -o “$1” == ${F} ] ; then<br>   shift<br>fi</p><p>for i in $*; do<br>   FILENAME=<code>basename $i</code><br>   STAMP=<code>date +%s</code><br>   mv -f “$i” ${TRASH_DIR}/${FILENAME}.${STAMP}<br>done<br>}</p></li></ul><p>alias rm=trash</p><pre><code>## bashrc文件德国人有一个造车时, 有一个思想, 这个思想用中国谚语说就是 `工欲善其事必先利其器` .有一些常用命令, 来弄个别名吧, 编辑`.merlin_bash`:```shell# here we confiure some alias and environment info# 1. alias# 2. environmen path# my alias## ls relatedalias ll=&#39;ls -al&#39;alias la=&#39;ls -A&#39;alias l=&#39;ls -CF&#39;## emacs relatedalias em=&#39;emacs -nw&#39;## move relatedalias mv=&#39;mv -i&#39;## cp relatedalias cp=&#39;cp -i&#39;## apt relatedalias add=&#39;sudo apt-get install&#39;alias delete=&#39;sudo apt-get --purge remove&#39;alias autoremove=&#39;sudo apt-get autoremove&#39;alias search=&#39;sudo apt-cache search&#39;alias policy=&#39;sudo apt-cache policy&#39;alias update=&#39;sudo apt-get update&#39;alias upgrade=&#39;sudo apt-get upgrade&#39;alias sysupgrade=&#39;sudo apt-get dist-upgrade&#39;## git related# path## java relatedJAVA_OPT=${_JAVA_OPTIONS}unset _JAVA_OPTIONSalias java=&quot;java ${JAVA_OPT}&quot;## node npm relatedexport NODE_HOME=/home/merlin/Software/node-v6.11.2-linux-x64export NODE_PATH=$NODE_HOME/lib/node_modulesexport PATH=$PATH:$NODE_HOME/bin## go relatedexport GOROOT=/usr/lib/go-1.7export GOBIN=$GOROOT/binexport PATH=$GOBIN:$PATHexport GOPATH=/home/merlin/Desktop/GOPATH###for cross-compling go-codeexport GOOS=linuxexport GOARCH=amd64## ld and static pathexport LIBRARY_PATH=/usr/local/lib:$LIBRARY_PATHexport LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH</code></pre><p>差不多就这样了.</p><h2 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h2><p>想下载东西, wget和curl必不可少(wget常用于下载, curl常用于调试RESTful)</p><pre><code>$ add wget$ add curl</code></pre><h2 id="git"><a href="#git" class="headerlink" title="git"></a>git</h2><p>没有git几乎无法生存, 想要去拉个库, 晕,没有安装git.</p><pre><code class="bash">$ add git正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  git-man liberror-perl建议安装：  git-daemon-run | git-daemon-sysvinit git-doc git-el git-email git-gui gitk gitweb git-arch git-cvs git-mediawiki git-svn下列【新】软件包将被安装：  git git-man liberror-perl升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 5,614 kB 的归档。解压缩后会消耗 31.0 MB 的额外空间。您希望继续执行吗？ [Y/n] Y获取:1 http://packages.deepin.com/deepin panda/main amd64 liberror-perl all 0.17024-1 [26.9 kB]获取:2 http://packages.deepin.com/deepin panda/main amd64 git-man all 1:2.11.0-4 [1,432 kB]获取:3 http://packages.deepin.com/deepin panda/main amd64 git amd64 1:2.11.0-4 [4,156 kB]                                       已下载 5,614 kB，耗时 15秒 (359 kB/s)                                                                                           正在选中未选择的软件包 liberror-perl。(正在读取数据库 ... 系统当前共安装有 152772 个文件和目录。)正准备解包 .../liberror-perl_0.17024-1_all.deb  ...正在解包 liberror-perl (0.17024-1) ...正在选中未选择的软件包 git-man。正准备解包 .../git-man_1%3a2.11.0-4_all.deb  ...正在解包 git-man (1:2.11.0-4) ...正在选中未选择的软件包 git。正准备解包 .../git_1%3a2.11.0-4_amd64.deb  ...正在解包 git (1:2.11.0-4) ...正在设置 git-man (1:2.11.0-4) ...正在设置 liberror-perl (0.17024-1) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...正在设置 git (1:2.11.0-4) ...</code></pre><p>看一下版本, 还挺新的.</p><pre><code>$ git --versiongit version 2.11.0</code></pre><p>配置一下自己的信息:</p><pre><code>$ git config --global user.name &quot;xxx&quot;$ git config --global user.email &quot;yyy&quot;</code></pre><h2 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h2><p>本机其实已经安装了ssh工具, 并且我也可以远程到我的remote服务器:</p><pre><code># 一般默认22端口$ ssh username@address</code></pre><p>但是本机是否允许别的机器远程呢? 还是配置一下, 允许远程登录</p><pre><code>$ ls /etc/sshmoduli    ssh_config</code></pre><p>自己建议一个文件<code>sshd_config</code>, 配置ssh-server，配置文件位于/etc/ssh/sshd_config, 默认端口为22, 为了安全, 一般自定义为其他端口.</p><p>修改配置文件sshd_config, 一般修改远程登录过来的端口, 允许的账户, 超时是否断开.</p><pre><code>1. 配置端口：　   Port 22 配置端口时你可以修改称自己想要的比方说23333,防止被端口扫描.2. 配置是否允许远程root账户登录   (但是你登录后可以su到root账户)   # Authentication:   LoginGraceTime 120   PermitRootLogin yes   StrictModes yes   一般可以禁止远程root账户登录.3. 避免超时自动断开   # keep alive within an hour if no operation happened of client   ClientAliveInterval 60   ClientAliveCountMax 60注意:每次一次配置都要重启sshd守护进程: service ssh restart(我这边儿重启sshd，提示unrecognized service)</code></pre><p>关于sshd的启动:</p><p>首先确保ssh服务已经安装, 检查服务是否已经启动 </p><pre><code>ps -e | grep sshd</code></pre><p>启动、停止、重启服务 </p><pre><code>$ service sshd start     #开启ssh服务 $ service sshd stop      #停止ssh服务 $ service sshd restart   #重启ssh服务</code></pre><p>或者使用带有路径的脚本： </p><pre><code>/etc/init.d/sshd start /etc/init.d/sshd stop /etc/init.d/restart</code></pre><h3 id="产生ssh-key"><a href="#产生ssh-key" class="headerlink" title="产生ssh_key"></a>产生ssh_key</h3><p>步骤很简单, 但是我劝你还是采用HTTPS实时的输入账号密码验证上传和下载; 不要使用ssh key(任何一个登录到你电脑的人可以随便弄你的库, 多可怕).</p><pre><code># 如果~/.ssh下已经有了秘钥文件则不必生成$ ssh-keygen -t rsa -C &quot;your_email@example.com&quot;(直接回车什么都不做)</code></pre><p>在~/.ssh/得到了两个文件：id_rsa和id_rsa.pub, 打开id_rsa.pub文件，里面的信息即为SSH key; 在github上把公钥贴到SSH Key认证的位置, 那么凡是走ssh协议的传入, 你都可以不用密码了.</p><p>当然如果你把自己的公钥<code>id_rsa.pub</code>拷贝到别人的<code>authorized_keys</code>文件内, 然后你ssh登录别人的电脑就不用认证密码了(但是你scp拷贝的这一回, 还是要输入登录到别人电脑的密码). 例如把我的公钥拷贝到xxx_ip地址的主机上, 登录那台电脑的用户名是yyy.</p><pre><code>scp -r ~/.ssh/id_rsa.pub xxx_ip:/home/yyy/.ssh/authorized_keys# 然后输入用户yyy的密码, 拷贝成功的话, 下次你登录xxx_ip这台电脑, 就不要密码了, 直接即可$ ssh xxx_ip</code></pre><h2 id="locate"><a href="#locate" class="headerlink" title="locate"></a>locate</h2><p>真的要是要什么没有什么.</p><pre><code>$ add locate正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。下列【新】软件包将被安装：  locate升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 212 kB 的归档。解压缩后会消耗 322 kB 的额外空间。获取:1 http://packages.deepin.com/deepin panda/main amd64 locate amd64 4.6.0+git+20161106-2 [212 kB]已下载 212 kB，耗时 0秒 (278 kB/s)正在选中未选择的软件包 locate。(正在读取数据库 ... 系统当前共安装有 153643 个文件和目录。)正准备解包 .../locate_4.6.0+git+20161106-2_amd64.deb  ...正在解包 locate (4.6.0+git+20161106-2) ...正在设置 locate (4.6.0+git+20161106-2) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...$ sudo updatedb</code></pre><h2 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h2><pre><code>$ add tree正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。下列【新】软件包将被安装：  tree升级了 0 个软件包，新安装了 1 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 46.1 kB 的归档。解压缩后会消耗 106 kB 的额外空间。获取:1 http://packages.deepin.com/deepin panda/main amd64 tree amd64 1.7.0-5 [46.1 kB]已下载 46.1 kB，耗时 0秒 (150 kB/s)正在选中未选择的软件包 tree。(正在读取数据库 ... 系统当前共安装有 153657 个文件和目录。)正准备解包 .../tree_1.7.0-5_amd64.deb  ...正在解包 tree (1.7.0-5) ...正在设置 tree (1.7.0-5) ...正在处理用于 man-db (2.7.6.1-2) 的触发器 ...</code></pre><h2 id="gcc"><a href="#gcc" class="headerlink" title="gcc"></a>gcc</h2><p>gcc的版本很给力, 但是有时候为了某些方便, 我还需要装一个低版本的.</p><pre><code class="bash">$ gcc --versiongcc (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.$ locate gcc | grep -E &quot;/usr/bin/gcc-[0-9]&quot;/usr/bin/gcc-6</code></pre><p>安装4.8, 4.9, 5.0版本的gcc</p><pre><code>$ add gcc-4.8 gcc-4.9 gcc-5正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  cpp-4.8 cpp-4.9 cpp-5 libasan0 libasan1 libasan2 libcloog-isl4 libgcc-4.8-dev libgcc-4.9-dev libgcc-5-dev libmpx0建议安装：  gcc-4.8-locales gcc-4.9-locales gcc-5-locales gcc-4.8-multilib gcc-4.8-doc libgcc1-dbg libgomp1-dbg libitm1-dbg  libatomic1-dbg libasan0-dbg libtsan0-dbg libquadmath0-dbg gcc-4.9-multilib gcc-4.9-doc libasan1-dbg liblsan0-dbg  libubsan0-dbg libcilkrts5-dbg gcc-5-multilib gcc-5-doc libasan2-dbg libmpx0-dbg下列【新】软件包将被安装：  cpp-4.8 cpp-4.9 cpp-5 gcc-4.8 gcc-4.9 gcc-5 libasan0 libasan1 libasan2 libcloog-isl4 libgcc-4.8-dev libgcc-4.9-dev  libgcc-5-dev libmpx0升级了 0 个软件包，新安装了 14 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 42.6 MB 的归档。解压缩后会消耗 141 MB 的额外空间。您希望继续执行吗？ [Y/n] Y</code></pre><p>安装完成之后, <code>sudo updatedb</code>, 然后查看一下相应的版本</p><pre><code>$ locate gcc | grep -E &quot;/usr/bin/gcc-[0-9]&quot;/usr/bin/gcc-4.8/usr/bin/gcc-4.9/usr/bin/gcc-5/usr/bin/gcc-6$ gcc --versiongcc (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><p>然后利用 <code>update-alternatives</code> 建立文件关联(当然你也可以自己建立软链接):</p><pre><code># 首先要让系统知道我们安装了多个版本的gcc# 命令最后的 20和50是优先级，如果使用auto选择模式，系统将默认使用优先级高的$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.8 20update-alternatives: 使用 /usr/bin/gcc-4.8 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-4.9 30update-alternatives: 使用 /usr/bin/gcc-4.9 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 40update-alternatives: 使用 /usr/bin/gcc-5 来在自动模式中提供 /usr/bin/gcc (gcc)$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 50update-alternatives: 使用 /usr/bin/gcc-6 来在自动模式中提供 /usr/bin/gcc (gcc)</code></pre><p>再查看一下当前系统中安装的gcc有哪些:</p><pre><code>$ sudo update-alternatives --query gccName: gccLink: /usr/bin/gccStatus: autoBest: /usr/bin/gcc-6Value: /usr/bin/gcc-6Alternative: /usr/bin/gcc-4.8Priority: 20Alternative: /usr/bin/gcc-4.9Priority: 30Alternative: /usr/bin/gcc-5Priority: 40Alternative: /usr/bin/gcc-6Priority: 50</code></pre><p>想切换默认的gcc可以使用修改优先值的方式:</p><pre><code>sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 60</code></pre><p>或者交互的方式:<br><img src="http://omotkhw3y.bkt.clouddn.com/update-alternatives.jpg" alt="交互方式"></p><blockquote><p>update-alternatives 还可以用于配置多版本的Java或者Python等.</p></blockquote><p>当然你配置gcc的时候, 也可以顺带配置一下, gcc需要调用的binuitls, 比如 ar, nm, ranlib等(当然也可以配置对应版本的g++), 使用<code>--slave</code>选项.</p><pre><code>$ sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-5 50 \--slave /usr/bin/g++ g++ /usr/bin/g++-5 \--slave /usr/bin/gcc-ar gcc-ar /usr/bin/gcc-ar-5 \--slave /usr/bin/gcc-nm gcc-nm /usr/bin/gcc-nm-5 \--slave /usr/bin/gcc-ranlib gcc-ranlib /usr/bin/gcc-ranlib-5</code></pre><h2 id="g"><a href="#g" class="headerlink" title="g++"></a>g++</h2><p>有些软件的安装, 需要其他的软件或者库; 如果那个工具&amp;库你经常用, 最好不要让它顺便给你装, 比如:</p><pre><code>$ add build-essential正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  g++ g++-6建议安装：  g++-multilib g++-6-multilib gcc-6-doc libstdc++6-6-dbg下列【新】软件包将被安装：  build-essential g++ g++-6升级了 0 个软件包，新安装了 3 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 7,096 kB 的归档。解压缩后会消耗 24.5 MB 的额外空间。您希望继续执行吗？ [Y/n] n中止。</code></pre><p>我自己装<code>g++</code>, 因为我可能要在多个版本的c++编译器间切换.</p><pre><code class="bash">$ search &quot;g\+\+-[0-9]&quot; | less$ add g++-4.9 g++-5 g++-6正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       下列软件包是自动安装的并且现在不需要了：  libfile-copy-recursive-perl update-inetd使用&#39;sudo apt autoremove&#39;来卸载它(它们)。将会同时安装下列软件：  libstdc++-4.9-dev libstdc++-5-dev建议安装：  g++-4.9-multilib gcc-4.9-doc libstdc++6-4.9-dbg g++-5-multilib gcc-5-doc libstdc++6-5-dbg g++-6-multilib gcc-6-doc  libstdc++6-6-dbg libstdc++-4.9-doc libstdc++-5-doc下列【新】软件包将被安装：  g++-4.9 g++-5 g++-6 libstdc++-4.9-dev libstdc++-5-dev升级了 0 个软件包，新安装了 5 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 35.8 MB 的归档。解压缩后会消耗 106 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb</code></pre><p>然后用<code>update-alternatives</code>来配置一下:</p><pre><code>$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-4.9 30$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-5 40$ sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 50</code></pre><p>然后query检查一下:</p><pre><code class="bash">$ sudo update-alternatives --query g++Name: g++Link: /usr/bin/g++Status: autoBest: /usr/bin/g++-6Value: /usr/bin/g++-6Alternative: /usr/bin/g++-4.9Priority: 30Alternative: /usr/bin/g++-5Priority: 40Alternative: /usr/bin/g++-6Priority: 50$ g++ --versiong++ (Debian 6.3.0-11) 6.3.0 20170321Copyright (C) 2016 Free Software Foundation, Inc.This is free software; see the source for copying conditions.  There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</code></pre><h2 id="build-essential"><a href="#build-essential" class="headerlink" title="build-essential"></a>build-essential</h2><p>先查看一下依赖:</p><pre><code class="bash">$ depends build-essentialbuild-essential |依赖: libc6-dev  依赖: &lt;libc-dev&gt;    libc6-dev  依赖: gcc  依赖: g++  依赖: make    make-guile  依赖: dpkg-dev</code></pre><p>先看一下哪些没有</p><pre><code class="bash"># 先更新一下本机数据$ update$ upgrade$ policy libc6-devlibc6-dev:  已安装：2.24-9  候选： 2.24-9  版本列表： *** 2.24-9 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status$ policy makemake:  已安装：4.1-9.1  候选： 4.1-9.1  版本列表： *** 4.1-9.1 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status$ policy make-guilemake-guile:  已安装：(无)  候选： 4.1-9.1  版本列表：     4.1-9.1 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages$ policy dpkg-devdpkg-dev:  已安装：1.18.23  候选： 1.18.23  版本列表： *** 1.18.23 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        500 http://packages.deepin.com/deepin panda/main i386 Packages        100 /var/lib/dpkg/status</code></pre><p>那就安装一下<code>make-guile</code>:</p><pre><code>$ search &quot;make-guile*&quot;make-guile - utility for directing compilation with guile support$ add &quot;make-guile&quot;正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  guile-2.0-libs建议安装：  make-doc下列软件包将被【卸载】：  make下列【新】软件包将被安装：  guile-2.0-libs make-guile升级了 0 个软件包，新安装了 2 个软件包，要卸载 1 个软件包，有 0 个软件包未被升级。需要下载 2,536 kB 的归档。解压缩后会消耗 11.8 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb$ make-guile --versionbash: make-guile: 未找到命令$ locate make-guile/usr/share/doc/make-guile/usr/share/doc/make-guile/ABOUT-NLS.gz/usr/share/doc/make-guile/AUTHORS/usr/share/doc/make-guile/Explanations.gz/usr/share/doc/make-guile/NEWS.Debian.gz/usr/share/doc/make-guile/NEWS.gz/usr/share/doc/make-guile/README.Debian-Source/usr/share/doc/make-guile/README.customs.gz/usr/share/doc/make-guile/README.gz/usr/share/doc/make-guile/changelog.Debian.gz/usr/share/doc/make-guile/copyright/var/cache/apt/archives/make-guile_4.1-9.1_amd64.deb/var/lib/dpkg/info/make-guile.list/var/lib/dpkg/info/make-guile.md5sums</code></pre><p>再装<code>build-essential</code>:</p><pre><code>$ add build-essential正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  g++建议安装：  g++-multilib下列【新】软件包将被安装：  build-essential g++升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 8,890 B 的归档。解压缩后会消耗 35.8 kB 的额外空间。您希望继续执行吗？ [Y/n] Y获取:1 http://packages.deepin.com/deepin panda/main amd64 g++ amd64 4:6.3.0-2 [1,544 B]获取:2 http://packages.deepin.com/deepin panda/main amd64 build-essential amd64 12.3 [7,346 B]已下载 8,890 B，耗时 6秒 (1,466 B/s)                                                                                            正在选中未选择的软件包 g++。(正在读取数据库 ... 系统当前共安装有 156361 个文件和目录。)正准备解包 .../g++_4%3a6.3.0-2_amd64.deb  ...正在解包 g++ (4:6.3.0-2) ...正在选中未选择的软件包 build-essential。正准备解包 .../build-essential_12.3_amd64.deb  ...正在解包 build-essential (12.3) ...正在设置 g++ (4:6.3.0-2) ...update-alternatives: 使用 /usr/bin/g++ 来在自动模式中提供 /usr/bin/c++ (c++)正在设置 build-essential (12.3) ...</code></pre><p>这么看来<code>policy</code>可能后面的<code>dpkg</code>工具可能和<code>update-alternatives</code>有点儿误会, 手动调整一下:</p><pre><code>$ sudo update-alternatives --config g++有 3 个候选项可用于替换 g++ (提供 /usr/bin/g++)。  选择       路径            优先级  状态------------------------------------------------------------* 0            /usr/bin/g++-6     50        自动模式  1            /usr/bin/g++-4.9   30        手动模式  2            /usr/bin/g++-5     40        手动模式  3            /usr/bin/g++-6     50        手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：update-alternatives: 警告: 链接组 g++ 已损坏，故强制重新安装候选项 /usr/bin/g++-6$ ls /usr/bin/g++*/usr/bin/g++  /usr/bin/g++-4.9  /usr/bin/g++-5  /usr/bin/g++-6merlin@merlin-deepin:~$ ll /usr/bin/g++$ sudo update-alternatives --config g++有 3 个候选项可用于替换 g++ (提供 /usr/bin/g++)。  选择       路径            优先级  状态------------------------------------------------------------* 0            /usr/bin/g++-6     50        自动模式  1            /usr/bin/g++-4.9   30        手动模式  2            /usr/bin/g++-5     40        手动模式  3            /usr/bin/g++-6     50        手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：$ policy g++g++:  已安装：4:6.3.0-2  候选： 4:6.3.0-2  版本列表： *** 4:6.3.0-2 500        500 http://packages.deepin.com/deepin panda/main amd64 Packages        100 /var/lib/dpkg/status</code></pre><p>好了.</p><h2 id="binutils"><a href="#binutils" class="headerlink" title="binutils"></a>binutils</h2><p>这里, 可能会装一些, 不太常用的工具,(常用的可能都已经装了) 为下面可能装的库打基础(下面会详细说明, 哪些库要用到这些工具).</p><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><p>老实说, java, groovy, scala这类jvm语言已经写的很少了.(现在多用shell, python和c++).</p><p>但是有些工具比如thrif还是需要这货的, 为java语言做支持.</p><p>还是装两个版本, jdk7和jdk8, 然后用update-alternatives进行调整.</p><pre><code>$ wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz -P ~/Desktop/apps--2017-08-31 17:58:54--  http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz正在解析主机 download.oracle.com (download.oracle.com)... 184.28.218.123, 184.28.218.122正在连接 download.oracle.com (download.oracle.com)|184.28.218.123|:80... 已连接。已发出 HTTP 请求，正在等待回应... 302 Found位置：http://101.44.1.8/files/2130000006C99F22/download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz [跟随至新的 URL]--2017-08-31 17:58:54--  http://101.44.1.8/files/2130000006C99F22/download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz正在连接 101.44.1.8:80... 已连接。已发出 HTTP 请求，正在等待回应... 200 OK长度：185515842 (177M) [application/octet-stream]正在保存至: “/home/merlin/Desktop/apps/jdk-8u144-linux-x64.tar.gz”jdk-8u144-linux-x64.tar.gz       100%[=======================================================&gt;] 176.92M  3.60MB/s  用时 44s     2017-08-31 17:59:44 (3.98 MB/s) - 已保存 “/home/merlin/Desktop/apps/jdk-8u144-linux-x64.tar.gz” [185515842/185515842])$ sudo mkdir /usr/local/lib/jvm$ sudo tar -xzvf ~/Desktop/apps/jdk-8u144-linux-x64.tar.gz -C /usr/local/lib/jvm$ $ ls /usr/local/lib/jvmjdk1.8.0_144# 设置环境变量, 在.merlin_bash结尾加上</code></pre><h2 id="jdk-path"><a href="#jdk-path" class="headerlink" title="jdk path"></a>jdk path</h2><p>export JAVA_HOME=/usr/local/lib/jvm/jdk1.8.0_144<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p><pre><code>然后看一下是否安装成功:</code></pre><p>$ source .bashrc<br>$ which java<br>/usr/local/lib/jvm/jdk1.8.0_144/bin/java</p><p>$ java -version<br>Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp<br>java version “1.8.0_144”<br>Java(TM) SE Runtime Environment (build 1.8.0_144-b01)<br>Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</p><pre><code>上面的`Picked up _JAVA_OPTIONS:   -Dawt.useSystemAAFontSettings=gasp`好奇怪, 检查一下`_JAVA_OPTIONS`这个环境变量:</code></pre><p>$ sudo grep -nr “JAVA_OPTIONS” /etc<br>/etc/profile.d/java-awt-font-gasp.sh:2:if ! echo ${_JAVA_OPTIONS} |grep -q – ${opt}  ;then<br>/etc/profile.d/java-awt-font-gasp.sh:3:    export _JAVA_OPTIONS=”${_JAVA_OPTIONS}  ${opt}”</p><pre><code>查看了一下:</code></pre><p>$ cat /etc/profile.d/java-awt-font-gasp.sh</p><pre><code>opt=&quot;-Dawt.useSystemAAFontSettings=gasp&quot;if ! echo ${_JAVA_OPTIONS} |grep -q -- ${opt}  ;then     export _JAVA_OPTIONS=&quot;${_JAVA_OPTIONS}  ${opt}&quot;fi</code></pre><p>这个宏本来是指定运行参数(<code>java %JAVA_OPTIONS% -Xmx1024m -XX:MaxPermSize=128m</code>), 这里检查到”JAVA_OPTIONS”里没有设置<code>awt</code>界面组建的宏, 所以在这里指定了运行系统的字体和图形库. 但是一旦这里export, 后面运行<code>java</code>命令就会打印那条语句, 没办法, 在我的配置文件里面做一下处理吧.(JAVA_OPTIONS是运行时会自动指定的), 这里的文件就不要动了.<br>(意思是, 你的运行参数不要export了, 我运行的时候自己手动加载好了)</p><pre><code>## java related (关于是否配置环境变量, 看下面说明)JAVA_OPT=${_JAVA_OPTIONS}unset _JAVA_OPTIONSalias java=&quot;java ${JAVA_OPT}&quot;</code></pre><p>然后注销重新登录, 运行<code>java -version</code> :</p><pre><code>$ alias javaalias java=&#39;java   -Dawt.useSystemAAFontSettings=gasp&#39;$ java -versionjava version &quot;1.8.0_144&quot;Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)</code></pre><blockquote><p>这里注意了,如果后面你要用update-alternatives管理javac,java等工具, 就不要配置环境变量!</p></blockquote><p>装完oralble的jdk, 还要装一个open jdk, 以免有时候编译需要(可能是某些版本的android框架或者应用需要).</p><pre><code>$ search openjdk-8-jdkdefault-jdk - Standard Java or Java compatible Development Kitdefault-jdk-headless - Standard Java or Java compatible Development Kit (headless)openjdk-8-jdk - OpenJDK Development Kit (JDK)openjdk-8-jdk-headless - OpenJDK Development Kit (JDK) (headless)$ add openjdk-8-jdk正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  ca-certificates-java fonts-dejavu-extra java-common libatk-wrapper-java libatk-wrapper-java-jni libice-dev  libpthread-stubs0-dev libsm-dev libx11-dev libx11-doc libxau-dev libxcb1-dev libxdmcp-dev libxt-dev  openjdk-8-jdk-headless openjdk-8-jre openjdk-8-jre-headless x11proto-core-dev x11proto-input-dev x11proto-kb-dev  xorg-sgml-doctools xtrans-dev建议安装：  default-jre libice-doc libsm-doc libxcb-doc libxt-doc openjdk-8-demo openjdk-8-source visualvm icedtea-8-plugin  libnss-mdns fonts-ipafont-gothic fonts-ipafont-mincho fonts-wqy-zenhei fonts-indic下列【新】软件包将被安装：  ca-certificates-java fonts-dejavu-extra java-common libatk-wrapper-java libatk-wrapper-java-jni libice-dev  libpthread-stubs0-dev libsm-dev libx11-dev libx11-doc libxau-dev libxcb1-dev libxdmcp-dev libxt-dev openjdk-8-jdk  openjdk-8-jdk-headless openjdk-8-jre openjdk-8-jre-headless x11proto-core-dev x11proto-input-dev x11proto-kb-dev  xorg-sgml-doctools xtrans-dev升级了 0 个软件包，新安装了 23 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 43.5 MB 的归档。解压缩后会消耗 170 MB 的额外空间。您希望继续执行吗？ [Y/n] Y...update-alternatives: 使用 /usr/lib/jvm/java-8-openjdk-amd64/bin/jconsole 来在自动模式中提供 /usr/bin/jconsole (jconsole)正在处理用于 libc-bin (2.24-9) 的触发器 ...正在处理用于 ca-certificates (20161130) 的触发器 ...Updating certificates in /etc/ssl/certs...0 added, 0 removed; done.Running hooks in /etc/ca-certificates/update.d...done.done.</code></pre><p>查看一下是不是update-alternatives已经托管:</p><pre><code>sudo update-alternatives --config java链接组 java (提供 /usr/bin/java)中只有一个候选项：/usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java无需配置。</code></pre><p>看来还是要手动配置一下, 我自己安装的/usr/local/lib/jvm下的那个, 以及这一个(因为他的路径不对, 主要到是jre)</p><pre><code>$ sudo update-alternatives --remove java /usr/lib/jvm/java-8-openjdk-amd64/jre/bin/java$ sudo update-alternatives --install /usr/bin/java java /usr/local/lib/jvm/jdk1.8.0_144/bin/java 300$ sudo update-alternatives --install /usr/bin/javac javac /usr/local/lib/jvm/jdk1.8.0_144/bin/javac 300$ sudo update-alternatives --install /usr/bin/jar jar /usr/local/lib/jvm/jdk1.8.0_144/bin/jar 300$ sudo update-alternatives --install /usr/bin/javah javah /usr/local/lib/jvm/jdk1.8.0_144/bin/javah 300$ sudo update-alternatives --install /usr/bin/javap javap /usr/local/lib/jvm/jdk1.8.0_144/bin/javap 300$ sudo update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-8-openjdk-amd64/bin/java 200$ sudo update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-8-openjdk-amd64/bin/javac 200$ sudo update-alternatives --install /usr/bin/jar jar /usr/lib/jvm/java-8-openjdk-amd64/bin/jar 200$ sudo update-alternatives --install /usr/bin/javah javah /usr/lib/jvm/java-8-openjdk-amd64/bin/javah 200$ sudo update-alternatives --install /usr/bin/javap javap /usr/lib/jvm/java-8-openjdk-amd64/bin/javap 200$ sudo update-alternatives --display javajava - 手动模式  最佳链接版本为 /usr/local/lib/jvm/jdk1.8.0_144/bin/java 链接目前指向 /usr/local/lib/jvm/jdk1.8.0_144/bin/java  链接 java 指向 /usr/bin/java/usr/lib/jvm/java-8-openjdk-amd64/bin/java - 优先级 200/usr/local/lib/jvm/jdk1.8.0_144/bin/java - 优先级 300</code></pre><p>(这里如果你配置了JAVA_HOME等环境变量, 那么<code>upate-alternatives</code>就失效了, 不能起到切换的作用)</p><p>破Java环境, 终于闹腾好了.</p><h2 id="ant"><a href="#ant" class="headerlink" title="ant"></a>ant</h2><p>ant: Java based build tool like make; 可能大家现在用maven啊, gradle啊比较多. 但是这个软件可能用于编译某些工具的库或者包, 所以还是要装一个.</p><pre><code>$ add ant正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  ant-optional建议安装：  ant-doc ant-gcj ant-optional-gcj antlr javacc junit junit4 jython libbcel-java libbsf-java libcommons-logging-java libcommons-net-java libmail-java libjaxp1.3-java  libjdepend-java libjsch-java liblog4j1.2-java liboro-java libregexp-java libxalan2-java libxml-commons-resolver1.1-java下列【新】软件包将被安装：  ant ant-optional升级了 0 个软件包，新安装了 2 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 2,270 kB 的归档。解压缩后会消耗 3,170 kB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which ant/usr/bin/ant</code></pre><p>安装完毕.</p><h2 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h2><p>有些库编译需要, 没有什么好说的.</p><pre><code>$ add maven正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  junit junit4 libaopalliance-java libapache-pom-java libasm-java libatinject-jsr330-api-java libbsh-java libcdi-api-java  libcglib-java libclassworlds-java libcommons-cli-java libcommons-codec-java libcommons-httpclient-java libcommons-io-java  libcommons-lang-java libcommons-lang3-java libcommons-logging-java libcommons-net-java libcommons-parent-java libdom4j-java  libdoxia-core-java libeasymock-java libeclipse-aether-java libgeronimo-interceptor-3.0-spec-java libguava-java libguice-java  libhamcrest-java libhttpclient-java libhttpcore-java libisorelax-java libjaxen-java libjaxp1.3-java libjdom1-java libjetty9-java  libjsch-java libjsoup-java libjsr305-java libjzlib-java liblog4j1.2-java libmaven-parent-java libmaven2-core-java  libmaven3-core-java libmsv-java libobjenesis-java libplexus-ant-factory-java libplexus-archiver-java libplexus-bsh-factory-java  libplexus-cipher-java libplexus-classworlds-java libplexus-classworlds2-java libplexus-cli-java  libplexus-component-annotations-java libplexus-component-metadata-java libplexus-container-default-java  libplexus-container-default1.5-java libplexus-containers-java libplexus-containers1.5-java libplexus-interactivity-api-java  libplexus-interpolation-java libplexus-io-java libplexus-sec-dispatcher-java libplexus-utils-java libplexus-utils2-java  libqdox2-java librelaxng-datatype-java libservlet3.1-java libsisu-inject-java libsisu-plexus-java libslf4j-java libwagon-java  libwagon2-java libxalan2-java libxbean-java libxerces2-java libxml-commons-external-java libxml-commons-resolver1.1-java  libxom-java libxpp2-java libxpp3-java建议安装：  junit-doc libaopalliance-java-doc libatinject-jsr330-api-java-doc libclassworlds-java-doc libcommons-httpclient-java-doc  libcommons-io-java-doc libcommons-lang-java-doc libcommons-lang3-java-doc libavalon-framework-java libcommons-logging-java-doc  libexcalibur-logkit-java libcommons-net-java-doc libdom4j-java-doc libeasymock-java-doc libjaxp1.3-java-gcj libjdom1-java-doc  jetty9 libjsoup-java-doc libjsr305-java-doc libmail-java liblog4j1.2-java-doc libobjenesis-java-doc libplexus-cipher-java-doc  libplexus-classworlds-java-doc libplexus-classworlds2-java-doc libplexus-cli-java-doc libplexus-container-default-java-doc  libplexus-interactivity-api-java-doc libplexus-interpolation-java-doc libplexus-sec-dispatcher-java-doc libplexus-utils-java-doc  libplexus-utils2-java-doc libqdox2-java-doc testng libwagon-java-doc libxalan2-java-doc libbsf-java libxsltc-java groovy  libequinox-osgi-java libosgi-compendium-java libosgi-core-java libqdox-java libspring-beans-java libspring-context-java  libspring-core-java libspring-web-java libxerces2-java-doc libxerces2-java-gcj libxml-commons-resolver1.1-java-doc  libxom-java-doc下列【新】软件包将被安装：  junit junit4 libaopalliance-java libapache-pom-java libasm-java libatinject-jsr330-api-java libbsh-java libcdi-api-java  libcglib-java libclassworlds-java libcommons-cli-java libcommons-codec-java libcommons-httpclient-java libcommons-io-java  libcommons-lang-java libcommons-lang3-java libcommons-logging-java libcommons-net-java libcommons-parent-java libdom4j-java  libdoxia-core-java libeasymock-java libeclipse-aether-java libgeronimo-interceptor-3.0-spec-java libguava-java libguice-java  libhamcrest-java libhttpclient-java libhttpcore-java libisorelax-java libjaxen-java libjaxp1.3-java libjdom1-java libjetty9-java  libjsch-java libjsoup-java libjsr305-java libjzlib-java liblog4j1.2-java libmaven-parent-java libmaven2-core-java  libmaven3-core-java libmsv-java libobjenesis-java libplexus-ant-factory-java libplexus-archiver-java libplexus-bsh-factory-java  libplexus-cipher-java libplexus-classworlds-java libplexus-classworlds2-java libplexus-cli-java  libplexus-component-annotations-java libplexus-component-metadata-java libplexus-container-default-java  libplexus-container-default1.5-java libplexus-containers-java libplexus-containers1.5-java libplexus-interactivity-api-java  libplexus-interpolation-java libplexus-io-java libplexus-sec-dispatcher-java libplexus-utils-java libplexus-utils2-java  libqdox2-java librelaxng-datatype-java libservlet3.1-java libsisu-inject-java libsisu-plexus-java libslf4j-java libwagon-java  libwagon2-java libxalan2-java libxbean-java libxerces2-java libxml-commons-external-java libxml-commons-resolver1.1-java  libxom-java libxpp2-java libxpp3-java maven升级了 0 个软件包，新安装了 80 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 27.6 MB 的归档。解压缩后会消耗 38.0 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which maven</code></pre><h2 id="IntelliJ"><a href="#IntelliJ" class="headerlink" title="IntelliJ"></a>IntelliJ</h2><p>直接去 <a href="https://www.jetbrains.com/idea/download/#section=linux" target="_blank" rel="external">页面</a> 下载安装包.</p><pre><code>$ wget https://download.jetbrains.8686c.com/idea/ideaIC-2017.2.3.tar.gz -P Desktop/apps$ mkdir Software$ tar -xzvf ~/Desktop/apps/ideaIC-2017.2.3.tar.gz -C Software/$ cd Software/idea-IC-172.3968.16/bin$ ./idea.sh</code></pre><p>之后安装时, 它会有一个步骤, 问你是否建立执行脚本, 点击确定即可, 然后可以看到:</p><pre><code>$ which idea/usr/local/bin/idea$ whereis ideaidea: /usr/local/bin/idea$ ll /usr/local/bin/idea-rwxr-xr-x 1 root root 3111 8月  31 21:58 /usr/local/bin/idea$ file /usr/local/bin/idea/usr/local/bin/idea: Python script, ASCII text executable</code></pre><p>这样就算安装完毕了.</p><h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><p>一般linux是自带2.7版本的python的, 出于某些目的有时候也要安装python3(比如cppman就是需要python3安装), 幸好deepin也自带了.</p><pre><code>$ which python/usr/bin/python$ whereis pythonpython: /usr/bin/python /usr/bin/python2.7 /usr/bin/python3.5 /usr/bin/python3.5m /usr/lib/python2.7 /usr/lib/python3.5 /etc/python /etc/python2.7 /etc/python3.5 /usr/local/lib/python2.7 /usr/local/lib/python3.5 /usr/include/python2.7 /usr/include/python3.5m /usr/share/python /usr/share/man/man1/python.1.gz$ python --versionPython 2.7.13</code></pre><p>那么先把python2.7交给update-altertives管理再说.</p><pre><code>$ sudo update-alternatives --list pythonupdate-alternatives: 错误: 无 python 的候选项$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.5 200$ sudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 100  $ sudo update-alternatives --list python/usr/bin/python2.7/usr/bin/python3.5$ sudo update-alternatives --display pythonpython - 自动模式  最佳链接版本为 /usr/bin/python3.5 链接目前指向 /usr/bin/python3.5  链接 python 指向 /usr/bin/python/usr/bin/python2.7 - 优先级 100/usr/bin/python3.5 - 优先级 200$ python --versionPython 3.5.3</code></pre><p>还没有完, 你会发现/usr/include/python2.7下面没有多少头文件! 所以还要安装相关的, 必要的库.</p><pre><code>$ sudo updatedb$ locate Python.h   #没有结果#下面也没有结果$ dpkg --get-selections |grep python-dev$ ldconfig -p | grep python-dev  libpython3.5m.so.1.0 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython3.5m.so.1.0  libpython3.5m.so (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython3.5m.so  libpython2.7.so.1.0 (libc6,x86-64) =&gt; /usr/lib/x86_64-linux-gnu/libpython2.7.so.1.0  libpyglib-2.0-python2.7.so.0 (libc6,x86-64) =&gt; /usr/lib/libpyglib-2.0-python2.7.so.0  libboost_python3.so.1.63.0 (libc6,x86-64) =&gt; /usr/local/lib/libboost_python3.so.1.63.0  libboost_python3.so (libc6,x86-64) =&gt; /usr/local/lib/libboost_python3.so  libboost_python.so.1.63.0 (libc6,x86-64) =&gt; /usr/local/lib/libboost_python.so.1.63.0  libboost_python.so (libc6,x86-64) =&gt; /usr/local/lib/libboost_python.so(可以查看库文件, 但不见得有头文件)</code></pre><p>所以下面安装一下(Python.h is provided by -dev)</p><pre><code>$ add python-dev libboost-python-dev libboost-mpi-python-dev正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  libboost-mpi-python1.62-dev libboost-mpi-python1.62.0 libboost-mpi1.62-dev libboost-mpi1.62.0 libboost-python1.62-dev  libboost-python1.62.0 libboost-serialization1.62-dev libboost-serialization1.62.0 libboost1.62-dev libfabric1 libhwloc-dev  libhwloc-plugins libhwloc5 libibverbs-dev libnuma-dev libopenmpi-dev libopenmpi2 libpsm-infinipath1 libpython-dev  libpython2.7-dev mpi-default-bin mpi-default-dev ocl-icd-libopencl1 openmpi-bin openmpi-common python2.7-dev建议安装：  libboost-graph1.62-dev libboost1.62-doc gccxml libboost-atomic1.62-dev libboost-chrono1.62-dev libboost-context1.62-dev  libboost-coroutine1.62-dev libboost-date-time1.62-dev libboost-exception1.62-dev libboost-fiber1.62-dev  libboost-filesystem1.62-dev libboost-graph-parallel1.62-dev libboost-iostreams1.62-dev libboost-locale1.62-dev  libboost-log1.62-dev libboost-math1.62-dev libboost-program-options1.62-dev libboost-random1.62-dev libboost-regex1.62-dev  libboost-signals1.62-dev libboost-system1.62-dev libboost-test1.62-dev libboost-thread1.62-dev libboost-timer1.62-dev  libboost-type-erasure1.62-dev libboost-wave1.62-dev libboost1.62-tools-dev libmpfrc++-dev libntl-dev libhwloc-contrib-plugins  openmpi-doc opencl-icd gfortran下列【新】软件包将被安装：  libboost-mpi-python-dev libboost-mpi-python1.62-dev libboost-mpi-python1.62.0 libboost-mpi1.62-dev libboost-mpi1.62.0  libboost-python-dev libboost-python1.62-dev libboost-python1.62.0 libboost-serialization1.62-dev libboost-serialization1.62.0  libboost1.62-dev libfabric1 libhwloc-dev libhwloc-plugins libhwloc5 libibverbs-dev libnuma-dev libopenmpi-dev libopenmpi2  libpsm-infinipath1 libpython-dev libpython2.7-dev mpi-default-bin mpi-default-dev ocl-icd-libopencl1 openmpi-bin openmpi-common  python-dev python2.7-dev升级了 0 个软件包，新安装了 29 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 40.9 MB 的归档。解压缩后会消耗 185 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ sudo updatedb$ locate Python.h/usr/include/python2.7/Python.h/usr/include/python3.5m/Python.h</code></pre><p>差不多了.</p><p>安装pip3工具:</p><pre><code>$ add python3-pip[sudo] merlin 的密码：正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  libexpat1-dev libpython3-dev libpython3.5-dev python-pip-whl python3-cffi-backend python3-crypto  python3-cryptography python3-dev python3-idna python3-keyring python3-keyrings.alt python3-pyasn1  python3-secretstorage python3-setuptools python3-wheel python3.5-dev建议安装：  python3-crypto-dbg python-crypto-doc python-cryptography-doc python3-cryptography-vectors libkf5wallet-bin  gir1.2-gnomekeyring-1.0 python3-pykde4 doc-base python-secretstorage-doc python-setuptools-doc下列【新】软件包将被安装：  libexpat1-dev libpython3-dev libpython3.5-dev python-pip-whl python3-cffi-backend python3-crypto  python3-cryptography python3-dev python3-idna python3-keyring python3-keyrings.alt python3-pip python3-pyasn1  python3-secretstorage python3-setuptools python3-wheel python3.5-dev升级了 0 个软件包，新安装了 17 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 40.8 MB 的归档。解压缩后会消耗 63.2 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ $ which pip3/usr/bin/pip3</code></pre><p>这样就算差不多了, 以后根据自己的需求, 选择安装相应的库即可.</p><h2 id="安装pycharm"><a href="#安装pycharm" class="headerlink" title="安装pycharm"></a>安装pycharm</h2><p>下载 pycharm</p><pre><code>$ wget https://download.jetbrains.8686c.com/python/pycharm-community-2017.2.2.tar.gz -P Desktop/apps</code></pre><p>安装</p><pre><code>$ tar -xzvf Desktop/apps/pycharm-community-2017.2.2.tar.gz -C Software/$ cd Software/pycharm-community-2017.2.2/bin$ ./pycharm.sh</code></pre><p>安装时, 请勾选建立<code>/usr/local/bin/pycharm</code>脚本这一项, 然后可以看到:</p><pre><code>$ which pycharm /usr/local/bin/pycharm$ file /usr/local/bin/pycharm /usr/local/bin/pycharm: Python script, ASCII text executable</code></pre><h2 id="golang"><a href="#golang" class="headerlink" title="golang"></a>golang</h2><p>一般而言, 选择apt工具就够了 <code>sudo apt-get install golang</code>, 但是为了能够实时更新一下, 可以采用源:</p><pre><code>sudo add-apt-repository ppa:gophers/gosudo apt-get updatesudo apt-get install golang-stable</code></pre><p>我直接安装的:</p><pre><code>$ add golang正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  golang-1.7 golang-1.7-doc golang-1.7-go golang-1.7-src golang-doc golang-go golang-src建议安装：  bzr mercurial subversion下列【新】软件包将被安装：  golang golang-1.7 golang-1.7-doc golang-1.7-go golang-1.7-src golang-doc golang-go golang-src升级了 0 个软件包，新安装了 8 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 29.5 MB 的归档。解压缩后会消耗 147 MB 的额外空间。您希望继续执行吗？ [Y/n] Y</code></pre><p>之后需要配置一下环境变量:(网上很多配的是错的)</p><pre><code>export GOROOT=/usr/lib/go-1.7export GOBIN=$GOROOT/binexport PATH=$GOBIN:$PATHexport GOPATH=/home/merlin/Desktop/GOPATHexport GOOS=linuxexport GOARCH=amd64</code></pre><p>查看一下配置:</p><pre><code>$ go versiongo version go1.7.4 linux/amd64$ source ~/.bashrc$ echo $GOPATH/home/merlin/Desktop/GOPATH</code></pre><p>在GOPATH下新建3个目录:(为你的项目)</p><ul><li>src 存放源码</li><li>pkg 存放编译生成的文件</li><li>bin 存放生成的可执行文件</li></ul><h2 id="cppman"><a href="#cppman" class="headerlink" title="cppman"></a>cppman</h2><p>我主业C++, 所以马上来配置一下c++的开发环境.</p><p><code>cppman</code> 可以实时从cplusplus.com以及cppreference.com上面下载文档的一个小工具.<br>repo的地址是: <a href="https://github.com/aitjcize/cppman" target="_blank" rel="external">https://github.com/aitjcize/cppman</a> </p><p>可以直接用apt工具安装</p><pre><code class="shell">$ search &quot;cppman&quot;cppman - C++ 98/11 manual pages for Linux, with source from cplusplus.com$ add cppman正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  python3-bs4 python3-html5lib python3-webencodings建议安装：  python3-genshi下列【新】软件包将被安装：  cppman python3-bs4 python3-html5lib python3-webencodings升级了 0 个软件包，新安装了 4 个软件包，要卸载 0 个软件包，有 0 个软件包未被升级。需要下载 321 kB 的归档。解压缩后会消耗 1,861 kB 的额外空间。您希望继续执行吗？ [Y/n] Y# 安装完成之后, 要先从网站上缓存页面才可以.## 切换源$ cppman -s cppreference.comSource set to `cppreference.com&#39;.## 缓存$ cppman -cBy default, cppman fetches pages on-the-fly if corresponding page is not found in the cache. The &quot;cache-all&quot; option is only useful if you want to view man pages offline. Caching all contents will take several minutes, do you want to continue [y/N]?y</code></pre><p>注意它需要装python3, 才行; 但是python是常用的, 所以版本管理还是交给update-alternatives吧.<br>(安装完python3之后再来安装cppman)</p><p>(再缓存<code>cppman -c</code>的时候, 你最好使用一下代理, 否则很容易缓存失败)</p><h2 id="cmake"><a href="#cmake" class="headerlink" title="cmake"></a>cmake</h2><p>像boost, thrift虽然都不适用cmake编译, 但是现在很多流行的库, 比如gtest等, 都是用cmake, 而且相对于make的好, 不需要我多说.</p><p>下面就安装一下cmake.</p><p><code>sudo apt-get install</code> 安装的版本往往比较老, 所以一般需要自己去下载, 然后编译安装.</p><p>下载:  <a href="https://cmake.org/download/" target="_blank" rel="external">https://cmake.org/download/</a> 或者 (<a href="https://github.com/Kitware/CMake" target="_blank" rel="external">https://github.com/Kitware/CMake</a>)<br>直接去官网拿压缩包源码</p><pre><code>$ wget https://cmake.org/files/v3.9/cmake-3.9.1.tar.gz -P Desktop/apps/$ cd Desktop/apps$ tar -xzvf cmake-3.9.1.tar.gz</code></pre><p>编译安装</p><pre><code>$ ./configureCMake has bootstrapped.  Now run make.$ make -j4$ sudo make install</code></pre><p>可以从安装日志中看到, 主要是这三个工具</p><pre><code>-- Installing: /usr/local/bin/cmake-- Installing: /usr/local/bin/ctest-- Installing: /usr/local/bin/cpack</code></pre><p>最后删除, 安装包.<br>(你不要去下载它的gui客户端呀, 好神经的说)</p><h2 id="qt"><a href="#qt" class="headerlink" title="qt"></a>qt</h2><p>主要包括qtcreator和qt库, 这是它的<a href="https://www.qt.io/download-open-source/" target="_blank" rel="external">官网</a>, 越来越恶心的官网, 我决定直接用apt工具下载qtcreator, 之后qt核心库再去官网下载.</p><pre><code>add qtcreator正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  binfmt-support clang clang-3.8 gdb libbabeltrace-ctf1 libbabeltrace1 libbotan-1.10-1 libc6-dbg  libclang-common-3.8-dev libclang1-3.8 libclang1-3.9 libdw1 libffi-dev libjsoncpp1 libllvm3.8 libobjc-6-dev  libqbscore1.8 libqbsqtprofilesetup1.8 libqt5designercomponents5 libqt5quicktest5 libqt5script5 libtinfo-dev llvm-3.8  llvm-3.8-dev llvm-3.8-runtime qml-module-qtqml-models2 qmlscene qt5-doc qt5-qmltooling-plugins qtbase5-dev-tools  qtbase5-doc qtconnectivity5-doc qtcreator-data qtcreator-doc qtdeclarative5-dev-tools qtdeclarative5-doc  qtgraphicaleffects5-doc qtlocation5-doc qtmultimedia5-doc qtquickcontrols5-doc qtscript5-doc qtsensors5-doc  qtserialport5-doc qtsvg5-doc qttools5-dev-tools qttools5-doc qtwebkit5-doc qtwebkit5-examples-doc qtwebsockets5-doc  qtx11extras5-doc qtxmlpatterns5-dev-tools qtxmlpatterns5-doc建议安装：  gnustep gnustep-devel clang-3.8-doc gdb-doc gdbserver llvm-3.8-doc qtbase5-dev cmake kdelibs5-data subversion下列【新】软件包将被安装：  binfmt-support clang clang-3.8 gdb libbabeltrace-ctf1 libbabeltrace1 libbotan-1.10-1 libc6-dbg  libclang-common-3.8-dev libclang1-3.8 libclang1-3.9 libdw1 libffi-dev libjsoncpp1 libllvm3.8 libobjc-6-dev  libqbscore1.8 libqbsqtprofilesetup1.8 libqt5designercomponents5 libqt5quicktest5 libqt5script5 libtinfo-dev llvm-3.8  llvm-3.8-dev llvm-3.8-runtime qml-module-qtqml-models2 qmlscene qt5-doc qt5-qmltooling-plugins qtbase5-dev-tools  qtbase5-doc qtconnectivity5-doc qtcreator qtcreator-data qtcreator-doc qtdeclarative5-dev-tools qtdeclarative5-doc  qtgraphicaleffects5-doc qtlocation5-doc qtmultimedia5-doc qtquickcontrols5-doc qtscript5-doc qtsensors5-doc  qtserialport5-doc qtsvg5-doc qttools5-dev-tools qttools5-doc qtwebkit5-doc qtwebkit5-examples-doc qtwebsockets5-doc  qtx11extras5-doc qtxmlpatterns5-dev-tools qtxmlpatterns5-doc升级了 0 个软件包，新安装了 53 个软件包，要卸载 0 个软件包，有 5 个软件包未被升级。需要下载 204 MB 的归档。解压缩后会消耗 601 MB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which qtcreator /usr/bin/qtcreator</code></pre><p>之后设置qt库的版本(环境变量), 比如<code>add libqt4-dev</code>, 可以在你的<code>.bashrc</code>里面, 或者使用<code>/usr/bin/qtchooser</code>来设置. 如要需要换最新版本的qt, 可以<code>sudo apt-get remove qtcreator</code>进行卸载, 或者purge.</p><h2 id="boost"><a href="#boost" class="headerlink" title="boost"></a>boost</h2><p>玩cpp的, 不装boost?<br>你可以用apt工具去装, 比如:</p><pre><code># 一般安装libboost-dev就行sudo apt-get install libboost-all-devsudo apt-get install libboost-dev# 或者sudo apt-cache search boost搜自己想要的库sudo apt-get install mpi-default-dev　　#安装mpi库sudo apt-get install libicu-dev　　　　　#支持正则表达式的UNICODE字符集sudo apt-get install python-dev　　　　　#需要python的话sudo apt-get install libbz2-dev     #失败的话 sudo apt-get update试试</code></pre><p>然后日常开发中, 常常用到这个库, 要确定的版本, 最好自己去官网下载安装(linux和vs版都要装).</p><p>关于安装, 你可以参考一下, 我这篇文章<a href="http://www.merlinblog.site/2017/06/21/boost.html">boost</a>, 下面快速说:<br>下载</p><pre><code>## 我直接从我的远端服务器拷贝了 boost_1_63_0.7z$ scp -r merlin@xxxx:/home/merlin/packages/boost_1_63_0.7z ./apps/$ 7z x boost_1_63_0.7z -o.</code></pre><p>编译安装:</p><pre><code>$ ./bootstrap.sh$ ./b2 --show-librariesThe following libraries require building:    - atomic    - chrono    - container    - context    - coroutine    - coroutine2    - date_time    - exception    - fiber    - filesystem    - graph    - graph_parallel    - iostreams    - locale    - log    - math    - metaparse    - mpi    - program_options    - python    - random    - regex    - serialization    - signals    - system    - test    - thread    - timer    - type_erasure    - wave# 也就是说, 下面编译全是为了上面那些库(下面还是全编译吧)# 如果./b2 --with-atomic --buildtype=complete install表示只编译atomic库# 注意一下拷贝权限问题$ sudo ./b2 --buildtype=complete install</code></pre><p>之后查看一下编译日志:</p><pre><code>Component configuration:    - atomic                   : building    - chrono                   : building    - container                : building    - context                  : building    - coroutine                : building    - coroutine2               : building    - date_time                : building    - exception                : building    - fiber                    : building    - filesystem               : building    - graph                    : building    - graph_parallel           : building    - iostreams                : building    - locale                   : building    - log                      : building    - math                     : building    - metaparse                : building    - mpi                      : building    - program_options          : building    - python                   : building    - random                   : building    - regex                    : building    - serialization            : building    - signals                  : building    - system                   : building    - test                     : building    - thread                   : building    - timer                    : building    - type_erasure             : building    - wave                     : building</code></pre><p>之后跟着一大堆common.copy把lib和头文件分别拷贝到了, <code>/usr/local/include</code>和<code>/usr/local/lib</code>下面.</p><p>只要不出现<code>failure</code>基本可以认定编译, 安装成功了.</p><h2 id="log4cpp"><a href="#log4cpp" class="headerlink" title="log4cpp"></a>log4cpp</h2><h2 id="rapidxml"><a href="#rapidxml" class="headerlink" title="rapidxml"></a>rapidxml</h2><p>这个是常用的库, 不过有个坑需要你调整一下. 详细内容不再叙述, 请参考我的文章 <a href="http://www.merlinblog.site/2017/08/22/rapid-xml.html">rapidxml</a></p><pre><code>$ wget https://nchc.dl.sourceforge.net/project/rapidxml/rapidxml/rapidxml%201.13/rapidxml-1.13.zip$ unzip rapidxml-1.13.zipArchive:  rapidxml-1.13.zip   creating: rapidxml-1.13/  inflating: rapidxml-1.13/license.txt    inflating: rapidxml-1.13/manual.html    inflating: rapidxml-1.13/rapidxml.hpp    inflating: rapidxml-1.13/rapidxml_iterators.hpp    inflating: rapidxml-1.13/rapidxml_print.hpp    inflating: rapidxml-1.13/rapidxml_utils.hpp $ sudo mv rapidxml-1.13 /usr/local/include/rapidxml</code></pre><h2 id="rapidjson"><a href="#rapidjson" class="headerlink" title="rapidjson"></a>rapidjson</h2><p>全部是头文件的库, 安装起来也比较简单:</p><pre><code>$ git clone https://github.com/miloyip/rapidjson.git$ cd rapidjson$ cmake .$ sudo make install</code></pre><h2 id="protobuffer"><a href="#protobuffer" class="headerlink" title="protobuffer"></a>protobuffer</h2><p>下载</p><pre><code>$ git clone https://github.com/google/protobuf.git</code></pre><p>编译安装:</p><pre><code>$ ./autogen.sh$ ./configure$ make$ make check$ sudo make install$ sudo ldconfig # refresh shared library cache.</code></pre><p>(整个过程还是比较顺利的)</p><h2 id="thrift"><a href="#thrift" class="headerlink" title="thrift"></a>thrift</h2><p>直接参考的文章 thrift.</p><h2 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h2><p>npm is distributed with Node.js- which means that when you download Node.js, you automatically get npm installed on your computer.<br>可能你不写JavaScript的东西, 不过这个npm被很多其他软件用到, 所以最好你还是装一下(三兄弟一起).</p><pre><code>checking for nodejs... nochecking for node... nochecking for npm... no</code></pre><p>下载并安装(不要使用apt工具, 因为版本都不新)</p><pre><code>$ wget https://nodejs.org/dist/v6.11.2/node-v6.11.2-linux-x64.tar.xz -P  ~/Desktop/apps$ tar -xJvf Desktop/apps/node-v6.11.2-linux-x64.tar.xz -C Software/</code></pre><p>之后配置一下环境变量就可以了:</p><pre><code>## node     npm relatedexport NODE_HOME=/home/merlin/Software/node-v6.11.2-linux-x64export NODE_PATH=$NODE_HOME/lib/node_modulesexport PATH=$PATH:$NODE_HOME/bin</code></pre><p>测试一下安装工作:</p><pre><code>$ npm -v3.10.10$ node -vv6.11.2</code></pre><h2 id="开发文档"><a href="#开发文档" class="headerlink" title="开发文档"></a>开发文档</h2><p>一般使用的就是 glibc-doc 和 manpages-posix-dev.</p><pre><code>$ add glibc-doc$ add glibc-doc-reference$ add manpages-dev$ add manpages-posix$ add manpages-posix-dev</code></pre><h2 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h2><h3 id="gitk"><a href="#gitk" class="headerlink" title="gitk"></a>gitk</h3><p>一般我熟悉的项目, 我直接用<a href="git clone https://github.com/tsgates/git-emacs.git">git-emacs</a>:<br>提交等写入操作, 使用git-emacs.</p><pre><code>;;git-emacs(add-to-list &#39;load-path &quot;/path/to/git-emacs/&quot;)(require &#39;git-emacs)</code></pre><p>如果是别人的项目, 要我接手或者帮忙找错, 那么我直接使用gitk: <code>M-x gitk</code><br>(阅读建议使用 <code>gitk</code>)</p><pre><code>add gitk正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  libtk8.6 tcl tcl8.6 tk tk8.6建议安装：  git-doc tcl-tclreadline下列【新】软件包将被安装：  gitk libtk8.6 tcl tcl8.6 tk tk8.6升级了 0 个软件包，新安装了 6 个软件包，要卸载 0 个软件包，有 2 个软件包未被升级。需要下载 1,757 kB 的归档。解压缩后会消耗 4,101 kB 的额外空间。您希望继续执行吗？ [Y/n] Y$ which gitk/usr/bin/gitk</code></pre><p>运行的时候, 切换到相应的库目录里面, 然后<code>gitk</code>, 例如我查看别人的库:<br><img src="" alt=""></p><h3 id="htop"><a href="#htop" class="headerlink" title="htop"></a>htop</h3><p>资源监控器</p><h3 id="understand"><a href="#understand" class="headerlink" title="understand"></a>understand</h3><p><a href="http://blog.csdn.net/p942005405/article/details/53639970" target="_blank" rel="external">Scientific Toolworks Understand</a><br>源码查看器(和gtags, source in sight类似)</p><h3 id="remarkable"><a href="#remarkable" class="headerlink" title="remarkable"></a>remarkable</h3><p>专门用于写markdown, 导出到pdf的编辑器.</p><pre><code># 安装的时候, 先把python切换到2.7版本$ add remarkable正在读取软件包列表... 完成正在分析软件包的依赖关系树       正在读取状态信息... 完成       将会同时安装下列软件：  gir1.2-javascriptcoregtk-3.0 gir1.2-soup-2.4 gir1.2-webkit-3.0 libjavascriptcoregtk-3.0-0 libqt5xmlpatterns5  libwebkitgtk-3.0-0 libyaml-0-2 python3-markdown python3-pygments python3-yaml wkhtmltopdf下列【新】软件包将被安装：  gir1.2-javascriptcoregtk-3.0 gir1.2-soup-2.4 gir1.2-webkit-3.0 libjavascriptcoregtk-3.0-0 libqt5xmlpatterns5  libwebkitgtk-3.0-0 libyaml-0-2 python3-markdown python3-pygments python3-yaml remarkable wkhtmltopdf升级了 0 个软件包，新安装了 12 个软件包，要卸载 0 个软件包，有 5 个软件包未被升级。需要下载 12.3 MB 的归档。解压缩后会消耗 53.3 MB 的额外空间。您希望继续执行吗？ [Y/n] Y# 安装成功$ which remarkable/usr/bin/remarkable</code></pre><p>配置一下</p><pre><code>## remarkable (u could add &amp; to run)alias md=&#39;nohup remarkable&#39;</code></pre><p>然后运行一下, 功能正常</p><pre><code>$ md read.md &amp;</code></pre><h3 id="vistual-studio-code"><a href="#vistual-studio-code" class="headerlink" title="vistual studio code"></a>vistual studio code</h3><p>我原来是用remarkable打开markdown文件, 后来发现这个vistual studio code越来越强大, 就直接用它了.<br>直接去<a href="https://code.visualstudio.com/" target="_blank" rel="external">官网</a>下载deb安装包, 安装即可.<br><code>`$ sudo dpkg -i code_1.15.1-1502903936_amd64.deb$ which code/usr/bin/code</code></p><hr><h2 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h2><p>当初把 Mac pro 15 卖掉的原因就是, 我已经非常熟悉Ubuntu了, 没必要在改变习惯, 使用homebrew等其他软件, 并且机器的配置文件位置我也习惯了. 所以即便是换系统, 也会和Ubuntu搭边儿, 正好deepin, 感觉不错哦.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      把自己的代码环境, 迁移新的 Deepin 发行版, 记录了一些常用库和工具的安装参考.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>里程碑1(Linux后台开发经验分享)</title>
    <link href="www.merlinblog.site/2017/08/30/milestone1.html"/>
    <id>www.merlinblog.site/2017/08/30/milestone1.html</id>
    <published>2017-08-30T08:07:59.000Z</published>
    <updated>2017-10-13T16:12:30.279Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本文只在每一次 milestone 记录点更新, 记录我开发中遇到的经验,体会; 有的单独总结了, 所以只给出链接</p></blockquote><p>当前文章(以后会更新), 总结了我的个人经验, 包括我自己亲身经历的, 后台同学一起讨论的, 网络曾经看到的等等. </p><p><strong>如果你把你学到的知识, 而不是思考问题的方式, 细心&amp;耐心的品质, 健康的身体, 银行的存款, 结交的人缘作为核心竞争力;</strong><br><strong>那么分享自己所学可能对你有点儿困难.(虽然最初的时候我写博客也只是完全为了记录我成长的过程, 不过渐渐目的已经转变了)</strong></p><a id="more"></a><h1 id="版本记录"><a href="#版本记录" class="headerlink" title="版本记录"></a>版本记录</h1><h2 id="milestone1-大巨变"><a href="#milestone1-大巨变" class="headerlink" title="milestone1: 大巨变"></a>milestone1: 大巨变</h2><blockquote><p><code>大巨变100天(100 days from New Era)</code></p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/new_era_1.png" alt="里程碑"></p><p>当前里程碑记录<strong>Linux后台开发经验</strong>.</p><p>下面是一些<code>基于当前工作经验&amp;年限</code>的认识:</p><ul><li>对于c++, go这类稍微偏底层, 并且常用的语言, 一定要了解细节, 深知见底.</li><li>对于python, shell这类脚本或者模型语言, 用好为主</li><li>对于数据结构和算法: 数据结构深入, 算法了解.</li><li>对于操作系统, 如果决心做高级工程师, 业内技术专家linux一定要深入到内核(具体的是内核哪个模块?所有.)</li><li>对于网络编程, 根据工作的不同, 有人工作在应用层,有人工作在传输层和网络层, 甚至是链路层(但是不管这么说, 应用层和网络层是要知道的)</li><li>对于项目管理和人员管理等管理问题, 请入行的第3年再去涉及.(也就是工作的第5-7年)</li><li>对于金钱, 抱歉我看到的身边的人30W一大把, 50W是一个坎大多人突破不过去. (自己实力稍弱的时候, <code>不要太看重钱</code>)</li><li></li></ul><p><code>表面上看我成长不少, 但是从一个高手的要求上看, 我所做的其实远远不够; 希望慢慢会快, 后期抓紧时间!</code></p><h2 id="milestone2-领域专家"><a href="#milestone2-领域专家" class="headerlink" title="milestone2 : 领域专家"></a>milestone2 : 领域专家</h2><p>期待 <strong>2019.9</strong>, 一个全新&amp;加强版的我.</p><blockquote><p>TODO, 等待下一次更新; 深入行业!</p></blockquote><hr><h1 id="核心内容"><a href="#核心内容" class="headerlink" title="核心内容"></a>核心内容</h1><h2 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h2><h3 id="编程语言"><a href="#编程语言" class="headerlink" title="编程语言"></a>编程语言</h3><p>游戏业内主要的是c/c++ + Python/lua模式做游戏服务器。<br>c/c++做网络通讯数据传输，python/lua做业务逻辑。这样既保持了网络传输的效率(c++)，又提升开发效率(Python/lua)，同时也支持热更新。</p><p>其他用 erlang, go, C#, 甚至java, node.js也有, 只是没有接触过.</p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>我看到同学中, 一般小公司的, 用mysql, mongodb足以; 如果要访问提升效率(减轻数据库压力), 选择内存数据库redis, memcached都不错.<br>(存盘可以即使存盘, 但一般都不这么做, 一般采用固定存盘减少服务器压力; 个别效率苛刻的场景除外)</p><h3 id="消息件"><a href="#消息件" class="headerlink" title="消息件"></a>消息件</h3><p>一般用于服务器或者多进程之间通信, 比如zeromq等.<br>网络通信方面可以自己处理粘包问题, 直接传输字节流, 也可以传输xml, json; 常见的可能是采用框架, 比如protobuffer, 二进制传输.</p><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议部分的, 一般会涉及三个协议: http, tcp, udp<br><strong>http</strong>: 如果是那种弱联网单机玩法，用http足够了，像天天酷跑之类，只在需要的时候处理一条http请求响应。<br><strong>tcp</strong>: 现在的网络游戏大多数都是tcp<br><strong>udp</strong>: 其实游戏是有udp的，在一些高效率(即时性, 实时性要求高)的场景下比如pvp即时战斗,tcp的拥塞控制和超时重传并不适合，有些就用的udp,然后自己做丢包重发</p><p>现在参与开发的游戏就同时使用了http协议和tcp协议，在游戏服是单机玩法用http协议,战斗服需要长连接保存协议状态，用的tcp。</p><h3 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h3><p>libevent, boost.asio等网络库， 网上有很多开源网络库，与其自己造轮子，不如就用开源网络库作为自己服务器的通讯库, 例如:<br>libevent和boost.asio:</p><ul><li>Boost的ASIO是一个异步IO库，封装了对Socket的常用操作，简化了基于socket程序的开发。支持跨平台。</li><li>Libevent是一个C语言写的事件驱动的开源网络库, 应用和异步IO逻辑思想类似的 reactor反应堆模型.</li></ul><p>这两个库我都有详细介绍过, 这里就不再多说了.</p><h3 id="相关架构"><a href="#相关架构" class="headerlink" title="相关架构"></a>相关架构</h3><p>后端服务器架构应该说有很多种, 我熟悉的:</p><ul><li>Gate: 首先要有一个Gate(网关)服务器，负责客户端连接及消息转发到Game(游戏服),保持客户端到服务端的连接<br>没有任何逻辑，只做消息加密和解密，以及客户端和服务器消息的转发(相当于两者之间的桥梁).</li><li>GameServer: GameServer是游戏进程,提供游戏逻辑功能(采用单进程(或者单线程)模型,游戏服务器的瓶颈从来不在CPU,所以只做逻辑功能的话单线程足够了,在这里没必要用多线程或多进程)。</li><li>DBManager:实现数据库的读写，方便Game服务器异步读写数据库的数据(有些把数据库读写放在游戏服务器，没有单独的服务器，那恐怕游戏服单进程就不够用了)。</li><li>GameManager: 负责管理所有的GameServer，GameServer之间消息转发，提供广播到所有Game的功能。</li></ul><p>分布式架构我就不太熟悉了, 一般需要到专门的大公司学习.</p><h3 id="其他技术"><a href="#其他技术" class="headerlink" title="其他技术"></a>其他技术</h3><p>一般用的都是开源的, 比如gtest, glog/zlog, tcmalloc(内存性能分析), distcc, repo等</p><blockquote><p>其他技术, 请参考我的博客其他文章.</p></blockquote><h2 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h2><h3 id="core文件"><a href="#core文件" class="headerlink" title="core文件"></a>core文件</h3><p>产生 core 文件, 命令 <code>ulimit -c</code> 如果显示 1024 那么说明 coredump 已经被开启, 0 则表示没有开启.</p><blockquote><p>一般临时修改: ulimit -c unlimited  或者 <code>ulimit -c 1024</code>;关闭的话<code>ulimit -c 0</code>.</p></blockquote><p>1024 限制产生的 core 文件的大小不能超过 1024kb，可以使用参数unlimited，取消该限制</p><p>也可以修改文件配置<code>/etc/security/limits.conf</code>, 添加一行<code>* soft core unilimited</code><br>其实这个是由pam来完成的，pam里有个模块叫pam_limits，它默认的会读取/etc/security/limits.conf文件来进行资源限制。而用户登录时会调用/etc/pam.d/login文件来进行检查，这个文件里标明了使用哪些模块。其中它include了一个叫system_auth的配置文件，在这个文件里有对pam_limits.so的调用。</p><p>如果上面没有生效, 可能是其他登陆模块强制修改了, 典型的需要查看一下<code>/etc/profile</code>, <code>/etc/init.d/functions</code>.<br>这些文件在用户登录时会执行，因此即使pam修改了还是会被它改回去, 可以把那几行注释掉, 不过我一直截止很简单的:</p><pre><code>echo &quot;ulimit -c 1024&quot; &gt;&gt; /etc/profile</code></pre><blockquote><p>将不该清空的内存清空了，导致执行的时候会进入不可状态; 此时每次看到的core dump信息都不一样.</p></blockquote><h2 id="RESTful相关"><a href="#RESTful相关" class="headerlink" title="RESTful相关"></a>RESTful相关</h2><p>本段属于上层协议内容, 感谢土哥的经验交流.</p><h3 id="restful简介"><a href="#restful简介" class="headerlink" title="restful简介"></a>restful简介</h3><p>RESTful 架构, 由于其以资源中心, 依赖http协议和uri, 虽然也会涉及c-s模型, 不过其更多的是强调对于相关资源的crud操作, 并且提供了统一的API形式:</p><ul><li>看Url就知道要什么</li><li>看http method就知道干什么</li><li>看http status  code就知道结果如何</li></ul><p>举几个例子就会发现它非常规范:</p><pre><code>https://api.qzone.com/user/getUserFeedList?from=web https://api.qzone.com?m=user&amp;c=getUserFeedList?from=web https://qzone.com/api/user/getUserFeedList?from=web https://qzone.com?m=api&amp;c=user&amp;a=getUserFeedList?from=web</code></pre><p>HTTP协议形式例如:</p><pre><code>GET /posts HTTP/1.1Accept: application/atom+xml响应：HTTP/1.1 200 OKContent-Type: application/atom+xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;feed xmlns=&quot;http://www.w3.org/2005/Atom&quot;&gt;    &lt;title&gt;Posts&lt;/title&gt;    &lt;link href=&quot;http://example.org/posts&quot; rel=&quot;self&quot; /&gt;    &lt;link href=&quot;http://example.org/posts?pn=2&quot; rel=&quot;next&quot; /&gt;    &lt;id&gt;urn:uuid:60a76c80-d399-11d9-b91C-0003939e0af6&lt;/id&gt;    &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;    &lt;entry&gt;        &lt;title&gt;Post XXX&lt;/title&gt;        &lt;link href=&quot;http://example.org/post-xxx&quot; /&gt;        &lt;id&gt;urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a&lt;/id&gt;        &lt;updated&gt;2003-12-13T18:30:02Z&lt;/updated&gt;        &lt;content type=&quot;xhtml&quot;&gt;            &lt;div xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;                &lt;p&gt;This is the post content.&lt;/p&gt;            &lt;/div&gt;        &lt;/content&gt;    &lt;/entry&gt;    &lt;entry&gt;...&lt;/entry&gt;&lt;/feed&gt;</code></pre><h3 id="api返回值经验"><a href="#api返回值经验" class="headerlink" title="api返回值经验"></a>api返回值经验</h3><blockquote><p>针对JSON型API的返回结果设计, 总结下自己的经验</p></blockquote><p>一般的返回结果是怎么样的?</p><pre><code>{    data : { // 请求数据        user_id: 123,        user_name: &quot;tutuge&quot;,        ...    },    msg : &quot;done&quot;, // 请求状态描述，调试用    code: 1001, // 业务自定义状态码    extra : { // 全局附加数据(optional字段)        type: 1,        desc: &quot;秒数信息&quot;    }}</code></pre><p>下面详细解释:</p><ul><li>data字段<br>本次请求结果的数据 data 字段, 其值为对象(字典)或数组(列表)均可以, 根据业务而定. 例如:<pre><code>data: [  {user_id: 123, user_name: &quot;tutuge&quot;},  {user_id: 321, user_name: &quot;zekunyan&quot;},  ...]</code></pre>当然数组, 对象还可以嵌套, 怎么灵活怎么用.(不用担心现有库对于字段的解析问题)</li><li>msg字段<br>该字段是本次请求的业务&amp;状态描述信息, 主要用于调试、测试等, 例如 “done”, “测试缺少参数”. 根据相关开发人员协商即可. </li><li>code字段<br>这是比较有争议的一个字段, 因为Http请求本身已经有了完备的状态码，再定义一套状态码直观上感受却是不对劲。但是实际开发中，确实发现 <code>自定义业务状态码</code> 的必要性，如一次成功的Http status 200的请求，可能由于用户未登录、登录过期而有不同的返回结果和处理方式，所以还是保留了; 权当http协议的详细说明.<br>定义规范根据业务来, 例如按照用户相关、授权相关、各种业务，做简单的分类:<pre><code>// Code 业务自定义状态码定义示例// 授权相关1001: 无权限访问1002: access_token过期1003: unique_token无效...// 用户相关2001: 未登录2002: 用户信息错误2003: 用户不存在// 业务13001: 业务1XXX3002: 业务1XXX// ...</code></pre>最好定义为常量, 当然能够动态解析最好.</li><li><p>extra字段<br>这个纯粹是附加字段(全局的附加数据), 为的是灵活扩展, 比如升级啊, 需求变化等. 由服务端的规则决定并且客户端要及时向用户展示变化, 所以加上了extra字段. 例如:</p><pre><code>// 升级type: 1,show_msg: &quot;恭喜您升级到XXX&quot;// 完成任务type: 2,task_desc: &quot;达成XXX成就&quot;</code></pre></li></ul><p>其实最终还是要看客户端和服务端人员的协商; 服务端人员切不可以为添加一个字段简单没有什么, 就随口答应, 一切都要走流程, 并且避免乱用. 这不仅仅是为了规范, 而是为了让项目不会再将来出现意想不到的 <code>惊喜</code> .</p><p>补充经验:</p><ul><li>命名, 和C语言保持一致就可以了(字段统一小写加下划线)<br>例如:<pre><code>// 字符串user_name, task_desc, date_str, article_title, feed_content 等// 数字user_id, users_count, task_num, xxx_offset 等// 日期login_at, create_date, logout_time 等// 布尔is_done, is_vip, protected, can_read 等// URLuser_avatar_url, thumb_url 等// 数组users, profiles, thumb_imgs 等</code></pre></li><li>设置默认值(空值)<ul><li>数字就是 <code>0</code></li><li>字符串就是空字符串<code>&quot;&quot;</code></li><li>数组就是空数组<code>[]</code></li><li>对象就是空对象{}</li></ul></li><li>bool值, 统一成0和1.<br>由于多种语言不统一, 所以一开始就要做好限定, 而不是<code>true</code>, <code>True</code>, <code>1</code>漫天乱飞.. 在客户端和服务端统一设置常量、宏定义，定义布尔的类型，所有的参数、结果的布尔字段全部做强制约束</li><li>时间处理, 统一使用Unix时间戳, 即GMT/UTC时间戳, 可以用<code>date +%s</code>命令查看, 然后各自客户端根据自己的时区, 显示做转换.<br>例如:<pre><code>// 从服务器接收的时间数据login_at: 1462068610// 根据时区、显示要求转换，如北京时间显示：2016年5月1日下午1点、1天前等</code></pre>(如果用字符串,可以参考<code>YYYY-MM-DDThh:mm:ssTZD</code>格式,保留了时区)</li><li>字符串常量 请用常量文档约束.<pre><code>// 如登录类型，QQ、微信、微博等login_type: &quot;qq&quot;,login_type: &quot;wechat&quot;,login_type: &quot;sina_weibo&quot;,</code></pre></li><li>使用完整的url, 指明网络协议(scheme).</li></ul><h2 id="C-语言"><a href="#C-语言" class="headerlink" title="C++语言"></a>C++语言</h2><h3 id="window移植"><a href="#window移植" class="headerlink" title="window移植"></a>window移植</h3><p>windows迁移问题, 自己遇到的, 记录一下:</p><ul><li>缺少最后一行空行, 多余的\r回车符<br><code>dos2unix &lt;file&gt; fromdos &lt;file&gt;</code></li><li>中文注释乱码<br><code>iconv –f gbk –t utf8</code> (utf8也可以写成utf-8)</li><li>不能忍的头文件<br><code>windows.h</code></li><li>不兼容的宏, 库函数<br><code>snprintf()</code>,<code>__FUNCTION__</code>, <code>__FILE__</code>, <code>__LINE__</code></li><li>特殊的宏<br><code>#ifdef WIN_32  #define …  #endif</code></li></ul><h3 id="宽字符问题"><a href="#宽字符问题" class="headerlink" title="宽字符问题"></a>宽字符问题</h3><p>本质上是ascii码和unicode的存储问题.(单字节不够用, 采用多字节)<br>先注意一下文件编码, windows下默认是gbk编码:</p><pre><code>iconv -f GBK -t UTF-8 main.cc &gt; mainu.cc</code></pre><p>之后注意一下多字节字符问题, 基本情况如下:(实际上wchar_t同样没有标准限定)</p><ul><li>Windows 下的 char 是 ANSI，WCHAR 是 UTF-16（UCS-2），跟 locale设置有关系</li><li>Linux   下的 char 是 UTF-8，WCHAR 是 UTF-32（UCS-4），都是 Unicode，与 locale 无关</li></ul><p>我建议你 Windows 下调用<code>MultiByteToWideChar</code>和<code>WideCharToMultiByte</code>，<br>而 Linux 直接自己写一个转换函数(UTF-8 和 UTF-32 转换规律很简单), 大致如下:</p><pre><code class="C++">#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int UTF8ToUnicode(const char *pmbs, wchar_t *pwcs, int size){    int cnt = 0;    // 这里 size-- 是预先除去尾零所需位置    if (pmbs != NULL &amp;&amp; pwcs != NULL &amp;&amp; size-- &gt; 0) {        while (*pmbs != 0 &amp;&amp; size &gt; 0) {            unsigned char ch = *pmbs;            if (ch &gt; 0x7FU) {                int cwch = 0;                while (ch &amp; 0x80U) {                    ch &lt;&lt;= 1;                    cwch++;                }                *pwcs = *pmbs++ &amp; (0xFFU &gt;&gt; cwch);                while (--cwch &gt; 0) {                    *pwcs &lt;&lt;= 6;                    *pwcs |= (*pmbs++ &amp; 0x3FU);                }            } else {                *pwcs = *pmbs++;            }            pwcs++;            size--;            cnt++;        }        *pwcs = 0;        cnt++;    }    return cnt;}int UnicodeToUTF8(const wchar_t *pwcs, char *pmbs, int size){    int cnt = 0;    // 这里 size-- 是预先除去尾零所需位置    if (pwcs != NULL &amp;&amp; pmbs != NULL &amp;&amp; size-- &gt; 0) {        while (*pwcs != 0 &amp;&amp; size &gt; 0) {            if (*pwcs &lt; 0x00000080U) {                *pmbs++ = (char)*pwcs;                size -= 1;                cnt += 1;            } else if (*pwcs &lt; 0x00000800U) {                // 剩余空间不够存放该字符                if (size &lt; 2) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 6) | (*pwcs &gt;&gt; 6);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 2;                cnt += 2;            } else if (*pwcs &lt; 0x00010000U) {                // 剩余空间不够存放该字符                if (size &lt; 3) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 5) | (*pwcs &gt;&gt; 12);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 3;                cnt += 3;            } else if (*pwcs &lt; 0x00200000U) {                // 剩余空间不够存放该字符                if (size &lt; 4) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 4) | (*pwcs &gt;&gt; 18);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 4;                cnt += 4;            } else if (*pwcs &lt; 0x04000000U) {                // 剩余空间不够存放该字符                if (size &lt; 5) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 3) | (*pwcs &gt;&gt; 24);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 5;                cnt += 5;            } else if (*pwcs &lt; 0x80000000U) {                // 剩余空间不够存放该字符                if (size &lt; 6) {                    break;                }                *pmbs++ = (0xFFU &lt;&lt; 2) | (*pwcs &gt;&gt; 30);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 24) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 18) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 12) &amp; 0x3FU);                *pmbs++ = 0x80U | ((*pwcs &gt;&gt; 6) &amp; 0x3FU);                *pmbs++ = 0x80U | (*pwcs &amp; 0x3FU);                size -= 6;                cnt += 6;            } else {                // 无法识别的 Unicode 字符                break;            }            pwcs++;        }        *pmbs = 0;        cnt++;    }    return cnt;}int main(void){    // 这部分代码请在 Linux 上测试，Windows 命令行无法打印 UTF-8 字符串。    char mbs1[256] = { 0 };    wchar_t wcs1[] = L&quot;测试文字&quot;; //单个中文, utf8存储3字节    int ret1 = UnicodeToUTF8(wcs1, mbs1, sizeof(mbs1)/sizeof(char));    printf(&quot;%d\n&quot;, ret1); //13    // 这部分代码请在 Linux 上测试，Windows 的 char 类型非 UTF-8 编码。    char mbs2[] = &quot;测试文字&quot;;    wchar_t wcs2[256] = { 0 };    int ret2 = UTF8ToUnicode(mbs2, wcs2, sizeof(wcs2)/sizeof(wchar_t));    printf(&quot;%d\n&quot;, ret2); //5    return 0;}</code></pre><p>参数作用简单说明如下：</p><ul><li>第一个参数为待转换的字符串</li><li>第二个参数为接收结果的缓冲区</li><li>第三个参数为结果缓冲区大小(包含尾零)<br>返回值为所写入缓冲区的大小(包含尾零)</li></ul><p>最好不要使用<code>wchar_t</code>, 而直接使用<code>std::wstring</code>, 例如下面的代码:(windows环境)</p><pre><code class="C++">//const wchar_t* ws = L&quot;世界你好！&quot;;std::wstring wstr = L&quot;世界你好！&quot;;std::wcout.imbue( std::locale(&quot;chs&quot;) );std::wcout &lt;&lt; wstr &lt;&lt; std::endl;</code></pre><p><code>std::locale( std::locale(),&quot;&quot;,std::locale::ctype )</code>会创建当前系统环境下locale，这个locale中会保存这个系统 ansi 使用 code page.<br>(wofstream，wcout 在处理 unicode字符 时，必须进行内部编码转换（unicode -&gt; ansi ）)</p><p>具体参考以下链接:</p><ol><li><a href="http://blog.csdn.net/xujiezhige/article/details/17843831" target="_blank" rel="external">http://blog.csdn.net/xujiezhige/article/details/17843831</a></li><li><a href="http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html" target="_blank" rel="external">http://www.cnblogs.com/Dageking/archive/2014/01/15/3520406.html</a></li><li><a href="http://bbs.csdn.net/topics/391079600?page=1" target="_blank" rel="external">http://bbs.csdn.net/topics/391079600?page=1</a></li></ol><h3 id="操作大文件"><a href="#操作大文件" class="headerlink" title="操作大文件"></a>操作大文件</h3><p>1.包含所有头文件以前，先定义这些宏：</p><pre><code class="C++">#ifndef __USE_FILE_OFFSET64#define __USE_FILE_OFFSET64#endif#ifndef __USE_LARGEFILE64#define __USE_LARGEFILE64#endif#ifndef _LARGEFILE64_SOURCE#define _LARGEFILE64_SOURCE#endif</code></pre><p>一般用 /usr/include/features.h 重定义的:</p><p>32位LINUX使用超过2G的大文件，需要定义很多宏，与文件操作API相关的宏都有这样一些：</p><pre><code>_FILE_OFFSET_BITS_LARGEFILE_SOURCE_LARGEFILE64_SOURCE__USE_FILE_OFFSET64__USE_LARGEFILE__USE_LARGEFILE64</code></pre><p>那么，它们之间的关系究竟是怎么样的呢？<br>终于在linux的头文件<code>/usr/include/features.h</code>中找到了定义。</p><pre><code class="C++">//原来这个文件就是专门让用户定义各种特性的：/*These are defined by the user (or the compiler)to specify the desired environment其中几个供用户配置的宏的注释为：_LARGEFILE_SOURCE    Some more functions for correct standard I/O._LARGEFILE64_SOURCE    Additional functionality from LFS for large files._FILE_OFFSET_BITS=N    Select default filesystem interface._GNU_SOURCE        All of the above, plus GNU extensions.__USE_LARGEFILE    Define correct standard I/O things.__USE_LARGEFILE64    Define LFS things with separate names.__USE_FILE_OFFSET64    Define 64bit interface as default.*/// use前缀的宏定义都先取消掉，说明这些宏不是直接供用户使用的，而是由其他宏的定义衍生这些宏#undef    __USE_LARGEFILE#undef    __USE_LARGEFILE64#undef    __USE_FILE_OFFSET64//   _GNU_SOURCE是一张很大的通行证，定义了这个，很多相关的开关都会打开/* If _GNU_SOURCE was defined by the user, turn on all the other features.  */#ifdef _GNU_SOURCE# undef     _LARGEFILE64_SOURCE# define _LARGEFILE64_SOURCE    1#endif// 下面是打开各个USE宏的位置#ifdef _LARGEFILE_SOURCE# define __USE_LARGEFILE    1#endif#ifdef _LARGEFILE64_SOURCE# define __USE_LARGEFILE64    1#endif#if defined _FILE_OFFSET_BITS &amp;&amp; _FILE_OFFSET_BITS == 64# define __USE_FILE_OFFSET64    1#endif</code></pre><p>总结： <strong>使用64位大文件，定义_LARGEFILE64_SOURCE和_FILE_OFFSET_BITS=64这两个宏即可</strong></p><p><strong>2.</strong>使用open打开文件的时候，加上O_LARGEFILE标志：<br>int fd = open(“test.dat”, O_RDWR|O_APPEND|O_CREAT|O_LARGEFILE, 0666);<br>read(), write()等与一般的用法一致，无变化。</p><p><strong>3.</strong>注意lseek()函数，文件未超过2G的时候，一切工作良好；<br>文件超过2G后，调用返回-1，errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>需要使用lseek64()代替lseek()。很奇怪，定义了宏以后，并未自动将lseek变成lseek64。（知道原因的朋友可以教教我）</p><p><strong>4.</strong>注意stat()函数，传入的文件如果在2G内，工作良好；<br>传入的文件如果超过2G，返回-1, errno为EOVERFLOW (errno=75, msg=Value too large for defined data type)<br>应该这样使用：struct stat64 st; stat64(“file”, &amp;st);</p><p><strong>5.</strong>为了保险，建议所有操作文件的函数都是用支持64位大文件的。否则当文件超过2G后，难免会出现什么未知的异常</p><h2 id="C-标准库"><a href="#C-标准库" class="headerlink" title="C++标准库"></a>C++标准库</h2><h3 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h3><p>具体可以参考一下我的文章, <a href="">C++11一致性初始化</a>, 提倡&amp;建议使用一致性初始化.</p><p>其他还有需要注意的就是, <strong>在线程编码中,尽量不要使用匿名对象</strong></p><blockquote><p>尽量不使用匿名对象，如果想要用完立即释放，可以使用单独的代码块包裹。</p></blockquote><h3 id="std-bind"><a href="#std-bind" class="headerlink" title="std::bind"></a>std::bind</h3><p>标准库的 bind 和 boost::bind 使用起来类似</p><p>举个例子</p><pre><code class="C++">void test(int a, int b, int c)boost::bind(test, 1, _1, _2);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(1,3,4)boost::bind(test, _2, 3, _1);;//得到一个函数对象b，当我们调用b(3,4)时，相当于调用test(4,3,3)</code></pre><p>而在标准库中一般是这么用的:</p><pre><code class="C++">auto handler = std::bind(test, 1, std::placeholders::_1, std::placeholders::_2);handler(3,4);// 相当于 test(1,3,4);</code></pre><p>其他的可以参考文章<a href="http://www.merlinblog.site/2017/07/01/bind-in-cpp.html">C++11 std:bind探究</a></p><h3 id="智能指针-多线程-问题"><a href="#智能指针-多线程-问题" class="headerlink" title="智能指针(多线程)问题"></a>智能指针(多线程)问题</h3><p>其实是异步代码问题.<br>具体现象描述:<br>一旦压力达到一定程度，程序立即就会崩溃，报的错误几乎都在new的时候没有内存了，一开始以为确实是因为内存分配的问题，后来在<strong>程序运行过程中</strong>用top观察，发现内存使用很低，因此可以确认不应该是瞬间内存使用完造成的。</p><p>因此认真看了一下 core dump 的地方，发现几乎都是在自己写的一个智能指针分配内存那里出的问题。<br>于是仔细思考了一下，发现是因为<strong>智能指针的引用计数没有加锁</strong>导致的, 或者说<strong>同一时间, 可能有多个线程持有该指针</strong>, 导致引用计数不能减为0。</p><p>例如下面的代码:</p><pre><code class="C++">void func(){    shared_ptr a;    async_call(a);}</code></pre><p>解释:首先有一个智能指针，接下来，这个智能指针被丢给了异步程序，因此这个时候其实已经有两个线程同时持有这个智能指针了，因为这个函数还未退出，当前线程还拥有这个指针a. 一般低压情况下，这两句很快就执行完了，不会出问题，但是高压情况下，这个函数先执行完，还是异步程序先执行完就不一定了（或者说是因为高压情况样本变多了）, 也就造成了资源没有释放.</p><h2 id="Boost-Asio"><a href="#Boost-Asio" class="headerlink" title="Boost.Asio"></a>Boost.Asio</h2><h3 id="read-util相关"><a href="#read-util相关" class="headerlink" title="read_util相关"></a>read_util相关</h3><p>在使用boost的read_util库的时候遇到一个很诡异的问题，如果用read_util(““)这样的调用，第一个请求可以得到，但是第二个请求会卡住，永远也拿不到。从服务器端看到的情况是，第二个响应已经完整的发送出去，但是read_util就是不返回。比较奇怪的是如果用read_util(‘&gt;’)这样调用，那是没有任何问题的。</p><blockquote><p>read_util(string)这样的函数，它所用的肯定是string.find这样的函数，而这样的函数它是用字符串查找的，这表示它一旦遇到<code>\0</code>就不再往后查找了。</p></blockquote><p>每个响应最后会有一个/0字符。因此在第一个包读完之后，接下来读到的第一个字符就是<code>\0</code>，那么第二个包读的时候，不论读到多少数据，这个字符串的内容是<code>\0xxxxxxxx</code>，在这个一个长度为0的字符串上进行查找<code>&quot;&lt;/data&gt;&quot;</code>，必然找不到任何有用的信息。</p><p>结论：<strong>在处理网络流的时候，即使协议是文本协议，最好还是把它当作二进制来处理或者用一些自己写的字符串匹配函数.</strong></p><h3 id="请求队列积压问题"><a href="#请求队列积压问题" class="headerlink" title="请求队列积压问题"></a>请求队列积压问题</h3><p>测试用asio写的模块时发现，在高压力情况下，内存使用很大，而且涨上去之后在低压力情况下内存依然没降下来。一开始以为是内存泄露，后来用valgrind查了半天，发现根本没有内存泄露的代码。</p><p>通过post方法将多个其他线程的日志内容推到这个日志线程的中去。于是这个时候就比较容易理解了，<strong>多线程来喂一个单线程，单线程必然响应不过来，这样子导致整个task队列比较一直在增长</strong>，并且当压力降下来之后，整个队列已经很大了，并不会再降回去。</p><blockquote><p>在所有异步系统中普遍存在的，当响应很慢时，会导致请求队列积压，造成内存的大量占用。</p></blockquote><p>解决办法: </p><ul><li>给队列一个上限，当走出这个队列长度之后，拒绝新的请求。这种方法很暴力，但是不会造成系统崩溃。<br>检查了io_service的构造函数之后发现，没有提供任何关于队列长度限制的函数，因此这个方法可以直接忽略了</li></ul><p>一般就是这么做, 但是这里由于环境限制, 所以只能提高日志的级别, 解决队列积压问题.</p><h2 id="长连接"><a href="#长连接" class="headerlink" title="长连接"></a>长连接</h2><p>首先一般不会用c/c++去写业务代码, 维护和开发成本太高, 一般都是通过服务器转发给前端其他模块&amp;语言处理, 比如php,<br>此时转发请求的服务器就要能保存状态&amp;维护长连接, 例如可以采用<code>boost/asio + fastcgi + php</code>.</p><p>当前端将请求发上来之后，长连接服务器通过 <code>fastcgi协议</code> 将请求发给 php，由php处理完成后再返回给长连接服务器，由长连接服务器返回给用户。<br>好处如下:</p><ul><li>web服务器是基于http协议的(架构显然协议不一定是http的，可以任意自己想要的协议)</li><li>http协议是无状态的</li></ul><p>那么第二个问题，如何解决无状态，通常web服务器是通过session，这个显然有性能问题，而且session是没有保证的。<br>于是我们反过来，长连接服务器同时作为session服务器，在把请求发给php时，同时将存储在长连接服务器的session也发给php，<br>php对session的任何更改也在响应中回传给服务器，由<strong>服务器保存(session)</strong>，下一次调用时再传回去。</p><p>这样一来，从 php 服务器端看到的是一个有状态的请求序列。 </p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>这篇文章会一直更新, 直到哪一天我不再在一线编码了, 希望能给看到的人提供一些帮助.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="https://www.zhihu.com/question/28557115" target="_blank" rel="external">知乎大神们对restful的看法</a></li><li><a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes" target="_blank" rel="external">http状态码大全</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      一些列工作经验的分享,干货
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="里程碑" scheme="www.merlinblog.site/tags/%E9%87%8C%E7%A8%8B%E7%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>网络吞吐量测试</title>
    <link href="www.merlinblog.site/2017/08/28/network-throughput-test.html"/>
    <id>www.merlinblog.site/2017/08/28/network-throughput-test.html</id>
    <published>2017-08-28T09:47:33.000Z</published>
    <updated>2017-10-12T20:27:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文结合网络编程&amp;工作中, 常用的命令, 测试一下<code>网络吞吐量</code>.</p><blockquote><p>我自己也是很长一段时间搞不清楚<code>TPS</code>, <code>QPS</code>, <code>吞吐量</code>等关系; 并且总是听别人说高性能, 但是不知道所谓的高性能是主观臆测的还是测量出来的</p></blockquote><p>先来一张有趣的图.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/throughput1.jpg" alt=""></p><h1 id="概念梳理"><a href="#概念梳理" class="headerlink" title="概念梳理"></a>概念梳理</h1><p>注意一下<code>带宽</code>, <code>传输速率</code>常常和<code>吞吐量</code>扯在一起, 下面先区分一下它们. </p><h2 id="带宽"><a href="#带宽" class="headerlink" title="带宽"></a>带宽</h2><p>定义：计算机网络中的主机在数字信道上，单位时间内从一段传送到另一端的最大数据量，即<code>最大速率</code>, <code>Max net bit rate</code><br>类比：一个供水管，假设管子中有流动的水，这里的水为数据。单位时间内，从管子的某个横截面就是速率，即单位时间内传送的数据量。当管子充满水的时候，管子的某个横截面就是最大速率，即带宽<br>单位：<code>bps</code>, 和<code>速率</code>一样, 注意是<code>b</code>,p<code>,</code>s` (bits per second).</p><p>1Byte=8bit, 即<code>1字节=8比特</code>， 所以<code>1Bps=8bps</code>.</p><blockquote><p>网络带宽为100Mbps, 但是我们性能测试出来的吞吐量却只有10MB多一点, 就是因为单位不同: 100Mbps的带宽实际上传输速率为12.5MB/s </p><blockquote><p>区分<code>Mbps</code>和<code>MBps</code></p></blockquote></blockquote><p>以前家里电信网是4M的, 4M的理论下载速度为500KB/S，实际速率只能达到200-440KB/S.</p><h2 id="传输速率"><a href="#传输速率" class="headerlink" title="传输速率"></a>传输速率</h2><blockquote><p>我们平常说的速率是<code>额定速率</code></p></blockquote><p>定义：在数据传输中，两个设备之间数据流动的物理速度成为传输速率，单位为bps<br>单位：比特是数据量最小单位，秒是时间的最小单位， 所以速率单位为bps, 类似的，有<code>kb/s</code>，<code>Mb/s</code>(M=10^6),<code>Gb/s</code>（G=10^9）,<code>Tb/s</code>(t=10^12)</p><blockquote><p>上面的单位都是<code>bit</code>, 比特.</p><blockquote><p>通常, 你把带宽理解成传输速率是不错的, 但不准确;但是反过来说传输速率是带宽就不对了.</p></blockquote></blockquote><p>各种传输媒介中信号的流动速度是恒定的，即使数据链路的传输速率不同，也不会出现忽快忽慢的情况。传输速率不是指单位数据流动的速度有多快，而是指单位时间内传输的数据量有多少。<br>以我们生活中的道路交通为例，低速数据链路如同车道较少无法让很多车同时通过的情况，与之相反，高速数据链路就相当于有多个车道，一次允许更多车辆行驶的道路。</p><blockquote><p>理论上说, 带宽越大网络传输能力就越强, 因为上限拉大了.</p></blockquote><h2 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h2><p>理论不等于实际, <code>吞吐量</code>, throuhgput就是<code>实际传输速率</code>. 你可以从它的单位可以看出来<code>bps</code>, 但是, 吞吐量不仅衡量带宽，同时也衡量主机的CPU处理能力、网络的拥堵程度等.</p><blockquote><p>说的通俗一点，就是单位时间内某个（端口）实际的数据量</p></blockquote><p>上面的内容都和速率有关. 下面的概念和<code>事务</code>, ``</p><h1 id="工具介绍"><a href="#工具介绍" class="headerlink" title="工具介绍"></a>工具介绍</h1><p>可以参考我的文章 <a href="http://www.merlinblog.site/2017/08/23/net-work-tools.html">net-work-tools</a></p><h1 id="正式测量"><a href="#正式测量" class="headerlink" title="正式测量"></a>正式测量</h1><h2 id="为啥要测试"><a href="#为啥要测试" class="headerlink" title="为啥要测试?"></a>为啥要测试?</h2><p>当我们讨论通信链路的带宽时，一般是指链路上每秒所能传送的比特数，它取决于链路时钟速率和信道编码在计算机网络中又称为线速。我们可以说以太网的带宽是10Mbps。但是，我们需要区分链路上的可用带宽（带宽）与实际链路中每秒所能传送的比特数（吞吐量）。我们倾向于用“吞吐量”一次来表示一个系统的测试性能。这样，因为实现受各种低效率因素的影响，所以由一段带宽为10Mbps的链路连接的一对节点可能只达到2Mbps的吞吐量。这样就意味着，一个主机上的应用能够以2Mbps的速度向另外的一个主机发送数据。</p><p>数据吞吐量 就是的数据包转发能力。也就是能同时转发多少数据包。也就是一个单位时间内，满负载，可以转发多少的一个数值 数据流量/秒 或者数据流量/分钟。</p><blockquote><p>简单说, 为了找出服务性能的瓶颈.</p></blockquote><h2 id="一般测试方法"><a href="#一般测试方法" class="headerlink" title="一般测试方法"></a>一般测试方法</h2><p>吞吐量的测试方法是：在测试中以一定速率发送一定数量的帧，并计算待测设备传输的帧，如果发送的帧与接收的帧数量相等，那么就将发送速率提高并重新测试；如果接收帧少于发送帧则降低发送速率重新测试，直至得出最终结果。吞吐量测试结果以比特/秒或字节/秒表示。</p><h2 id="实际测量"><a href="#实际测量" class="headerlink" title="实际测量"></a>实际测量</h2><blockquote><p>在linux平台下, 借助<code>nc</code>, <code>dd</code>, <code>time</code>等工具, 工作远没有那么复杂.</p></blockquote><p>测试环境, 本机(上海浦东金融区) –&gt; 华北(具体不知道哪)阿里云服务器, 指定端口5000</p><p>姑且成为, A –&gt; B 之间的测试吧, 带宽50Mbps. (阿里云的带宽应该远超50M)</p><p>下面开始几组测量: </p><h3 id="dd-nc"><a href="#dd-nc" class="headerlink" title="dd+nc"></a>dd+nc</h3><p>A也就是本机进行写(读完即舍弃):<br><img src="http://omotkhw3y.bkt.clouddn.com/dd-nc-first.png" alt=""></p><p>B,也就是阿里云服务器进行读:<br><img src="http://omotkhw3y.bkt.clouddn.com/dd-nc-first1.jpg" alt=""></p><h3 id="time-nc"><a href="#time-nc" class="headerlink" title="time+nc"></a>time+nc</h3><p>然后用time进行测试, 得出结果:</p><p>A端写的结果:<br><img src="http://omotkhw3y.bkt.clouddn.com/time-nc.png" alt=""></p><p>B端读的结果:<br><img src="http://omotkhw3y.bkt.clouddn.com/time-nc1.jpg" alt=""></p><blockquote><p>好吧, 这个结果应该是被别的因素干扰了.</p></blockquote><p>分析如下:</p><p>因为dd在统计时也会占用一部分资源(或者多了一次管道读写), 具体如下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/nc_dd.jpg" alt=""></p><blockquote><p>此外, netcat的版本也是影响测量因素的原因, 只是这个案例中没有体现出来.</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p><h1 id="TPS-QPS"><a href="#TPS-QPS" class="headerlink" title="TPS QPS"></a>TPS QPS</h1><blockquote><p>一个系统吞吐量通常由QPS（TPS）、并发数两个因素决定，每套系统这两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统的吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换、内存等等其它消耗导致系统性能下降。</p></blockquote><p><strong>TPS</strong>：Transactions Per Second（<code>每秒传输的事物处理个数</code>），即服务器每秒处理的事务数。TPS包括一条消息入和一条消息出，加上一次用户数据库访问。<br>（业务TPS = CAPS × 每个呼叫平均TPS）TPS是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。<strong>客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数</strong>。</p><p><strong>QPS</strong>：每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准</p><p>下面有个具体的例子:<br>一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。<br>可以用下面的方法计算。<br><code>QPS = 1000/(30*60) 事务/秒</code>,<br><code>平均响应时间为 = 5*60  秒</code>,<br><code>并发数= QPS*平均响应时间 = 1000/(30*60) *(5*60)=166.7</code>;</p><p><strong>并发数</strong>也很好理解, 在处理响应的时间内, 能够处理的事物总个数; 即<code>qps * 平均响应时间</code>.</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://blog.csdn.net/wind19/article/details/8600083" target="_blank" rel="external">http://blog.csdn.net/wind19/article/details/8600083</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      主要使用nc测试一下网络吞吐量(throughput), 辅助工具time, pv, dd, nc
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>First Agile</title>
    <link href="www.merlinblog.site/2017/08/27/first-about-agile.html"/>
    <id>www.merlinblog.site/2017/08/27/first-about-agile.html</id>
    <published>2017-08-27T03:37:08.000Z</published>
    <updated>2017-09-24T07:26:34.663Z</updated>
    
    <content type="html"><![CDATA[<p>老东家一直有个站会, 在看板(Kan Board)面前阐述一下自己的任务进度. 说实话, 我非常排斥这种东西(虽然我拥护TDD和XP). 后来听京东和支付宝的同学也在说敏捷会议, 敏捷开发, 我这才意识过来:</p><pre><code>哦, 敏捷已经是趋势了.</code></pre><p>开始认真接受 <code>Agile</code> .</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>我亲身实践的敏捷, 印象比较深刻的有两部分内容:</p><ul><li>站会的反馈</li><li>(配合SCM)持续集成</li><li>测试驱动</li></ul><p>总结起来, 我所重视的是: <code>参与</code>, <code>协作</code>, <code>持续交付</code> (每个阶段都是可交付的).</p><p>本文先说敏捷, 之后再说我的个人体会.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>敏捷到底是一种软件开发方法, 还是一种技术思想? 到现在我的觉得, 这些已经不再重要, 重要的是, 我们通过 Agile 能够获得什么, 而不是我最初跟风的, 尝试敏捷.</p><h2 id="敏捷宣言"><a href="#敏捷宣言" class="headerlink" title="敏捷宣言"></a>敏捷宣言</h2><p>主要的内容就这么几句话:</p><pre><code> Individuals and interactions over processes and tools Working software over comprehensive documentation Customer collaboration over contract negotiation Responding to change over following a plan</code></pre><p>如下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/agile.jpg" alt="agile"></p><p>看得出, 宣言其实是很空洞的, 所以又出现了下面的 <code>12项原则</code> .</p><h2 id="12项原则"><a href="#12项原则" class="headerlink" title="12项原则"></a>12项原则</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/agile_principle.jpg" alt="agile"></p><p>从中可以提取很多关键思想: <code>不断交付</code>, <code>拥抱变化</code>, <code>合作</code>, <code>可工作的软件</code>, <code>简洁为本</code>, <code>定期反思</code> …</p><h2 id="Scrum"><a href="#Scrum" class="headerlink" title="Scrum"></a>Scrum</h2><p>不管一个产品, 还是一个项目, 整个团队的协作, 参与是最重要的. 所以比起其他一些(重视开发流程, 过程的)方法, Scrum更加注重协作&amp;参与(当然也包括交付, 每一个过程都是可交付的).</p><p>是的, 我这里多次强调了 <code>参与</code> .</p><p>关于这部分理论, 请找专业的资料参考吧, 不要去网上看一些不太专业的转载.</p><h2 id="站会反馈"><a href="#站会反馈" class="headerlink" title="站会反馈"></a>站会反馈</h2><p>每天早上9:30, 会有一个站会, 内容是围绕看板任务, 大家各自汇报一下. 说实话, 效果很差. 因为除非是你的模块, 否则大家对你的进度, 遇到的困难, 没有太多的体会, 也很难给出意见. (何况有时候我都是单独一个项目, 单枪匹马).</p><p>但是在这里, 我却有一些很深刻的体会, 大体可以归纳为: 我们认为重要的, 用户不一定觉得重要.</p><p>这么说呢? 具体解释:</p><p>好比我的模块, 是否需要一个数据库View(视图), 一个Contoller调度模块, 是否要给出应用界面, 表格是竖着展开还是横向排列, 你的意见, 和最终用户的意见可能相差很远, 甚至你觉得重要的, 用户完全不care, 不关注的.</p><p>所以站会反馈, 最好能让用户, 客户参与到团队的开发中; 这里增加一点儿成本, 却省下了后期需求变更, 调整的代价. 好处不言自明.</p><p>也就是宣言中所说的 <code>Customer collaboration over contract negotiation</code>, 客户协作胜过合同谈判.</p><h2 id="持续集成"><a href="#持续集成" class="headerlink" title="持续集成"></a>持续集成</h2><p>在持续集成方面, 老东家 <code>ZTE</code> 可以说, 做的非常好; 因为面对的北美项目比较多, 所以在集成测试做不好, 不仅会加大人力投入, 还会降低开发效率. 但是就像自动测试一样, 是否应该持续集成关键在于投资回报率和缓解风险. 我想这一点, 不必多解释, 请看下面的要点.</p><p>持续集成的要点:</p><ul><li>统一的代码库</li><li>自动构建</li><li>自动测试</li><li>每个人每天都要向代码库主干提交代码</li><li>每次代码递交后都会在持续集成服务器上触发一次构建</li><li>保证快速构建</li><li>模拟生产环境的自动测试</li><li>每个人都可以很容易的获取最新可执行的应用程序</li><li>每个人都清楚正在发生的状况</li><li>自动化的部署</li></ul><p>个人的经验是:<br>以前我的代码入库前, 至少经历这样的步骤:<br>代码编写完毕, 本地验证通过(包括编译和功能验证), 然后在本地集成(可能是具体的开发板,比如手机), 之后上传代码, 在容器(生产环境)中测试, 而且分两次, 早上和下午(赶上一次就可以了), 之后通过了, 才合入dev分支, 经过几个版本的测试, 没有问题了, 才最终合入master分支. 中间经过了N次自动化测试, 集成, 而且你的提交根本不干预集成.</p><p>这里面相关的技术也很多, Jekins, Gerrit, repo, Docker等.</p><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>关心团队协作, 用心做产品.</p><p>希望敏捷的路越走越顺吧.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      谈谈自己经历 敏捷开发 的体会
    
    </summary>
    
      <category term="managements" scheme="www.merlinblog.site/categories/managements/"/>
    
    
      <category term="开发管理" scheme="www.merlinblog.site/tags/%E5%BC%80%E5%8F%91%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>集中谈谈C++资源管理</title>
    <link href="www.merlinblog.site/2017/08/25/cpp-resource-manage.html"/>
    <id>www.merlinblog.site/2017/08/25/cpp-resource-manage.html</id>
    <published>2017-08-25T02:24:19.000Z</published>
    <updated>2017-10-09T11:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>C++中谈资源管理, 已经不是一天两天的事儿了, 感觉心好累. 看看大佬们为了资源管理(偷懒), 都做哪些事儿.</p><p>由于以前已经写了好多篇了, 这里算作汇总吧:</p><ul><li>RAII</li><li>PIMPL</li><li>智能指针(引用计数,标记擦除)</li><li>GC</li><li>对齐问题</li><li>malloc/free</li><li>new/delete (placement new)</li><li>分配器</li><li>内存池</li></ul><a id="more"></a><blockquote><p>还是有时间再写吧…</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      白话一下资源管理, 虽然以前就已经谈过很多次了.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="cpp" scheme="www.merlinblog.site/tags/cpp/"/>
    
  </entry>
  
  <entry>
    <title>网络开发中常用的工具</title>
    <link href="www.merlinblog.site/2017/08/23/net-work-tools.html"/>
    <id>www.merlinblog.site/2017/08/23/net-work-tools.html</id>
    <published>2017-08-23T10:48:19.000Z</published>
    <updated>2017-10-09T11:01:44.882Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>网络中常用的Linux命令, 主要涉及, <code>time</code>, <code>dd</code>, <code>pv</code>, <code>nc</code>或者全称<code>netcat</code>, 还有tcpdump</p><blockquote><p><code>tcpdump</code>以后有时间再说, 这一篇写简单点.</p></blockquote></blockquote><p>本篇就算linux常用工具的一个补充吧.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/net-tools.png" alt="post-cover"></p><h1 id="time"><a href="#time" class="headerlink" title="time"></a>time</h1><p>这个太熟悉了</p><pre><code>real    0m0.000suser    0m0.000ssys     0m0.000s</code></pre><p>主要是来统计某个程序运行的时间, 分为<code>用户时间</code>和<code>内核时间</code>.</p><h1 id="dd"><a href="#dd" class="headerlink" title="dd"></a>dd</h1><p>我以前在加密打包的时候用到过<code>dd</code>工具, 它比较适合处理<code>字节块</code>. </p><p>例如你可以拿它去测量<code>拷贝数据的时间</code>, 即磁盘跑分:</p><pre><code>dd if=/dev/zero of=sun.txt bs=100M count=10</code></pre><p>从/dev/zero不断拿0字符, 拿100M大小的数据块x1, 写到sun.txt, 统计操作所花费的时间, 以及写入速度.<br>其中<code>bs</code> 代表块, 它可以使用下面的单位:</p><pre><code>字节（1B）    c 字（2B）    w 块（512B）    b 千字节（1024B）    k 兆字节（1024KB）    M 吉字节（1024MB）    G</code></pre><p>当然还有其他参考, 不过我常用的就这么多了.</p><h1 id="nc"><a href="#nc" class="headerlink" title="nc"></a>nc</h1><blockquote><p>或者叫做 netcat, 不同的Linux或者Unix可能有不同的实现版本, 所对应的参数也不一样.</p></blockquote><p>常用的参数如下:</p><pre><code>nc -h[v1.10-41+b1]connect to somewhere:    nc [-options] hostname port[s] [ports] ... listen for inbound:    nc -l -p port [-options] [hostname] [port]options:    -c shell commands    as `-e&#39;; use /bin/sh to exec [dangerous!!]    -e filename        program to exec after connect [dangerous!!]    -b            allow broadcasts    -g gateway        source-routing hop point[s], up to 8    -G num            source-routing pointer: 4, 8, 12, ...    -h            this cruft    -i secs            delay interval for lines sent, ports scanned    -k                      set keepalive option on socket    -l            listen mode, for inbound connects    -n            numeric-only IP addresses, no DNS    -o file            hex dump of traffic    -p port            local port number    -r            randomize local and remote ports    -q secs            quit after EOF on stdin and delay of secs    -s addr            local source address    -T tos            set Type Of Service    -t            answer TELNET negotiation    -u            UDP mode    -v            verbose [use twice to be more verbose]    -w secs            timeout for connects and final net reads    -C            Send CRLF as line-ending    -z            zero-I/O mode [used for scanning]port numbers can be individual or ranges: lo-hi [inclusive];hyphens in port names must be backslash escaped (e.g. &#39;ftp\-data&#39;).</code></pre><p>解释一下:</p><pre><code>[-hlnruz][-g&lt;网关...&gt;][-G&lt;指向器数目&gt;][-i&lt;延迟秒数&gt;][-o&lt;输出文件&gt;][-p&lt;通信端口&gt;][-s&lt;来源位址&gt;]           [-v...][-w&lt;超时秒数&gt;][主机名称][通信端口...]其他参数:    -g&lt;网关&gt; 设置路由器跃程通信网关，最丢哦可设置8个。    -G&lt;指向器数目&gt; 设置来源路由指向器，其数值为4的倍数。    -h 在线帮助。    -i&lt;延迟秒数&gt; 设置时间间隔，以便传送信息及扫描通信端口。    -l 使用监听模式，管控传入的资料。    -n 直接使用IP地址，而不通过域名服务器。    -o&lt;输出文件&gt; 指定文件名称，把往来传输的数据以16进制字码倾倒成该文件保存。    -p&lt;通信端口&gt; 设置本地主机使用的通信端口。    -r 乱数指定本地与远端主机的通信端口。        -s&lt;来源位址&gt; 设置本地主机送出数据包的IP地址。    -u 使用UDP传输协议。    -v 显示指令执行过程。    -w&lt;超时秒数&gt; 设置等待连线的时间。    -z 使用0输入/输出模式，只在扫描通信端口时使用。    -q 超时退出时间</code></pre><p>nc 往指定端口发送数据, 例如:<br><code>nc localhost 3306 &lt; xxx.txt</code>  向本机的3306端口发送数据<br>或者<br><code>dd if=/dev/zero bs=100M count=10 | nc localhost 3306</code> 向本机3306端口发送数据, 同时dd统计.</p><p>当然你用time统计也可以:<br><code>time nc localhost 3306 &lt; xxx.txt</code></p><p>别人(与我IP不同)要取得数据?<br>直接连接我的IP, 3306端口即可, 例如: <code>nc &lt;my_ip&gt; 3306 &gt; xxx.txt</code>,<br>如果是发送的压缩文件, 或者发送的识货用tar处理了, 例如:<br><code>tar -zcvf - xxx.txt | pv | nc -l -p 3306 -q 5</code>, 那么接收的时候要进行相应的解压缩, 例如:<br><code>nc &lt;target_ip&gt; 3306 | pv | tar -zxvf -</code> </p><p>如果是我向你的端口写, 那么你直接连接你的端口即可获取数据, 例如:<br>写:<br><code>nc &lt;ur ip&gt; &lt;ur port&gt; &lt; /dev/zero</code> 或者你可以使用dd, 做一下网络带宽写出速度统计<br><code>dd if=/dev/zero bs=1MB count=1000 | nc &lt;ur_ip&gt; &lt;ur_port&gt;</code></p><p>接收端, 就非常好办了:<br><code>nc -l &lt;port&gt; &gt;/dev/null</code> 或者看看进度 <code>nc -l  &lt;port&gt; |pv -W &gt; /dev/null</code><br>(你要保留文件的话, 就不要把它重定向到<code>/dev/null</code>了)</p><blockquote><p>注意这里的接收端, 不要写ip选项 (我实验了一下, 如果指定了<code>localhost</code>返回会出问题)</p></blockquote><p>当然也可以进行端口扫描(即<code>-z</code>选项):</p><pre><code>nc -v -z -w2 192.168.0.3 1-100     扫描192.168.0.3 的端口 范围是 1-100.nc -u -z -w2 192.168.0.1 1-1000    扫描192.168.0.3 的端口 范围是 1-1000不过扫描的是UDP端口nc -nv 192.168.0.1 80              扫描 80端口</code></pre><blockquote><p>查看目录下文件大小: <code>ls -lh</code>;   查看文件的大小: <code>du -sh &lt;filename&gt;</code></p></blockquote><h1 id="pv"><a href="#pv" class="headerlink" title="pv"></a>pv</h1><p>pv, 即pip viewer; 它会显示当前在命令行执行的命令的进度信息 <code>sudo apt-get install pv</code> .<br>pv 命令提供了多种显示选项开关: </p><ul><li><code>-p</code>来显示百分比</li><li><code>-t</code>来显示时间</li><li><code>-r</code>表示传输速率</li><li><code>-e</code> 代表eta（LCTT 译注：估计剩余的时间）</li></ul><blockquote><p>好事是你不必记住某一个选项，因为默认这几个选项都是启用的。但是，如果你只要其中某一个信息，那么可以通过控制这几个选项来完成任务。</p></blockquote><p>这里还有一个<code>-n</code>选项来允许 pv 命令显示整数百分比，在标准错误输出上每行显示一个数字，用来替代通常的可视进度条, 但是会分行打印, <code>个人不推荐</code></p><p>接下来还有一个命令行选项，<code>-L</code> 可以让你修改 pv 命令的传输速率。举个例子，使用 -L 选项来限制传输速率为2MB/s。</p><pre><code>pv -L 2m xxx.mkv &gt; ./Desktop/yyy.mkv</code></pre><p>这条命令等价于 <code>cp xxx.mkv &gt; ./Desktop/yyy.mkv | pv -L 2m</code><br>(Pv测试管道前面紧邻的任务)</p><p>另一个pv 可以帮上忙的情景是压缩文件。这里有一个例子可以向你解释如何与压缩软件Gzip 一起工作。</p><p><code>pv /media/himanshu/1AC2-A8E3/fnf.mkv | gzip &gt; ./Desktop/fnf.log.gz</code></p><p>但是注意, 凡是不加密的传输, 都不安全.</p><blockquote><p><code>nc</code>和<code>pv</code>传输文件? 还是使用<code>SSH</code>或者<code>SCP</code>吧, 这样比较安全.</p><blockquote><p>emacs的<code>TRAMP</code>也不错哦.</p></blockquote></blockquote><h1 id="tcpdump"><a href="#tcpdump" class="headerlink" title="tcpdump"></a>tcpdump</h1><p>这个在调试, 管理连接方面, 非常有用, 也是网络编程中, 最最常用的东西, 比如说, 你可能会碰上数据<code>鬼打墙</code>的状况, 这可能就是<code>TCP自连接</code>问题, 自己连接自己, 然后收发数据.<br>(发现这个现象, 查看一下连接, 断开, 重置连接就好了)</p><blockquote><p>关于tcpdump的经验总结, 本月有机会, 再说.</p></blockquote><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      整理和重新发布一下网络编程中的调试&amp;测试工具.
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="网络" scheme="www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="linux" scheme="www.merlinblog.site/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>Thrift</title>
    <link href="www.merlinblog.site/2017/08/22/thrift.html"/>
    <id>www.merlinblog.site/2017/08/22/thrift.html</id>
    <published>2017-08-22T00:08:22.000Z</published>
    <updated>2017-09-26T05:41:37.958Z</updated>
    
    <content type="html"><![CDATA[<p>有同行老早就在实践这个库了.毫无疑问, 本文是继 protobuffer 之后, 又要花大力气讲解的一个(FB的)库(而且绝对是值得你花一个晚上自习看看的库). 不过可惜的是, 实际开发中它并不如pb应用广泛, 可能很大一个原因是因为太重了, 而且代码还依赖了外部库boost, libevent等, 相比之下, RESTful的做法就会简单很多.(我不得不说, 花了很多时间在踩开源的坑…最终结论, 于开源来说, Thrift可能不是最好的选择) </p><p>还是强调一些最基本的概念吧:</p><blockquote><p>框架的协议是指传输时候的编码方式(而不是网络协议); 框架的传输方式包括文件, 缓存buffer, 压缩二进制或者文本, 以及其他需要服务器端同步阻塞或者非阻塞操作,多线程或者异步IO支持的方式(因为可能传输方式使用了一些同步或者异步的IO), 传输方式也会(包括)指定传输的网络协议. 服务器类型是指服务器的工作模式, 是同步阻塞处理请求还是非阻塞操作(轮询检查IO-fd), 是否支持多线程模型, 还是异步多路IO.</p></blockquote><p>本篇也作为 <code>跨语言编程实践</code> 的最后一篇, 后期可能会有更新(主要是补充 <code>源码分析</code> 部分).</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>From Wikipedia, the free encyclopedia:</p><blockquote><p>Thrift is an interface definition language and binary communication protocol that is used to define and create services for numerous languages.</p></blockquote><p>wiki上的一句话概括了: 用于使用接口定义语言和二进制通信协议定义并创建跨语言服务的框架.(通信格式是二进制, 和pb一样)</p><p>实际上, 谈thrift更多的也是从服务架构, 传输, RPC上说它的作用(可以简单把RPC理解成非同一进程调用, 非异步网络情况下的阻塞调用), 简单的了解可以说它如何构建服务, 深入的可以分析一下它的rpc调用机制. 总之, 你不仅可以了解它的序列化机制, c-s服务模型, 传输体系, 还能学习它内部代码生成引擎. (看样子是应该不支持协程的)</p><p>(有时间可以学习一下它的源码)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>下面记录在Ubuntu64上进行编译安装的过程, 我不得不说, 编译安装是个很坑爹的过程, 所有我接触过的开源产品里面, thrift做的支持最差了.<br>安装绝对没有那么顺利, 上述任何过程出错, 请根据相关提示拍错, 下面是我遇到的:</p><p>首先确保你的环境里面安装了 libssl-dev, libtool, flex, bison(即yacc), pkg-config, boost和libevent(a minimal RPC framework), 之后再去安装thrift. 下面是一个详细记录.</p><pre><code># 先安装我缺失的# automake$ sudo apt-get install automake# yacc: command not found$ sudo apt-get install -y byacc# flex: command not found$ sudo apt-get install -y flex# 安装libevent-dev$ sudo apt-get install libevent-dev# 安装ssl$ sudo apt-get install libssl-dev# 下载$ wget http://mirror.bit.edu.cn/apache/thrift/0.10.0/thrift-0.10.0.tar.gz -P Desktop/apps$ tar xzvf thrift-0.10.0.tar.gz$ cd thrift-0.10.0# 配置$ ./configure</code></pre><p>注意一下日志, 如果你还要编译其他语言的, 请注意安装相应的库, 比如我要再去装Go语言支持, 那么我就要在日志中找Go语言相关的依赖库.</p><pre><code>thrift 0.10.0Building Plugin Support ...... : yesBuilding C++ Library ......... : yesBuilding C (GLib) Library .... : yesBuilding Java Library ........ : yesBuilding C# Library .......... : noBuilding Python Library ...... : yesBuilding Ruby Library ........ : noBuilding Haxe Library ........ : noBuilding Haskell Library ..... : noBuilding Perl Library ........ : noBuilding PHP Library ......... : noBuilding Dart Library ........ : noBuilding Erlang Library ...... : noBuilding Go Library .......... : yesBuilding D Library ........... : noBuilding NodeJS Library ...... : yesBuilding Lua Library ......... : noC++ Library:   Build TZlibTransport ...... : yes   Build TNonblockingServer .. : yes   Build TQTcpServer (Qt4) .... : yes   Build TQTcpServer (Qt5) .... : noJava Library:   Using javac ............... : javac   Using java ................ : java   Using ant ................. : /usr/bin/antPython Library:   Using Python .............. : /usr/bin/python   Using Python3 ............. : /usr/bin/python3Go Library:   Using Go................... : /usr/lib/go-1.7/bin/go   Using Go version........... : go version go1.7.4 linux/amd64NodeJS Library:   Using NodeJS .............. : /home/merlin/Software/node-v6.11.2-linux-x64/bin/node   Using NodeJS version....... : v6.11.2If something is missing that you think should be present,please skim the output of configure to find the missingcomponent.  Details are present in config.log.</code></pre><p>但是注意:</p><blockquote><p>你支持的库越多, 后期编译出问题的可能性越大.</p></blockquote><p>最好禁用一些选项, 和自定义一些选项.</p><pre><code>./configure --libdir=/usr/local/lib --without-java --without-python</code></pre><p>编译安装</p><pre><code>$ make -j8 &amp;&amp; make check# 跨语言测试$ sh test/test.sh# 编译$ sudo make install</code></pre><p>查看一下目录, 发现勉强还是安装成功了.</p><pre><code>ls /usr/local/lib | grep libthriftlibthrift-0.10.0.jarlibthrift-0.10.0-javadoc.jarlibthrift-0.10.0.solibthrift.alibthriftc.alibthrift_c_glib.alibthrift_c_glib.lalibthrift_c_glib.solibthrift_c_glib.so.0libthrift_c_glib.so.0.0.0libthriftc.lalibthriftc.solibthriftc.so.0libthriftc.so.0.0.0libthrift.lalibthriftnb-0.10.0.solibthriftnb.alibthriftnb.lalibthriftnb.solibthriftqt-0.10.0.solibthriftqt.alibthriftqt.lalibthriftqt.solibthrift.solibthriftz-0.10.0.solibthriftz.alibthriftz.lalibthriftz.so$ ls /usr/local/include | grep thriftthrift$ which thrift /usr/local/bin/thrift</code></pre><p>(先跑起来再说)</p><p>编译日志里有一大段比较重要:</p><pre><code>If you ever happen to want to link against installed librariesin a given directory, LIBDIR, you must either use libtool, andspecify the full pathname of the library, or use the `-LLIBDIR&#39;flag during linking and do at least one of the following:   - add LIBDIR to the `LD_LIBRARY_PATH&#39; environment variable     during execution   - add LIBDIR to the `LD_RUN_PATH&#39; environment variable     during linking   - use the `-Wl,-rpath -Wl,LIBDIR&#39; linker flag   - have your system administrator add LIBDIR to `/etc/ld.so.conf&#39;See any operating system documentation about shared libraries formore information, such as the ld(1) and ld.so(8) manual pages.</code></pre><p>去检查一下<code>/etc/ld.so.conf</code>是否已经囊括了你安装库的目录.</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>一般的开发流程是这样的(和pb类似):</p><ul><li>规矩需求编写thrift接口定义文件</li><li>使用thrift binary为不同的语言生成代码</li><li>根据需求, 修改生成的代码(主要是Server端骨架代码), 编写实际的业务逻辑</li><li>编译, 集成</li></ul><p>通过IDL, 即thrft描述文件, 对其中定义的<code>数据结构</code>, 如struct等, 以及传输业务逻辑, 根据不同的运行环境构建相应的代码. 至于内部序列化, 压缩, 文本交互, 并发, 这个在其框架内部已经解决, 描述起来就是下图:<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_sequence.jpg" alt=""></p><p>整个过程非常清晰, 只是中间有一些小细节需要注意一下, 比如说thrift文件怎么写才规范, 怎么生成代码, 运行生成的代码加入实际业务逻辑等. 下面给出一个案例.(我习惯用cpp语言, 当然别的语言也有案例, 暂时小的案例用cpp)</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="rpc"><a href="#rpc" class="headerlink" title="rpc"></a>rpc</h3><p>按照上面讲的流程, 先跑起来; 为了简单, 我先不管目录结构. 下面的例子, 演示一下rpc.</p><p>先创建必要的目录</p><pre><code>$ mkdir thrift_test$ cd thrift_test$ touch ping.thrift</code></pre><p>ping.thrift的代码如下:</p><pre><code># ping.thrift/** * Thrift files can namespace, package, or prefix their output in various * target languages. */namespace cpp pingtest/** * Defining a class named pinger */service pinger{  /**   * client calls ping method to make sure service process is active or dead   */   void ping()}</code></pre><p>(注意我使用的关键词 <code>service</code>)<br>代码比较简单, 然后就在本目录下生成server端的骨架(框架模板代码):</p><pre><code>$ thrift --gen cpp -o . ping.thrift $ tree -L 2.├── gen-cpp│   ├── ping_constants.cpp│   ├── ping_constants.h│   ├── pinger.cpp│   ├── pinger.h│   ├── pinger_server.skeleton.cpp│   ├── ping_types.cpp│   └── ping_types.h└── ping.thrift1 directory, 8 files</code></pre><p>也就是说服务器端的模板代码全部产品了, 但是这些代码基本不涉及业务, 所以还要写自己的业务server端代码来调用上述框架代码, 但是这里仅仅是演示, 不需要写了, 直接利用<code>pinger_server.skeleton.cpp</code> 这个主文件就好(这个文件你可以改名为server.cpp, 它就是server端的主文件, 含有main函数).</p><pre><code>$ cp gen-cpp/* .$ cat pinger_server.skeleton.cpp</code></pre><p>代码如下: (中间我就加了一句打印)</p><pre><code class="c++">// This autogenerated skeleton file illustrates how to build a server.// You should copy it to another filename to avoid overwriting it.#include &quot;pinger.h&quot;#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using boost::shared_ptr;using namespace  ::pingtest;class pingerHandler : virtual public pingerIf { public:  pingerHandler() {    // Your initialization goes here  }  /**   * client calls ping method to make sure service process is active or dead   */  void ping() {    // Your implementation goes here    printf(&quot;ping\n&quot;);  }};int main(int argc, char **argv) {  //默认9090端口  int port = 9090;  //下面是一些通讯必要的协议等内容  shared_ptr&lt;pingerHandler&gt; handler(new pingerHandler());  shared_ptr&lt;TProcessor&gt; processor(new pingerProcessor(handler));  shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));  shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());  shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());  //创建一个TSimpleServer对象， 虽然效率不高， 但是仅仅做远端检查足够了  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);  server.serve();//开始监听了  return 0;}</code></pre><p>好了, 先把server端可执行文件编译出来:</p><pre><code>$ g++ -g -Wall -std=c++11  -lthrift ./*.cpp -o server</code></pre><p>如果你没有配置环境, 完整的应该是这样:</p><pre><code>g++ -g -Wall -std=c++11 -I/usr/local/include -L/usr/local/lib -lthrift ./*.cpp -o server</code></pre><p>如果不是需要客户端调用, 可以用curl或者nc进行调试, 但是这里是RPC, 不仅仅是通讯或者交换数据, 所以这里客户端要手写 <code>client.cpp</code>. 代码如下:</p><pre><code class="c++">#include &lt;iostream&gt;#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/transport/TSocket.h&gt;#include &lt;thrift/transport/TTransportUtils.h&gt;#include &quot;pinger.h&quot; //使用pingerClient对象using namespace std;using namespace apache::thrift;using namespace apache::thrift::protocol;using namespace apache::thrift::transport;using namespace pingtest;int main(void){  //连接远端服务器  boost::shared_ptr&lt;TTransport&gt; socket(new TSocket(&quot;localhost&quot;, 9090));  boost::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));  boost::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));  pingerClient client(protocol);  try {    transport-&gt;open();    client.ping();//远端调用    transport-&gt;close();  } catch (TException&amp; tx) {    cout &lt;&lt; &quot;ERROR: &quot; &lt;&lt; tx.what() &lt;&lt; endl;  }  return 0;}</code></pre><p>编译</p><pre><code>g++ -g -Wall -std=c++11  -lthrift client.cpp ping_constants.cpp pinger.cpp ping_types.cpp  -o client</code></pre><p>运行一下(开两个端口, 先开server, 在开client)</p><pre><code>$ ./server pingping</code></pre><p>server一直运行(死循环), 然后client运行一次, server端打印ping一次.</p><p>远端调用就是这么简单? 其实是骨架代码做了很多, 先不探讨源码(这里只说简单的案例)</p><p>最后补充关于目录组织, makefile, 请按照你们研发经理的要求来.</p><h3 id="数据传递"><a href="#数据传递" class="headerlink" title="数据传递"></a>数据传递</h3><p>上面那个仅仅有远端调用, 没有实际的c-s传输数据, 下面这个案例带有数据传递.<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_c_s_1.jpg" alt="数据传递"><br>先写thrift接口文件:</p><pre><code># transfer.thriftnamespace cpp transfertestenum ResponseState{    StateOk = 0,    StateError = 1,    StateEmpty = 2}/*请求时的数据*/struct Request{    1: i32 studentID = 0}/*响应时的数据*/struct Response{    1: i32 studentID = 0,    2: string name,    3: list&lt;string&gt; infos,    4: ResponseState state}/*远端调用*/service TransferService{    Response getStudentInfo(1: Request request); }</code></pre><p>注意 <code>Response getStudentInfo(1: Request request)</code> 原型和生成的代码有区别, 当然你的IDL文件里面写很多crud的servcie都没有关系, 根据你的业务需要来.</p><p>生成框架代码.</p><pre><code>$ thrift --gen cpp transfer.thrift$ cp gen-cpp/* .$ ll总用量 68drwxr-xr-x 3 merlin merlin  4096 9月   2 17:23 .drwxr-xr-x 4 merlin merlin  4096 9月   2 17:11 ..drwxr-xr-x 2 merlin merlin  4096 9月   2 17:22 gen-cpp-rw-r--r-- 1 merlin merlin   305 9月   2 17:23 transfer_constants.cpp-rw-r--r-- 1 merlin merlin   393 9月   2 17:23 transfer_constants.h-rw-r--r-- 1 merlin merlin 12831 9月   2 17:23 TransferService.cpp-rw-r--r-- 1 merlin merlin  9888 9月   2 17:23 TransferService.h-rw-r--r-- 1 merlin merlin  1423 9月   2 17:23 TransferService_server.skeleton.cpp-rw-r--r-- 1 merlin merlin   433 9月   2 17:20 transfer.thrift-rw-r--r-- 1 merlin merlin  7347 9月   2 17:23 transfer_types.cpp-rw-r--r-- 1 merlin merlin  3205 9月   2 17:23 transfer_types.h</code></pre><p>修改<code>TransferService_server.skeleton.cpp</code>代码.</p><pre><code class="c++">// TransferService_server.skeleton.cpp#include &quot;TransferService.h&quot;#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/server/TSimpleServer.h&gt;#include &lt;thrift/transport/TServerSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;using namespace ::apache::thrift;using namespace ::apache::thrift::protocol;using namespace ::apache::thrift::transport;using namespace ::apache::thrift::server;using boost::shared_ptr;using namespace  ::transfertest;class TransferServiceHandler : virtual public TransferServiceIf { public:  TransferServiceHandler() {    // Your initialization goes here  }  void getStudentInfo(Response&amp; _return, const Request&amp; request) {    // Your implementation goes here    printf(&quot;getStudentInfo called\n&quot;);    //处理请求数据， 发送响应给客户端    printf(&quot;client request studentID: %d\n&quot;, request.studentID);    //给Response设置数据    _return.studentID = request.studentID;    _return.name = &quot;merlin&quot;;    _return.infos.push_back(&quot;信息1&quot;);    _return.infos.push_back(&quot;信息2&quot;);    _return.state = ResponseState::StateOk;    printf(&quot;data has benn sent to client\n&quot;);  }};int main(int argc, char **argv) {  int port = 9090;  shared_ptr&lt;TransferServiceHandler&gt; handler(new TransferServiceHandler());  shared_ptr&lt;TProcessor&gt; processor(new TransferServiceProcessor(handler));  shared_ptr&lt;TServerTransport&gt; serverTransport(new TServerSocket(port));  shared_ptr&lt;TTransportFactory&gt; transportFactory(new TBufferedTransportFactory());  shared_ptr&lt;TProtocolFactory&gt; protocolFactory(new TBinaryProtocolFactory());  TSimpleServer server(processor, serverTransport, transportFactory, protocolFactory);  server.serve();  return 0;}</code></pre><p>函数<code>void getStudentInfo(Response&amp; _return, const Request&amp; request)</code>原型和我们在thrift里面指定的有区别.</p><p>编译服务端:</p><pre><code>$ g++ -g -Wall -std=c++11 *.cpp -o server -lthrift</code></pre><p>然后在写客户端client.cpp, 发送请求:</p><pre><code class="c++">#include &lt;thrift/protocol/TBinaryProtocol.h&gt;#include &lt;thrift/transport/TSocket.h&gt;#include &lt;thrift/transport/TBufferTransports.h&gt;#include &lt;thrift/protocol/TCompactProtocol.h&gt;#include &quot;TransferService.h&quot; //使用TransferServiceClient对象using namespace ::transfertest; //Request, Responseusing namespace apache::thrift;using namespace apache::thrift::protocol;using namespace apache::thrift::transport;using boost::shared_ptr;int main(int argc, char **argv){  //如果和服务端信息不匹配就报错  boost::shared_ptr&lt;TSocket&gt; socket(new TSocket(&quot;localhost&quot;, 9090));  boost::shared_ptr&lt;TTransport&gt; transport(new TBufferedTransport(socket));  boost::shared_ptr&lt;TProtocol&gt; protocol(new TBinaryProtocol(transport));  //设置响应的数据(发给服务端, 其实是rpc)  Request quest;  quest.studentID = 1;  //用于接收服务端信息  Response resp;  //打开连接  transport-&gt;open();  TransferServiceClient client(protocol);  client.getStudentInfo(resp, quest);  //关闭连接  transport-&gt;close();  //输出信息  printf(&quot;get response: ID=%d  name=%s  state=%d\n&quot;, resp.studentID,   resp.name.c_str(), resp.state);  return 0;}</code></pre><p>编译</p><pre><code>$ g++ -g -Wall -std=c++11 -lthrift client.cpp \ transfer_constants.cpp transfer_types.cpp TransferService.cpp -o client</code></pre><p>运行一下, 效果如下:</p><pre><code>$ ./server getStudentInfo calledclient request studentID: 1data has benn sent to client^C##另外一个terminal$ ./clientget response: ID=1  name=merlin  state=0</code></pre><p>这个例子就这样了, 当然官网还有一个类似的, 稍稍复杂的 <a href="https://thrift.apache.org/tutorial/cpp" target="_blank" rel="external">例子</a> , 就不再多说了.</p><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p>本段内容是对 <a href="https://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="external">thrift-wiki</a> 架构部分的剖析.</p><p>总体的架构图如下:<br><img src="http://omotkhw3y.bkt.clouddn.com/Apache_Thrift_architecture.png" alt="架构"></p><p>可以看到, thrift实际跨了两层: 应用层和传输层(有些博文非要把它的那个颜色认为是不同的层, 我也就无话可说了), 也就是我们再网络编程中最长需要打交道的, 并且<code>read/write</code>以下的部分, 即TProtocol, TTransport属于thrift框架的传输体系, 如果不是研究源码, 可以暂时不关注(使用的时候具体选择以下使用哪种类型的传输协议).  实际上研究源码, 发现也就是我们通常需要手工完成的:</p><ul><li>服务器端这里还有一个TProcessor负责读写 消息体等操作(客户端对应TProcessor的是TriftClient)</li><li>服务器端这里还有Tserver, 负责接收Client的请求, 并将请求转换给TProcessor</li><li>编码封装 (TProtocol) 把用户的数据封装成一个 消息体, 通常是二进制的; (注意原来的数据是带有类型的, 消息体的数据只管encode编码字节数)</li><li>字节流转换 (TTransport) 把消息体以字节流的方式发送给底层IO(或者从其接收字节流再转换成消息体), 到底是流式IO还是文件IO; 每一种底层IO对应这里的一种TTransport</li><li>底层IO (socket/file/zip)</li></ul><p>我们真正需要处理(修改)的也就是<code>Input code</code>部分和<code>Service Client</code>.</p><p>如下图:(详细架构)<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_real.jpg" alt=""></p><p>准确说 <code>TProtocol</code>定义了传输协议规范(编码规范-大体上分为二进制和文本方式), <code>TTransport</code>定义了传输数据标准(根据不同的方式把说句做转换), 以及服务器类型, 当然服务器类型不仅仅包含IO类型. </p><p>Processor(或者TProcessor)负责对Client的请求做出响应, 包括 RPC 请求转发(TProcessor.process), 调用参数解析和用户逻辑调用, 返回值写回等处理步骤, 也包括thrift消息结构体的读取和写入. Processor是服务器端从Thrift框架转入用户业务逻辑的关键流程, 你简单理解成这个复杂系统中统一的输入和输出处理即可.(针对详细结构体和远端调用)</p><p>其模块设计, 层次界限非常到位.</p><p>强调一些最基本的概念.</p><blockquote><p>框架的协议是指编码方式; 框架的传输方式包括文件,缓存buffer, 压缩或者需要服务器端同步异步工作支持的IO类型(因为传输方式使用了一些同步或者异步的IO), 传输方式也会指定传输协议. 服务器类型是指服务器的工作模式, 是同步阻塞处理请求还是非阻塞操作, 是否支持多线程模型, 还是异步多路IO.</p></blockquote><h3 id="协议规范"><a href="#协议规范" class="headerlink" title="协议规范"></a>协议规范</h3><p>Thrift可以让用户选择客户端与服务端之间传输通信协议的类别，在传输协议上总体划分为文本(text)和二进制(binary)传输协议，为节约带宽，提高传输效率，一般情况下使用二进制类型的传输协议为多数，有时还会使用基于文本类型的协议，这需要根据项目/产品中的实际需求.<br>常用协议有以下几种: </p><ul><li>BinaryProtocol: 二进制编码格式进行数据传输使</li><li>TCompactProtocol: 高效率的、密集的二进制编码格式进行数据传输</li><li>TJSONProtocol: 使用 JSON 数据编码协议进行数据传输</li></ul><p>wiki中说到的其他的:</p><ul><li>TDebugProtocol(调试时使用的文本格式)</li><li>TDenseProtocol(类似TCompactProtocol, 但不包含 meta info)</li><li>TSimpleJSONProtocol(drops metadata using JSON, 所以只用于只读解析).</li></ul><h3 id="传输标准"><a href="#传输标准" class="headerlink" title="传输标准"></a>传输标准</h3><p>这里的传输标准通俗说就是读写方式, 可能有一些方式需要服务器以同步或者异步的工作形式支持, 也可能有些形式仅用于服务端或者客户端等, 比如下面名字中带有Server字样的, 仅用于服务器端. (不强调Server字样的, 一般既可以用于服务器端也可以用于客户端)</p><p>由于一些语言有限制,或者标准不同, thrift定义的标准在具体语言中可能处理情况不一样.</p><ul><li>TSocket : 使用阻塞式 I/O 进行传输，是最常见的模式(就是简单的阻塞IO: read, write)</li><li>TServerSocket：非阻塞型 socket 传输, 轮询的时候, 没有IO读写就直接返回, 但一旦 accecpt 到, 还是阻塞读写, 即TSocket(即阻塞型 socket).</li></ul><p>wiki里面也谈到了其他种类:(可能不太常用)</p><ul><li>TFDTransport 是非常简单地写数据到文件和从文件读数据，它的 write 和 read 函数都是直接调用系统函数 write 和 read 进行写和读文件</li><li>TSimpleFileTransport 直接继承 TFDTransport，没有添加任何成员函数和成员变量, 算是对TFDTransport的轻量扩展</li><li>TFileTransport - (一些写线程, 一个读线程)以文件的方式传输, 主线程负责将事件入列，写线程将事件入列，并将事件里的数据写入磁盘.(继承自TTransport)</li><li>TBufferedTransport - 带缓存的传输形式(需要使用non-blocking IO)</li><li>TFramedTransport -  带缓存(以帧的)形式传输(要求使用非阻塞IO, 可能因为帧指定了长度; 头4个字节指定了长度; int32_t)</li><li>TMemoryTransport - 这个使用内存做IO(用于程序内部通信用，不涉及任何网络I/O)<ul><li>OBSERVE模式，不可写数据到缓存</li><li>TAKE_OWNERSHIP模式，需负责释放缓存</li><li>COPY模式, 拷贝外面的内存块到TMemoryBuffer</li></ul></li><li>TZlibTransport - 压缩传输需要配合其他传输协议一起.</li></ul><p>(一般用于缓存读写的方式是TMemoryTransport, 没有调用flush方法之前, 不涉及网络)</p><p>还有2个比较特殊的:</p><ul><li>TSSLSocket 继承 TSocket,阻塞型 socket, 用于<code>客户端</code>. (采用 openssl 的接口进行读写数据)<br>checkHandshake()函数调用 SSL_set_fd 将 fd 和 ssl 绑定在一起，之后就可以通过 ssl 的 SSL_read和SSL_write 接口进行读写网络数据</li><li>TSSLServerSocket 继承 TServerSocket, 非阻塞型 socket, 用于<code>服务器端</code>. accecpt 到的 socket 类型都是 TSSLSocket 类型.</li></ul><p>当然, 也提供了基于 <code>HTTP协议</code> 的传输类型: (继承 THttpTransport, 基于Http1.1)</p><ul><li>THttpClient 用于客户端</li><li>THttpServer 用于服务器端<br>两者都调用下一层 <code>TTransport</code> 类进行读写操作, 均用到 TMemoryBuffer 作为读写缓存, 只有调用 flush() 函数才会将真正调用网络 I/O 接口发送数据; 并且这里的TTransport为上层提供的类似多态的方法, 通过TTransport接口可以调用其子类的不同实现. (TTransport 是所有 Transport 类的父类; 而THttpTransport是Transport的子类)</li></ul><h3 id="服务端类型"><a href="#服务端类型" class="headerlink" title="服务端类型"></a>服务端类型</h3><p>根据传输标准的不同, 并发程度的要求, 也有多种不同类型的服务器(也就是服务端的工作模式), 并且生成不同语言代码时, 实现也不一样, 比如说非阻塞IO, Java使用NIO, 而C++借助Lievent库. 根据不同场合选择不同的server类型, 需要对网络模型非常熟悉.</p><p>下面是主要的服务端类型:(源码剖析的时候会再说)</p><ul><li>TSimpleServer : 单线程服务器端使用标准的阻塞式 I/O</li><li>TNonblockingServer : 单线程异步IO(多路轮询检测, 处理读写的时候还是阻塞IO), 该类型Server必须使用TFramedTransport.</li><li>THsHaServer : select轮询 + 线程池工作线程处理读任务, 写任务还是阻塞IO. (半同步半异步)</li><li>TThreadPoolServer : 线程池+标准的阻塞式 I/O</li><li>TThreadedSelectorServer : AcceptThread + SelectorThread + SelectorThreadLoadBalancer(调度器) + ExecutorService(工作线程池)</li></ul><p>(如果看源码, 我局的最后这一种高级方式, 值得一看)</p><p>TSimpleServer 接受一个连接，处理连接请求，直到客户端关闭了连接，它才回去接受一个新的连接。正因为它只在一个单独的线程中以阻塞 I/O 的方式完成这些工作，所以它只能服务一个客户端连接，其他所有客户端在被服务器端接受之前都只能等待. 可以看到TSimpleServer基本只能用于测试.</p><p>TThreadPoolServer 如果有连接请求来了, 那么从线程池中拿一个工作线程来应对网络IO事件, 主线程是非阻塞的, worker线程则是使用阻塞IO. (但是吞吐量是原来的N倍, N为work线程的个数)</p><p>TNonblockingServer 这种模式对应linux网络编程中的select模型; 所以socket都注册到select, 然后一个线程中通过seletor循环监控所有的socket，每次selector结束时，处理所有的处于就绪状态的socket，对于有数据到来的socket进行数据读取操作，对于有数据发送的socket则进行数据发送，对于监听socket则产生一个新业务socket并将其注册到selector中. (如果没有则进行下一次轮询, 如果有, 就必须处理完相关的socket IO才能进行下一次轮询) 该模式比TSimpleServer好的地方在于, 原来是单线程阻塞, 即一旦连接上了, 非要你IO完毕, 我服务端才处理下一个请求. (该模型是, 我都(监听)处理, 你都来吧, 但是真正有IO读写的, select才去调用阻塞IO去处理读写任务)监听的多, 但是真正处理起来还是一个一个顺序执行, 一旦有耗时任务, 效率就不高了.</p><p>THsHaServer类是TNonblockingServer类的子类, 是TThreadPoolServer单线程的部分解决方(引入了一个线程池做优化), 专门进行读业务处理. 也就是原来selector的主线程主要负责写任务, 之后进入下一次轮询(主线程也处理就绪需要accept的socket); 但是读任务全部交给线程池中的工作线程, 不阻塞主线程. 只能说部分优化了, 当并发请求数较大时，且发送数据量较多时，监听socket上新连接请求不能被及时接受(毕竟主线程还是会被写任务阻塞住)。</p><p>TThreadPoolServer模式, 这种模式没有使用select这类异步操作, 而是同步的去判断是否由socket就绪(accept), 对仅仅是处理accept, 没有的话阻塞整个进程在那儿等待, 然后一旦有连接, 不管有没有IO任务, 它都会启动一个专门的线程去处理这个连接上的所有任务(方式是把socket封装成一个新任务交给线程池, 之后工作线程才去从socket拿出请求, 完成具体调用返还客户客户端), 这样得以把主线程空出来继续阻塞等待别的连接请求. 这个缺点就很明显了, 受限于线程池中线程的数量(并发量大于线程池数量时, 能扩展线程数最好, 不能的话, 那么只能进入队列等待了), 并发量不大. (最好你知道有多少个, 最多有多少个客户端会连接的情况)</p><p>TThreadedSelectorServer : 这种模型, 把网络中的任务细致划分. 可谓足够精细, 多个部分协作工作. 如果说上面的都是个人&amp;两三个人, 这个模型就是一个小团队, 请直接看图.<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_thread_selector.jpg" alt=""></p><p>稍微解释一下, 普通的网络编程中成功用例是这么工作的: (服务端)</p><blockquote><p>接受连接请求 –&gt; 检测是否有IO就绪 —&gt; 处理真正的IO操作</p></blockquote><p>但是引入线程池之后, 这个模型变成了:(流程自上而下)</p><ul><li>线程AcceptThread阻塞(或者非阻塞)等待是否由心的连接  (这个是<code>销售顾问</code>, 拿到订单)</li><li>有新的连接就把它交给SelectorThread以检测socket是否就绪(是否由IO读写请求)  (这个是<code>项目经理</code>, 负责拿到的订单项目)</li><li>被accept的连接,需要SelectorThreadLoadBalancer来调度,以免某个SelectorThread压力过大(这个是<code>研发经理</code>, 分派任务)</li><li>SelectorThread读取具体的请求, 但是实际完成耗时IO(或者具体调用)的却是ExecutorService. (这个就是<code>高级工程师</code>)</li></ul><blockquote><p>如果你的场景不需要某种支持高并发的姿态, 就不要浪费资源选择高级模式; 够用就好. 但是还有一句, 如果几种模型的优缺点你不知道, 那么选择最好的总不会错, 直接上TThreadedSelectorServer也没事儿.</p></blockquote><hr><h2 id="详细说明"><a href="#详细说明" class="headerlink" title="详细说明"></a>详细说明</h2><p>这一部分是阅读其官网文档的总结, 你可以把它看做使用手册.</p><h3 id="传输框架"><a href="#传输框架" class="headerlink" title="传输框架"></a>传输框架</h3><p>该部分请 <code>参考架构部分</code>. (上面)</p><p>主要是协议protocol, transport方式, 以及server类型即可. 协议部分我们在pb里面以及涉及到编码规则内容了,没有必要详细深挖; 主要值得研究的是在 <code>传输方式</code>和<code>服务器类型</code>上, 不同的方式有不同的实现细节, 以及后端思想; 并且效率也可能相差很多.</p><blockquote><p>后期有时间, 可以像Libevent一样, 把TSocket等传输方式, 以及TSimpleServer等服务器类型; 源码剖析一下.</p></blockquote><p>(见下面 <code>源码分析</code> 部分)</p><h3 id="名字空间"><a href="#名字空间" class="headerlink" title="名字空间"></a>名字空间</h3><p>越来越多的语言使用package作为代码控制机制, 到具体的语言可能是模块(Python), 包(Java), 或者namespace(Cpp)</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>thrift定义了几大数据类型, 在不同环境中翻译成不同语言时候mapping关系也不大一样; 幸运的是, 这一层抽象被thrift框架处理了, 我们只用关心thrift数据类型即可.</p><p>类型主要包括: 基本类型、结构体和异常类型(异常使用关键字exception)、容器类型、服务(service)类型;</p><p>基本类型:</p><ul><li>bool：布尔值 (true or false), 1 字节</li><li>byte：有符号字节</li><li>i16：16位有符号整型</li><li>i32：32位有符号整型</li><li>i64：64位有符号整型</li><li>double：64位浮点型</li><li>string：未知编码或者二进制的字符串</li></ul><p>结构体:<br>例如:</p><pre><code>struct UserDemo {　　1: i32 id;　　2: string name;　　3: i32 age = 25;　　4： string phone;}</code></pre><p>必须注意:</p><ul><li>struct 不能继承，但是可以嵌套别人，不能嵌套自己</li><li>其成员都是有明确类型</li><li>成员是被正整数编号过的，其中的编号使不能重复的，这个是为了在传输过程中编码是用(和pb一样)</li><li>成员分割符可以是逗号或是分号, 而且可以混用(建议使用分号, C语言习惯)</li><li>字段会有optional和required之分(和pb一样)</li><li>每个字段可以设置默认值(和pb一样)</li><li>同一文件可以定义多个struct; 可以用include包含别的文件的struct定义</li></ul><p>补充说明:</p><ul><li>编码值, 不要随便编; </li><li>字段类型required或者optional(没有赋值则不进行序列化), 不指定则默认是会被序列化的(基本和required相同, 但required会被框架提示)</li></ul><p>容器类型:<br>主要使用编程语言无关的数据结构作为容器, 一般就三个:</p><ul><li>list<t>: 有序表, 允许元素重复</t></li><li>set<t>: 无序表, 不容许元素重复</t></li><li>map<t,t>: 键类型为t, 值类型为t的kv对, 键不容许重复</t,t></li></ul><p>生成的代码中, 不同语言对应的数据结构可能有一些差异, 但是不影响其功能.</p><p>服务类型:<br>就是trift文件中的service, 代码中等价于类或者接口集合(代码中支持继承, 但如果继承这个类, 其方法必须实现), 但接口里面定义的方法不支持重载.<br>由上面的实践来看, 参数一般是const类型, 并且最终生成的代码和你定义的service函数原型可能不一样, 可能会根据具体的语言进行调整(具体规则, 需要参考它的gen代码生成器).</p><h3 id="代码生成"><a href="#代码生成" class="headerlink" title="代码生成"></a>代码生成</h3><p>Thrift自动生成代码的代码框架被直接硬编码(hardcode)到了代码生成器里(不知道Facebook有没有工具)，因此对生成代码的结构进行修改需要重新编译Thrift，并不是十分方便。如果Thrift将代码结构保存到一个模板文件里，修改生成代码就会相对容易一些。</p><p>自动生成的代码就会遵守一定的命名规则。Thrift中几种主要的命名规则为:</p><pre><code>1.    IDLName + ”_types.h” ：用户自定义数据类型头文件2.    IDLName + ”_constants.h” ：用户自定义的枚举和常量数据类型头文件3.    ServiceName + “.h” ：Server端Processor定义和Client定义头文件----------------------------------------------------------------------------------------4.    ServericeName + ”_” + RPC名称 + “_args” ：服务器端RPC参数解析类---统一参数解析类5.    ServericeName + ”_” + RPC名称 + “_result” ：服务器端RPC返回值打包类6.    ServericeName + ”_” + RPC名称 + “_pargs” ：客户端RPC参数打包类7.    ServericeName + ”_” + RPC名称 + “_presult” ：客户端RPC返回值解析类8.    “process_” + RPC名称：服务器端RPC调用处理函数9.    “send_” + RPC名称：客户端发送RPC请求的方法10.    “recv_” + RPC名称：客户端接收RPC返回的方法</code></pre><p>统一参数解析类和处理方法的设想:<br>客户端和服务器的参数解析和返回值解析, 虽然针对的是同样的数据结构, 但是 thrift 并没有使用同一个类来完成任务, 而是将客户端和服务器的解析类分开. (TProcess和Client)</p><blockquote><p>当 RPC 调用参数含有相同信息并需要进行相同操作的时候, 对参数解析类的集中管理就会变得非常有必要了. 比如在一些用 thrift 实现访问控制的系统中, 每一个 RPC 调用都会加一个参数token作为访问凭证(是否可以访问), 并在每一个用户函数里进行权限检查. 使用 <code>统一的参数解析类接口</code> 的话, 就可以将分散的权限检查集中到一块进行处理. thrift 中有众多的解析类, 这些解析类的接口类似, 但是却没有一个共有的基类. 对参数的集中管理造成了一定的困难. 如果Thrift为解析类建立一个基类, 并把解析类指针放到一个Map中, 这样参数就可以进行集中管理, 不仅可以进一步减小自动生成代码的体积, 也满足了对参数进行统一管理的需求.</p></blockquote><p>下面开始重头戏.</p><hr><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>框架本身有很多精华, 我抽取其中我熟悉的进行分析.</p><h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>该部分其实是解释thrift框架如何工作的, 形式上是c-s一次通信的过程; 这个要结合源码起来看(下面图片请在新窗口中打开观看), 不同源码版本可能不一样.</p><p>服务端主要流程如下:</p><blockquote><p>TThreadPoolServer 的 serve() 方法后，server 进入阻塞监听状态，其阻塞在 TServerSocket 的 accept()方法上。当接收到来自客户端的消息后，服务器发起一个新线程处理这个消息请求，原线程再次进入阻塞状态。在新线程中，服务器通过 TBinaryProtocol 协议读取消息内容，调用 HelloServiceImpl 的 helloVoid() 方法，并将结果写入 helloVoid_result 中传回客户端。</p></blockquote><p>过程如下图:(下面的图请单独拉开网页看)<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_call_1.png" alt="server"></p><p>(整理处理流程比较简单, 就是调用过程负责)</p><p>客户端的处理流程如下: (下面的图请单独拉开网页看)</p><blockquote><p>程序调用了 Hello.Client 的 helloVoid() 方法，在 helloVoid() 方法中，通过 send_helloVoid() 方法发送对服务的调用请求，通过 recv_helloVoid() 方法接收服务处理请求后返回的结果。远程rpc调用过程,以及网络传输过程, 全部被封装在框架里了.</p></blockquote><p><img src="http://omotkhw3y.bkt.clouddn.com/thrift_call_2.png" alt="client"></p><h3 id="Server工作模式"><a href="#Server工作模式" class="headerlink" title="Server工作模式"></a>Server工作模式</h3><p>但凡后端人员接触这个库, 我觉得最感兴趣的, 一定是server的类型, 即服务器的工作模式. 当然网络编程玩烂的后端人员真正剖析的识货, 也就是见怪不怪了. (不知道我说啥的同学, 可以补一下 apue的9种网络模式或者参考unp 卷1)</p><p>下面主要剖析一下(权做复习):</p><ul><li>TSimpleServer</li><li>TNonblockingServer</li><li>THsHaServer</li><li>TThreadPoolServer</li><li>TThreadedSelectorServer—优先剖析</li></ul><h3 id="连接池实现"><a href="#连接池实现" class="headerlink" title="连接池实现"></a>连接池实现</h3><p>再讲线程相关的内容时, 我连着对象池, 连接池, 线程池一起说了. 请参考本博客里线程池相关内容.</p><p>(谁有时间再来看它的连接池接口代码吧—不懂源码不影响使用流程的)</p><h2 id="对比其他框架"><a href="#对比其他框架" class="headerlink" title="对比其他框架."></a>对比其他框架.</h2><p>看到的RPC框架或者有RPC功能的框架已经算比较多的了, protobuffer, soap, grpc, 甚至libevent也说自己是rpc框架.</p><p>pb更多的是提供了跨语言的序列化和反序列化机制, 而thrift则是在数据结构信息中提供了消息头用来进行RPC, 详细信息可以参考下图:(thrift消息体逻辑结构)</p><p><img src="http://omotkhw3y.bkt.clouddn.com/thrift_rpc.jpg" alt=""></p><p>优点:</p><ul><li>用于搭建大型数据交换及存储的通用工具， 对于大型系统中的内部数据传输相对于 JSON 和 XML 无论在性能、传输大小上有明显的优势.</li><li>拥有比较完整的体系(内嵌完整的RPC层次), 省去了很多手工编码的机会.</li><li>多语言, 多数据类型支持(支持的语言比pb多, 还支持容器数据结构)</li><li>运行开销性能比pb略好(cpu占用率维持在30%以内)<br><img src="http://omotkhw3y.bkt.clouddn.com/thrift_load.jpg" alt=""></li></ul><p>缺点:</p><ul><li>框架庞大(IDL借鉴与CORBA, 完成了整个服务端和客户端的架构体系), 排查错误费时间</li><li>thrift是完全静态化的描述文件(生成器是硬编码而不是依据模板来的), 一旦数据结构发生改变, 须重新编辑IDL文件, 代码生成, 再编译载入的流程(和pb相比较弱)</li><li>传输性能上比pb要略差(即使是压缩二进制 TCompactProtocol方式)</li><li>参考资料少啊!</li></ul><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>综合一圈玩下来, 这个库太棒了, 把我从学习网络以来的绝大部分工作全部整合成流程了, 而且效率也不差(参考网友的评测).</p><p>但是就是坑太多! 如果你没有把它大部分源码吃透, 目前还不适合用于实际工程项目(我是指你负责这个项目工程的兜底工作), 并且由于其框架太重, 所以可能学习成本会稍高.</p><p>墨镜王(王家卫导演啦)东邪西毒里有一句话, </p><blockquote><p>“男人看见一座山总想翻过去, 看看山的那一边是什么, 等真正翻过去了, 也没发现有什么好, 说不定山的这一边儿反而更好.”</p></blockquote><p>以后等它成熟了再来, 目前libevent + 手写代码(或者pb), 挺好的. (但是这个 <code>库的学习价值真的很高</code> , 比如说在线程管理上, 它用 boost::shared_ptr 弱引用保证被多个线程接纳的已死对象的清理工作; 并且在保证返回给调用者一定能拿到操作系统创建的线程时使用了弱引用指向自身, 这样在真正拿到线程之前就能保证不被操作系统过早清理掉–过早返回给ThreadMain的调用者是有可能被清理掉的…等等技巧)</p><blockquote><p>这个库没有说完, 以后有时间再回来更新.</p></blockquote><p>好累.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://thrift.apache.org/" target="_blank" rel="external">http://thrift.apache.org/</a></li><li><a href="https://en.wikipedia.org/wiki/Apache_Thrift" target="_blank" rel="external">https://en.wikipedia.org/wiki/Apache_Thrift</a></li><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift" target="_blank" rel="external">https://www.ibm.com/developerworks/cn/java/j-lo-apachethrift</a></li><li><a href="http://thrift.apache.org/static/files/thrift-20070401.pdf" target="_blank" rel="external">http://thrift.apache.org/static/files/thrift-20070401.pdf</a></li><li><a href="https://wiki.apache.org/thrift/ThriftInstallation" target="_blank" rel="external">https://wiki.apache.org/thrift/ThriftInstallation</a></li><li><a href="https://wiki.apache.org/thrift/FrontPage" target="_blank" rel="external">https://wiki.apache.org/thrift/FrontPage</a></li><li><a href="http://www.cnblogs.com/cyfonly/p/6059374.html" target="_blank" rel="external">和 Thrift 的一场美丽邂逅</a> 文章有一些地方讲述错误</li><li><a href="http://blog.csdn.net/houjixin/article/details/42779915" target="_blank" rel="external">http://blog.csdn.net/houjixin/article/details/42779915</a></li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      经典的跨语言编程框架Thrift, 有着protobuffer无法匹敌的, 庞大...
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="框架" scheme="www.merlinblog.site/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Jni</title>
    <link href="www.merlinblog.site/2017/08/22/jni.html"/>
    <id>www.merlinblog.site/2017/08/22/jni.html</id>
    <published>2017-08-22T00:08:12.000Z</published>
    <updated>2017-09-26T05:41:17.178Z</updated>
    
    <content type="html"><![CDATA[<p>“Java Native Interface” , 最初是在Android NDK编程的时候接触的, 不过个人对于客户端开发一直没有太大的兴趣, 所以自那之后也搁置了很久.</p><p>近期正好总结<code>跨语言编程实践</code>, 那么正好也就写一写, 就当写了一个中文的简要参考手册.</p><p>(参考资料中的第一本书推荐一下)</p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>跨语言的调用怎么弄? 这个话题, 太大了, 我倒是可以给你推荐一个框架, 脸书的Thrift; 这里只考虑 Java 和 C 的互相调用的话(调用方向不一样,方式也有稍稍不同, 复杂度也不一样), 就引出了JNI技术(JNI本身是native接口, 但在编程框架中更像一种协议), 专门针对Java和C交互.</p><p>我想最初设计这个框架的人一定考虑了至少3个问题:</p><ul><li>跨语言对象的对接问题</li><li>数据类型规格问题</li><li>调用效率问题</li></ul><p>JNI允许运行在Java虚拟机的Java代码与用其他语言(如C, C++和汇编)编写的库交互, 通过JNI, 可以在native code中完成至少下面的事情:</p><ul><li>创建、检查或者更新java对象</li><li>调用java方法</li><li>捕捉和抛出异常</li><li>加载class和获取class信息</li><li>运行时类型检查</li></ul><p>理论太啰嗦了, 不说了. 下面详细介绍这些技术, 以及常见的开发流程.</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><h3 id="Java主调C代码"><a href="#Java主调C代码" class="headerlink" title="Java主调C代码."></a>Java主调C代码.</h3><p>也就是说实现部分是在C, Java部分就是起到简单的调用.</p><p>根据Java代码, 使用相应的编译器Javap生成本地访问头文件, 然后C代码中引用该头文件, 返回操作结果. Java代码中虚拟机运行时加载相应的本地代码(可能需要LoadLibrary), 从而完成java代码调用C代码.</p><p>流程归纳起来就是:<br>编译,加载,链接本地方法.</p><ul><li>编译:<br>java VM是多线程的 ，所以native libraries应该用多线程编译器来进行编译和链接。例如使用Sun Studio compiler编译器的时候，要为c++代码添加-mt标记；使用 GNU gcc compiler的时候，需添加-D_REENTRANT 或-D_POSIX_C_SOURCE</li><li>加载<br>native库通过System.loadLibrary方法进行加载。如：<br>```c++<br>package pkg;  </li></ul><p>class Cls { </p><pre><code> native double f(int i, String s);  static {      System.loadLibrary(“pkg_Cls”);  } </code></pre><p>} </p><pre><code> 系统会对library名会进行转换，在不同平台上有不同的转换方式，例如，Solaris系统转换pkg_Cls为libpkg_Cls.so，而Win32系统转换pkg_Cls为pkg_Cls.dll* 链接 如果系统不支持动态链接，那么所有本地方法需要预链接到虚拟机，这种情况下，VM已经完成System.loadLibrary了。程序员也可以调用JNI函数RegisterNatives()来注册该类关联的本地方法### C主调Java代码这个相对来说, 应该算作被动调用(需求比较少), C语言回调Java方法.根据Java代码生成相应的C代码的步骤是一样的, `javap -jni 包名.类名`, 然后在本地代码中引入生成的头文件, 然后根据该头文件的函数, 给出函数实现.但是在函数实现中, 就开始利用虚拟机的特性, 开始`反射`的写法了, 比如你的反射可能是这么写的:```javaClass&lt;?&gt; instance = Class.forName(&quot;com.example.Test&quot;);Method declearMethod = instance.getDeclaredMethod(&quot;intMethod&quot;, new Class[]{});declearMethod.invoke(instance.newInstance(), new Object[]{});</code></pre><p>那么在本地代码写法也类似, 先要拿到Class类型, 之后找到方法(ID), 然后再进行调用处理, 核心代码可能是:</p><pre><code class="c++">//在某本地函数体内 jclass jclazz = (*env)-&gt;FindClass(env, &quot;com/example/Test&quot;);jmethodID methodId = (*env)-&gt;GetMethodID(env, jclazz, &quot;intMethod&quot;, &quot;()V&quot;/*方法签名符号,约定参数和返回值*/);(*env)-&gt;CallVoidMethod(env, jobject, methodId); //jobject是本地函数默认的参数</code></pre><p>(如果是返回值的可能要用其他的JNI方法)</p><p>(方法签名可以看下面的规则, 得知其符号规则; 或者使用javap工具通过字节码拿到方法签名<code>javap -s</code>)</p><p>但是值得注意的是C回调Java代码, 是发生在Java代码调用C代码的时候, 发现自己被回调了; 毕竟运行都是在虚拟机的主导下(也就是说没有虚拟机环境是不行的). </p><p>C回调的方法一定要和jobject是同一个类型的(jobject实例所在的类), 如果你在该类的这个本地方法里, 调用其他Java类的方法, 还要增加处理:需要创建相关类的对象(就是拿到局部引用,AllObject或者NewObject方法)或者获取类的信息(静态方法调用GetStaticMethodID(), CallStaicVoidMethod()等), 例如</p><pre><code class="c">//先FindClass 返回一个jclass对象clazz, 并且拿到methodIDjobject obj = (*env)-&gt;AllocObject(env, clazz);(*env)-&gt;CallVoidMethod(env, obj, methodId);</code></pre><p>但是回调的场景, 最好还是放在同一个类吧, 不要跨类方法调用.</p><h2 id="本地方法规范"><a href="#本地方法规范" class="headerlink" title="本地方法规范"></a>本地方法规范</h2><p>Java方法, 如果转换(编译)到本地代码, 对应哪个方式其实是有讲究的, 例如:</p><pre><code class="java">package pkg;  class Cls {     //对应本地方法名: Java_pkg_Cls_f__ILjava_lang_String_2,    //参数列表:JNIEnv *env,jobject obj,jint i,jstring s    native double f(int i, String s); p}</code></pre><p>下面就仔细讲解一下对应的映射或者编译规则.</p><h3 id="命名符号解析"><a href="#命名符号解析" class="headerlink" title="命名符号解析"></a>命名符号解析</h3><p>一个本地方法名有以下几个组成部分：</p><ul><li>前缀Java_</li><li>完整类名（类名中的.用_代替）</li><li>下划线_</li><li>方法名（方法名中的特殊字符需要转义）</li><li>参数签名（非必须，有重载方法的时候才需要），如果有重载的本地方法，需要再添加两个下划线_<em>，然后再添加方法签名（由java字段描述符描述，用</em>代替描述符中的包名分割/符，签名中的特殊字符需要转义）</li></ul><p>关于转义:</p><ul><li>_0XXXX    一个Unicode字符XXXX。注意小写是用来表示非ascii Unicode字符, 如:_0abcd与_0ABCD不相同</li><li><em>1        字符</em></li><li>_2        参数签名中的字符;</li><li>_3        参数签名中的字符[</li></ul><h3 id="类型符号解析"><a href="#类型符号解析" class="headerlink" title="类型符号解析"></a>类型符号解析</h3><p>注意这些规则, 对应的是用在函数或者参数名字上(java和c数据类型对应有另外一套规则)<br>命名中的类型(Java类型对应本地符号)规则, 如下:</p><pre><code>Boolean        ZByte        BChar        CShort        SInt        ILong        J (特殊)Float        FDouble        DVoid        V</code></pre><p>特殊的有数组和对象:</p><pre><code>数组:   &quot;[类型&quot; 表示, 如：int[]-&gt; [I, int[][]-&gt; [[I, Thread[]-&gt; [Ljava/lang/Thread;objects:   以&quot;L&quot;开头, 以&quot;;&quot;结尾, 用&quot;/&quot; 隔开的包及类名. 比如: Ljava/lang/String;   如果是嵌套类, 则用$来表示嵌套, 例 Landroid/os/FileUtils$FileStatus;</code></pre><h3 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h3><p>一个Java方法, 编译到native code会自然多出两个参数, 一个代表JNI接口指针类型(Java虚拟机环境), 另外一个是对象实例的引用(通俗来说就是this指针, 当然进程方法可以不用).</p><p>例如:<br>Java代码:</p><pre><code class="java">package pkg;  class Cls {      native double f(int i, String s); }</code></pre><p>编译到C代码就是:</p><pre><code class="c++">/*c和c++在使用JNI接口的时候有点不一致,    请仔细观察通过env调用接口的调用方式 *///C版本jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (     JNIEnv *env,        /* interface pointer */     jobject obj,        /* &quot;this&quot; pointer */     jint i,             /* argument #1 */     jstring s)          /* argument #2 */{     /* Obtain a C-copy of the Java string */     const char *str = (*env)-&gt;GetStringUTFChars(env, s, 0);     /* process the string */     ...     /* Now we are done with str */     (*env)-&gt;ReleaseStringUTFChars(env, s, str);     return ...}//C++版本extern &quot;C&quot; /* specify the C calling convention */  jdouble Java_pkg_Cls_f__ILjava_lang_String_2 (      JNIEnv *env,        /* interface pointer */      jobject obj,        /* &quot;this&quot; pointer */      jint i,             /* argument #1 */      jstring s)          /* argument #2 */ {      const char *str = env-&gt;GetStringUTFChars(s, 0);      ...      env-&gt;ReleaseStringUTFChars(s, str);      return ... }</code></pre><h3 id="对象类型解析"><a href="#对象类型解析" class="headerlink" title="对象类型解析"></a>对象类型解析</h3><p>本地代码中的参数, 才不管你Java类的具体类型, 统一jobject类型;<br>当然也可以对应更细致(也不那么细致):<br><img src="http://omotkhw3y.bkt.clouddn.com/jobject.jpg" alt="jobject"></p><p>java对象引用:</p><ul><li>基本类型（如整型，字符等）在Java和native之间是采用值传递</li><li>Java对象采用的是引用(地址)传递(Java语言本身封装了指针)</li></ul><p>全局引用&amp;弱全局引用, 局部引用:</p><ul><li>局部引用在方法调用的时候有效，在方法调用结束之后会自动释放</li><li>全局引用会一直可用，直到显式地对其进行释放</li><li>弱全局引用跟全局引用的区别是弱全局引用持有的java对象可以被VM进行回收，所以才使用弱全局引用前，我们需要对其进行检测，看它对应的对象是否被回收了</li></ul><p>JNIENV方法:</p><ul><li>返回的Java对象都是局部引用</li><li>可以接受全局引用和全局引用</li></ul><p>native方法: (C方法)</p><ul><li>可以返回局部或者全局引用</li><li>接收的一般是局部引用(Java对象)</li></ul><p>并且JNI允许程序从局部引用创建一个全局引用.</p><p>native代码中的局部的对象, 该怎么释放?</p><ul><li>在方法调用结束之后，我们依赖VM去帮我们释放所有局部引用</li><li>以下几种情况下，我们应该显式地释放局部引用:<ul><li>方法中创建了一个比较大的java对象的，并持有其局部引用，使用完之后，如果接下来都不再需要使用了，如果仍然不对它进行释放的话，在方法结束之前，这个对象都不会进行释放，这样会对资源造成浪费</li><li>JNI会将创建的局部引用都存储在一个局部引用表中，如果这个表超过了最大容量限制，就会造成局部引用表溢出，使程序崩溃。比如在一个循环中创建局部引用，最好在每一轮循环中释放局部引用，否则随着循环次数增加，很可能就内存溢出了</li></ul></li></ul><p>局部引用仅仅在其创建的线程内有效(也就是占用的是本地代码的栈空间), native代码不能跨线程传递局部引用.</p><h3 id="类型别名解析"><a href="#类型别名解析" class="headerlink" title="类型别名解析"></a>类型别名解析</h3><p>上面的jint, 其实是JNI定义的别名(具体对应什么可以自己定义), 对应的可能是标准C中的long, 其实你也可以使用c语言标准中的int类型.</p><p>详细的信息可以参考下面:</p><pre><code>Java 类型   JNI类型别名         描述boolean        jboolean         unsigned char, 8 bitsbyte        jbyte         signed char, 8 bitschar        jchar         unsigned short, 16 bitsshort        jshort         signed short, 16 bitsint        jint         signed long, 32 bitslong        jlong         __int64, signed long long,  64 bitsfloat        jfloat         float, 32 bitsdouble        jdouble         double 64 bitsvoid        void         N/A</code></pre><p><img src="http://omotkhw3y.bkt.clouddn.com/jni.jpg" alt="别名"><br>当然你也可以选择使用或者不用:(默认使用)</p><pre><code>#define JNI_FALSE  0 #define JNI_TRUE   1</code></pre><p>注意到char使用的双字节编码, 而不是单字节编码，所以Java虚拟机的UTF-8字符串不可能有嵌入的空值; 并且不支持标准的四字节编码，用 two-times-three-byte 格式代替</p><h3 id="调用Java方法"><a href="#调用Java方法" class="headerlink" title="调用Java方法"></a>调用Java方法</h3><p>JNI允许native代码访问对象的成员以及调用它的方法，通过两个步骤即可实现访问，比如，我们需要调用cls中的f方法：</p><pre><code class="c">jmethodID mid = env-&gt;GetMethodID(cls, “f”, “(ILjava/lang/String;)D”);//mid可以重复使用jdouble result = env-&gt;CallDoubleMethod(obj, mid, 10, str);</code></pre><p>但是需要注意的是，字段ID或方法ID并不能防止VM卸载该类. 当类被卸载后, 方法ID和字段ID将变成不可用的. 因此，我们需要确保： </p><ul><li>持有class的引用，让它不被卸载，或者 </li><li>重新获取方法id或者字段id</li></ul><p>关于<code>jmethodID</code>:<br>在C中, 字段和方法的 ID 是一个指向结构体的指针:</p><pre><code class="c">struct _jfieldID;                       /* opaque structure */typedef struct _jfieldID* jfieldID;     /* field IDs */struct _jmethodID;                      /* opaque structure */typedef struct _jmethodID* jmethodID;   /* method IDs */</code></pre><h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3><pre><code class="c">//方法签名为：(ILjava/lang/String;[I)J long f (int n, String s, int[] arr);</code></pre><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>JNI不对空指针或非法参数类型等错误进行检测, 因为:</p><ul><li>检查所有可能的错误会降低方法执行的性能</li><li>在很多时候，没有足够的运行时信息去进行检测<br>程序员不得传递一个非法指针或者错误的类型给JNI函数, 否则可能会导致系统异常货虚拟机崩溃.</li></ul><p>JNI允许本地方法抛出处理任何异常，也可以处理Java中抛出的异常，剩下没有处理的异常会继续给VM处理.</p><h3 id="Java部分处理"><a href="#Java部分处理" class="headerlink" title="Java部分处理:"></a>Java部分处理:</h3><p>大多数情况下，JNI提供的方法通过返回错误码或者抛出java异常来处理错误，因此，程序中可以:</p><ul><li>检查JNI函数返回值</li><li>调用 ExceptionOccurred() 方法，获取方法中抛出的异常</li></ul><p>有两种情况下，程序需要优先检测java异常而不是先检测返回码:</p><ul><li>通过JNI调用Java方法的时候，需要ExceptionOccurred()检测是否在Java方法中抛出了异常</li><li>一些访问数组的方法，它不返回错误码，但是会抛出 ArrayIndexOutOfBoundsException 或者 ArrayStoreException异常</li></ul><h3 id="本地部分处理"><a href="#本地部分处理" class="headerlink" title="本地部分处理"></a>本地部分处理</h3><p>有两种方法可以在本地方法中处理异常:</p><ul><li>检测到异常的时候立即返回，异常将会在调用该本地代码的地方抛出</li><li>在本地方法中调用ExceptionClear()清除异常，处理接下来的逻辑</li></ul><p>异常抛出的时，本地方法需清除异常后，才能继续调用其他JNI接口方法.</p><p>有异常发生后，只有以下方法才能被安全调用：</p><pre><code>  ExceptionOccurred()  ExceptionDescribe()  ExceptionClear()  ExceptionCheck()  ReleaseStringChars()  ReleaseStringUTFChars()  ReleaseStringCritical()  Release&lt;Type&gt;ArrayElements()  ReleasePrimitiveArrayCritical()  DeleteLocalRef()  DeleteGlobalRef()  DeleteWeakGlobalRef()  MonitorExit()  PushLocalFrame()  PopLocalFrame()</code></pre><h2 id="JNI接口详解"><a href="#JNI接口详解" class="headerlink" title="JNI接口详解"></a>JNI接口详解</h2><p>花时间阅读那个 <code>jni.h</code>, 以及参考文档.</p><p>JNI函数必须接受一个非空对象，你必须保证传入的参数不为空，JNI函数不需要再对它进行空指针判断.</p><h3 id="返回码说明"><a href="#返回码说明" class="headerlink" title="返回码说明"></a>返回码说明</h3><pre><code class="c">#define JNI_OK          (0)         /* no error */#define JNI_ERR         (-1)        /* generic error */#define JNI_EDETACHED   (-2)        /* thread detached from the VM */#define JNI_EVERSION    (-3)        /* JNI version error */#define JNI_COMMIT      1           /* copy content, do not free buffer */#define JNI_ABORT       2           /* free buffer w/o copying back */</code></pre><h3 id="接口代码说明"><a href="#接口代码说明" class="headerlink" title="接口代码说明"></a>接口代码说明</h3><p>该部分比较多(1000多行), 有一定的注释</p><pre><code class="c">    /**     * 返回本地方法接口的版本     *     * @param env JNI接口指针     *     * @return 高16位返回主版本号，低16位返回次版本号,       如在JDK/JRE 1.6中，返回0x00010006      也有可能返回 JNI_EDETACHED 和 JNI_EVERSION 错误码     */    jint (*GetVersion)(JNIEnv *);    /**     * 从二进制的.class的数据缓冲区中加载类     *     * @param env JNI接口指针     * @param name UTF8编码的需要加载的类的名字     * @param loader 类加载器     * @param buf 包含.class字节码的数组     * @param bufLen 长度     *     * @return class对象或NULL     *     * @throws ClassFormatError 不是有效的class数据     * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口     * @throws OutOfMemoryError 内存不足     * @throws SecurityException 如果该类是属于java包的     */    jclass (*DefineClass)(JNIEnv *, const char *, jobject, const jbyte *, jsize);    /**     * 用于加载本地定义的类     *     * @param env JNI接口指针     * @param name 完整的包名(&quot;/&quot;代替&quot;.&quot;) 或 数组类型字段描述(&quot;[&quot;开头，紧跟签名描述)，        如&quot;java/lang/String&quot; for java.lang.String,           &quot;[Ljava/lang/Object;&quot; for java.lang.Object[]     *     * @return class对象或NULL     *     * @throws ClassFormatError 不是有效的class数据     * @throws ClassCircularityError 类或接口是自身的父类或自身继承了该接口     * @throws OutOfMemoryError 内存不足     * @throws NoClassDefFoundError 找不到name对应的class类     */    jclass (*FindClass)(JNIEnv *, const char *);    /**     * 从java.lang.reflect.Method 或 java.lang.reflect.Constructor 获取method ID     *     * @param env JNI接口指针     * @param method java.lang.reflect.Method 或 java.lang.reflect.Constructor对象     *     * @return 方法ID     */    jmethodID (*FromReflectedMethod)(JNIEnv *, jobject);    /**     * 从java.lang.reflect.Field获取field ID     *     * @param env JNI接口指针     * @param field java.lang.reflect.Field对象     *     * @return field ID     */    jfieldID (*FromReflectedField)(JNIEnv *, jobject);    /**     * 从method ID获取 java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象     *     * @param env JNI接口指针     * @param cls 该方法的类对象     * @param methodID 方法ID     * @param isStatic 是否静态方法     *     * @return java.lang.reflect.Method 或 java.lang.reflect.Constructor 对象     *     * @throws OutOfMemoryError 内存不足     */    jobject (*ToReflectedMethod)(JNIEnv *, jclass, jmethodID, jboolean);    /**     * 如果clazz不是class对象或接口，则返回该class的超类     *     * @param env JNI接口指针     * @param clazz class对象     *     * @return 返回输入类的父类 或 NULL     */    jclass (*GetSuperclass)(JNIEnv *, jclass);    /**     * class1是否可以安全地转换为class2，以下三种情况会返回TRUE     * 1. 当class1和class2是同一个java class的引用     * 2. class1是class2的子类     * 3. class2是class1的某个接口     *     * @param env JNI接口指针     * @param clazz1 class1     * @param clazz2 class2     *     * @return JNI_TRUE or JNI_FALSE     */    jboolean (*IsAssignableFrom)(JNIEnv *, jclass, jclass);    /**     * 根据 field ID 获取 java.lang.reflect.Field 对象     *     * @param env JNI接口指针     * @param cls 该方法的类对象     * @param fieldID 字段ID     * @param isStatic 是否静态变量     *     * @return java.lang.reflect.Field 对象     *     * @throws OutOfMemoryError 内存不足     */    jobject (*ToReflectedField)(JNIEnv *, jclass, jfieldID, jboolean);    /**     * 抛出异常     *     * @param env JNI接口指针     * @param obj java.lang.Throwable 对象     *     * @return 0：成功， 负数：失败     *     * @throws Throwable     */    jint (*Throw)(JNIEnv *, jthrowable);    /**     * 根据clazz和message构造一个异常对象，并将它抛出     *     * @param env JNI接口指针     * @param clazz java.lang.Throwable的子类     * @param message 错误信息     *     * @return 0：成功， 负数：失败     *     * @throws Throwable     */    jint (*ThrowNew)(JNIEnv *, jclass, const char *);    /**     * 判断是否有异常抛出，在调用ExceptionClear()或java代码处理了exception之前，都可以用这个方法判断是否有异常     *     * @param env JNI接口指针     *     * @return 异常对象 or NULL     */    jthrowable (*ExceptionOccurred)(JNIEnv *);    /**     * 打印异常信息     *     * @param env JNI接口指针     */    void (*ExceptionDescribe)(JNIEnv *);    /**     * 清除所有已抛出的异常     *     * @param env JNI接口指针     */    void (*ExceptionClear)(JNIEnv *);    /**     * 抛出致命错误并且不希望虚拟机进行恢复。无返回值     *     * @param env JNI接口指针     * @param msg 错误信息     */    void (*FatalError)(JNIEnv *, const char *);    /**     * 创建一个新的本地引用帧     *     * @param env JNI接口指针     * @param capacity 容量     *     * @return 0：成功，负数：失败     *     * @throws OutOfMemoryError     */    jint (*PushLocalFrame)(JNIEnv *, jint);    /**     * 弹出当前本地引用帧，释放所有本地引用     *     * @param env JNI接口指针     * @param result     *     * @return     */    jobject (*PopLocalFrame)(JNIEnv *, jobject);    /**     * 为传入的obj创建全局引用，obj可以是全局引用也可以是局部引用。全局引用需要调用DeleteGlobalRef来释放     *     * @param env JNI接口指针     * @param obj 全局或局部引用     *     * @return 全局引用 or NULL(内存不足)     */    jobject (*NewGlobalRef)(JNIEnv *, jobject);    /**     * 释放全局引用     *     * @param env JNI接口指针     * @param globalRef 全局引用     */    void (*DeleteGlobalRef)(JNIEnv *, jobject);    /**     * 释放局部引用     *     * @param env JNI接口指针     * @param localRef 局部引用     */    void (*DeleteLocalRef)(JNIEnv *, jobject);    /**     * 判断两个引用是否同一java对象的引用     *     * @param env JNI接口指针     * @param ref1 引用1     * @param ref2 引用2     *     * @return JNI_TRUE:两个引用指向同一个java对象     */    jboolean (*IsSameObject)(JNIEnv *, jobject, jobject);    /**     * 为传入的ref创建局部引用，ref可以是全局引用也可以是局部引用     *     * @param env JNI接口指针     * @param ref 全局或局部引用     *     * @return 局部引用 or NULL     */    jobject (*NewLocalRef)(JNIEnv *, jobject);    /**     * 确保当前线程可以创建capacity个局部引用。在进入本地方法时，VM确保可以可以创建最少16个局部引用     *     * @param env JNI接口指针     * @param capacity 局部引用个数     *     * @return 0：成功，负数：失败     *     * @throws OutOfMemoryError 内存不足     */    jint (*EnsureLocalCapacity)(JNIEnv *, jint);    /**     * 创建一个新的java对象（不会调用对象的构造方法）     *     * @param env JNI接口指针     * @param clazz 非数组class对象     *     * @return java对象     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*AllocObject)(JNIEnv *, jclass);    /**     * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得     *     * @param env JNI接口指针     * @param clazz 非数组class对象     * @param ... 传递给构造方法的参数     *     * @return java对象 or NULL(对象构造失败)     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*NewObject)(JNIEnv *, jclass, jmethodID, ...);    /**     * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得     *     * @param env JNI接口指针     * @param clazz 非数组class对象     * @param args va_list结构，里面有传递给构造方法的参数     *     * @return java对象 or NULL(对象构造失败)     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*NewObjectV)(JNIEnv *, jclass, jmethodID, va_list);    /**     * 构造一个新的java对象，method ID指用以生成该类的构造方法，method ID必须是通过GetMethodID()获得     *     * @param env JNI接口指针     * @param clazz 非数组class对象     * @param args 参数数组，里面是传递给构造方法的参数     *     * @return java对象 or NULL(对象构造失败)     *     * @throws InstantiationException clazz是一个接口或抽象类     * @throws OutOfMemoryError 内存不足     */    jobject (*NewObjectA)(JNIEnv *, jclass, jmethodID, jvalue *);    /**     * 返回对象对应的class对象     *     * @param env JNI接口指针     * @param obj 非空java对象     *     * @return class对象     */    jclass (*GetObjectClass)(JNIEnv *, jobject);    /**     * 判断obj是否clazz的实例对象     *     * @param env JNI接口指针     * @param obj java对象     * @param clazz class对象     *     * @return     */    jboolean (*IsInstanceOf)(JNIEnv *, jobject, jclass);    /**     * 返回非静态方法的method ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 方法名     * @param sig 方法签名     *     * @return 方法ID or NULL     *     * @throws NoSuchMethodError 找不到对应的方法     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jmethodID (*GetMethodID)(JNIEnv *, jclass, const char *, const char *);    /**     * Call&lt;type&gt;Method(JNIEnv *env, jobject obj, jmethodID methodID, ...);调用参数放到可变参数中     * Call&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组     * Call&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jmethodID methodID, va_list args);调用参数放入va_list结构中     *     * 以上三组调用接口都是根据 method ID调用java实例方法（非静态方法）的接口，其中method ID是通过GetMethodID()获取的     * 当这些方法用于调用java对象的私有方法或构造函数时，method ID必须从obj的真实类获取，而不应从其某个父类获取     * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同     *     *     * @param env JNI接口指针     * @param obj java对象     * @param methodID 方法ID     * @param args 调用参数     *     * @return java方法返回结果     *     * @throws java方法中可能抛出的异常     */    jobject (*CallObjectMethod)(JNIEnv *, jobject, jmethodID, ...);    jobject (*CallObjectMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jobject (*CallObjectMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jboolean (*CallBooleanMethod)(JNIEnv *, jobject, jmethodID, ...);    jboolean (*CallBooleanMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jboolean (*CallBooleanMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jbyte (*CallByteMethod)(JNIEnv *, jobject, jmethodID, ...);    jbyte (*CallByteMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jbyte (*CallByteMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jchar (*CallCharMethod)(JNIEnv *, jobject, jmethodID, ...);    jchar (*CallCharMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jchar (*CallCharMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jshort (*CallShortMethod)(JNIEnv *, jobject, jmethodID, ...);    jshort (*CallShortMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jshort (*CallShortMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jint (*CallIntMethod)(JNIEnv *, jobject, jmethodID, ...);    jint (*CallIntMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jint (*CallIntMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jlong (*CallLongMethod)(JNIEnv *, jobject, jmethodID, ...);    jlong (*CallLongMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jlong (*CallLongMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jfloat (*CallFloatMethod)(JNIEnv *, jobject, jmethodID, ...);    jfloat (*CallFloatMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jfloat (*CallFloatMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    jdouble (*CallDoubleMethod)(JNIEnv *, jobject, jmethodID, ...);    jdouble (*CallDoubleMethodV)(JNIEnv *, jobject, jmethodID, va_list);    jdouble (*CallDoubleMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    void (*CallVoidMethod)(JNIEnv *, jobject, jmethodID, ...);    void (*CallVoidMethodV)(JNIEnv *, jobject, jmethodID, va_list);    void (*CallVoidMethodA)(JNIEnv *, jobject, jmethodID, jvalue *);    /**     * CallNonvirtual&lt;type&gt;Method(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中     * CallNonvirtual&lt;type&gt;MethodA(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组     * CallNonvirtual&lt;type&gt;MethodV(JNIEnv *env, jobject obj, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中     *     * 以上三组调用接口都是根据 method ID 和 class 调用java实例方法（非静态方法）的接口，其中method ID是基于clazz通过GetMethodID()获取的     * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同     * 注意，和Call&lt;type&gt;Method不同，如果子类重写了父类的方法，Call&lt;type&gt;Method调用的是子类的方法，如果想调用父类的方法，     * 则需要用CallNonvirtual&lt;type&gt;Method，这个方法可以传入父类的class和父类的method id，从而达到调用父类方法的效果     *     *     * @param env JNI接口指针     * @param clazz class对象     * @param obj java对象     * @param methodID 方法ID     * @param args 调用参数     *     * @return java方法返回结果     *     * @throws java方法中可能抛出的异常     */    jobject (*CallNonvirtualObjectMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jobject (*CallNonvirtualObjectMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jobject (*CallNonvirtualObjectMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jboolean (*CallNonvirtualBooleanMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jboolean (*CallNonvirtualBooleanMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jboolean (*CallNonvirtualBooleanMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jbyte (*CallNonvirtualByteMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jbyte (*CallNonvirtualByteMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jbyte (*CallNonvirtualByteMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jchar (*CallNonvirtualCharMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jchar (*CallNonvirtualCharMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jchar (*CallNonvirtualCharMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jshort (*CallNonvirtualShortMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jshort (*CallNonvirtualShortMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jshort (*CallNonvirtualShortMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jint (*CallNonvirtualIntMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jint (*CallNonvirtualIntMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jint (*CallNonvirtualIntMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jlong (*CallNonvirtualLongMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jlong (*CallNonvirtualLongMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jlong (*CallNonvirtualLongMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jfloat (*CallNonvirtualFloatMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jfloat (*CallNonvirtualFloatMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jfloat (*CallNonvirtualFloatMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    jdouble (*CallNonvirtualDoubleMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    jdouble (*CallNonvirtualDoubleMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    jdouble (*CallNonvirtualDoubleMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    void (*CallNonvirtualVoidMethod)(JNIEnv *, jobject, jclass, jmethodID, ...);    void (*CallNonvirtualVoidMethodV)(JNIEnv *, jobject, jclass, jmethodID, va_list);    void (*CallNonvirtualVoidMethodA)(JNIEnv *, jobject, jclass, jmethodID, jvalue *);    /**     * 根据class对象获取非静态成员变量的field ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 变量名     * @param sig 变量签名     *     * @return field ID or NULL     *     * @throws NoSuchFieldError 找不到对应的变量ID     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jfieldID (*GetFieldID)(JNIEnv *, jclass, const char *, const char *);    /**     * 根据field id取出对象中相应的变量值，field Id通过GetFieldID()获取     *     * @param env JNI接口指针     * @param obj java对象     * @param fieldID 有效的field id     *     * @return 相应的变量值     */    jobject (*GetObjectField)(JNIEnv *, jobject, jfieldID);    jboolean (*GetBooleanField)(JNIEnv *, jobject, jfieldID);    jbyte (*GetByteField)(JNIEnv *, jobject, jfieldID);    jchar (*GetCharField)(JNIEnv *, jobject, jfieldID);    jshort (*GetShortField)(JNIEnv *, jobject, jfieldID);    jint (*GetIntField)(JNIEnv *, jobject, jfieldID);    jlong (*GetLongField)(JNIEnv *, jobject, jfieldID);    jfloat (*GetFloatField)(JNIEnv *, jobject, jfieldID);    jdouble (*GetDoubleField)(JNIEnv *, jobject, jfieldID);    /**     * 根据field id为相应的变量设置新的值，field Id通过GetFieldID()获取     *     * @param env JNI接口指针     * @param obj java对象     * @param fieldID 有效的field id     * @param value 要设置的值     */    void (*SetObjectField)(JNIEnv *, jobject, jfieldID, jobject);    void (*SetBooleanField)(JNIEnv *, jobject, jfieldID, jboolean);    void (*SetByteField)(JNIEnv *, jobject, jfieldID, jbyte);    void (*SetCharField)(JNIEnv *, jobject, jfieldID, jchar);    void (*SetShortField)(JNIEnv *, jobject, jfieldID, jshort);    void (*SetIntField)(JNIEnv *, jobject, jfieldID, jint);    void (*SetLongField)(JNIEnv *, jobject, jfieldID, jlong);    void (*SetFloatField)(JNIEnv *, jobject, jfieldID, jfloat);    void (*SetDoubleField)(JNIEnv *, jobject, jfieldID, jdouble);    /**     * 返回静态方法的method ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 方法名     * @param sig 方法签名     *     * @return 方法ID or NULL     *     * @throws NoSuchMethodError 找不到对应的方法     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jmethodID (*GetStaticMethodID)(JNIEnv *, jclass, const char *, const char *);    /**     * CallStatic&lt;type&gt;Method(JNIEnv *env, jclass clazz, jmethodID methodID, ...);调用参数放到可变参数中     * CallStatic&lt;type&gt;MethodA(JNIEnv *env, jclass clazz, jmethodID methodID, const jvalue *args);调用参数放入jvalue数组     * CallStatic&lt;type&gt;MethodV(JNIEnv *env, jclass clazz, jmethodID methodID, va_list args);调用参数放入va_list结构中     *     * 以上三组调用接口都是根据 method ID调用java静态方法的接口，其中method ID是通过GetStaticMethodID()获取的     * method ID必须从clazz的真实类获取，而不应从其某个父类获取     * &lt;type&gt;是方法的返回类型，三类接口间唯一的区别是methodID参数之后调用参数的不同     *     *     * @param env JNI接口指针     * @param clazz class对象     * @param methodID 方法ID     * @param args 调用参数     *     * @return java方法返回结果     *     * @throws java方法中可能抛出的异常     */    jobject (*CallStaticObjectMethod)(JNIEnv *, jclass, jmethodID, ...);    jobject (*CallStaticObjectMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jobject (*CallStaticObjectMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jboolean (*CallStaticBooleanMethod)(JNIEnv *, jclass, jmethodID, ...);    jboolean (*CallStaticBooleanMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jboolean (*CallStaticBooleanMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jbyte (*CallStaticByteMethod)(JNIEnv *, jclass, jmethodID, ...);    jbyte (*CallStaticByteMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jbyte (*CallStaticByteMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jchar (*CallStaticCharMethod)(JNIEnv *, jclass, jmethodID, ...);    jchar (*CallStaticCharMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jchar (*CallStaticCharMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jshort (*CallStaticShortMethod)(JNIEnv *, jclass, jmethodID, ...);    jshort (*CallStaticShortMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jshort (*CallStaticShortMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jint (*CallStaticIntMethod)(JNIEnv *, jclass, jmethodID, ...);    jint (*CallStaticIntMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jint (*CallStaticIntMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jlong (*CallStaticLongMethod)(JNIEnv *, jclass, jmethodID, ...);    jlong (*CallStaticLongMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jlong (*CallStaticLongMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jfloat (*CallStaticFloatMethod)(JNIEnv *, jclass, jmethodID, ...);    jfloat (*CallStaticFloatMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jfloat (*CallStaticFloatMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    jdouble (*CallStaticDoubleMethod)(JNIEnv *, jclass, jmethodID, ...);    jdouble (*CallStaticDoubleMethodV)(JNIEnv *, jclass, jmethodID, va_list);    jdouble (*CallStaticDoubleMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    void (*CallStaticVoidMethod)(JNIEnv *, jclass, jmethodID, ...);    void (*CallStaticVoidMethodV)(JNIEnv *, jclass, jmethodID, va_list);    void (*CallStaticVoidMethodA)(JNIEnv *, jclass, jmethodID, jvalue *);    /**     * 根据class对象获取静态成员变量的field ID     *     * @param env JNI接口指针     * @param clazz class对象     * @param name 变量名     * @param sig 变量签名     *     * @return field ID or NULL     *     * @throws NoSuchFieldError 找不到对应的变量ID     * @throws ExceptionInInitializerError class初始化失败     * @throws OutOfMemoryError 内存不足     */    jfieldID (*GetStaticFieldID)(JNIEnv *, jclass, const char *, const char *);    /**     * 根据field id取出对象中相应的变量值，field Id通过GetStaticFieldID()获取     *     * @param env JNI接口指针     * @param clazz class对象     * @param fieldID 有效的field id     *     * @return 相应的静态变量值     */    jobject (*GetStaticObjectField)(JNIEnv *, jclass, jfieldID);    jboolean (*GetStaticBooleanField)(JNIEnv *, jclass, jfieldID);    jbyte (*GetStaticByteField)(JNIEnv *, jclass, jfieldID);    jchar (*GetStaticCharField)(JNIEnv *, jclass, jfieldID);    jshort (*GetStaticShortField)(JNIEnv *, jclass, jfieldID);    jint (*GetStaticIntField)(JNIEnv *, jclass, jfieldID);    jlong (*GetStaticLongField)(JNIEnv *, jclass, jfieldID);    jfloat (*GetStaticFloatField)(JNIEnv *, jclass, jfieldID);    jdouble (*GetStaticDoubleField)(JNIEnv *, jclass, jfieldID);    /**     * 根据field id为相应的静态变量设置新的值，field Id通过GetStaticFieldID()获取     *     * @param env JNI接口指针     * @param clazz class对象     * @param fieldID 有效的field id     * @param value 要设置的值     */    void (*SetStaticObjectField)(JNIEnv *, jclass, jfieldID, jobject);    void (*SetStaticBooleanField)(JNIEnv *, jclass, jfieldID, jboolean);    void (*SetStaticByteField)(JNIEnv *, jclass, jfieldID, jbyte);    void (*SetStaticCharField)(JNIEnv *, jclass, jfieldID, jchar);    void (*SetStaticShortField)(JNIEnv *, jclass, jfieldID, jshort);    void (*SetStaticIntField)(JNIEnv *, jclass, jfieldID, jint);    void (*SetStaticLongField)(JNIEnv *, jclass, jfieldID, jlong);    void (*SetStaticFloatField)(JNIEnv *, jclass, jfieldID, jfloat);    void (*SetStaticDoubleField)(JNIEnv *, jclass, jfieldID, jdouble);    /**     * 创建一个新的java.lang.String对象     *     * @param env JNI接口指针     * @param unicodeChars 指向Unicode字符串的指针     * @param len Unicode字符串的长度     *     * @return String对象 or NULL     *     * @throws OutOfMemoryError 内存不足     */    jstring (*NewString)(JNIEnv *, const jchar *, jsize);    /**     * 返回java.lang.String的长度（Unicode字符数）     *     * @param env JNI接口指针     * @param string String对象     *     * @return 长度     */    jsize (*GetStringLength)(JNIEnv *, jstring);    /**     * 返回指向Unicode字符数组的指针     * 该指针在调用ReleaseStringchars()前一直有效     * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE     *     * @param env JNI接口指针     * @param string String对象     * @param isCopy 指向boolean的指针     *     * @return 指向字符串的指针 or NULL     */    const jchar *(*GetStringChars)(JNIEnv *, jstring, jboolean *);    /**     * 通知VM无需再访问chars     * chars是一个指针，通过GetStringChars()     *     * @param env JNI接口指针     * @param string String对象     * @param chars 指向字符串的指针     */    void (*ReleaseStringChars)(JNIEnv *, jstring, const jchar *);    /**     * 根据UTF-8编码的字符数组创建一个新的java.lang.String对象     *     * @param env JNI接口指针     * @param bytes 指向UTF-8字符串的指针     *     * @return String对象 or NULL     *     * @throws OutOfMemoryError 内存不足     */    jstring (*NewStringUTF)(JNIEnv *, const char *);    /**     * 返回字符串以UTF-8为编码的字节数     *     * @param env JNI接口指针     * @param string String对象     *     * @return 字符串的UTF-8字节数     */    jsize (*GetStringUTFLength)(JNIEnv *, jstring);    /**     * 返回指向UTF-8编码字符数组的指针     * 该指针在调用ReleaseStringUTFChars()前一直有效     * 如果isCopy非空，则在复制完成后将*isCopy设为JNI_TRUE。否则设为JNI_FALSE     *     * @param env JNI接口指针     * @param string String对象     * @param isCopy 指向boolean的指针     *     * @return 指向字符串的指针 or NULL     */    const char *(*GetStringUTFChars)(JNIEnv *, jstring, jboolean *);    /**     * 通知VM无需再访问utf     * utf是一个指针，通过GetStringUTFChars()     *     * @param env JNI接口指针     * @param string String对象     * @param utf 指向字符串的指针     */    void (*ReleaseStringUTFChars)(JNIEnv *, jstring, const char *);    /**     * 获取数组元素个数     *     * @param env JNI接口指针     * @param array java数组对象     *     * @return 数组长度     */    jsize (*GetArrayLength)(JNIEnv *, jarray);    /**     * 创建新的elementClass类型数组，所有元素初始值均设为initialElement     *     * @param env JNI接口指针     * @param length 数组大小     * @param elementClass 数组类型     * @param initialElement 初始值     *     * @return 数组对象 or NULL     */    jobjectArray (*NewObjectArray)(JNIEnv *, jsize, jclass, jobject);    /**     * 获取对象数组中指定index的值     *     * @param env JNI接口指针     * @param array java数组     * @param index 索引     *     * @return 索引对象的对象     *     * @throws ArrayIndexOutOfBoundsException     */    jobject (*GetObjectArrayElement)(JNIEnv *, jobjectArray, jsize);    /**     * 设置对象数组中指定index的值     *     * @param env JNI接口指针     * @param array java数组     * @param index 索引     * @param value 新的值     *     * @throws ArrayIndexOutOfBoundsException     */    void (*SetObjectArrayElement)(JNIEnv *, jobjectArray, jsize, jobject);    /**     * ArrayType New&lt;PrimitiveType&gt;Array(JNIEnv *env, jsize length);     * 创建基本类型数组对象     *     * @param env JNI接口指针     * @param length 数组大小     *     * @return 数组对象 or NULL     */    jbooleanArray (*NewBooleanArray)(JNIEnv *, jsize);    jbyteArray (*NewByteArray)(JNIEnv *, jsize);    jcharArray (*NewCharArray)(JNIEnv *, jsize);    jshortArray (*NewShortArray)(JNIEnv *, jsize);    jintArray (*NewIntArray)(JNIEnv *, jsize);    jlongArray (*NewLongArray)(JNIEnv *, jsize);    jfloatArray (*NewFloatArray)(JNIEnv *, jsize);    jdoubleArray (*NewDoubleArray)(JNIEnv *, jsize);    /**     * NativeType *Get&lt;PrimitiveType&gt;ArrayElements(JNIEnv *env, ArrayType array, jboolean *isCopy);     * 返回基本类型数组中的数据，通过返回的指针可以访问这些数据，若虚拟机支持pinning，则指针指向原始数组，否则指向原始数组的拷贝     * 返回的指针在Release&lt;PrimitiveType&gt;ArrayElements()调用前一直有效     * 数组用使用结束后，调用Release&lt;PrimitiveType&gt;ArrayElements，并在调用参数中决定是否把修改提交给java     *     * @param env JNI接口指针     * @param array java数组     * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE     *     * @return 指向数组元素的指针 or NULL     */    jboolean *(*GetBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *);    jbyte *(*GetByteArrayElements)(JNIEnv *, jbyteArray, jboolean *);    jchar *(*GetCharArrayElements)(JNIEnv *, jcharArray, jboolean *);    jshort *(*GetShortArrayElements)(JNIEnv *, jshortArray, jboolean *);    jint *(*GetIntArrayElements)(JNIEnv *, jintArray, jboolean *);    jlong *(*GetLongArrayElements)(JNIEnv *, jlongArray, jboolean *);    jfloat *(*GetFloatArrayElements)(JNIEnv *, jfloatArray, jboolean *);    jdouble *(*GetDoubleArrayElements)(JNIEnv *, jdoubleArray, jboolean *);    /**     * Release&lt;PrimitiveType&gt;ArrayElements     * 通知VM不再需要访问这些数组，根据mode参数的不同，将决定是否把数组的修改复制到源数组     *     * @param env JNI接口指针     * @param array java数组对象     * @param elems 指向数组元素的指针     * @param mode 释放模式，0：把数据复制回源数组并释放elems缓冲区，JNI_COMMIT：把数据复制回源数组但不释放elems缓冲区，JNI_ABORT：不把数据复制回源数组，释放elems缓冲区     */    void (*ReleaseBooleanArrayElements)(JNIEnv *, jbooleanArray, jboolean *, jint);    void (*ReleaseByteArrayElements)(JNIEnv *, jbyteArray, jbyte *, jint);    void (*ReleaseCharArrayElements)(JNIEnv *, jcharArray, jchar *, jint);    void (*ReleaseShortArrayElements)(JNIEnv *, jshortArray, jshort *, jint);    void (*ReleaseIntArrayElements)(JNIEnv *, jintArray, jint *, jint);    void (*ReleaseLongArrayElements)(JNIEnv *, jlongArray, jlong *, jint);    void (*ReleaseFloatArrayElements)(JNIEnv *, jfloatArray, jfloat *, jint);    void (*ReleaseDoubleArrayElements)(JNIEnv *, jdoubleArray, jdouble *, jint);    /**     * void Get&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, NativeType *buf);     * 把基本类型数组拷贝到buf中     *     * @param env JNI接口指针     * @param array java数组     * @param start 开始index     * @param len 拷贝长度     * @param buf 目标地址     *     * @throws ArrayIndexOutOfBoundsException     */    void (*GetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, jboolean *);    void (*GetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, jbyte *);    void (*GetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, jchar *);    void (*GetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, jshort *);    void (*GetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, jint *);    void (*GetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, jlong *);    void (*GetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, jfloat *);    void (*GetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, jdouble *);    /**     * void Set&lt;PrimitiveType&gt;ArrayRegion(JNIEnv *env, ArrayType array, jsize start, jsize len, const NativeType *buf);     * 把buf中的内容拷贝回数组中     *     * @param env JNI接口指针     * @param array java数组     * @param start 开始index     * @param len 拷贝长度     * @param buf 源数据     *     * @throws ArrayIndexOutOfBoundsException     */    void (*SetBooleanArrayRegion)(JNIEnv *, jbooleanArray, jsize, jsize, const jboolean *);    void (*SetByteArrayRegion)(JNIEnv *, jbyteArray, jsize, jsize, const jbyte *);    void (*SetCharArrayRegion)(JNIEnv *, jcharArray, jsize, jsize, const jchar *);    void (*SetShortArrayRegion)(JNIEnv *, jshortArray, jsize, jsize, const jshort *);    void (*SetIntArrayRegion)(JNIEnv *, jintArray, jsize, jsize, const jint *);    void (*SetLongArrayRegion)(JNIEnv *, jlongArray, jsize, jsize, const jlong *);    void (*SetFloatArrayRegion)(JNIEnv *, jfloatArray, jsize, jsize, const jfloat *);    void (*SetDoubleArrayRegion)(JNIEnv *, jdoubleArray, jsize, jsize, const jdouble *);    /**     * 为clazz类注册本地方法     *     * @param env JNI接口指针     * @param clazz class对象     * @param methods clazz类中的本地方法，指向方法数组     * @param nMethods 本地方法个数     *     * @return 0：成功， 负数：失败     *     * @throws NoSuchMethodError     */    jint (*RegisterNatives)(JNIEnv *, jclass, const JNINativeMethod *, jint);    /**     * 取消clazz类本地方法的注册     *     * @param env JNI接口指针     * @param clazz class对象     *     * @return 0：成功， 负数：失败     */    jint (*UnregisterNatives)(JNIEnv *, jclass);    /**     * 进入与obj所引用的Java对象相关联的监控，obj 必须为非空     *     * @param env JNI接口指针     * @param obj java对象 或 class对象     *     * @return 0：成功， 负数：失败     */    jint (*MonitorEnter)(JNIEnv *, jobject);    /**     * 退出与obj所引用的Java对象相关联的监控，obj 必须为非空     * 当前线程必须是与obj所引用的Java对象相关联的监控程序的所有者     * 监控程序次数的计数器减 1。如果计数器的值变为 0，则释放当前线程的监控程序     *     * @param env JNI接口指针     * @param obj java对象 或 class对象     *     * @return 0：成功， 负数：失败     */    jint (*MonitorExit)(JNIEnv *, jobject);    /**     * 获取当前线程关联的Java VM接口     *     * @param env JNI接口指针     * @param vm java VM接口指针     *     * @return 0：成功， 负数：失败     */    jint (*GetJavaVM)(JNIEnv *, JavaVM **);    /**     * 从start index开始，拷贝len个Unicode字符到buf     *     * @param env JNI接口指针     * @param str string对象     * @param start 开始index     * @param len 拷贝长度     * @param buf 目标地址     *     * @throws StringIndexOutOfBoundsException     */    void (*GetStringRegion)(JNIEnv *, jstring, jsize, jsize, jchar *);    /**     * 从start index开始，取出len个Unicode字符转换为UTF-8编码后拷贝到buf     *     * @param env JNI接口指针     * @param str string对象     * @param start 开始index     * @param len 拷贝长度     * @param buf 目标地址     *     * @throws StringIndexOutOfBoundsException     */    void (*GetStringUTFRegion)(JNIEnv *, jstring, jsize, jsize, char *);    /**     * 与Get/Release&lt;primitivetype&gt;ArrayElements方法非常相似，在这个方法中VM尽量返回指向原始数组的指针     *     * @since JDK/JRE 1.2     *     * @param env JNI接口指针     * @param array java数组     * @param isCopy 指向boolean的指针，若不为NULL，则执行了复制设为JNI_TRUE，否则设为JNI_FALSE     *     * @return 指向数组元素的指针 or NULL     */    void *(*GetPrimitiveArrayCritical)(JNIEnv *, jarray, jboolean *);    void (*ReleasePrimitiveArrayCritical)(JNIEnv *, jarray, void *, jint);    /**     * 与Get/ReleaseStringChars方法非常相似，在这个方法中VM尽量返回指向原始字符串的指针     *     * @since JDK/JRE 1.2     *     * @param env JNI接口指针     * @param string String对象     * @param isCopy 指向boolean的指针     *     * @return 指向字符串的指针 or NULL     */    const jchar *(*GetStringCritical)(JNIEnv *, jstring, jboolean *);    void (*ReleaseStringCritical)(JNIEnv *, jstring, const jchar *);    /**     * 为传入的obj创建弱全局引用     * 弱全局引用不会阻止VM释放所引用的对象，程序中可以通过使用IsSameObject比较弱全局引用和NULL来确认所引用的对象是否被释放     *     * @param env JNI接口指针     * @param obj 全局或局部引用     *     * @return 弱全局引用 or NULL     */    jweak (*NewWeakGlobalRef)(JNIEnv *, jobject);    /**     * 删除弱全局引用     *     * @param env JNI接口指针     * @param obj 弱全局引用     */    void (*DeleteWeakGlobalRef)(JNIEnv *, jweak);    /**     * 判断是否有未处理异常     *     * @param env JNI接口指针     *     * @return JNI_TRUE表示有未处理异常，否则为JNI_FALSE     */    jboolean (*ExceptionCheck)(JNIEnv *);    /**     * 创建并返回java.nio.ByteBuffer对象，该对象引用以address为开始地址，大小为capacity的内存块     *     * @since JDK/JRE 1.4     *     * @param env JNI接口指针     * @param address 开始地址     * @param capacity 内存大小     *     * @return Jjava.nio.ByteBuffer or NULL     *     * @throws OutOfMemoryError     */    jobject (*NewDirectByteBuffer)(JNIEnv *, void *, jlong);    /**     * 根据java.nio.ByteBuffer对象，获取相应的内存数据并返回开始地址     *     * @since JDK/JRE 1.4     *     * @param env JNI接口指针     * @param buf java.nio.ByteBuffer对象     *     * @return 数据的开始地址 or NULL     */    void *(*GetDirectBufferAddress)(JNIEnv *, jobject);    /**     * 根据java.nio.ByteBuffer对象，获取相应的内存数据的大小     *     * @since JDK/JRE 1.4     *     * @param env JNI接口指针     * @param buf java.nio.ByteBuffer对象     *     * @return 数据大小 or -1     */    jlong (*GetDirectBufferCapacity)(JNIEnv *, jobject);    /**     * 获取java对象的引用类型，可能的返回值有：     * JNIInvalidRefType     * JNILocalRefType：局部引用     * JNIGlobalRefType：全局引用     * JNIWeakGlobalRefType ：全局弱若引用     *     * @since JDK/JRE 1.6     *     * @param env JNI接口指针     * @param obj java对象的引用     *     * @return 引用类型     */    jobjectRefType (*GetObjectRefType)(JNIEnv *, jobject);</code></pre><h3 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h3><p>一般用的最多的就是Java调用C的实现, 下面给出了一个非常简单的例子:</p><pre><code class="c">JNIEXPORT jintArray JNICALL Java_com_example_Test_intMethod(JNIENV *env, jobject jobject, jintArray jarray) {  //遍历数组元素, 每个元素+5; 最后返回原数组  int length = (*env)-&gt;GetArrayLength(env, jarray);  int *array = (*env)-&gt;GetINtArrayElements(env,jarray,0);  for(int i=0; i &lt; length; ++i) {      *(array+i) += 5;  }  return jarray;}</code></pre><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>jni本身还是比较简单的, 因为机制比较成熟了. 基本的规则, 本文已经讲了非常多了, 关键还是要熟悉 jni.h 这个文件里的相关API.</p><p>先这样, 以后用到了再来详细搞.</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="">《the JNI Programmer’s Guide and Specification》</a>  主要参考资料, 把这本好好读读就可以了</li><li><a href="http://docs.oracle.com/javase/7/docs/technotes/guides/jni/" target="_blank" rel="external">http://docs.oracle.com/javase/7/docs/technotes/guides/jni/</a> 主要参考资料</li><li><a href="">JNI编程指南</a>  网上找的比较偏理论的讲解,80多页</li><li><a href="http://blog.csdn.net/shensky711/article/details/52806794" target="_blank" rel="external">http://blog.csdn.net/shensky711/article/details/52806794</a>  作者写的太乱了</li></ol><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      JNI技术, 一种本来是用来写java虚拟机的技术, 后来被NDK玩坏了
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="框架" scheme="www.merlinblog.site/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Rapid Json</title>
    <link href="www.merlinblog.site/2017/08/22/rapid-json.html"/>
    <id>www.merlinblog.site/2017/08/22/rapid-json.html</id>
    <published>2017-08-22T00:07:54.000Z</published>
    <updated>2017-09-26T05:40:47.126Z</updated>
    
    <content type="html"><![CDATA[<p>国人自己开发的库, 全部以头文件的形式包含. 在知乎的<a href="https://www.zhihu.com/question/23654513" target="_blank" rel="external">评测</a>也是各种好评.<br>其他的解析工具, 玩玩就可以了, 实际项目中, 还是推荐用 <code>RapidJson</code>.</p><p>本文是关于 rapid-json 的简单讲解和介绍.</p><p><img src="http://omotkhw3y.bkt.clouddn.com/rjson.jpg" alt=""></p><a id="more"></a><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>发现每次都会有一大堆人去说XML和JSON的优缺点, 我觉得也是挺烦的, 下面一句话带过:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;&lt;country&gt;  &lt;name&gt;中国&lt;/name&gt;  &lt;province&gt;    &lt;name&gt;黑龙江&lt;/name&gt;    &lt;citys&gt;      &lt;city&gt;哈尔滨&lt;/city&gt;      &lt;city&gt;大庆&lt;/city&gt;    &lt;/citys&gt;  　　  &lt;/province&gt;  &lt;province&gt;    &lt;name&gt;广东&lt;/name&gt;    &lt;citys&gt;      &lt;city&gt;广州&lt;/city&gt;      &lt;city&gt;深圳&lt;/city&gt;      &lt;city&gt;珠海&lt;/city&gt;    &lt;/citys&gt; 　　  &lt;/province&gt;  &lt;province&gt;    &lt;name&gt;台湾&lt;/name&gt;    &lt;citys&gt;      　&lt;city&gt;台北&lt;/city&gt;      　&lt;city&gt;高雄&lt;/city&gt;    &lt;/citys&gt;　  &lt;/province&gt;  &lt;province&gt;    &lt;name&gt;新疆&lt;/name&gt;    &lt;citys&gt;      &lt;city&gt;乌鲁木齐&lt;/city&gt;    &lt;/citys&gt;  &lt;/province&gt;&lt;/country&gt;</code></pre><p>再看json</p><pre><code>{    name: &quot;中国&quot;,    provinces:         [     { name: &quot;黑龙江&quot;, citys: { city: [&quot;哈尔滨&quot;, &quot;大庆&quot;]} },     { name: &quot;广东&quot;, citys: { city: [&quot;广州&quot;, &quot;深圳&quot;, &quot;珠海&quot;]} },     { name: &quot;台湾&quot;, citys: { city: [&quot;台北&quot;, &quot;高雄&quot;]} },     { name: &quot;新疆&quot;, citys: { city: [&quot;乌鲁木齐&quot;]} }    ]}</code></pre><p>XML的可读性稍微好一些, 但是冗余信息多, 体积大; 并且解析方便程度来说, JSON完胜.<br>(但是业界流行程度来说, XML业界广泛认同)</p><p>本文主要介绍RapidJson的使用以及一些心得, 如果你对它的源码也感兴趣的话, 可以参考该 <a href="http://miloyip.com/rapidjson/" target="_blank" rel="external">链接</a><br>(补充, 有人喜欢用 <a href="http://blog.csdn.net/hailong0715/article/details/51942736" target="_blank" rel="external">JsonCpp</a>, 不过还是推荐你用RapidJson吧)</p><p>(虽然有官方教程, 不过觉得那个教程也是非常啰嗦的)</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>rapidjson是腾讯的开源json解析框架，用c++实现。由于全部代码仅用header file实现，所以很容易集成到项目中。rapidjson的另一个特点是对json的标准符合程度是100%的(在开启了full precision选项的情况下).</p><p>最重要的: <code>RapidJSON is a JSON parser and generator for C++</code> .</p><p>总之, 业界也有好评, 个人觉得比 JsonCpp 好.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>RapidJSON 是只有头文件的 C++ 库。只需把 include/rapidjson 目录复制至系统或项目的 include 目录中。<br>给出我的参考步骤:</p><pre><code>$ git clone https://github.com/miloyip/rapidjson.git$ cmake .$ sudo make install</code></pre><p>然后, 你的相关库就安装到了 <code>/usr/local/include/</code></p><h2 id="库文件"><a href="#库文件" class="headerlink" title="库文件"></a>库文件</h2><p>安装完了, 顺便可以扫一眼, 都有哪些库:</p><pre><code>$ tree -L 2 /usr/local/include/rapidjson/usr/local/include/rapidjson├── allocators.h├── document.h├── encodedstream.h├── encodings.h├── error│   ├── en.h│   └── error.h├── filereadstream.h├── filewritestream.h├── fwd.h├── internal│   ├── biginteger.h│   ├── diyfp.h│   ├── dtoa.h│   ├── ieee754.h│   ├── itoa.h│   ├── meta.h│   ├── pow10.h│   ├── regex.h│   ├── stack.h│   ├── strfunc.h│   ├── strtod.h│   └── swap.h├── istreamwrapper.h├── memorybuffer.h├── memorystream.h├── msinttypes│   ├── inttypes.h│   └── stdint.h├── ostreamwrapper.h├── pointer.h├── prettywriter.h├── rapidjson.h├── reader.h├── schema.h├── stream.h├── stringbuffer.h└── writer.h3 directories, 35 files</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>先来些简单的案例, 再说相关的API和机制.</p><p>此简单例子解析一个 JSON 字符串至一个 document (DOM), 对 DOM 作出简单修改, 最终把 DOM 转换(stringify) 至 JSON 字符串.</p><pre><code class="c++">// JSON simple example// This example does not handle errors.#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/writer.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &lt;iostream&gt;using namespace rapidjson;int main() {    // 1. Parse a JSON string into DOM.    const char* json = &quot;{\&quot;project\&quot;:\&quot;rapidjson\&quot;,\&quot;stars\&quot;:10}&quot;;    Document d;    d.Parse(json);    // 2. Modify it by DOM.    Value&amp; s = d[&quot;stars&quot;];    s.SetInt(s.GetInt() + 1);    // 3. Stringify the DOM    StringBuffer buffer;    Writer&lt;StringBuffer&gt; writer(buffer);    d.Accept(writer);    // Output {&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11}    std::cout &lt;&lt; buffer.GetString() &lt;&lt; std::endl;    return 0;}</code></pre><p>注意此例子并没有处理潜在错误, 比如:</p><pre><code class="c++">// 2. Modify it by DOM.   Value&amp; s = d[&quot;stars&quot;];if( s.IsInt() ) {    s.SetInt(s.GetInt() + 1);  }</code></pre><p>编译运行:</p><pre><code>$ g++ -g -Wall -O0 simpledom.cpp -o simpledom -I/usr/local/inlcude/$ ./simpledom{&quot;project&quot;:&quot;rapidjson&quot;,&quot;stars&quot;:11}</code></pre><p>可以简单的得出结论, 解析JSON是围绕 <code>rapidjson::Document</code>, <code>rapidjson::Value</code> 展开的, 关键性头文件:</p><ul><li>rapidjson/document.h</li><li>rapidjson/writer.h</li></ul><hr><p>再来一个实用一点儿的例子:<br>test.json</p><pre><code>{    &quot;dictVersion&quot;: 1,      &quot;content&quot;:      [           {&quot;key&quot;: &quot;word1&quot;, &quot;value&quot;: &quot;单词1&quot;} ,        {&quot;key&quot;: &quot;word2&quot;, &quot;value&quot;: &quot;单词2&quot;} ,        {&quot;key&quot;: &quot;word3&quot;, &quot;value&quot;: &quot;单词3&quot;} ,        {&quot;key&quot;: &quot;word4&quot;, &quot;value&quot;: &quot;单词4&quot;} ,        {&quot;key&quot;: &quot;word5&quot;, &quot;value&quot;: &quot;单词5&quot;}     ]}</code></pre><p>对于这种格式化好的文件的读写, 可以采用流式读写处理:</p><pre><code class="c++">// test.cpp#include &quot;rapidjson/document.h&quot;#include &quot;rapidjson/stringbuffer.h&quot;#include &quot;rapidjson/writer.h&quot;#include &lt;fstream&gt;#include &lt;string&gt;#include &lt;cassert&gt;#include &lt;iostream&gt;#define psln(x) std::cout &lt;&lt; #x &quot; = &quot; &lt;&lt; (x) &lt;&lt; std::endlvoid testSimpleDoc() {  using std::string;  using std::ifstream;  // read json content into string.  string      stringFromStream;  ifstream    in;  in.open(&quot;test.json&quot;, ifstream::in);  if (!in.is_open())    return;  string line;  while (getline(in, line)) {    stringFromStream.append(line + &quot;\n&quot;);  }  in.close();  // ---------------------------- read json --------------------  // parse json from string.  using rapidjson::Document;  Document doc;  doc.Parse(stringFromStream.c_str());  if (doc.HasParseError()) {    rapidjson::ParseErrorCode code = doc.GetParseError();    psln(code);    return;  }  // use values in parse result.  using rapidjson::Value;  using rapidjson::Type;  using rapidjson::StringBuffer;  using rapidjson::Writer;  Value &amp; v = doc[&quot;dictVersion&quot;];  if (v.IsInt()) {    psln(v.GetInt());  }  Value &amp; contents = doc[&quot;content&quot;];  if (contents.IsArray()) {    for (size_t i = 0; i &lt; contents.Size(); ++i) {      Value &amp; v = contents[i];      assert(v.IsObject());      if (v.HasMember(&quot;key&quot;) &amp;&amp; v[&quot;key&quot;].IsString()) {    psln(v[&quot;key&quot;].GetString());      }      if (v.HasMember(&quot;value&quot;) &amp;&amp; v[&quot;value&quot;].IsString()) {    psln(v[&quot;value&quot;].GetString());      }    }  }  // ---------------------------- write json --------------------  psln(&quot;add a value into array&quot;);  Value item(Type::kObjectType);  item.AddMember(&quot;key&quot;, &quot;word5&quot;, doc.GetAllocator());  item.AddMember(&quot;value&quot;, &quot;单词5&quot;, doc.GetAllocator());  contents.PushBack(item, doc.GetAllocator());  // convert dom to string.  StringBuffer buffer;      // in rapidjson/stringbuffer.h  Writer&lt;StringBuffer&gt; writer(buffer); // in rapidjson/writer.h  doc.Accept(writer);// Accept() traverses the DOM and generates Handler events.  psln(buffer.GetString());}int main(void){  testSimpleDoc();  return 0;}</code></pre><p>编译运行:</p><pre><code>$ g++ -g -Wall test.cpp -o test -I/usr/local/include$ ./test v.GetInt() = 1v[&quot;key&quot;].GetString() = word1v[&quot;value&quot;].GetString() = 单词1v[&quot;key&quot;].GetString() = word2v[&quot;value&quot;].GetString() = 单词2v[&quot;key&quot;].GetString() = word3v[&quot;value&quot;].GetString() = 单词3v[&quot;key&quot;].GetString() = word4v[&quot;value&quot;].GetString() = 单词4v[&quot;key&quot;].GetString() = word5v[&quot;value&quot;].GetString() = 单词5&quot;add a value into array&quot; = add a value into arraybuffer.GetString() = {&quot;dictVersion&quot;:1,&quot;content&quot;:[{&quot;key&quot;:&quot;word1&quot;,&quot;value&quot;:&quot;单词1&quot;},{&quot;key&quot;:&quot;word2&quot;,&quot;value&quot;:&quot;单词2&quot;},{&quot;key&quot;:&quot;word3&quot;,&quot;value&quot;:&quot;单词3&quot;},{&quot;key&quot;:&quot;word4&quot;,&quot;value&quot;:&quot;单词4&quot;},{&quot;key&quot;:&quot;word5&quot;,&quot;value&quot;:&quot;单词5&quot;},{&quot;key&quot;:&quot;word5&quot;,&quot;value&quot;:&quot;单词5&quot;}]}</code></pre><p>从上面两个例子, 就可以看出, 只要你给document对象parse(const char*)一个C串, 那么它就会把解析的内容全部存储在document对象里; <code>Value &amp; v = doc[key];</code> 可以拿到单个对象或者Array(这里的array就像一个list或者数组), 结合Value进行读写, Value类含有 <code>HasMember()</code>, <code>AddMemeber()</code> 之类的方法, 以及和Document类一样重载了 <code>operator[]()</code>, 而<code>v[&quot;key&quot;].GetString()</code>,  <code>v.GetInt()</code> 则可以拿到具体的内容. 上面例子只给出了array如何添加成员, 其实document添加成员, 也是<code>document.AddMember(&quot;key buffer&quot;, &quot;value buffer-object&quot;, document.GetAllocator());</code> , 并且 document 可以是Object, 也可以是Array, 上面这些例子都是Object. </p><p>value[“key”]得到的类型还是Value类型, 当然也可以用v.IsObject()检验:</p><pre><code class="c++">//Document -&gt; ValueValue &amp; v = doc[key];v.GetInt();//对比: value.GetInt()v[&quot;key&quot;].GetString()</code></pre><p>漂亮的输出到屏幕上(格式修正):</p><pre><code class="c++">   #include &quot;rapidjson/prettywriter.h&quot;    StringBuffer sb;    PrettyWriter&lt;StringBuffer&gt; writer(sb);    document.Accept(writer);    puts(sb.GetString());</code></pre><p>运行结果大致是:</p><pre><code>v.GetInt() = 1v[&quot;key&quot;].GetString() = word1v[&quot;value&quot;].GetString() = 单词1v[&quot;key&quot;].GetString() = word2v[&quot;value&quot;].GetString() = 单词2v[&quot;key&quot;].GetString() = word3v[&quot;value&quot;].GetString() = 单词3v[&quot;key&quot;].GetString() = word4v[&quot;value&quot;].GetString() = 单词4&quot;add a value into array&quot; = add a value into arraybuffer.GetString() = {    &quot;dictVersion&quot;: 1,    &quot;content&quot;: [        {            &quot;key&quot;: &quot;word1&quot;,            &quot;value&quot;: &quot;单词1&quot;        },        {            &quot;key&quot;: &quot;word2&quot;,            &quot;value&quot;: &quot;单词2&quot;        },        {            &quot;key&quot;: &quot;word3&quot;,            &quot;value&quot;: &quot;单词3&quot;        },        {            &quot;key&quot;: &quot;word4&quot;,            &quot;value&quot;: &quot;单词4&quot;        },        {            &quot;key&quot;: &quot;word5&quot;,            &quot;value&quot;: &quot;单词5&quot;        }    ]}</code></pre><p>之后如果你想写入文件, 那么就把 <code>sb.GetString()</code> 以文本格式写入文件即可; 或者借助其他的流(下面的例子从stdin和stdout作为流输入和输出):</p><pre><code class="c++">#include &quot;rapidjson/reader.h&quot;#include &quot;rapidjson/prettywriter.h&quot;#include &quot;rapidjson/filereadstream.h&quot;#include &quot;rapidjson/filewritestream.h&quot;#include &quot;rapidjson/error/en.h&quot;using namespace rapidjson;int main(int, char*[]) {    // Prepare reader and input stream.    Reader reader;    char readBuffer[65536];    /*     ifstream    in;     in.open(&quot;test.json&quot;, ifstream::in);     */    FileReadStream is(stdin, readBuffer, sizeof(readBuffer));    // Prepare writer and output stream.    char writeBuffer[65536];    FileWriteStream os(stdout, writeBuffer, sizeof(writeBuffer));    PrettyWriter&lt;FileWriteStream&gt; writer(os);    // JSON reader parse from the input stream and let writer generate the output.    if (!reader.Parse&lt;kParseValidateEncodingFlag&gt;(is, writer)) {        fprintf(stderr, &quot;\nError(%u): %s\n&quot;,      static_cast&lt;unsigned&gt;(reader.GetErrorOffset()),          GetParseError_En(reader.GetParseErrorCode()));        return 1;    }    return 0;}</code></pre><p>总之, 先把流读到字符串, 之后写解析逻辑.</p><h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>其实说到这里, 使用上, 基本没有问题了.</p><p>进一步的深入, 我给的建议是: </p><ol><li>先读一下 <a href="http://rapidjson.org/zh-cn/md_doc_tutorial_8zh-cn.html" target="_blank" rel="external">官方教程</a>.</li><li>然后把源码下面的 example 下面所有的 demo 全部玩一遍.</li></ol><p>教程里面, 拷贝转移以及move()部分, 内存流&amp;文件流部分(包装流效率不高), DOM&amp;SAX部分都是仔细看的, 下面是我的部分笔记:</p><pre><code>Value可以用作表示Object, Array, 甚至简单的stringValue a(kArrayType);Value o(Type::kObjectType);Value s = &quot;str&quot;;如果Value直接写Value v; //NUll此时你并不知道它表示什么.下面这种形式存储的就是指针了(浅拷贝)Value s;s.SetString(&quot;rapidjson&quot;);    // 可包含空字符，长度在编译萁推导s = &quot;rapidjson&quot;;             // 上行的缩写直接赋值, 有时候为了安全, 需要做一下标记: `StringRef(cstr)`const char * cstr = getenv(&quot;USER&quot;);    //注意是 const char *size_t cstr_len = ...;                 // 如果有长度Value s;// s.SetString(cstr);                  // 这不能通过编译s.SetString(StringRef(cstr));          // 可以，假设它的生命周期安全，并且是以空字符结尾的s = StringRef(cstr);                   // 上行的缩写s.SetString(StringRef(cstr, cstr_len));// 更快，可处理空字符s = StringRef(cstr, cstr_len);         // 上行的缩写补充: 和value的直接赋值, AddMember(), PushBack() 都采用转移语义(没有分配内存)这是深拷贝, setString时提供了allocator, 并且指定了长度.//value.GetStringLength() 能获取UTF字符串中如果存在\u000即空字符的情况下的长度//比strlen()强大, 当然如果你不传入长度, 那就默认使用strlen()value.SetString(buffer, len, document.GetAllocator()); 如果value之间, 想深复制, 那么有两种方式:1. 构造中带有allocatorDocument d;Document::AllocatorType&amp; a = d.GetAllocator();Value v1(&quot;foo&quot;);// Value v2(v1); // 不容许Value v2(v1, a); // 制造一个克隆2. 采用copyfromValue v2;v2.CopyFrom(v1, a);对于Value如果是 Object, 它的AddMemeber()比较标准的写法, 即采用的是重置的写法://和Document一样的AddMember(), 注Object是有key, value的pair,并且key一定是字符串Value item(Type::kObjectType);item.AddMember(&quot;key&quot;, &quot;word5&quot;, doc.GetAllocator());Value类型是Array, 注意它的PushBack是移动语义就可以了(即使带了allocator), 当然这是针对非基本类型的数据(String, Object), 即Push进去的元素可以是string类型的value, 或者Object类型的value.push进去的是 string类型或者Object类型也存在临时变量无法赋值给非const引用的, 移动语义问题, 可以类似解决方法: move()返回一个非const引用// 就地 Value 参数contact.PushBack(Value(&quot;copy&quot;, document.GetAllocator()).Move(), // copy string                 document.GetAllocator());// 显式 Value 参数Value val(&quot;key&quot;, document.GetAllocator()); // copy stringcontact.PushBack(val, document.GetAllocator());</code></pre><p>这个时候(把那个几个example玩熟), 对这个库已经很熟悉了.<br>再深入, 就结合他的<a href="rapidjson.org">官网</a>以及源码慢慢琢磨吧.</p><hr><h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>没太多可说的, 写多了就熟悉了.</p><hr><p>who is sponsoring the site? - i shall say merlin (<code>wizardmerlin945@gmail.com</code>)<br>欢迎发邮件给我(生活问题，请高抬贵手)</p>]]></content>
    
    <summary type="html">
    
      总结rapid-json
    
    </summary>
    
      <category term="codings" scheme="www.merlinblog.site/categories/codings/"/>
    
    
      <category term="框架" scheme="www.merlinblog.site/tags/%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
