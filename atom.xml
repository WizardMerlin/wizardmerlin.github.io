<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>梅林日志</title>
  
  <subtitle>云卷云舒，平常心态</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.merlinblog.site/"/>
  <updated>2018-04-12T06:55:17.661Z</updated>
  <id>http://www.merlinblog.site/</id>
  
  <author>
    <name>Merlin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>技巧: iOS 工作流</title>
    <link href="http://www.merlinblog.site/posts/7ef0bd11/"/>
    <id>http://www.merlinblog.site/posts/7ef0bd11/</id>
    <published>2018-04-12T02:45:41.000Z</published>
    <updated>2018-04-12T06:55:17.661Z</updated>
    
    <content type="html"><![CDATA[<p>高效工作流的第一篇，此篇是進入 v2.4 版本的象征。</p><a id="more"></a><p>其實為高效的工作流，我已經做了相當多的工作了，這其中有些技巧普遍適用，但是更多技巧屬於個人的優化，不宜分享。</p><p>今天談的就是，一個普遍的，和工作生活相關的，技術 tips — <strong>WorkFlow</strong>。(我也是以此命名本版本的)</p><p>App Store 裡面直接搜索，WorkFlow，然後下載那個 App，由 Apple 公司出品的一個自動化程式可視化編輯工具。</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/Jietu20180412-125728-e1523511790819.jpg" alt=" "></p><p>總體來說，對於我們專業人員來說，這類腳本還是太過簡單，而且很多語法不齊全，完成同樣的想法可能要繞路寫一種複雜的流程(原因是語法不如程序設計語言語法靈活，它都是設計好的流程，你只用來組織自己的流程)。簡單一句話：只要你有編程經驗，思維；這工具非常簡單。</p><p>當然要寫出整合的，複雜的 Case 還是需要你動點腦筋，比如 Grid 組織照片的時候，選中了約24張(不確定)圖片，我需要讓它 3 個為一組 Composite，那麼4個為一組呢？ 例如:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/Jietu20180412-130223.jpg" alt=" "></p><p>也就是原來需要幾個步驟的，甚至在 Mac/PC 上需要手動搞半天的，現在寫個流程腳本，自動弄好，還給上傳&amp;郵件，分享社區等。</p><p>大致的步驟怎麼？我舉個簡單的例子，刪除圖片的步驟：打開照片–&gt;找到相冊–&gt;找到照片–&gt;刪除</p><p>現在怎麼做？直接看圖：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/Jietu20180412-132533.jpg" alt=" "></p><p>很簡單吧。儘管是初級玩法，但是很多原來在 Mac 上花功夫的工作也能移植過來，而且節省了時間。畢竟，也是腳本嘛。</p><p>(更高階的玩法，後續見我分享 Python 腳本 — 腳本為王)</p><hr><p>最後，紀念進入 <code>高效流</code>，來一波安利  —  願你的將來化身 Master</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/Jietu20180412-131816-e1523511670142.jpg" alt=" "></p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/Jietu20180412-132023-e1523511600716.jpg" alt=" "></p><hr><p>Merlin 2018.4 高效流，來了。紀念進入 Ver 2.4</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;高效工作流的第一篇，此篇是進入 v2.4 版本的象征。&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://www.merlinblog.site/categories/tips/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: 并发聊天室综合案例</title>
    <link href="http://www.merlinblog.site/posts/1e2300e0/"/>
    <id>http://www.merlinblog.site/posts/1e2300e0/</id>
    <published>2018-04-07T06:21:22.000Z</published>
    <updated>2018-04-12T06:55:17.660Z</updated>
    
    <content type="html"><![CDATA[<p>一个小的并发案例，网络聊天室，在线统计，消息转发。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《CaseGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Case》</a>。</p></blockquote><p>这里主要是一步步实现一个并发的聊天室，很简单的案例。</p><h2 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h2><p>实现细节可能会冗杂一些，但是大致的实现思路却非常简单。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//总体流程</span><br><span class="line">//server -(处理连接 或者 转发)-&gt; message ---&gt;Client.C ---&gt; 读conn.Write给Client端</span><br></pre></td></tr></table></figure><p>具体的功能可以按照客户端发送的消息不同，而处理方式不同：</p><ul><li>已经连接时，向所有客户端显示已经登录</li><li>客户端发消息要求更改客户端显示名字</li><li>发送聊天消息则简单转发给所有用户</li><li>离线时，向所有客户端显示某客户端已经离线</li><li>查看在线人数或者哪些用户在线</li></ul><p>大致思路如下：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver0.jpg" alt="设计思路"></p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="上线功能"><a href="#上线功能" class="headerlink" title="上线功能"></a>上线功能</h3><p>先测试一下服务器端的功能: (之后再完善)</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver1.jpg" alt="上线转发功能"></p><p>此阶段性代码如下: (当前只管功能完成，不管是否高效)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//filename: server.go</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"net"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于记录全局在线人员</span></span><br><span class="line"><span class="keyword">type</span> Client <span class="keyword">struct</span> &#123;</span><br><span class="line">  C <span class="keyword">chan</span> <span class="keyword">string</span> <span class="comment">//用于给该Client转发消息</span></span><br><span class="line">  Name <span class="keyword">string</span>  <span class="comment">//用户名</span></span><br><span class="line">  Addr <span class="keyword">string</span>  <span class="comment">//网络地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> onlineMap <span class="keyword">map</span>[<span class="keyword">string</span>]Client</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> message = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>) <span class="comment">//用于操作 onlineMap 同步控制，同时传输消息</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//总体流程</span></span><br><span class="line"><span class="comment">//server -(处理连接 或者 转发)-&gt; message ---&gt;Client.C ---&gt; 读conn.Write给Client端</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">":8000"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(<span class="string">"net.Listen = "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//初始化 map</span></span><br><span class="line">  onlineMap = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]Client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//协程1，用于转发消息给 Client.C</span></span><br><span class="line">  <span class="keyword">go</span> sendMessage2ClientChan()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//主协程，循环等待连接</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Println(<span class="string">"listen.Accept err = "</span>, err)</span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//处理用户连接:</span></span><br><span class="line">    <span class="comment">// 1. 新连接加入 map</span></span><br><span class="line">    <span class="comment">// 2. 开启等待读取 Client.C 写回客户端的协程，等待读取Client.C</span></span><br><span class="line">    <span class="comment">// 3. 广播该客户端上线了</span></span><br><span class="line">    <span class="comment">// 4. 新开协程接收用户发送过来的数据 TODO</span></span><br><span class="line">    <span class="keyword">go</span> HandleConn(conn)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//死循环，阻塞等待，写消息(写入 Client.C)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage2ClientChan</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    msg := &lt;- message <span class="comment">//阻塞等待读取消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, cli := <span class="keyword">range</span> onlineMap &#123;</span><br><span class="line">      cli.C &lt;- msg <span class="comment">//写</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取 Client.C 转发给具体的 CLient</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeMsg2Client</span><span class="params">(cli Client, conn net.Conn)</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> msg := <span class="keyword">range</span> cli.C &#123; <span class="comment">//读</span></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(msg + <span class="string">"\n"</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//处理新连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleConn</span><span class="params">(conn net.Conn)</span></span> &#123; <span class="comment">//处理用户连接</span></span><br><span class="line">  <span class="keyword">defer</span> conn.Close()  <span class="comment">//处理完就关闭连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取客户端信息，加入 map</span></span><br><span class="line">  cliAddr := conn.RemoteAddr().String()  <span class="comment">//作为key</span></span><br><span class="line">  <span class="comment">////默认情况 Client.Name 就是地址名字</span></span><br><span class="line">  cli := Client&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>), cliAddr, cliAddr&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把结构体添加到 map</span></span><br><span class="line">  onlineMap[cliAddr] = cli</span><br><span class="line"></span><br><span class="line">   <span class="comment">//等待读取 Client.C，转发给 Client 对端</span></span><br><span class="line">  <span class="keyword">go</span> writeMsg2Client(cli, conn)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写 mesage 给具体的 cli.C</span></span><br><span class="line">  message &lt;- makeMsg(cli, <span class="string">"上线了。"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//开一个协程，读取Client发送过来的数据</span></span><br><span class="line">  <span class="comment">//TODO</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">//连接还不能关闭</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工具方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeMsg</span><span class="params">(cli Client, str <span class="keyword">string</span>)</span> <span class="params">(buf <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  buf = <span class="string">"[ "</span> + cli.Addr + <span class="string">" ] "</span> + cli.Name + <span class="string">" : "</span> + str</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消息转发功能"><a href="#消息转发功能" class="headerlink" title="消息转发功能"></a>消息转发功能</h3><p>客户端发送的消息，可以全局显示：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver2.jpg" alt="转发功能"></p><p>代码也很简单，即 hanldeConn 开个协程专门用来读取客户端写过来的内容，通过 message 转发:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//处理新连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleConn</span><span class="params">(conn net.Conn)</span></span> &#123; <span class="comment">//处理用户连接</span></span><br><span class="line">  <span class="keyword">defer</span> conn.Close()  <span class="comment">//处理完就关闭连接</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取客户端信息，加入 map</span></span><br><span class="line">  cliAddr := conn.RemoteAddr().String()  <span class="comment">//作为key</span></span><br><span class="line">  <span class="comment">////默认情况 Client.Name 就是地址名字</span></span><br><span class="line">  cli := Client&#123;<span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>), cliAddr, cliAddr&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//把结构体添加到 map</span></span><br><span class="line">  onlineMap[cliAddr] = cli</span><br><span class="line"></span><br><span class="line">   <span class="comment">//等待读取 Client.C，转发给 Client 对端</span></span><br><span class="line">  <span class="keyword">go</span> writeMsg2Client(cli, conn)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//写 mesage 给具体的 cli.C</span></span><br><span class="line">  message &lt;- makeMsg(cli, <span class="string">"上线了。"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//新开协程接收用户Client的数据</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      n, err := conn.Read(buf)</span><br><span class="line">      <span class="keyword">if</span> n==<span class="number">0</span> &#123; <span class="comment">//对端断开或者其他连接问题</span></span><br><span class="line">        log.Println(<span class="string">"conn.Read err = "</span>, err)</span><br><span class="line">        <span class="keyword">return</span> <span class="comment">//该协程结束，而不是server结束</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//转发读到的消息</span></span><br><span class="line">      msg := <span class="keyword">string</span>(buf[:n<span class="number">-1</span>]) <span class="comment">//读多少，转发多少</span></span><br><span class="line">      message &lt;- makeMsg(cli, msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line"></span><br><span class="line">  &#125;<span class="comment">//连接还不能关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提示自己功能"><a href="#提示自己功能" class="headerlink" title="提示自己功能"></a>提示自己功能</h3><p>上线向大家提示一下我上线了，同时显示下 <code>whoami</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//写 mesage 给具体的 cli.C</span></span><br><span class="line">message &lt;- makeMsg(cli, <span class="string">"上线了。"</span>)</span><br><span class="line"><span class="comment">//写给自己端，提示我的用户是谁 ---- 后面的改名功能</span></span><br><span class="line">cli.C &lt;- makeMsg(cli, cli.Name + <span class="string">"初来乍到，请多指教"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//新开协程接收用户Client的数据</span></span><br></pre></td></tr></table></figure><h3 id="查看用户"><a href="#查看用户" class="headerlink" title="查看用户"></a>查看用户</h3><p>万一我想查看一下当前在线的用户怎么办？<code>who</code>:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver4.jpg" alt="在线用户"></p><p>代码实现，就是对读取的字符串细化处理：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转发读到的消息</span></span><br><span class="line">msg := <span class="keyword">string</span>(buf[:n<span class="number">-1</span>]) <span class="comment">//读多少，转发多少</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(msg) == <span class="number">3</span> &amp;&amp; msg == <span class="string">"who"</span> &#123;</span><br><span class="line">  <span class="comment">//遍历 map，给当前用户发送所有成员</span></span><br><span class="line">  conn.Write([]<span class="keyword">byte</span>(<span class="string">"-----------\n用户列表如下: \n"</span>))</span><br><span class="line">  <span class="keyword">for</span> _, tmp := <span class="keyword">range</span> onlineMap &#123;</span><br><span class="line">    usrStr := tmp.Addr + <span class="string">":"</span> + tmp.Name +<span class="string">"\n"</span></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(usrStr))</span><br><span class="line">  &#125;</span><br><span class="line">  conn.Write([]<span class="keyword">byte</span>(<span class="string">"-----------\n"</span>))</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  message &lt;- makeMsg(cli, msg)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="改名功能"><a href="#改名功能" class="headerlink" title="改名功能"></a>改名功能</h3><p>我想改名，显示一个吊炸天的名字。发送 <code>rename|骨傲天</code>:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver5.jpg" alt="改名"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> <span class="built_in">len</span> &gt;=<span class="number">8</span> &amp;&amp; msg[:<span class="number">6</span>] == <span class="string">"rename"</span> &#123; <span class="comment">//rename|骨傲天</span></span><br><span class="line">      newName := strings.Split(msg, <span class="string">"|"</span>)[<span class="number">1</span>]</span><br><span class="line">      cli.Name = newName</span><br><span class="line">      onlineMap[cliAddr] = cli <span class="comment">//因为map存储的是副本</span></span><br><span class="line">      conn.Write([]<span class="keyword">byte</span>(<span class="string">"rename 完毕。\n"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="离线功能"><a href="#离线功能" class="headerlink" title="离线功能"></a>离线功能</h3><p>如果 server 从 client 读到的信息是对方重置了连接，即表明离线了：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver3.jpg" alt="离线功能"></p><p>此时怎么办？简单处理如下：(检测到下线了，给大家写一下消息)。</p><p>但是实际上，应该更加细分，如果对方是主动退出，如果是连接断开导致的退出。</p><blockquote><p>其实也可能是超时连接，或者长时间连接但不发送消息导致了。(<strong>超时退出，看后面</strong>)</p></blockquote><p>如此一来，考虑用 slelect 比较好：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver7.jpg" alt="离线功能"></p><p>效果如下：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver6.jpg" alt="离线功能"></p><h3 id="超时退出"><a href="#超时退出" class="headerlink" title="超时退出"></a>超时退出</h3><p>就是在 select 里面加一个分支检测超时，即其他分支不执行，就执行这个分支：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver8.jpg" alt="超时功能"></p><p>代码如下:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gochatserver9.jpg" alt="超时功能代码"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>map 为什么可以并发写？</li></ul><p>因为这里是以 ip:port 作为 key 的，一定不会重复(无脏数据)。严格意义上，还是要做好同步控制。</p><ul><li>先写入 message 在写入 Client.C 的原因？</li></ul><p>因为这里的 Client 是一个领域模型对象，代表了不同的客户端；但是 message 代表数据队列。<br>两者本质上是不同的，通过写入数据管道，最终保存在数据结构中，围绕数据结构展开读写，这是本编程案例的思想。</p><p>其次： <code>message</code> 是全局的，而 <code>Client.C</code> 这个消息是单个Client，代码中所有的开启，处理连接的协程都是基于个体Client的，阻塞读取也是基于本 client的，单个 client 的消息之所以会群显示，就是因为遍历单独写入了 Client.C :</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//死循环，阻塞等待，写消息(写入 Client.C)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendMessage2ClientChan</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    msg := &lt;- message <span class="comment">//阻塞等待读取消息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, cli := <span class="keyword">range</span> onlineMap &#123;</span><br><span class="line">      cli.C &lt;- msg <span class="comment">//写</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>缺陷：容器里面存入引用&amp;指针才是上策—如果修改的话。</p></blockquote><p>map 里面一开始就应该存储 Client 结构的指针，因为没想到后面想修改其中的内容，所以一开始设计成了值副本。</p><p>最后，详细代码放在了 github 上 <a href="https://github.com/WizardMerlin/gopher/tree/master/cases" target="_blank" rel="noopener">《gopher宝库》</a> 。</p><hr><p>Merlin 最后补充 网络部分(网络和并发联系紧密)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个小的并发案例，网络聊天室，在线统计，消息转发。&lt;/p&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: TCP 文件传输案例</title>
    <link href="http://www.merlinblog.site/posts/74edbb6d/"/>
    <id>http://www.merlinblog.site/posts/74edbb6d/</id>
    <published>2018-04-06T11:37:23.000Z</published>
    <updated>2018-04-12T06:55:17.660Z</updated>
    
    <content type="html"><![CDATA[<p>基于 tcp 网络的文件读写案例，反复演练 c-s 通信过程。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《CaseGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-case》</a>。</p></blockquote><p>流程和原理设计如下：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gotcpfile.jpg" alt="文件传输过程"></p><p>流程比较清晰，代码也比较简单，直接贴在下面了: 已经上传 github.</p><p>客户端代码: client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//获取命令行参数 (包含要发送的文件名)</span></span><br><span class="line">  list := os.Args</span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(list) != <span class="number">2</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"usage : ./client filePath"</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  filePath := list[<span class="number">1</span>] <span class="comment">//发送给 server</span></span><br><span class="line"></span><br><span class="line">  info, err := os.Stat(filePath) <span class="comment">//获取文件属性</span></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"err = "</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//info.Name(), info.Size()</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//连接服务器</span></span><br><span class="line">  conn, err1 := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">  <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"dial error : "</span>, err1)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//先发送一次文件名</span></span><br><span class="line">  _, err = conn.Write([]<span class="keyword">byte</span>(info.Name()))</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"conn Write server err : "</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//坐等接收对方的回应(最好是 "ok" )</span></span><br><span class="line">  <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">  n, err = conn.Read(buf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"conn.Read err = "</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> <span class="string">"ok"</span> == <span class="keyword">string</span>(buf[:n]) &#123;</span><br><span class="line">    <span class="comment">//发送文件</span></span><br><span class="line">    sendFile(filePath, conn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sendFile</span><span class="params">(filePath <span class="keyword">string</span>, conn net.Conn)</span></span> &#123;</span><br><span class="line">  <span class="comment">//读多少写多少</span></span><br><span class="line">  f, err := os.Open(filePath)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"os.Open err = "</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := f.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err == io.EOF &amp;&amp; n ==<span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"文件发送完毕"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"f.Read err = "</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> </span><br><span class="line">    &#125;</span><br><span class="line">    conn.Write(buf[:n])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端代码: server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"net.Listen err ="</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">  conn, err1 := listener.Accept()</span><br><span class="line">  <span class="keyword">if</span> err1 != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"listener.Accept err = "</span>, err1)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取客户端请求</span></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">  <span class="keyword">var</span> n <span class="keyword">int</span></span><br><span class="line">  n, err = conn.Read(buf)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"conn Read err = "</span>, err1)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fileName := <span class="keyword">string</span>(buf[:n])</span><br><span class="line">  conn.Write([]<span class="keyword">byte</span>(<span class="string">"ok"</span>))</span><br><span class="line"></span><br><span class="line">  <span class="comment">//介绍文件内容</span></span><br><span class="line">  recvFile(fileName, conn)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recvFile</span><span class="params">(fileName <span class="keyword">string</span>, conn net.Conn)</span></span> &#123;</span><br><span class="line">  <span class="comment">//新建一个文件</span></span><br><span class="line">  f ,err := os.Create(fileName)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"create file err = "</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//从 conn 读取然后写入本地文件</span></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//接收多少写多少</span></span><br><span class="line">  <span class="keyword">for</span>&#123;</span><br><span class="line">    n, err := conn.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &amp;&amp; err != io.EOF &#123;</span><br><span class="line">      fmt.Println(<span class="string">"conn.Read err = "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"文件接收完毕"</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    f.Write(buf[:n])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gotcpfile1.jpg" alt="文件传输过程"></p><hr><p>Merlin 上传 tcp 案例</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;基于 tcp 网络的文件读写案例，反复演练 c-s 通信过程。&lt;/p&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: TCP 简单并发服务器</title>
    <link href="http://www.merlinblog.site/posts/a8342f6/"/>
    <id>http://www.merlinblog.site/posts/a8342f6/</id>
    <published>2018-04-06T11:23:35.000Z</published>
    <updated>2018-04-12T06:55:17.660Z</updated>
    
    <content type="html"><![CDATA[<p>一个简单的多协程并发服务器，客户端从标准输入读取内容，服务器处理后返回。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《CaseGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Case》</a>。</p></blockquote><p>案例比较简单：客户端从标准输入读取内容发送给服务器，服务器处理之后返回给客户端。<br>(中间关于读写的时候，有些小细节要注意；不展开直接看代码吧)</p><p>直接贴代码：（server.go）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"io"</span></span><br><span class="line">  <span class="string">"strings"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  listener, err := net.Listen(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatalln(<span class="string">"err = "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> listener.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//并发接收多个请求</span></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    conn, err := listener.Accept()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      log.Fatalln(<span class="string">"err = "</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为每一个连接开一个协程</span></span><br><span class="line">    <span class="keyword">go</span> HandleConn(conn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleConn</span><span class="params">(conn net.Conn)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取对端地址</span></span><br><span class="line">  addr := conn.RemoteAddr().String()</span><br><span class="line">  fmt.Println(addr + <span class="string">"addr connect succeed"</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//读取用户请求</span></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>*<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := conn.Read(buf)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> err != io.EOF &#123;</span><br><span class="line">        fmt.Println(<span class="string">"err = "</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"read buf = "</span>, <span class="keyword">string</span>(buf[:n])) <span class="comment">//查看读取到的内容</span></span><br><span class="line"></span><br><span class="line">    conn.Write([]<span class="keyword">byte</span>(strings.ToUpper(<span class="keyword">string</span>(buf[:n])))) <span class="comment">//转成大写返回给客户端</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后 client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"net"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*直接发送内容*/</span></span><br><span class="line"><span class="comment">/* func main() &#123;</span></span><br><span class="line"><span class="comment">  conn, err := net.Dial("tcp", "127.0.0.1:8000")</span></span><br><span class="line"><span class="comment">  if err != nil &#123;</span></span><br><span class="line"><span class="comment">    fmt.Println("err = ", err)</span></span><br><span class="line"><span class="comment">    return</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">  defer conn.Close()</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  conn.Write([]byte("big")) //发送数据</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//从 os.Stdin读取内容，然后在发送</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  conn, err := net.Dial(<span class="string">"tcp"</span>, <span class="string">"127.0.0.1:8000"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"dial err : "</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//从键盘设备文件读</span></span><br><span class="line">    str := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      n, err := os.Stdin.Read(str)  <span class="comment">//读取标准输入</span></span><br><span class="line">      <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"os.Stdin, err = "</span>, err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//把输入的内容给服务器发送</span></span><br><span class="line">      conn.Write(str[:n]) <span class="comment">//读多少写多少</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">//主协程负责死循环在这守着服务器的回写 </span></span><br><span class="line">  <span class="comment">//(好处是服务器关闭，这边儿可以退出; 否则放到子协程中读，主协程进行 stdin输出，</span></span><br><span class="line">    <span class="comment">//则即使读到服务器关闭的异常，程序也无法退出)</span></span><br><span class="line">  buf := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1024</span>)</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">    n, err := conn.Read(buf) <span class="comment">//接收服务器的写回</span></span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">      fmt.Println(<span class="string">"read err = "</span>, err)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(buf[:n])) <span class="comment">//打印服务器拿过来的数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不解释了，注意下 IO 的处理，还有一种方式，判断读取的字节数 n 。</p><p>运行大致如下：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/04/gosimpleserver.jpg" alt="并发服务器"></p><hr><p>Merlin 网络小案例 upload</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个简单的多协程并发服务器，客户端从标准输入读取内容，服务器处理后返回。&lt;/p&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>技巧: B站视频下载脚本</title>
    <link href="http://www.merlinblog.site/posts/aa0a3cc6/"/>
    <id>http://www.merlinblog.site/posts/aa0a3cc6/</id>
    <published>2018-03-27T09:00:36.000Z</published>
    <updated>2018-04-12T06:55:17.660Z</updated>
    
    <content type="html"><![CDATA[<p>和 Bilibili 的 web 开发人员斗智斗勇的过程，累了，不玩了。分享一下我的脚本。</p><a id="more"></a><blockquote><p>如果说国内有可以和 Utube 对抗的视频网站的话，我觉得应该是 B站，而不是 youku。</p></blockquote><p>B站不断的改变策略，从最初的认证 ssl, 到现在的不断改进 B 站链接形式，router，URL参数，清晰度等。<br>脚本也要不断随之改进，实在累了，分享脚本如下：(需要的人可以根据自己的需要进行改进)</p><p><img src="http://omotkhw3y.bkt.clouddn.com/2018-03-27-bilib.jpg" alt=" "></p><blockquote><p>当初为什么要去下载这些视频呢？</p></blockquote><p>————<strong>认清楚哪些东西重要，那么东西不重要；把时间精力投入在该投入的地方</strong>。</p><p>听了朋友弹的一首旅行的青蛙，瞬间释怀了。</p><hr><p>Merlin 2018.3.27 我曾一次次迷失，又一次次在钢琴中找回初心。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;和 Bilibili 的 web 开发人员斗智斗勇的过程，累了，不玩了。分享一下我的脚本。&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://www.merlinblog.site/categories/tips/"/>
    
    
      <category term="视频" scheme="http://www.merlinblog.site/tags/%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>技巧: 多用户共享 Parralles 虚拟机</title>
    <link href="http://www.merlinblog.site/posts/8180668e/"/>
    <id>http://www.merlinblog.site/posts/8180668e/</id>
    <published>2018-03-23T08:55:16.000Z</published>
    <updated>2018-04-12T06:55:17.659Z</updated>
    
    <content type="html"><![CDATA[<p>mac 多个用户之间，共享虚拟机。</p><a id="more"></a><p>家里的台式机在多个用户之间，需要共享一个。</p><p>如何在 Mac 上的多个用户账户之间共享虚拟机:</p><ul><li>Parallels Desktop for Mac Business Edition</li><li>Parallels Desktop for Mac Home Edition</li><li>Parallels Desktop for Mac Pro Edition</li><li>Parallels Desktop Lite</li></ul><p><strong>问题</strong>:<br>我无法在另一个 Mac 用户账户上使用虚拟机。</p><p><strong>原因</strong>:<br>该虚拟机的 <code>.pvm</code> 文件并非在所有 Mac 用户之间共享，且权限未正确设置。</p><p><strong>解决方案</strong>:<br>如果您要在多个 Mac 用户账户之间共享一台虚拟机，需要将该虚拟机放置在这些账户都可以访问的目录中。最好放置在 /Users/Shared/ 目录中；在该目录中，您可以创建专用的 Parallels 文件夹，用以存储该虚拟机的所有文件。(或者其他共享的目录也可以)</p><p>每个用户都应该有权读取、写入和执行该虚拟机的文件。</p><p>如果您要创建新的虚拟机：当创建新的虚拟机时，勾选 <code>share with others of this Mac</code> 复选框。</p><p><img src="http://omotkhw3y.bkt.clouddn.com/2018-03-23-paral12.jpg" alt=" "></p><p>如果是企业版，则没有办法；只能按照已经存在虚拟机处理。</p><p>已经存在的虚拟机，可以参考这篇 <a href="https://kb.parallels.com/en/9303" target="_blank" rel="noopener">《文章》</a> 。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;mac 多个用户之间，共享虚拟机。&lt;/p&gt;
    
    </summary>
    
      <category term="tips" scheme="http://www.merlinblog.site/categories/tips/"/>
    
    
      <category term="mac" scheme="http://www.merlinblog.site/tags/mac/"/>
    
      <category term="虚拟机" scheme="http://www.merlinblog.site/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Golang: 值类型&amp;引用类型坑(12)</title>
    <link href="http://www.merlinblog.site/posts/55b0329b/"/>
    <id>http://www.merlinblog.site/posts/55b0329b/</id>
    <published>2018-03-19T11:18:48.000Z</published>
    <updated>2018-04-12T06:55:17.657Z</updated>
    
    <content type="html"><![CDATA[<p>别再说<code>传引用</code>还是<code>传值</code>了，在 Golang 里面应该先搞清楚这个东西的类型是什么。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>透过现象看本质。我们当初在 C/C++ 中折腾指针啊，引用啊，不就是为了<strong>能否修改原来的变量么</strong>？</p><p><strong>Golang 直接指针问题的核心，用类型本身的性质解决了该问题；而不是过多的把注意力放在参数传递上</strong>。</p><ul><li>值类型？ — 包括基本类型，数组，自定义类型struct, 只有传递指针才能更改其原来内存的内容，否则值传递只能是拷贝</li><li>引用类型? — 包括 slice, map, chan, func，这里本身就是引用类型, 即便是值传递也可以更改原来的内容(但是内部和外部的地址不同)</li></ul><p>举个例子吧: 自定义的 type, struct</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u user)</span> <span class="title">fun1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *user)</span> <span class="title">fun2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Value receiver操作的是值的拷贝，而pointer receiver操作的是实际的值。</p><p>用pointer去调用value receiver的方法，实际的操作是： <code>(*p).fun1()</code><br>而用value去调用pointer receiver的方法，实际的操作是：<code>(&amp;v).fun2()</code></p><p>对于引用类型，就不要，也不需要去使用其指针了，直接拿到实例就可以了，一般是 <code>make</code> 返回的，内部实现返回的其实是指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//make map</span></span><br><span class="line"><span class="comment">// makemap implements a Go map creation make(map[k]v, hint)</span></span><br><span class="line"><span class="comment">// If the compiler has determined that the map or the first bucket</span></span><br><span class="line"><span class="comment">// can be created on the stack, h and/or bucket may be non-nil.</span></span><br><span class="line"><span class="comment">// If h != nil, the map can be created directly in h.</span></span><br><span class="line"><span class="comment">// If bucket != nil, bucket can be used as the first bucket.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makemap</span><span class="params">(t *maptype, hint <span class="keyword">int64</span>, h *hmap, bucket unsafe.Pointer)</span> *<span class="title">hmap</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//make chan</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="keyword">int64</span>)</span> *<span class="title">hchan</span></span> &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>搞清楚是引用类型，还是值类型；再决定是传递指针，还是传递引用</p></blockquote><p>因为可以看到引用类型本身相关的方法已经做了封装，不需要再额外传递指针了。</p><p>但是不管哪种类型，只要是值传递，那么调用内部和外部，相关参数的地址肯定不一样，值传递就是拷贝啊，都是副本(即便是引用类型，也是副本；可以比较内外引用变量的地址)。但是决定能够修改原来的变量与否，还在于传递的变量本身是值类型，还是引用类型。</p><p>透过现象看本质。我们当初在 C/C++ 中折腾指针啊，引用啊，<code>不就是为了能否修改原来的变量么</code>？</p><p><strong>Golang 直指指针问题的核心，用类型本身的性质解决了该问题；而不是过多的把注意力放在参数传递上</strong>。</p><hr><p>Merlin 2018.3 参数本身的坑，核心且关键</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;别再说&lt;code&gt;传引用&lt;/code&gt;还是&lt;code&gt;传值&lt;/code&gt;了，在 Golang 里面应该先搞清楚这个东西的类型是什么。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: 函数类型实现接口封装问题(11)</title>
    <link href="http://www.merlinblog.site/posts/ac5ecee9/"/>
    <id>http://www.merlinblog.site/posts/ac5ecee9/</id>
    <published>2018-03-19T10:52:54.000Z</published>
    <updated>2018-04-12T06:55:17.657Z</updated>
    
    <content type="html"><![CDATA[<p>提供一种非常 “绕” 的思路，实现一下 C 语言那种函数指针的灵活。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>函数类型实现接口提供了一种非常好的思路，比如 http.Handler 就是这么实现的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">  ServeHTTP(ResponseWriter, *Request)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Handle</span><span class="params">(pattern <span class="keyword">string</span>, handler Handler)</span></span> &#123;</span><br><span class="line">  DefaultServeMux.Handle(pattern, handler)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleFunc</span><span class="params">(pattern <span class="keyword">string</span>, handler <span class="keyword">func</span>(ResponseWriter, *Request)</span>)</span> &#123;</span><br><span class="line">  DefaultServeMux.HandleFunc(pattern, handler)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我们平常调用的时候，传递的 <code>Handler</code> 其实都是函数类型，也就是说， Handler 接口可以由函数类型实现。</p><p>下面代码的脉络或许封装过多，但是如果把握 <code>函数作为一种类型，实现接口</code>其实还好:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//接口</span></span><br><span class="line"><span class="keyword">type</span> Handler <span class="keyword">interface</span> &#123;</span><br><span class="line">  Do(k, v <span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数类型实现接口 Handler</span></span><br><span class="line"><span class="keyword">type</span> HandlerFunc <span class="function"><span class="keyword">func</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="params">(f HandlerFunc)</span> <span class="title">Do</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  f(k, v)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里 Handler 可以接收 HandlerFunc 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Each</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;, h Handler)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> m != <span class="literal">nil</span> &amp;&amp; <span class="built_in">len</span>(m) &gt; <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> m &#123;</span><br><span class="line">      h.Do(k, v) <span class="comment">//h(k, v) --- selfInfo(k, v)  注意</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EachFunc</span><span class="params">(m <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;, f <span class="keyword">func</span>(k, v <span class="keyword">interface</span>&#123;&#125;)</span>)</span> &#123;</span><br><span class="line">  Each(m, HandlerFunc(f)) <span class="comment">//selfInfo 做了一下转换 HandlerFunc 类型(子类、实现了 Handler 接口)。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">selfInfo</span><span class="params">(k, v <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">  fmt.Printf(<span class="string">"大家好,我叫%s,今年%d岁\n"</span>, k, v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  persons := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;)</span><br><span class="line">  persons[<span class="string">"张三"</span>] = <span class="number">20</span></span><br><span class="line">  persons[<span class="string">"李四"</span>] = <span class="number">23</span></span><br><span class="line">  persons[<span class="string">"王五"</span>] = <span class="number">26</span></span><br><span class="line">  EachFunc(persons, selfInfo)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大家好,我叫张三,今年20岁</span><br><span class="line">大家好,我叫李四,今年23岁</span><br><span class="line">大家好,我叫王五,今年26岁</span><br></pre></td></tr></table></figure><p>全部的精妙，都是从 <code>type HandlerFunc func(k, v interface{})</code> 类型开始。</p><p>不过也应该封装过多，造成调用层次过深，<strong>了解即可</strong>。原文参考 <a href="http://www.flysnow.org/2016/12/30/golang-function-interface.html" target="_blank" rel="noopener">飞雪博客-接口型函数</a>。</p><hr><p>Merlin 2018.3 函数类型接口, 坑</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;提供一种非常 “绕” 的思路，实现一下 C 语言那种函数指针的灵活。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: struct打印输出问题(10)</title>
    <link href="http://www.merlinblog.site/posts/eecafb73/"/>
    <id>http://www.merlinblog.site/posts/eecafb73/</id>
    <published>2018-03-19T08:00:01.000Z</published>
    <updated>2018-04-12T06:55:17.657Z</updated>
    
    <content type="html"><![CDATA[<p>每次都要实现 String() 或者 GoString()，太麻烦了。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>以前在学习 标准库 fmt 的时候，说过如果你想更好的打印，可以使用 formater，最不济也可以重写 String() 或者 GoString()。如果不想这么做，可以简单的用 <code>%+v</code> 来打印。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> address <span class="keyword">struct</span> &#123;</span><br><span class="line">  city,province <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    addr address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">  <span class="comment">//address&#123;&#125; 必须写</span></span><br><span class="line">    v := info&#123;<span class="string">"Nan"</span>, <span class="number">33</span>, address&#123;city:<span class="string">"shanghai"</span>, province:<span class="string">"shanghai"</span>&#125;&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, v) <span class="comment">//&#123;Nan 33 &#123;shanghai shanghai&#125;&#125;</span></span><br><span class="line">    fmt.Printf(<span class="string">"%+v\n"</span>, v) <span class="comment">//&#123;name:Nan id:33 addr:&#123;city:shanghai province:shanghai&#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方便很多，不需要重写哪些方法了。</p><hr><p>Merlin 2018.3 泛型容器的坑</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每次都要实现 String() 或者 GoString()，太麻烦了。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: string和byte slie字节问题(9)</title>
    <link href="http://www.merlinblog.site/posts/8f54ef0c/"/>
    <id>http://www.merlinblog.site/posts/8f54ef0c/</id>
    <published>2018-03-19T07:34:37.000Z</published>
    <updated>2018-04-12T06:55:17.659Z</updated>
    
    <content type="html"><![CDATA[<p>讲清楚 string 和 bytes[], 字符，字面量，unicode编码, rune。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p><strong>为什么 string 不可变，[]bytes 可变</strong>?</p><p>字符串是一段只读切片，存储的是字节；utf8 编码的字符，字节数不确定，所以 string 再按照 C 语言的习惯(ascii编码的字符)去操作字符串，势必出问题，好在这方面 golang 语言自己已经做了一定的处理， fmt包，range循环， encoding/utf8包等。</p><p>下面慢慢看看详情。</p><hr><p><strong>golang 中的字符串，不管是字面量，还是先定义 string 后赋值的都是只读的，要操作必须先转换层字符串</strong>。</p><p>此外，byte slice 也可以转化成字符串。这两种转化都需要分配一块新的内存，然后进行内容拷贝。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">"abc"</span></span><br><span class="line">b := []<span class="keyword">byte</span>(s) <span class="comment">//新内存</span></span><br><span class="line"></span><br><span class="line">s2 := <span class="keyword">string</span>(b) <span class="comment">//新内存</span></span><br></pre></td></tr></table></figure><p>运行结果如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  s := <span class="string">"abc"</span></span><br><span class="line">  b := []<span class="keyword">byte</span>(s) <span class="comment">//新内存</span></span><br><span class="line">  fmt.Printf(<span class="string">"%#x\n"</span>, &amp;s) <span class="comment">//0x1040c138</span></span><br><span class="line">  fmt.Printf(<span class="string">"%#x\n"</span>, &amp;b[<span class="number">0</span>]) <span class="comment">//0x10414020</span></span><br><span class="line"></span><br><span class="line">  s2 := <span class="keyword">string</span>(b) <span class="comment">//新内存</span></span><br><span class="line">  fmt.Printf(<span class="string">"%#x\n"</span>, &amp;s2) <span class="comment">//0x1040c148</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>string 截取操作没有改变底层数组(即重新分配内存)但是关于底层数组的索引已经变了，长度改变。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  str := <span class="string">"hello"</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(str[<span class="number">2</span>])) <span class="comment">//l</span></span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"%#x\n"</span>, &amp;str) <span class="comment">//0x1040c138</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">//str[2] = 'x'</span></span><br><span class="line">  <span class="comment">//fmt.Println(str[2]) //unicode 不支持下标赋值</span></span><br><span class="line">  <span class="comment">//（按字节提取的并不是一定是具体的 ascii字符，或可打印字符）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//底层数组已经改变, len 变为1</span></span><br><span class="line">  str = str[<span class="number">2</span>:<span class="number">3</span>]</span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(str)) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">  fmt.Printf(<span class="string">"%#x\n"</span>, &amp;str) <span class="comment">//0x1040c138</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  fmt.Println(str) <span class="comment">// l</span></span><br><span class="line">  fmt.Println(<span class="keyword">string</span>(str[<span class="number">0</span>])) <span class="comment">//l</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//str[0] = 'x'</span></span><br><span class="line">  <span class="comment">//fmt.Println(str[0]) //unicode 不支持下标赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//下面越界，所以报错</span></span><br><span class="line">  <span class="comment">//fmt.Println(str[2]) //panic: runtime error: index out of range</span></span><br><span class="line"></span><br><span class="line">  fmt.Println(reflect.TypeOf(str)) <span class="comment">//string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>字符串实际上是一个只读的片段，保存任意字节。</p></blockquote><p>为 <code>字符串保存的是字节</code>, 另一部分就是 <code>字符的含义很难定义</code> ，UTF8的字符可能是2-6字节(utf16,像 Qt 里面的 QString 则明确的说用 utf16 进行内部字符串编码；utf8, ascii 都有它不方便的地方)，<strong>rune</strong> 就专门用来定义<strong>单个字符Unicode编码</strong>，而不仅仅是 int32 的别名。</p><blockquote><p>rune ： fmt.Println(str[2]); //108 ，打印的数字就表明了 rune 代表的是该字节对应 Unicode 编码</p></blockquote><p>而对于上面的 <code>&quot;hello&quot;</code> 根本没有字节级别的转义，所以不能取按照字节赋值。打印是经过特殊处理了，也就是说不仅仅可以按小标打印字面量，也可以通过循环打印，他们已经解码 utf8的rune：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nihongo = <span class="string">"日本語"</span></span><br><span class="line"><span class="keyword">for</span> index, runeValue := <span class="keyword">range</span> nihongo &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, index)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>循环输出按照 unicode 编码来的，可以看到字节占用: (索引操作是按照字节来的)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">U+65E5 &apos;日&apos; starts at byte position 0</span><br><span class="line">U+672C &apos;本&apos; starts at byte position 3</span><br><span class="line">U+8A9E &apos;語&apos; starts at byte position 6</span><br></pre></td></tr></table></figure><p>上面的串，不是英文字母，也就是一个字符占用多过一个字节，那么再用字节操作，即下标索引，那么打印就很奇怪了。</p><p>当然，如果在 string 字面量里面初始化一堆无效的 unicode，打印出来的状况很诡异的。</p><p>一定要自己去处理和组合这些 utf8 编码的字节，或者称 string，<code>unicode/utf8</code> 标准库操作：</p><p>(用的很少，特殊需求)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> nihongo = <span class="string">"日本語"</span></span><br><span class="line">  <span class="keyword">for</span> i, w := <span class="number">0</span>, <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nihongo); i += w &#123;</span><br><span class="line">      runeValue, width := utf8.DecodeRuneInString(nihongo[i:])</span><br><span class="line">      fmt.Printf(<span class="string">"%#U starts at byte position %d\n"</span>, runeValue, i)</span><br><span class="line">      w = width</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>字节、字符、rune之间的区别,UTF-8编码和Unicode编码之间的区别, 一个字符串和一个字符串字面量的区别。</p><p>扩展阅读：<a href="https://blog.golang.org/strings" target="_blank" rel="noopener">《string, bytes, runes, chars》</a>。</p><p>与其这样采用 utf8，然后为了适配字符和字节问题专门弄一个 utf8 包，还不如一开始采用 utf16呢。笑。(那样占用的控件就大了)<em>其他关于 string 和 []byte 的操作可以借助标准库 <code>strings</code> 和 <code>bytes</code></em>。</p><hr><p>Merlin 2018.3 string 和 []bytes 之间的恩怨</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲清楚 string 和 bytes[], 字符，字面量，unicode编码, rune。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: time计算问题(8)</title>
    <link href="http://www.merlinblog.site/posts/8a7f81db/"/>
    <id>http://www.merlinblog.site/posts/8a7f81db/</id>
    <published>2018-03-19T06:52:51.000Z</published>
    <updated>2018-04-12T06:55:17.659Z</updated>
    
    <content type="html"><![CDATA[<p>某段代码运行时间的计算。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>这个问题还是比较常见的，一般用减法，但是有更好的方法。</p><p>一般怎么写？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">t1 := time.Now()</span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">t2 := time.Now()</span><br><span class="line"></span><br><span class="line">duration := t2.Sub(t1)  <span class="comment">//时间的减法</span></span><br><span class="line"></span><br><span class="line">fmt.Println(duration)</span><br></pre></td></tr></table></figure><p>如果简写，可以写成 <code>duration := time.Now().Sub(t1)</code>。</p><p>直接用 <code>time.Since()</code> 其实更好:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"time"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    t1 := time.Now()</span><br><span class="line">    time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">    duration := time.Since(t1)</span><br><span class="line"></span><br><span class="line">    fmt.Println(durantion)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>Merlin 2018.3 time 的 shorthand</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;某段代码运行时间的计算。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: chan定义问题(7)</title>
    <link href="http://www.merlinblog.site/posts/d4333ec1/"/>
    <id>http://www.merlinblog.site/posts/d4333ec1/</id>
    <published>2018-03-19T06:35:11.000Z</published>
    <updated>2018-04-12T06:55:17.659Z</updated>
    
    <content type="html"><![CDATA[<p>通常都是定义读写双向的 chan，定义单向 chan 问题。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p><strong>通过 只写 chan 传递另一个只读的 chan，怎么写</strong>？</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>平常一般是这么声明 chan 的:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">//var xChan chan int //双向 chan，可以读写 int 类型变量(只声明还不够，要定义)</span></span><br><span class="line">  xChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line"></span><br><span class="line">  fmt.Println(<span class="built_in">len</span>(xChan)); <span class="comment">//0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要声明一个单向的 chan 可以使用这一的方式:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">float64</span>  <span class="comment">// 只写 float64 类型变量 （write-only）</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> <span class="keyword">int</span>      <span class="comment">// 只读 int 类型变量 （read-only）</span></span><br></pre></td></tr></table></figure><p>传递 chan 变量怎么办？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">chan</span>&lt;- <span class="keyword">chan</span> <span class="keyword">int</span>    <span class="comment">//传递双向 chan, 同 chan&lt;- (chan int)</span></span><br><span class="line"><span class="keyword">chan</span>&lt;- &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">//传递只读 给只写chan, 同 chan&lt;- (&lt;-chan int)</span></span><br><span class="line">&lt;-<span class="keyword">chan</span> &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>  <span class="comment">//传递只读chan 给只读chan 同 &lt;-chan (&lt;-chan int)</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>定义只读，只写的类型，看上去比较诡异，可以把 <code>&lt;-chan</code> ，<code>chan&lt;-</code> 看做类型即可，同 <code>chan</code> 一样。</p><hr><p>Merlin 2018.3 chan 的定义问题</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;通常都是定义读写双向的 chan，定义单向 chan 问题。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: defer 时机问题(6)</title>
    <link href="http://www.merlinblog.site/posts/aec4de55/"/>
    <id>http://www.merlinblog.site/posts/aec4de55/</id>
    <published>2018-03-19T06:17:29.000Z</published>
    <updated>2018-04-12T06:55:17.658Z</updated>
    
    <content type="html"><![CDATA[<p>空指针解析，越界，除数为零等异常应该在检查 error 之后定义 defer。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>defer 定义的时机。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>一般应该把 defer 语句写在 erorr 检查之后:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(dataFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br></pre></td></tr></table></figure><p>不要写成这样:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file, err := os.Open(dataFile)</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Close 并不检查 file 是否真的打开了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>defer语句可以看成是把指定的函数压入“堆栈”，当外面函数退出时。“堆栈”内的函数会依次弹出执行。这样可以防止资源泄露。即使发生 panic 也会调用 defer 定义的内容，然后才运行 panic，依次上报 panic。</p><hr><p>Merlin 2018.3 defer 定义时机的坑</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;空指针解析，越界，除数为零等异常应该在检查 error 之后定义 defer。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: make和new坑(5)</title>
    <link href="http://www.merlinblog.site/posts/e9bf7e00/"/>
    <id>http://www.merlinblog.site/posts/e9bf7e00/</id>
    <published>2018-03-19T05:43:18.000Z</published>
    <updated>2018-04-12T06:55:17.658Z</updated>
    
    <content type="html"><![CDATA[<p>使用 map 的时候，遇到了个坑，来仔细看看 make 以及 new 。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>Go语言中new和make是内建的两个函数，主要用来创建分配类型内存。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>声明的同时不赋值，也就是没有初始化；基本类型就算了，但是指针类型和引用类型则不行:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//基本类型 ok, 声明即定义了</span></span><br><span class="line">  <span class="keyword">var</span> i <span class="keyword">int</span></span><br><span class="line">  <span class="keyword">var</span> s <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i *<span class="keyword">int</span> <span class="comment">//只声明, 不定义</span></span><br><span class="line">  *i=<span class="number">10</span></span><br><span class="line">  fmt.Println(*i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行肯定报错了: <code>panic: runtime error: invalid memory address or nil pointer dereference</code>。</p><ul><li>对于值类型的声明不需要，是因为已经默认帮我们分配好了，默认零值。</li><li>对于引用和指针类型，要分配内存，就引出来今天的new和make。</li></ul><p>new 内置函数如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The new built-in function allocates memory. The first argument is a type,</span></span><br><span class="line"><span class="comment">// not a value, and the value returned is a pointer to a newly</span></span><br><span class="line"><span class="comment">// allocated zero value of that type.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">new</span><span class="params">(Type)</span> *<span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>使用案例如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> i *<span class="keyword">int</span></span><br><span class="line">  i=<span class="built_in">new</span>(<span class="keyword">int</span>)</span><br><span class="line">  <span class="comment">//*i=10</span></span><br><span class="line">  fmt.Println(*i) <span class="comment">//打印为0，默认会赋值为0值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new 返回的具体类型的指针，指向分配类型的内存地址，且类型变量的值为零值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  u:=<span class="built_in">new</span>(user) <span class="comment">//内部变量全部为 0 值</span></span><br><span class="line"></span><br><span class="line">  u.lock.Lock()</span><br><span class="line">  u.name = <span class="string">"张三"</span></span><br><span class="line">  u.lock.Unlock()</span><br><span class="line"></span><br><span class="line">  fmt.Println(u)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">  age <span class="keyword">int</span></span><br><span class="line">  lock sync.Mutex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回 指针并不一定总是好的，对于引用类型，直接返回它本身就可以了，用 make:</p><p>make: 从函数声明中可以看到，返回的还是该类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">make</span><span class="params">(t Type, size ...IntegerType)</span> <span class="title">Type</span></span></span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//map1 := map[int]string&#123;&#125;</span></span><br><span class="line">map1 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>) <span class="comment">//也会给与零值</span></span><br><span class="line">map1[<span class="number">1</span>]=<span class="string">"one"</span></span><br><span class="line">map1[<span class="number">2</span>]=<span class="string">"two"</span></span><br></pre></td></tr></table></figure><p>对于 slice, map, chan 一般使用 make 返回这三个引用类型本身，new 返回的是指向类型的指针。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>make 还是比较常用的，直接返回引用类型本身；其他时候直接使用段语句 <code>:=</code> 在栈上声明更加方便。指针操作，尽量少用。</p><hr><p>Merlin 2018.3 make的坑</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 map 的时候，遇到了个坑，来仔细看看 make 以及 new 。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: import和package坑(4)</title>
    <link href="http://www.merlinblog.site/posts/e0c9893e/"/>
    <id>http://www.merlinblog.site/posts/e0c9893e/</id>
    <published>2018-03-19T04:45:15.000Z</published>
    <updated>2018-04-12T06:55:17.658Z</updated>
    
    <content type="html"><![CDATA[<p>import 后面的是 package name? 那是 java。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>这里主要有两个坑：</p><ul><li>一个文件夹下的所有文件必须属于同一个 package (同级目录只有一个包名)<ul><li>一个好的规则是 package 和文件夹名字相同</li></ul></li><li>import语句所指定的是寻找 package 的 path，而不是 package 的名字</li></ul><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>具体的语法如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> [packagename] importpath</span><br></pre></td></tr></table></figure><p>package name 可以省略，但是路径名字不能。</p><p>先看常见的 fmt 的情况:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>fmt 是 Golang 的标准库，他其实是去 GOROOT 下去加载该模块(路径名是在 GOROOT 基础上查找的)。</p><blockquote><p>一般可以使用绝对路径或者相对路径来<strong>加载自己的模块</strong>(省略包的别名)</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">相对路径     import   &quot;./model&quot;             //当前文件同一目录的model目录，但是不建议这种方式来import</span><br><span class="line">绝对路径     import   &quot;shorturl/model&quot;      //加载GOPATH/src/shorturl/model模块</span><br></pre></td></tr></table></figure><p>还是最好用 <code>GOPATH/src</code> 这种方式比较好，而不是依赖基于 src 的相对目录。</p><p>详细讲解每种方式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Import declaration          Local name of Sin</span><br><span class="line"></span><br><span class="line">import   &quot;lib/math&quot;         math.Sin</span><br><span class="line">import m &quot;lib/math&quot;         m.Sin</span><br><span class="line">import . &quot;lib/math&quot;         Sin</span><br></pre></td></tr></table></figure><ul><li><strong>第一种情况</strong>: 我们一般使用第一种方式 <code>import &quot;lib/math&quot;</code>，然后用 <code>math.Sin</code> 来使用具体包内的内容。</li><li><strong>第二种情况</strong>: 给包起一个别名, 例如 import( f “fmt” )   别名操作调用包函数时前缀变成了重命名的前缀，即f.Println(“hello world”)</li><li><strong>第三种情况</strong>: 使用这个包，可以省略 package 名字，当做本地函数使用。</li></ul><p>一般用第一种形式，引入路径，但是在具体的文件中，还是按照 <code>pkgname.xxx</code> 来调用。</p><h2 id="导入过程"><a href="#导入过程" class="headerlink" title="导入过程"></a>导入过程</h2><p>程序的初始化和执行都起始于 main 包。如果 main 包还导入了其它的包，那么就会在编译时将它们依次导入。有时一个包会被多个包同时导入，那么它只会被导入一次（例如很多包可能都会用到fmt包，但它只会被导入一次，因为没有必要导入多次）。当一个包被导入时，如果该包还导入了其它的包，那么会先将其它包导入进来，然后再对这些包中的包级常量和变量进行初始化，接着执行init函数（如果有的话），依次类推。等所有被导入的包都加载完毕了，就会开始对main包中的包级常量和变量进行初始化，然后执行main包中的init函数（如果存在的话），最后执行main函数。</p><p>下图详细地解释了整个执行过程：</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/golang-init-package.jpg" alt=" "></p><h2 id="init函数"><a href="#init函数" class="headerlink" title="init函数"></a>init函数</h2><blockquote><p>引用但是不使用某个包，使用 <code>_</code></p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_ <span class="string">"github.com/xxx"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这种做法可以保证 “github.com/xxx” 这个 package 的初始化操作完成（这个package中所有init函数都执行），即使在当前文件中没有显式地使用到这个package。有些时候并非真的需要使用这些包，仅仅是希望它的init()函数被执行而已。这个时候就可以使用<em>操作引用该包了。即使用</em>操作引用包是无法通过包名来调用包中的导出函数，而是 <code>只是为了简单的调用其init函数()</code> 。</p><p>通过上面的介绍我们了解了import的时候其实是执行了该包里面的init函数，初始化了里面的变量，_操作只是说该包引入了，只初始化里面的init函数和一些变量，不能通过包名来调用其它的函数，这有什么用呢？往往这些init函数里面是注册自己包里面的引擎，让外部可以方便的使用，就很多实现database/sql的引用，在init函数里面都是调用了sql.Register(name string, driver driver.Driver)注册自己，然后外部就可以使用了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>一个包可以有多个 init (最好只有一个)；</li><li>优先导入其他包(初始化变量，调用init)，然后才是本包。</li><li>初始化本包的变量，然后调用本包的 init 函数。</li></ul><p>外部包不能和主模块放到一起，可能会编译不过的。</p><hr><p>Merlin 2018.3 import 的坑</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;import 后面的是 package name? 那是 java。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: runtime.Gosched 问题(3)</title>
    <link href="http://www.merlinblog.site/posts/4ff88030/"/>
    <id>http://www.merlinblog.site/posts/4ff88030/</id>
    <published>2018-03-19T03:57:55.000Z</published>
    <updated>2018-04-12T06:55:17.658Z</updated>
    
    <content type="html"><![CDATA[<p>专门看看 <code>runtime.Gosched()</code> 。</p><a id="more"></a><blockquote><p>专栏的介绍可以参考 <a href="http://www.merlinblog.site/posts/590c21ce/#Gogolang">《GotchaGolang专栏》</a>，代码可以看<a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-Gotcha》</a>。</p></blockquote><p>这个函数的作用是让当前goroutine让出CPU，好让其它的goroutine获得执行的机会。同时，当前的goroutine也会在未来的某个时间点继续运行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Gosched</span></span></span><br><span class="line"><span class="function">    <span class="title">func</span> <span class="title">Gosched</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">Gosched</span> <span class="title">yields</span> <span class="title">the</span> <span class="title">processor</span>, <span class="title">allowing</span> <span class="title">other</span> <span class="title">goroutines</span> <span class="title">to</span> <span class="title">run</span>.</span></span><br><span class="line"><span class="function"><span class="title">It</span> <span class="title">does</span> <span class="title">not</span> <span class="title">suspend</span> <span class="title">the</span> <span class="title">current</span> <span class="title">goroutine</span>, <span class="title">so</span> <span class="title">execution</span> <span class="title">resumes</span> <span class="title">automatically</span>.</span></span><br></pre></td></tr></table></figure><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>原来需要在 main 里面 sleep 或者 select{} 才能让其他 goroutines 有执行的机会</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showNumber</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> showNumber(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"Haha"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Haha</span><br></pre></td></tr></table></figure><p>没有打印出数字，可以看到goroutine没有获得机会运行。</p><p>修改代码：在main函数中加上runtime.Gosched()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"runtime"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">showNumber</span> <span class="params">(i <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Println(i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> showNumber(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    runtime.Gosched()</span><br><span class="line">    fmt.Println(<span class="string">"Haha"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果改变了:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line">Haha</span><br></pre></td></tr></table></figure><p>具体和 goroutines 的实现有关，简单说 <code>logical concurrent coroutines which do not map 1:1 to OS threads</code> 。</p><p>具体可以参考这篇<a href="https://stackoverflow.com/questions/13107958/what-exactly-does-runtime-gosched-do" target="_blank" rel="noopener">《文章》</a>。</p><p>摘要如下: (没有利用多核的状态下，一般使用的是一个线程，执行权都是这一个线程中交换&amp;调度)<br>When you run Go program without specifying GOMAXPROCS environment variable, <strong>Go goroutines are scheduled for execution in single OS thread</strong>. However, to make program appear to be multithreaded (that’s what goroutines are for, aren’t they?), the Go scheduler must sometimes switch the execution context, so each goroutine could do its piece of work.</p><p>when GOMAXPROCS variable is not specified, Go runtime is only allowed to use one thread, so it is impossible to switch execution contexts while goroutine is performing some conventional work, like computations or even IO (which is mapped to plain C functions). The context can be switched only when Go concurrency primitives are used, e.g. when you switch on several chans, or (this is your case) when you explicitly tell the scheduler to switch the contexts - this is what runtime.Gosched is for.</p><p>So, in short, when execution context in one goroutine reaches Gosched call, the scheduler is instructed to switch the execution to another goroutine. In your case there are two goroutines, main (which represents ‘main’ thread of the program) and additional, the one you have created with go say. If you remove Gosched call, the execution context will never be transferred from the first goroutine to the second, hence no ‘world’ for you. When Gosched is present, the scheduler transfers the execution on each loop iteration from first goroutine to the second and vice versa, so you have ‘hello’ and ‘world’ interleaved.</p><p>Looks like that in newer versions of Go compiler Go runtime forces goroutines to yield not only on concurrency primitives usage, but on OS system calls too. This means that execution context can be switched between goroutines also on IO functions calls.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>goroutines 的 gosched 有点儿像以前线程模型中的 yeild，让出执行权。但是协程并不是线程。</p><hr><p>Merlin 2018.3 协程调度</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;专门看看 &lt;code&gt;runtime.Gosched()&lt;/code&gt; 。&lt;/p&gt;
    
    </summary>
    
      <category term="GotchaGolang专栏" scheme="http://www.merlinblog.site/categories/GotchaGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: HTML Template案例(xml新闻解析+并发改进)</title>
    <link href="http://www.merlinblog.site/posts/690caed4/"/>
    <id>http://www.merlinblog.site/posts/690caed4/</id>
    <published>2018-03-16T23:14:23.000Z</published>
    <updated>2018-04-12T06:55:17.656Z</updated>
    
    <content type="html"><![CDATA[<p>HTML 中使用 golang 模板编程。<br><a id="more"></a></p><p>主要写两个案例，都是 HTML 参数解析展示类的模板编程。由于这部分内容比较简单，直接上代码了。</p><p>simple.go 解析 JSON 数据，展示到自定义的网页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"html/template"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">"/"</span>, indexHandler)</span><br><span class="line">  http.HandleFunc(<span class="string">"/new/"</span>, newsAggHandler)</span><br><span class="line">  http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">indexHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  fmt.Fprintf(w, <span class="string">"&lt;h1&gt; Hi, there.&lt;/h1"</span>) <span class="comment">//without template</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewsPara <span class="keyword">struct</span> &#123;</span><br><span class="line">  Title <span class="keyword">string</span></span><br><span class="line">  News  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newsAggHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  p := NewsPara&#123;Title: <span class="string">"Wow"</span>, News: <span class="string">"news"</span>&#125;</span><br><span class="line">  t, _ := template.ParseFiles(<span class="string">"simple.html"</span>) <span class="comment">// &#123;&#123; .Title&#125;&#125; , &#123;&#123;.News&#125;&#125;</span></span><br><span class="line">  <span class="comment">//t.Execute(w, p)</span></span><br><span class="line">  fmt.Println(t.Execute(w, p)) <span class="comment">//在控制台打印消息 (解析错误会有报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网页的模板代码非常简单: simple.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123; .Title&#125;&#125; , &#123;&#123;.News&#125;&#125;</span><br></pre></td></tr></table></figure><p>然后控制台运行 <code>localhost:8080/new/</code> 看到参数已经解析到页面上了。(如果HTML 模板参数名字写错了，则报错)</p><hr><p>下面来个稍微复杂一点的，复杂的模板使用。(从 WT xml 获取消息，然后显示到自己的网页)</p><p>模板如下: (网页上显示整个 map 的内容，所以需要循环)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> &#123;&#123; .Title &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>KeyWords<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">        &#123;&#123; range $key, $value := .News &#125;&#125;</span><br><span class="line">          <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"&#123;&#123;$value.Location&#125;&#125;"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>&#123;&#123; $key &#125;&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; $value.Keyword &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        &#123;&#123; end &#125;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>消息结构定义如下: (只是截取了标签内部分子标签)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Sitemapindex <span class="keyword">struct</span> &#123;</span><br><span class="line">  Locations []<span class="keyword">string</span> <span class="string">`xml: "sitemap&gt;loc"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> News <span class="keyword">struct</span> &#123;</span><br><span class="line">  Titles []<span class="keyword">string</span> <span class="string">`xml:"url&gt;news&gt;title"`</span></span><br><span class="line">  Keywords []<span class="keyword">string</span> <span class="string">`xml:"url&gt;news&gt;keywords"`</span></span><br><span class="line">  Locations []<span class="keyword">string</span> <span class="string">`xml:"url&gt;loc"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewsMap <span class="keyword">struct</span> &#123;</span><br><span class="line">  Keyword <span class="keyword">string</span></span><br><span class="line">  Location <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> NewsPara <span class="keyword">struct</span> &#123;</span><br><span class="line">  Title <span class="keyword">string</span></span><br><span class="line">  News  <span class="keyword">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后摘取然后显示的代码如下, 其 xml 结构类似如下:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">This XML file does not appear to have any style information associated with it. The document tree is shown below.</span><br><span class="line"><span class="tag">&lt;<span class="name">sitemapindex</span> <span class="attr">xmlns</span>=<span class="string">"http://www.sitemaps.org/schemas/sitemap/0.9"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sitemap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">loc</span>&gt;</span></span><br><span class="line">  http://www.washingtonpost.com/news-politics-sitemap.xml</span><br><span class="line">  <span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sitemap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">sitemap</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">loc</span>&gt;</span></span><br><span class="line">  http://www.washingtonpost.com/news-blogs-politics-sitemap.xml</span><br><span class="line">  <span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sitemap</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">sitemapindex</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体的每一条新闻类似:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">loc</span>&gt;</span></span><br><span class="line">    https://www.washingtonpost.com/politics/courts_law/is-california-protecting-women-or-forcing-clinics-to-promote-abortion-supreme-court-to-decide/2018/03/16/05ab6db4-2627-11e8-874b-d517e912f125_story.html</span><br><span class="line">  <span class="tag">&lt;/<span class="name">loc</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">changefreq</span>&gt;</span>hourly<span class="tag">&lt;/<span class="name">changefreq</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">n:news</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">n:publication</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">n:name</span>&gt;</span>Washington Post<span class="tag">&lt;/<span class="name">n:name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">n:language</span>&gt;</span>en<span class="tag">&lt;/<span class="name">n:language</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">n:publication</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">n:publication_date</span>&gt;</span>2018-03-17T00:30:17Z<span class="tag">&lt;/<span class="name">n:publication_date</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">n:title</span>&gt;</span></span><br><span class="line">      Is California protecting women or forcing clinics to promote abortion? Supreme Court to decide.</span><br><span class="line">    <span class="tag">&lt;/<span class="name">n:title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">n:keywords</span>&gt;</span></span><br><span class="line">      courts,informed choices,xavier becerra,supreme court,fake clinics,abortion</span><br><span class="line">    <span class="tag">&lt;/<span class="name">n:keywords</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">n:news</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>如果你无法访问该网页，可以把代码改成请求本地的 XML</strong>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newsHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> s Sitemapindex</span><br><span class="line">  <span class="keyword">var</span> n News</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取 xml 信息</span></span><br><span class="line">  resp, err := http.Get(<span class="string">"https://www.washingtonpost.com/news-sitemap-index.xml"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bytes, err:= ioutil.ReadAll(resp.Body)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  resp.Body.Close()</span><br><span class="line"></span><br><span class="line">  xml.Unmarshal(bytes, &amp;s) <span class="comment">//拿到具体的新闻地址 Sitemapindex.locations</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(s.Locations)==<span class="number">0</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"get the news xml locations error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//调试用</span></span><br><span class="line"><span class="comment">/* for url := range s.Locations &#123;</span></span><br><span class="line"><span class="comment">    log.Println(url)</span></span><br><span class="line"><span class="comment">    fmt.Println("s", url)</span></span><br><span class="line"><span class="comment">  &#125; */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析 xml</span></span><br><span class="line">  newsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]NewsMap) <span class="comment">//存储单个每一条新闻</span></span><br><span class="line">  <span class="keyword">for</span> _, Location := <span class="keyword">range</span> s.Locations &#123;</span><br><span class="line">    resp, _ := http.Get(Location)</span><br><span class="line">    bytes, _ := ioutil.ReadAll(resp.Body)</span><br><span class="line">    resp.Body.Close()</span><br><span class="line">    xml.Unmarshal(bytes, &amp;n) <span class="comment">//拿到具体新闻 News</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储到 NewsMap中</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> n.Keywords &#123;</span><br><span class="line">      newsMap[n.Titles[idx]] = NewsMap&#123;n.Keywords[idx], n.Locations[idx]&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//调试用</span></span><br><span class="line"><span class="comment">/*  for kk, vv := range newsMap &#123;</span></span><br><span class="line"><span class="comment">      log.Printf("title: %s\n", kk)</span></span><br><span class="line"><span class="comment">      log.Printf("News: keywords &#123;%s&#125; ", vv.Keyword)</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p := NewsPara&#123;Title: <span class="string">"Wow"</span>, News: newsMap&#125;</span><br><span class="line">  t, _ := template.ParseFiles(<span class="string">"complex.html"</span>)</span><br><span class="line">  <span class="comment">//t.Execute(w, p)</span></span><br><span class="line">  fmt.Println(t.Execute(w, p)) <span class="comment">//在控制台打印消息 (解析错误会有报错)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>为了让表格好看，可以加上一些格式代码</strong>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf8"</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">charset</span>=<span class="string">"utf8"</span> <span class="attr">src</span>=<span class="string">"//cdn.datatables.net/1.10.16/js/jquery.dataTables.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">type</span>=<span class="string">"text/css"</span> <span class="attr">href</span>=<span class="string">"//cdn.datatables.net/1.10.16/css/jquery.dataTables.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  $(<span class="built_in">document</span>).ready( <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    $(<span class="string">'#myTable'</span>).DataTable();</span></span><br><span class="line"><span class="undefined">&#125; );</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>=<span class="string">"mytable"</span> <span class="attr">class</span>=<span class="string">"display"</span>&gt;</span> ... <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>具体效果如下:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/golangnews.jpg" alt=" "></p><p>另外，可以看到网页的展示效果，但是就是速度上很慢，因为我们是顺序下载然后展示的，CPU 很大一部分时间在 idle 等待 IO 完毕(或者对方 server reponse 写回)，其实可以并行执行，同时多个 routine 去取，然后先返回的显写入 map.</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/oldspeed.jpg" alt=" "></p><p>做法有很多：比如开 N 个 goroutines， 把获取 xml news content 的工作交出去(哪几个 routines 抢到工作我不关心)，然后在 main routine 里面不断的读取 chan (这个 chan 可以开 x buffer，避免阻塞)，然后写入 map，即写入newsMap; 并且只能主 routine 写。</p><p>具体的模型可以参考这篇我写的这篇文章的线程池部分: <a href="http://www.merlinblog.site/posts/94df7563/#多个协程实现线程池">《Golang: Here We Go(5.孰能生巧)》</a></p><blockquote><p>读取 xml news 可以有多个，但是写保证只有一个人，即 main 在写(避免混乱)</p></blockquote><p>main 和其他 goroutines 之间可以用 sync.WaitGroup 的 Done() 和 Add()，也可以不用，读写同一个 阻塞型 chan 自动保证了协作&amp;同步。</p><p>我给出另外一种方案，使用 WaitGroup 的方案:(队列 + WaitGroup保证主routine等待其他routine完成具体的工作)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">newsHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> s Sitemapindex</span><br><span class="line"></span><br><span class="line">  <span class="comment">//获取 xml 信息</span></span><br><span class="line">  resp, err := http.Get(<span class="string">"https://www.washingtonpost.com/news-sitemap-index.xml"</span>)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  bytes, err:= ioutil.ReadAll(resp.Body)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  resp.Body.Close()</span><br><span class="line"></span><br><span class="line">  xml.Unmarshal(bytes, &amp;s) <span class="comment">//拿到具体的新闻地址 Sitemapindex.locations</span></span><br><span class="line">  <span class="keyword">if</span> <span class="built_in">len</span>(s.Locations)==<span class="number">0</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"get the news xml locations error"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  queue := <span class="built_in">make</span>(<span class="keyword">chan</span> News, <span class="number">50</span>) <span class="comment">//缓冲队列有50，然后开启100个 goroutines</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//解析 xml 存储新闻到 map 里面 ---- 把这里分割取出，并发</span></span><br><span class="line">  newsMap := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]NewsMap) <span class="comment">//存储单个每一条新闻</span></span><br><span class="line">  log.Println(<span class="built_in">len</span>(s.Locations)) <span class="comment">//22</span></span><br><span class="line">  <span class="keyword">for</span> _, Location := <span class="keyword">range</span> s.Locations &#123;</span><br><span class="line">    wg.Add(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">go</span> worker(queue, Location) <span class="comment">//往 News 队列里面写拿到的 xml 具体信息</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  <span class="built_in">close</span>(queue)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 从 chan 中拿到 News 写入 map</span></span><br><span class="line">  <span class="keyword">for</span> elem := <span class="keyword">range</span> queue &#123;</span><br><span class="line">    <span class="comment">/*if len(elem.Keywords)==0 &#123;</span></span><br><span class="line"><span class="comment">      log.Fatal("get the news xml content error") //有的链接拿到的就是空</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">    <span class="keyword">for</span> idx := <span class="keyword">range</span> elem.Keywords &#123;</span><br><span class="line">      newsMap[elem.Titles[idx]] = NewsMap&#123;elem.Keywords[idx], elem.Locations[idx]&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p := NewsPara&#123;Title: <span class="string">"Wow"</span>, News: newsMap&#125;</span><br><span class="line">  t, _ := template.ParseFiles(<span class="string">"complex.html"</span>)</span><br><span class="line">  <span class="comment">//t.Execute(w, p)</span></span><br><span class="line">  fmt.Println(t.Execute(w, p)) <span class="comment">//在控制台打印消息 (解析错误会有报错)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">worker</span><span class="params">(newsChan <span class="keyword">chan</span> News, Location <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">  <span class="keyword">defer</span> wg.Done()</span><br><span class="line">  <span class="keyword">var</span> n News</span><br><span class="line">  resp, _ := http.Get(Location) <span class="comment">//1</span></span><br><span class="line">  bytes, _ := ioutil.ReadAll(resp.Body) <span class="comment">//2</span></span><br><span class="line">  resp.Body.Close()</span><br><span class="line">  xml.Unmarshal(bytes, &amp;n) <span class="comment">//拿到具体新闻 News</span></span><br><span class="line"></span><br><span class="line">  newsChan &lt;- n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>速度提升了快了很多:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/newspeed.jpg" alt=" "></p><p>但是还能不能更快一点？应该可以，开更多的线程，比如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">queue := <span class="built_in">make</span>(<span class="keyword">chan</span> News, <span class="number">50</span>)</span><br><span class="line">urlChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">15</span>)</span><br><span class="line"><span class="keyword">for</span> i :=<span class="number">0</span>; i&lt;<span class="number">50</span>; i++ &#123;</span><br><span class="line">  wg.Add(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">go</span> worker(queue, urlChan)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能写的有点儿慢了, 所以把写也拿出去</span></span><br><span class="line"><span class="comment">//开的 routine 有点儿多，所以不用担心，一个劲儿派发 url 给它们抢</span></span><br><span class="line"><span class="keyword">for</span> _, Location := <span class="keyword">range</span> s.Locations &#123;</span><br><span class="line">  <span class="comment">//urlChan&lt;- Location</span></span><br><span class="line">  <span class="keyword">go</span> dispathURL(urlChan, Location)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里同步控制就比较烦了，控制不当可能有的 routine 一直等待写 urlChan。(因为还没有close)</p><p>并发部分，要么非常懂再去写；懂一点点&amp;知道语法，很容易写出带有Bug的并发程序。</p><hr><p>Merlin 2018.3 Golang HTML 模板(根据本案例扩展，其实可以做一个 RSS 订阅器)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;HTML 中使用 golang 模板编程。&lt;br&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: JSON 小案例(读配置文件)</title>
    <link href="http://www.merlinblog.site/posts/4620296/"/>
    <id>http://www.merlinblog.site/posts/4620296/</id>
    <published>2018-03-16T07:21:06.000Z</published>
    <updated>2018-04-12T06:55:17.657Z</updated>
    
    <content type="html"><![CDATA[<p>习惯于 xml 和 ioutil 的 []byte slice 读写，换换口味儿。(两种方式操作 JSON)<br><a id="more"></a></p><p>要读写一个简单的 Json 文件，这回用的是 io.Reader 对象，具体点儿说是 File 对象。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configFile, err := ioutil.ReadFile(filename) <span class="comment">//slice</span></span><br><span class="line"><span class="comment">//json.Marshal --- slice</span></span><br><span class="line"><span class="comment">//json.Unmarshal  --- slice</span></span><br><span class="line"></span><br><span class="line">configFile, err:= os.Open(filename) <span class="comment">// * File</span></span><br><span class="line">jsonParser := json.NewDecoder(configFile)</span><br><span class="line">err = jsonParser.Decode(&amp;config) <span class="comment">//store it in struct config</span></span><br></pre></td></tr></table></figure><p>看到啦，其实是两种完全不同的思路。</p><p>下面进入正文：</p><p>json 配置文件:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"database"</span>:&#123;</span><br><span class="line">        <span class="attr">"host"</span>: <span class="string">"localhost"</span>,</span><br><span class="line">        <span class="attr">"port"</span>: <span class="string">"3306"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"host"</span>:<span class="string">"localhost"</span>,</span><br><span class="line">    <span class="attr">"port"</span>: <span class="string">"8080"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后读取配置文件，其中一种写法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">_  <span class="string">"io/ioutil"</span></span><br><span class="line">  <span class="string">"os"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Config <span class="keyword">struct</span> &#123;</span><br><span class="line">  Database <span class="keyword">struct</span> &#123;</span><br><span class="line">    Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">    Port <span class="keyword">string</span> <span class="string">`json:"port"`</span></span><br><span class="line">  &#125; <span class="string">`json:"database"`</span></span><br><span class="line">  Host <span class="keyword">string</span> <span class="string">`json:"host"`</span></span><br><span class="line">  Port <span class="keyword">string</span> <span class="string">`json:"port"`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">LoadConfiguration</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="params">(Config, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> config Config</span><br><span class="line">  <span class="comment">//configFile, err := ioutil.ReadFile(filename) //slice</span></span><br><span class="line">  configFile, err:= os.Open(filename) <span class="comment">// * File</span></span><br><span class="line">  <span class="keyword">defer</span> configFile.Close()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> config, err</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//json.Marshal --- slice</span></span><br><span class="line">  <span class="comment">//json.Unmarshal  --- slice</span></span><br><span class="line">  jsonParser := json.NewDecoder(configFile)</span><br><span class="line">  err = jsonParser.Decode(&amp;config) <span class="comment">//store it in struct config</span></span><br><span class="line">  <span class="keyword">return</span> config, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(config Config)</span> <span class="title">String</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> fmt.Sprintf(<span class="string">"Config&#123;database&#123;host:%s, port:%s&#125;, host:%s, port:%s&#125;"</span>, </span><br><span class="line">    config.Database.Host, config.Database.Port, config.Host, config.Port)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  fmt.Println(<span class="string">"starting the application..."</span>)</span><br><span class="line">  <span class="keyword">if</span> config, err := LoadConfiguration(<span class="string">"config.json"</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Println(err);</span><br><span class="line">    os.Exit(<span class="number">1</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, config)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">json_config git:(master) ✗ go run main.go</span><br><span class="line">starting the application...</span><br><span class="line">Config&#123;database&#123;host:localhost, port:3306&#125;, host:localhost, port:8080&#125;</span><br></pre></td></tr></table></figure><hr><p>Merlin 2018.3 玩坏的json</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;习惯于 xml 和 ioutil 的 []byte slice 读写，换换口味儿。(两种方式操作 JSON)&lt;br&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: JSON 综合案例(天气预报)</title>
    <link href="http://www.merlinblog.site/posts/777e9274/"/>
    <id>http://www.merlinblog.site/posts/777e9274/</id>
    <published>2018-03-16T06:01:51.000Z</published>
    <updated>2018-04-12T06:55:17.656Z</updated>
    
    <content type="html"><![CDATA[<p>we create a tiny JSON client/server app in Go.<br><a id="more"></a></p><p>JSON 数据格式&amp;改编版就不说了，这里主要记录读写，简单小案例，练习。</p><p>我现在有一个 JSON 数据文件，请给我生成一个自动生成的 struct 结构体。(手写也可以，但是太麻烦)<br>免得我自己去写 backquote 映射。可以借助 <a href="https://mholt.github.io/json-to-go/" target="_blank" rel="noopener">josn2go工具</a> ，</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/golangjson.jpg" alt=" "></p><p>但是对于嵌入式结构，不要嵌入定义，带出来单独定义:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> weatherData <span class="keyword">struct</span> &#123;</span><br><span class="line">  LocationName <span class="keyword">string</span>   <span class="string">`json: locationName`</span></span><br><span class="line">  Weather      <span class="keyword">string</span>   <span class="string">`json: weather`</span></span><br><span class="line">  Temperature  <span class="keyword">int</span>      <span class="string">`json: temperature`</span></span><br><span class="line">  Celsius      <span class="keyword">bool</span>     <span class="string">`json: celsius`</span></span><br><span class="line">  TempForecast []<span class="keyword">int</span>    <span class="string">`json: temp_forecast`</span></span><br><span class="line">  Wind         windData <span class="string">`json: wind`</span>   <span class="comment">//here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> windData <span class="keyword">struct</span> &#123;</span><br><span class="line">  Direction <span class="keyword">string</span> <span class="string">`json: direction`</span></span><br><span class="line">  Speed     <span class="keyword">int</span>    <span class="string">`json: speed`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后读写代码如下:( ioutil.ReadAll 方法可能会占用大量机器内存)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> weatherData <span class="keyword">struct</span> &#123;</span><br><span class="line">  LocationName <span class="keyword">string</span>   <span class="string">`json: locationName`</span></span><br><span class="line">  Weather      <span class="keyword">string</span>   <span class="string">`json: weather`</span></span><br><span class="line">  Temperature  <span class="keyword">int</span>      <span class="string">`json: temperature`</span></span><br><span class="line">  Celsius      <span class="keyword">bool</span>     <span class="string">`json: celsius`</span></span><br><span class="line">  TempForecast []<span class="keyword">int</span>    <span class="string">`json: temp_forecast`</span></span><br><span class="line">  Wind         windData <span class="string">`json: wind`</span>   <span class="comment">//here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> windData <span class="keyword">struct</span> &#123;</span><br><span class="line">  Direction <span class="keyword">string</span> <span class="string">`json: direction`</span></span><br><span class="line">  Speed     <span class="keyword">int</span>    <span class="string">`json: speed`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一可能需要注意的是， JSON Field 只映射 struct 中 exported，公有的字段。(指定的映射默认此规则)</p><p>然后读写代码如下:( ioutil.ReadAll 方法可能会占用大量机器内存)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"bytes"</span></span><br><span class="line">  <span class="string">"encoding/json"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"io/ioutil"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> weatherData <span class="keyword">struct</span> &#123;</span><br><span class="line">  LocationName <span class="keyword">string</span>   <span class="string">`json: locationName`</span></span><br><span class="line">  Weather      <span class="keyword">string</span>   <span class="string">`json: weather`</span></span><br><span class="line">  Temperature  <span class="keyword">int</span>      <span class="string">`json: temperature`</span></span><br><span class="line">  Celsius      <span class="keyword">bool</span>     <span class="string">`json: celsius`</span></span><br><span class="line">  TempForecast []<span class="keyword">int</span>    <span class="string">`json: temp_forecast`</span></span><br><span class="line">  Wind         windData <span class="string">`json: wind`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> windData <span class="keyword">struct</span> &#123;</span><br><span class="line">  Direction <span class="keyword">string</span> <span class="string">`json: direction`</span></span><br><span class="line">  Speed     <span class="keyword">int</span>    <span class="string">`json: speed`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> loc <span class="keyword">struct</span> &#123;</span><br><span class="line">  Lat <span class="keyword">float32</span> <span class="string">`json: lat`</span></span><br><span class="line">  Lon <span class="keyword">float32</span> <span class="string">`json: lon`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">weatherHandler</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">  location := loc&#123;&#125;</span><br><span class="line"></span><br><span class="line">  log.Println(r.Method)</span><br><span class="line">  jsn, err := ioutil.ReadAll(r.Body)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"Error reading the body"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  err = json.Unmarshal(jsn, &amp;location)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"Decoding error: "</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.Printf(<span class="string">"Received: %v\n"</span>, location)</span><br><span class="line">  weather := weatherData&#123;</span><br><span class="line">    LocationName: <span class="string">"Zzyzx"</span>,</span><br><span class="line">    Weather:      <span class="string">"cloudy"</span>,</span><br><span class="line">    Temperature:  <span class="number">31</span>,</span><br><span class="line">    Celsius:      <span class="literal">true</span>,</span><br><span class="line">    TempForecast: []<span class="keyword">int</span>&#123;<span class="number">30</span>, <span class="number">32</span>, <span class="number">29</span>&#125;,</span><br><span class="line">    Wind: windData&#123;</span><br><span class="line">      Direction: <span class="string">"S"</span>,</span><br><span class="line">      Speed:     <span class="number">20</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  weatherJson, err := json.Marshal(weather)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Error: %s"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">  w.Header().Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">  w.Write(weatherJson)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">server</span><span class="params">()</span></span> &#123;</span><br><span class="line">  http.HandleFunc(<span class="string">"/"</span>, weatherHandler)</span><br><span class="line">  http.ListenAndServe(<span class="string">":8080"</span>, <span class="literal">nil</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">client</span><span class="params">()</span></span> &#123;</span><br><span class="line">  locJson, err := json.Marshal(loc&#123;Lat: <span class="number">35.14326</span>, Lon: <span class="number">-116.104</span>&#125;)</span><br><span class="line">  req, err := http.NewRequest(<span class="string">"POST"</span>, <span class="string">"http://localhost:8080"</span>, bytes.NewBuffer(locJson))</span><br><span class="line">  req.Header.Set(<span class="string">"Content-Type"</span>, <span class="string">"application/json"</span>)</span><br><span class="line">  client := &amp;http.Client&#123;&#125;</span><br><span class="line">  resp, err := client.Do(req)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">  &#125;</span><br><span class="line">  body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">  fmt.Println(<span class="string">"Response: "</span>, <span class="keyword">string</span>(body))</span><br><span class="line">  resp.Body.Close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">go</span> server()</span><br><span class="line">  client()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码和简单，跑一个客户端发送 location 给 服务端，服务端解析请求JSON段，然后打印；之后服务端回写一些JSON给client。专门用 <code>client := &amp;http.Client{}</code> 建立一个客户端实例的原因是，既要发送，又要等着接收服务端的回写。</p><p>然后运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2018/03/16 15:27:34 POST</span><br><span class="line">2018/03/16 15:27:34 Received: &#123;35.14326 -116.104&#125;</span><br><span class="line">Response:  &#123;&quot;LocationName&quot;:&quot;Zzyzx&quot;,&quot;Weather&quot;:&quot;cloudy&quot;,&quot;Temperature&quot;:31,&quot;Celsius&quot;:true,&quot;TempForecast&quot;:[30,32,29],&quot;Wind&quot;:&#123;&quot;Direction&quot;:&quot;S&quot;,&quot;Speed&quot;:20&#125;&#125;</span><br></pre></td></tr></table></figure><p>结合 net/http, 练习了一下 encoding/json 感觉不错。(虽然数据都是 Mock 的)</p><hr><p>Merlin 2018.3 更复杂的案例，可以参考 blog.golang.org/json-and-go </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;we create a tiny JSON client/server app in Go.&lt;br&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang: RESTful 小案例</title>
    <link href="http://www.merlinblog.site/posts/21f718fc/"/>
    <id>http://www.merlinblog.site/posts/21f718fc/</id>
    <published>2018-03-16T04:49:49.000Z</published>
    <updated>2018-04-12T06:55:17.656Z</updated>
    
    <content type="html"><![CDATA[<p>讲真，我听了很多关于 Rest 的解释，这个算是让我最懂的。<br><a id="more"></a></p><p>千万别去找 Restful 的全拼写，这就好像:</p><blockquote><p>你看到一个人在谈<strong>代码格式</strong>，然后你跑过去加入其中；这只能说明你跟这群人一样low</p><blockquote><p><code>go fmt code/path</code></p></blockquote></blockquote><p>开个玩笑，下面是正题。</p><p>Rest 和 HTTP 紧密联系是因为，这种协议(protocol) 一般用于 web 开发。(具体原因看下面)<br>Rest 更多的应该是和 CRUD (create, read, update, delete)关联，对应 HTTP的多种方法。</p><p><strong>Restful协议为什么和HTTP联系这么紧密</strong>?</p><ol><li>REST 的架构组成和 HTTP应用协议的应用类似:</li></ol><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/rest_http.jpg" alt=" "></p><p>可以看做抽象的 web-server 模型，就好像你点击超链接(hyperlink)然后返回得到的网页信息。</p><ol><li>REST操作基于 CRUD, 它和 HTTP 操作可以对应</li></ol><p>HTTP 兼容了 REST 的各种操作(mapping): GET/POST/PUT/DELTE/OPTIONS. （映射并不固定）<br>(至于请求时通过 URL 头，还是 body发送出去， REST并没与规定，这是HTTP的工作)<br>但是资源的 URL 并不包含具体的HTP Method 名字，而是通过具体的资源是元素还是集合给出不同的链接。</p><p>同时， REST 也可以对应 SQL操作 (Web 应用一定会有持久化动作)。</p><p><strong>RESTful API</strong>?</p><blockquote><p>其实说白了，REST/HTTP API 做了那部分工作呢？ URL/ROUTER 对应具体的 API</p><blockquote><p>把本地资源的 CRUD 操作，通过类似HTTP协议的形式映射出去，链接就是其表现形式，绑定的方法才是实质</p></blockquote></blockquote><p>例如:<br>URL <code>/note/:id</code> 可以绑定具体的 handler 处理，就像这样:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.GET(<span class="string">"url格式"</span>, 具体方法)</span><br><span class="line">router.PUT(<span class="string">"url格式"</span>, 具体方法)</span><br></pre></td></tr></table></figure><p>具体案例：(需要借助 httprouter 这个 golang 库)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"flag"</span></span><br><span class="line">  <span class="string">"fmt"</span></span><br><span class="line">  <span class="string">"github.com/julienschmidt/httprouter"</span></span><br><span class="line">  <span class="string">"log"</span></span><br><span class="line">  <span class="string">"net/http"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">  addr = flag.String(<span class="string">"addr"</span>, <span class="string">":8080"</span>, <span class="string">"http service address"</span>)</span><br><span class="line">  data <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  flag.Parse()</span><br><span class="line">  data = <span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">string</span>&#123;&#125; <span class="comment">//存储相应数据</span></span><br><span class="line"></span><br><span class="line">  r := httprouter.New()</span><br><span class="line">  r.GET(<span class="string">"/entry/:key"</span>, show) <span class="comment">//handler: show</span></span><br><span class="line">  r.GET(<span class="string">"/list"</span>, show)</span><br><span class="line">  r.PUT(<span class="string">"/entry/:key/:value"</span>, update)</span><br><span class="line">  err := http.ListenAndServe(*addr, r)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(<span class="string">"ListenAndServer:"</span>, err)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">show</span><span class="params">(w http.ResponseWriter, r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">  p httprouter.Params)</span></span> &#123;</span><br><span class="line">  k := p.ByName(<span class="string">"key"</span>)</span><br><span class="line">  <span class="keyword">if</span> k == <span class="string">""</span> &#123;</span><br><span class="line">    fmt.Fprintf(w, <span class="string">"Read list :%v"</span>, data)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  fmt.Fprintf(w, <span class="string">"Read entry: data[%s] = %s"</span>, k, data[k])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">update</span><span class="params">(w http.ResponseWriter, r *http.Request,</span></span></span><br><span class="line"><span class="function"><span class="params">  p httprouter.Params)</span></span> &#123;</span><br><span class="line">  k := p.ByName(<span class="string">"key"</span>)</span><br><span class="line">  v := p.ByName(<span class="string">"value"</span>)</span><br><span class="line"></span><br><span class="line">  data[k] = v</span><br><span class="line">  fmt.Fprintf(w, <span class="string">"Update : data[%s] = %s"</span>, k, data[k])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>(代码存储在: <a href="https://github.com/WizardMerlin/gopher" target="_blank" rel="noopener">《宝库-cases》</a>)</p><p>运行一下, 然后 curl 调试:</p><p><img src="http://www.commoncommonheart.com/wp-content/uploads/2018/03/rest_http1.jpg" alt=" "></p><hr><p>Merlin 通过 golang 解释了一下 RESTful 协议，点到为止</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;讲真，我听了很多关于 Rest 的解释，这个算是让我最懂的。&lt;br&gt;
    
    </summary>
    
      <category term="CaseGolang专栏" scheme="http://www.merlinblog.site/categories/CaseGolang%E4%B8%93%E6%A0%8F/"/>
    
    
      <category term="网络" scheme="http://www.merlinblog.site/tags/%E7%BD%91%E7%BB%9C/"/>
    
      <category term="http" scheme="http://www.merlinblog.site/tags/http/"/>
    
      <category term="golang" scheme="http://www.merlinblog.site/tags/golang/"/>
    
  </entry>
  
</feed>
