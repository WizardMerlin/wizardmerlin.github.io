<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Merlin" />



<meta name="description" content="这里涉及到了至少两个问题, 移动语义和完美转发; 最后还说了RVO问题">
<meta name="keywords" content="cpp,右值,移动语义,完美转发">
<meta property="og:type" content="article">
<meta property="og:title" content="技术: C++11 右值相关问题探讨">
<meta property="og:url" content="http://www.merlinblog.site/posts/f306f9f9/index.html">
<meta property="og:site_name" content="梅林日志">
<meta property="og:description" content="这里涉及到了至少两个问题, 移动语义和完美转发; 最后还说了RVO问题">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-04-12T06:55:17.620Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技术: C++11 右值相关问题探讨">
<meta name="twitter:description" content="这里涉及到了至少两个问题, 移动语义和完美转发; 最后还说了RVO问题">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="梅林日志" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/red/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>技术: C++11 右值相关问题探讨 | 梅林日志</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/mine.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Merlin</a></h1>
        </hgroup>

        
        <p class="header-subtitle">云卷云舒，平常心态</p>
        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">[归档]</a></li>
                        
                            <li><a href="/works/">小作品</a></li>
                        
                            <li><a href="/tags/">[标签]</a></li>
                        
                            <li><a href="/about/">关于</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/WizardMerlin" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" href="https://www.douban.com/people/170414854/" title="豆瓣"></a>
                            
                                <a class="fa Email" href="mailto:&#119;&#105;&#122;&#97;&#114;&#100;&#109;&#101;&#114;&#108;&#105;&#110;&#57;&#52;&#53;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa QQ" href="tencent://message/?Menu=yes&uin=3076407405" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">极简.</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Merlin</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/mine.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Merlin</a></h1>
            </hgroup>
            
            <p class="header-subtitle">云卷云舒，平常心态</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">[归档]</a></li>
                
                    <li><a href="/works/">小作品</a></li>
                
                    <li><a href="/tags/">[标签]</a></li>
                
                    <li><a href="/about/">关于</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/WizardMerlin" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" target="_blank" href="https://www.douban.com/people/170414854/" title="豆瓣"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:&#119;&#105;&#122;&#97;&#114;&#100;&#109;&#101;&#114;&#108;&#105;&#110;&#57;&#52;&#53;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="tencent://message/?Menu=yes&uin=3076407405" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-right-value-related" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/f306f9f9/" class="article-date">
      <time datetime="2016-05-21T05:52:16.000Z" itemprop="datePublished">2016-05-21</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      技术: C++11 右值相关问题探讨
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/右值/">右值</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/完美转发/">完美转发</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/移动语义/">移动语义</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>这里涉及到了至少两个问题, 移动语义和完美转发; 最后还说了RVO问题<br><a id="more"></a></p>
<blockquote>
<p>本文集中说说和右值相关的所有问题, 右值&amp;左值, 移动语义, 完美转发, 非const引用; 以及引入移动语义的利弊.</p>
</blockquote>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>这里要总结一下, 左值, 右值, 左值引用等.</p>
<blockquote>
<p>左值（lvalue）表示一个可被标识的（变量或对象的）内存位置，并且允许使用&amp;操作符来获取这块内存的地址。</p>
</blockquote>
<p>如果一个表达式不是左值，那它就被定义为右值。</p>
<p>左值转换为右值:</p>
<blockquote>
<p>一般上讲，对象之间的运算，对象是以右值的形式参与的;那些表示数组、函数和非完整类型的左值是不能转换为右值的，因为无法对那些类型进行求值</p>
</blockquote>
<p>例如下面的代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;     <span class="comment">// a 是左值</span></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;     <span class="comment">// b 是左值</span></span><br><span class="line"><span class="keyword">int</span> c = a + b; <span class="comment">// a和b自动转换为右值求和</span></span><br></pre></td></tr></table></figure>
<p>左值转换右值, 还涉及到CV限定问题:</p>
<ul>
<li>非对象类型的左值, 转换为右值计算或者求值, 会去掉其CV限定</li>
<li>类对象类型的左值, 转换为右值, 则保留其原有类型修饰(const or volatile)</li>
</ul>
<blockquote>
<p>也就是说，如果是类类型，从左值转为右值时，它的CV限定符会被保留</p>
</blockquote>
<p>例如下面的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo() const\n"</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"A::foo()\n"</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">A <span class="title">bar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;           <span class="comment">//返回临时对象，为右值</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> A <span class="title">cbar</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> A(); &#125;    <span class="comment">//返回带const的右值（带CV限定符）</span></span><br></pre></td></tr></table></figure>
<p>由于C语言不涉及类, 所以也就不存在右值可以保留CV限定这一说.</p>
<p>btw: 什么是CV限定符？如果变量声明时类型前带有const或volatile，就说此变量类型具有CV限定符。</p>
<p>左值引用</p>
<blockquote>
<p>如果一个左值同时是引用，就称为左值引用.</p>
</blockquote>
<p>例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp; sref = s;  <span class="comment">//sref为左值引用</span></span><br></pre></td></tr></table></figure>
<h1 id="非const引用"><a href="#非const引用" class="headerlink" title="非const引用"></a>非const引用</h1><blockquote>
<p>最开始, 碰到右值问题的时候是, <code>临时对象不能赋值给非const类型的引用</code> (编译器从安全检查的角度禁止你这么做).</p>
</blockquote>
<p>非const引用, 一般也可以称为<code>左值引用</code>.</p>
<p>例如有一个函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_move</span><span class="params">(A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//do nothing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你这么调用<code>test_move(A(1));</code>, 即使用临时对象进行调用, 然后直接就报错了:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">invalid initialization of non-const reference of type ‘A&amp;’ from an rvalue of type ‘A’</span><br></pre></td></tr></table></figure>
<p>然后, 没办法, 为了通过编译, 改进一下引入了一个<code>A&amp; setInt(int i);</code>方法让其返回<code>A&amp;</code>, 通过编译.<br>完整代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  A()=<span class="keyword">default</span>;</span><br><span class="line">  A(<span class="keyword">int</span> i): i_(i)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">A&amp; <span class="title">setInt</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123; <span class="comment">//注意该函数返回值类型 A&amp;</span></span><br><span class="line">    i_ = i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ~A()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> i_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_move</span><span class="params">(A&amp; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//do nothing</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">/*invalid initialization of non-const reference of type ‘A&amp;’</span></span><br><span class="line"><span class="comment">   from an rvalue of type ‘A’ */</span></span><br><span class="line">  <span class="comment">//test_move(A(1));</span></span><br><span class="line">  test_move(A().setInt(<span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么有没有一种机制, 可以直接接收临时对象呢? 而不再受限于<code>test_move(A&amp;)</code>这种形式? (当然你改写成<code>const A&amp;</code>是可以解决问题的)</p>
<blockquote>
<p>这样就由非const引用, 引出了<code>右值引用</code>问题(右值专用的引用)</p>
</blockquote>
<h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>上面顺利成章的说道了 C++11的<code>右值引用问题, 符号表示就是</code>T &amp;&amp;<code>, 表示上不同于以前的</code>左值引用`, 即一般引用.</p>
<p>但是右值引用的存在, 不仅仅只是因为非const引用问题, 它的主要用途:</p>
<blockquote>
<p>利用临时对象, 即右值</p>
</blockquote>
<p>利用临时对象, 以前我们用临时对象是利用<code>const T &amp;</code>来做, 例如string的交换:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">string</span>&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"copy assignment operator"</span>);</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">tmp</span><span class="params">(other)</span></span>;  <span class="comment">//构造一个临时对象，因为other为const，不能被修改</span></span><br><span class="line">    <span class="built_in">std</span>::swap(m_size, tmp.m_size);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_data, tmp.m_data);  </span><br><span class="line">    <span class="comment">//跟临时对象交换值，临时对象晰构时会delete [] m_data</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上, 我们还是拿右值创建了一个临时对象, 然后进行的交换, 那么为何不直接利用好临时对象呢?<br>比如, 这样利用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span>&amp; <span class="keyword">operator</span>=(<span class="built_in">string</span>&amp;&amp; other)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">log</span>(<span class="string">"move assignment operator"</span>);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_size, other.m_size);</span><br><span class="line">    <span class="built_in">std</span>::swap(m_data, other.m_data);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如<code>v = string(&quot;33&quot;);</code>, 赋值交换完毕, 外部的临时对象也是会被销毁的, 何苦在内部创建一个? </p>
<blockquote>
<p>&amp;&amp;语法声明右值引用，表示一个指向右值的引用，通过这个引用，可以直接操作右值.</p>
</blockquote>
<p>实际上<strong>右值引用专门用于引用右值(临时对象、匿名对象)</strong>, 但是也可以接收左值.</p>
<p>但是除了可以引用临时对象, 很多时候, 也需要减少对象的构建代价, 直接利用已经存在的临时对象生成新对象(比如上面的例子),<br>甚至把别的对象挖空, 然后转移到本对象. 这方面广泛的应用是<code>拷贝构造</code>和<code>拷贝赋值</code>.</p>
<blockquote>
<p>但是归根揭底, 右值引用只是为临时对象, 匿名对象设置了机制</p>
</blockquote>
<p>如果拿到临时对象, 或者具体的说, 从原有对象中拿到临时对象? (比如说就是要利用现有对象构造新的对象, 避免拷贝, 要偷)</p>
<blockquote>
<p>于是引出了<code>移动语义</code>, 移动语义是利用<code>右值引用</code>引用机制.</p>
</blockquote>
<h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>说先强调一下, 移动语义应该分成两个方面理解:</p>
<ul>
<li>我们提供 move 版本的函数, 比如构造和拷贝构造</li>
<li>系统提供的 std::move 作用方面(仅仅为了产生临时对象, 方便调用移动版本-避免拷贝)</li>
</ul>
<p>(其中移动语义, 很小一部分程度是指std::move, 更多的是指完成偷的任务, 下面详细说)</p>
<p>先说第一点:</p>
<p>我们提供 move 版函数, 实际上就是为了挖空对象或者说利用已知对象, 更高效的创建对象; 避免拷贝(只是搬动指针指向).</p>
<p>对于挖空(偷)别的对象的资源, 不管是不是临时对象, 移动语义写法可谓是得心应手, 很多时候, 你甚至可以简单的认为:</p>
<blockquote>
<p>移动语义就是浅拷贝, 安全的浅拷贝.</p>
</blockquote>
<p>因为它避免了隐式的转移操作 (这也是我们舍弃auto_ptr, 改用unique_ptr的原因之一), 改成了<code>显式</code>的语义, 被偷的对象不再拥有相关资源的所有权.</p>
<blockquote>
<p>你可以理解成原来资源的指针已经被置为null.</p>
</blockquote>
<p>但是C++是有规则的, 什么对象可以偷?</p>
<blockquote>
<p>没有主人的, 即非左值的, that is <code>非具名</code>的.</p>
</blockquote>
<p>也就是你给我一个右值最好, 我心安理得地偷; 但是, 如果你给我左值, 我会先把它转换为右值(<code>&amp;&amp;</code>可以接收左值), 再偷, 于是引出了move的第二个方面, std::move. 如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class _Ty&gt; inline</span><br><span class="line">constexpr typename remove_reference&lt;_Ty&gt;::type&amp;&amp;</span><br><span class="line">move(_Ty&amp;&amp; _Arg) _NOEXCEPT</span><br><span class="line">&#123;</span><br><span class="line">    return (static_cast&lt;typename remove_reference&lt;_Ty&gt;::type&amp;&amp;&gt;(_Arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意区别于算法的 std::move, 这个<code>std::move</code>定义在<code>&lt;utility&gt;</code>头文件中.</p>
<blockquote>
<p>凡是经过 move 这一家伙动作, 原来的对象已经不再控制相关内部资源了.</p>
</blockquote>
<p>也就是说 std::move 已经是提供好的 move 版本的函数, 它会把原对象的资源转移到临时对象上. 注意其返回值<code>&amp;&amp;</code>.</p>
<blockquote>
<p>准确来说, std::move(x)只是产生临时对象, 方便调用移动版本的函数, 而这个函数才是真正的转移资源.</p>
</blockquote>
<p>最简单的例子, 你可以试试:(str合法, 但是没有任何内部值)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str = <span class="string">"Hello"</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; v;</span><br><span class="line"> v.push_back(<span class="built_in">std</span>::move(str));</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"After move, str is \""</span> &lt;&lt; str &lt;&lt; <span class="string">"\"\n"</span>; <span class="comment">//output : After move, str is ""</span></span><br></pre></td></tr></table></figure>
<p>此时, 移动语义和右值引用的关系就是:</p>
<blockquote>
<p>移动语义为右值引用产生临时对象, 副作用是把原来对象的资源偷到临时对象(右值)中了, 而这部分工作是由<code>vector::push_back(string &amp;&amp;)</code>版本的函数实现的.</p>
</blockquote>
<p>std::movej就像个助手, 安全的转换工具; 不借助 std::move, 很难完成具名对象的转移任务, 除非你自己提供<code>移动版本</code>的函数, 就像移动构造和移动赋值函数一样.</p>
<blockquote>
<p>How does std::move work</p>
<p>You might be wondering, how does one write a function like std::move? How do you get this magical property of transforming an lvalue into an rvalue reference? The answer, as you might guess, is typecasting.<br>The actual declaration for std::move is somewhat more involved, but at its heart, it’s just a static_cast to an rvalue reference. This means, actually, that you don’t really need to use move–but you should, since it’s much more clear what you mean. The fact that a cast is required is, by the way, a very good thing! It means that you cannot accidentally convert an lvalue into an rvalue, which would be dangerous since it might allow an accidental move to take place. You must explicitly use std::move (or a cast) to convert an lvalue into an rvalue reference, and an rvalue reference will never bind to an lvalue on its own.</p>
</blockquote>
<p>一句话总结, 移动语义就是偷, 明目张胆的偷, 而 std::move 帮你偷, 它是帮助你调用到你移动版本函数的助手.</p>
<h2 id="容器的影响"><a href="#容器的影响" class="headerlink" title="容器的影响"></a>容器的影响</h2><p>临时对象放入容器, 对比一下临时对象带有移动语义或者不带有移动语义的情况, 发现, 对于vector的影响最大.<br>其他的比如list, deque(只往末端插入), map, unordered容器(底层实际为hashtable)影响不是太大.</p>
<p>实际拷贝容器的时候, vector直接拷贝构造和使用<code>std::move();</code>差别也很大:</p>
<ul>
<li>实际拷贝的, 一个元素一个元素的拷贝(从头到尾), 所以慢</li>
<li>std::move 版本, <code>vector(vector&amp;&amp; __x) noexcept</code>, 内部实现其实是<code>交换地址指针</code>(begin, end, capacity), 所以快.</li>
</ul>
<p><code>使用std::move是为了调用移动版本的重载函数</code>, 副作用才是产生临时对象(右值), 例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; b(<span class="built_in">std</span>::move(a));       <span class="comment">//这里调用的是b的移动构造函数</span></span><br><span class="line">							  <span class="comment">//a在重新赋值之前绝不使用</span></span><br></pre></td></tr></table></figure>
<p>vector自己提供的移动版本才是避免拷贝的真正所在, 即移动的真理.</p>
<blockquote>
<p>一旦<code>std::move()</code>之后, 就不能再使用原来的资源了, 不管原来的是否是具名的变量.</p>
</blockquote>
<h1 id="右值引用引发的问题"><a href="#右值引用引发的问题" class="headerlink" title="右值引用引发的问题"></a>右值引用引发的问题</h1><p>是的, 不管是移动语义本身, 还是系统帮我们实现的简化偷动作的 <code>std::move</code> 都是有代价的,<br>可以回想一下, 以前我们在说拷贝问题时, 涉及的问题:</p>
<ul>
<li>返回值问题 (引出了返回值优化问题, 即RVO)</li>
<li>函数参数问题 (完美转发问题)</li>
</ul>
<p>先说比较简单的, <code>完美转发</code>问题.</p>
<h2 id="完美转发"><a href="#完美转发" class="headerlink" title="完美转发"></a>完美转发</h2><p>已经知道了右值引用, 可以直接说这个问题, 例如: (参考<code>&lt;C++ primer&gt;</code> page162)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">(T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionB(t1, t2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你先不管 <code>functionB</code>, 只看functionA, 我传递给你的是右值, 然后在functionA内部使用这些值, 其实会把它弄为临时变量(拷贝), 即编译器会给它命名.<br>那么如果functionB有非右值重载函数, 直接调用非右值版本了;</p>
<p>此时, 这样的转发就不是<code>完美</code>的, 只能说是<code>正确</code>的; 因为经过中途调用, 我还是想保留调用的是右值版本.</p>
<p>标准库给了一种方案, 语言层面的实现, 头文件 <code>move.h</code>中<code>forward()</code>部分,  源码实现也简单, 例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">_t</span>&amp;&amp; <span class="comment">//注意其返回值</span></span><br><span class="line">	forward(<span class="keyword">typename</span> <span class="built_in">std</span>::remove_reference&lt;_Tp&gt;::type&amp; <span class="keyword">_t</span>) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;_Tp &amp;&amp;&gt;(<span class="keyword">_t</span>);&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中<code>typename std::remove_reference&lt;_Tp&gt;::type&amp; _t</code>, <code>typename std::remove_reference&lt;_Tp&gt;</code>看做类型转换的模板,<br>实际上可以简单认为就是<code>T&amp; &amp;&amp;</code>, 即<code>T &amp;</code> (具体可以参考<code>折叠规则</code>) 大部分去掉左值名字关联的动作就在这个模板里面<br>而<code>::type&amp;</code>则拿到了模板中内部参数的类型, <code>_t</code>则是调用时传递的实参对应的形参. 之后内部实现, 由于已经拿掉命名了, 直接<code>static_cast</code>即可.</p>
<blockquote>
<p>简单说, 摘掉名字, 强制转换一下.</p>
</blockquote>
<p>(为什么这里不用std::move, 其实可以; 但是由于各自用途不同, 以及未来的扩展, 这里还是规范的采用forward)</p>
<p>于是就变成了这样:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functionA</span><span class="params">(T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	functionB(<span class="built_in">std</span>::forward&lt;T1&gt;(t1), <span class="built_in">std</span>::forward&lt;T2&gt;(t2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实和 <code>std::move</code>工具一样, <code>std::forward</code>也就是为了调用右值版本的函数, 从而完成移动语义, 避免拷贝, 提高效率.</p>
<p>最常见的例子:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vector容器中</span></span><br><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span>... <span class="title">Args</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">emplace_back</span>( <span class="title">Args</span>&amp;&amp;... <span class="title">args</span> );</span></span><br></pre></td></tr></table></figure>
<p>c++11中大部分容器都加了一个emplace_back成员函数, 它的内部也是调用了std::forward实现完美转发的。</p>
<p>因此如果我们需要往容器中添加右值、临时变量时，用emplace_back版本<code>最终可以调用移动版本的添加函数</code>, 从而可以提高性能。</p>
<p>甚至, 有人为不带移动语义的函数提供了转发语义<code>包装函数</code>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">auto</span> <span class="title">FuncWrapper</span>(<span class="title">Function</span> &amp;&amp; <span class="title">f</span>, <span class="title">Args</span> &amp;&amp; ... <span class="title">args</span>) -&gt; <span class="title">decltype</span>(<span class="title">f</span>(<span class="title">std</span>:</span>:forward&lt;Args&gt;(args)...))</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> f(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转发之后, 优先调用右值引用版本(如果没有则调用值拷贝版本, 即普通右值版本)</p>
<p>具体实际的例子如下, 可以加深一下理解:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//对不同类型的参数进行转发测试</span><br><span class="line">void RunCode(int &amp;&amp; m) &#123;cout &lt;&lt; &quot;rv ref&quot; &lt;&lt; endl;&#125;</span><br><span class="line">void RunCode(int &amp; m) &#123;cout &lt;&lt; &quot;lv ref&quot; &lt;&lt; endl;&#125;</span><br><span class="line">void RunCode(const int &amp;&amp; m) &#123;cout &lt;&lt; &quot;const rv ref&quot; &lt;&lt; endl;&#125;</span><br><span class="line">void RunCode(const int &amp; m) &#123;cout &lt;&lt; &quot;const lv ref&quot; &lt;&lt; endl;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">void PerfectForward(T &amp;&amp;t) &#123; RunCode(forward&lt;T&gt;(t));&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int a, b;</span><br><span class="line">    const int c =1;</span><br><span class="line">    const int d = 0;</span><br><span class="line"></span><br><span class="line">    PerfectForward(a);</span><br><span class="line">    PerfectForward(move(b));</span><br><span class="line">    PerfectForward(c);</span><br><span class="line">    PerfectForward(move(d));</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">lv ref</span><br><span class="line">rv ref</span><br><span class="line">const lv ref</span><br><span class="line">const rv ref</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全部转发成了对目标函数的调用了. 其他复杂的例子, 例如:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PerfectForward</span><span class="params">(T &amp;&amp;t, U&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Func(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大同小异.</p>
<blockquote>
<p>完美转发其实就是一个包装函数的作用, 只不过它增加了对右值引用的支持.</p>
<blockquote>
<p>没有必要去钻那么引用推导规则, 只要明白, 一旦你的外层函数参数涉及了右值, 你就可能要进行一波完美转发, 才能调用到正确的函数版本</p>
</blockquote>
</blockquote>
<h2 id="RVO"><a href="#RVO" class="headerlink" title="RVO"></a>RVO</h2><p>虽然利用右值引用可以写出<code>移动语义</code>的高效代码, 但是也已经引发了, 完美转发问题, 以及现在要说的<code>返回右值引用</code>问题.</p>
<p>但是这方面问题一直很奇怪. 以一个简单的案例解释一下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getInt</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> &amp;&amp; <span class="title">getRvalueInt</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// notice that it's fine to move a primitive type--remember, std::move is just a cast</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::move( x );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printAddress</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; v)</span> <span class="comment">// const ref to allow binding to rvalues</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">void</span>*&gt;( &amp; v ) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用代码如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">printAddress( x );  <span class="comment">//1</span></span><br><span class="line">printAddress( getInt() ); <span class="comment">//2</span></span><br><span class="line">printAddress( getRvalueInt() ); <span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>明确返回右值引用的 <strong>3</strong>和<strong>1</strong>是一样的, 而2则不同.</p>
<blockquote>
<p>So returning an rvalue reference is a different thing than not returning an rvalue reference, but this difference manifests itself most noticeably if you have a pre-existing object you are returning instead of a temporary object created in the function (where the compiler is likely to eliminate the copy for you).</p>
</blockquote>
<p>(也就是说, 但你外部有接收对象接收临时对象, 编译器是会进行具名返回值的优化; 并且明确返回原右值引用的确实返回的是同一地址的右值, 返回右值的则是值拷贝)</p>
<blockquote>
<p>具名优化, 和编译器实现有关, 不再多谈这些边角料;</p>
<blockquote>
<p>g++ 使用选项 <code>-fno-elide-constructors</code> 关闭该选项</p>
</blockquote>
</blockquote>
<p>总之, 明确返回右值引用的, 应该是想利用原右值做进一步的操作, 比如再调用右值版本的函数.</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="string类参考"><a href="#string类参考" class="headerlink" title="string类参考"></a>string类参考</h2><blockquote>
<p>自己实现move版本的函数, 尤其注意把原来参数中的指针置为null.<br>代码实现如下:</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">char</span> *_data;</span><br><span class="line">	<span class="keyword">size_t</span> _len;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//only deal with data part</span></span><br><span class="line">	<span class="keyword">void</span> _init_data(<span class="keyword">const</span> <span class="keyword">char</span>* s)</span><br><span class="line">	&#123;</span><br><span class="line">		_data = <span class="keyword">new</span> <span class="keyword">char</span>[_len+<span class="number">1</span>];</span><br><span class="line">		<span class="built_in">memcpy</span>(_data, s, _len);</span><br><span class="line">		_data[_len] = <span class="string">'\0'</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">//default</span></span><br><span class="line">	MyString() : _data(<span class="literal">NULL</span>), _len(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//constructor</span></span><br><span class="line">	MyString(<span class="keyword">const</span> <span class="keyword">char</span> *p) : _len(<span class="built_in">strlen</span>(p)) &#123;</span><br><span class="line">		_init_data(p);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//copy constructor</span></span><br><span class="line">	MyString(<span class="keyword">const</span> MyString&amp; str) : _len(str._len)</span><br><span class="line">	&#123;</span><br><span class="line">		_init_data(str._data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//copy assigment</span></span><br><span class="line">	MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp;str)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> != &amp;str) &#123;</span><br><span class="line">			<span class="keyword">if</span>(_data) &#123;</span><br><span class="line">				<span class="keyword">delete</span> _data;</span><br><span class="line">			&#125;</span><br><span class="line">			_len = str._len; </span><br><span class="line">			_init_data(str._data);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//move constructor</span></span><br><span class="line">	MyString(MyString&amp;&amp; str) <span class="keyword">noexcept</span> : </span><br><span class="line">		_data(str._data), _len(str._len) &#123;</span><br><span class="line">		</span><br><span class="line">		str._len = <span class="number">0</span>;</span><br><span class="line">		str._data = <span class="literal">nullptr</span>; <span class="comment">//watchout double delete</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//move assigment</span></span><br><span class="line">	MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; str) <span class="keyword">noexcept</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(<span class="keyword">this</span> != &amp; str) &#123;</span><br><span class="line">			<span class="keyword">if</span>(_data) &#123;</span><br><span class="line">				<span class="keyword">delete</span> _data;</span><br><span class="line">			&#125;</span><br><span class="line">			_len = str._len;</span><br><span class="line">			_data = str._data; <span class="comment">//MOVE</span></span><br><span class="line">			</span><br><span class="line">			str._len = <span class="number">0</span>;</span><br><span class="line">			str._data = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//deconstructor</span></span><br><span class="line">	<span class="keyword">virtual</span> ~MyString()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span>(_data) &#123;</span><br><span class="line">			<span class="keyword">delete</span> _data;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//为了放入一些有序容器中, 需要下面的函数</span></span><br><span class="line">	<span class="comment">//compare</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> MyString&amp; str) <span class="keyword">const</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//借用std::string的比较函数</span></span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;_data) &lt; <span class="built_in">string</span>(str._data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//==</span></span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> MyString&amp; str)</span><br><span class="line">	&#123;()</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">string</span>(<span class="keyword">this</span>-&gt;_data) == <span class="built_in">std</span>::<span class="built_in">string</span>(str._data);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//get , c_str()</span></span><br><span class="line">	<span class="function"><span class="keyword">char</span> *<span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _data;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//一般还要提供一个 MyStringHashCodeFunctor函数对象用于hash容器, 或者借助标准库的`std::hash`仿函数模板特化一个属于MyString的特化模板仿函数.</span></span><br><span class="line"><span class="comment">//例如下面</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;<span class="comment">//一定要放在std下</span></span><br><span class="line">	<span class="keyword">template</span>&lt;&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;MyString&gt;</span></span><br><span class="line"><span class="class">	&#123;</span>	</span><br><span class="line">		<span class="keyword">size_t</span> <span class="keyword">operator</span>(<span class="keyword">const</span> MyString&amp; s) <span class="function"><span class="keyword">const</span> <span class="title">noexcept</span><span class="params">()</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(<span class="built_in">string</span>(s.get()));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol>
<li><a href="http://thbecker.net/articles/rvalue_references/section_01.html" target="_blank" rel="noopener">http://thbecker.net/articles/rvalue_references/section_01.html</a></li>
<li><a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c" target="_blank" rel="noopener">https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c</a></li>
<li><a href="https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html" target="_blank" rel="noopener">https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html</a></li>
<li><a href="https://en.wikipedia.org/wiki/Return_value_optimization" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Return_value_optimization</a></li>
<li><a href="https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en" target="_blank" rel="noopener">https://www.ibm.com/developerworks/community/blogs/5894415f-be62-4bc0-81c5-3956e82276f3/entry/RVO_V_S_std_move?lang=en</a></li>
<li>《深入理解C++11新特性与应用》 C++标准委员会 &amp; IBM XL编译器中国开发团队</li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/posts/f306f9f9/">技术: C++11 右值相关问题探讨</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Merlin</a></p>
        <p><span>发布时间:</span>2016-05-21, 13:52:16</p>
        <p><span>最后更新:</span>2018-04-12, 14:55:17</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/posts/f306f9f9/" title="技术: C++11 右值相关问题探讨">http://www.merlinblog.site/posts/f306f9f9/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.merlinblog.site/posts/f306f9f9/　　作者: Merlin" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/posts/b0dbc55e/">
                    技术: 带有移动语义的 C++ 字符串类
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/posts/e9705375/">
                    技术: C++11 类型萃取
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本概念"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#非const引用"><span class="toc-number">2.</span> <span class="toc-text">非const引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#右值引用"><span class="toc-number">3.</span> <span class="toc-text">右值引用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#移动语义"><span class="toc-number">4.</span> <span class="toc-text">移动语义</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#容器的影响"><span class="toc-number">4.1.</span> <span class="toc-text">容器的影响</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#右值引用引发的问题"><span class="toc-number">5.</span> <span class="toc-text">右值引用引发的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#完美转发"><span class="toc-number">5.1.</span> <span class="toc-text">完美转发</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RVO"><span class="toc-number">5.2.</span> <span class="toc-text">RVO</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#其他"><span class="toc-number">6.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#string类参考"><span class="toc-number">6.1.</span> <span class="toc-text">string类参考</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考"><span class="toc-number">7.</span> <span class="toc-text">参考</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/posts/b0dbc55e/" title="上一篇: 技术: 带有移动语义的 C++ 字符串类">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/posts/e9705375/" title="下一篇: 技术: C++11 类型萃取">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/2ff459d4/">Android: 彙編語言基礎</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7ef0bd11/">技巧: iOS 工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e2300e0/">Golang: 并发聊天室综合案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/74edbb6d/">Golang: TCP 文件传输案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a8342f6/">Golang: TCP 简单并发服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aa0a3cc6/">技巧: B站视频下载脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8180668e/">技巧: 多用户共享 Parralles 虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/55b0329b/">Golang: 值类型&引用类型坑(12)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ac5ecee9/">Golang: 函数类型实现接口封装问题(11)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/eecafb73/">Golang: struct打印输出问题(10)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8f54ef0c/">Golang: string和byte slie字节问题(9)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8a7f81db/">Golang: time计算问题(8)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d4333ec1/">Golang: chan定义问题(7)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aec4de55/">Golang: defer 时机问题(6)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e9bf7e00/">Golang: make和new坑(5)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e0c9893e/">Golang: import和package坑(4)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4ff88030/">Golang: runtime.Gosched 问题(3)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/690caed4/">Golang: HTML Template案例(xml新闻解析+并发改进)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4620296/">Golang: JSON 小案例(读配置文件)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/777e9274/">Golang: JSON 综合案例(天气预报)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/21f718fc/">Golang: RESTful 小案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ad1d8b3/">Golang: 泛型容器的安全问题 (2)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3fde375b/">Golang: 内嵌真的不是继承 (1)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ede42ab6/">Golang: 注意空接口运行时类型 (0)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bd0987da/">Android: 音频框架&驱动解析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6c3c68b0/">Gcc: Gcc优化指南(5. 功成身退-总结)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/466242ae/">Gcc: Gcc优化指南(4. Gcc & G++ & 相关工具)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/425935e0/">Gcc: Gcc优化指南(3. Gcc Optimize-核心)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5cd24f32/">Gcc: Gcc优化指南(2. Gcc Options)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11ea881a/">Gcc: Gcc优化指南(1. Common Problmes of Path & Libs)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e58a5cc/">量化: 数学和量化研究(0. 总起)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6805cb0/">Gcc: Gcc优化指南(0. Basic Skills)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/78268fe4/">Golang: 标准库解决方案(8.总结-功成身退)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e3c9a06b/">Golang: 标准库解决方案(7.Concurrency)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bb600d10/">Golang: 标准库解决方案(6.REST & JSON API)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2f5310cf/">Golang: 标准库解决方案(5.Web Server & Client)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/40bd3fcc/">Golang: 标准库解决方案(4.Math/Time/Archives/Images)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fedfbade/">Golang: 标准库解决方案(3.处理BuildTools,IO,Error)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/42e1a67a/">Golang: 标准库解决方案(2.处理Strings,Bytes,Runes)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/461f0c5f/">Golang: 标准库解决方案(1.听两位大师讲标准库)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/dbbca7df/">Golang: WebGoGoGo(0.Web编程的方方面面)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/187d6c5a/">Golang: WebGoGoGo(0.概述Web编程)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/94df7563/">Golang: Here We Go(5.孰能生巧-Oreilly大师讲解&再练习)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/53a29a57/">Golang: RobPike谈 并发Vs并行</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9b9dc4cb/">Golang: One Video Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9d17f938/">Golang: 标准库解决方案(0.总起)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e5c13927/">Golang: Think in Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/514585e8/">Golang: Here We Go(4.功成身退-资料&面试题)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4f07614d/">Golang: Here We Go(3.登堂入室-全部语法&大量练习)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/872df2cf/">Golang: Here We Go(2.常用命令&代码结构&语法大纲)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/51cffabe/">Golang: Here We Go(1.安装&&脚本)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d740c2ec/">Golang: Here We Go(0.Google工程师介绍)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/590c21ce/">V-skills 专栏指南</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df51d2c/">技巧: Hexo 置顶问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4111adcd/">技巧: WordPress 迁移&备份技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d61966e4/">略懂: Nginx 折腾</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/12cc604a/">技巧: WordPress upload 最终解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/173f9602/">技术: 深耕 Docker 生态圈(十一){Docker 实践}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5ac3e07f/">技巧: Wordpress 网页(h5) mp4 兼容问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/65a942dd/">技术: 深耕 Docker 生态圈(十一){Docker 三剑客}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a30c0f5f/">技术: 深耕 Docker 生态圈(十){私有仓库配置}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c73a742c/">技术: 深耕 Docker 生态圈(九){Docker 数据管理}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/19c3a85f/">技术: 深耕 Docker 生态圈(八){Docker 网络部分}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b3512db9/">技术: 深耕 Docker 生态圈(七){Docker 的底层实现}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cd70a238/">技术: 深耕 Docker 生态圈(六){Dockerfile 文法}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/36bc3b47/">技术: 深耕 Docker 生态圈(五){自己构建的镜像为何这么大}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cb3fb6f1/">技术: 深耕 Docker 生态圈(四){镜像存储在哪}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e0391b88/">技术: 深耕 Docker 生态圈(三){Docker 指令}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8abfca36/">技术: 深耕 Docker 生态圈(二){配置 Docker }</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70ca69ad/">技术: 深耕 Docker 生态圈(一){总起:安装环境}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9724f8c0/">传送门(Gate)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/683530b4/">略懂: Docker 镜像与容器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ab11b0d1/">略懂: 软件架构模式</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e1b58964/">技术: Sqlite 主键自增(Python接口)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/121fc86a/">技巧: 迁移博客到 VPS (借助hook)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/337aa775/">略懂: 我所认识的 Nodejs</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f8bb990d/">技巧: iOS 原生客户端配置 Gmail</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ecd9f8c2/">略懂: 前端相关的缓存技术</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9b49ffe2/">Golang: 深入探究 Golang 并发</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5009ef69/">技巧: macOS 录屏保存为 gif 格式</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/85a160b/">技巧: Numbers(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d3fb236/">Golang: Golang 代码走廊</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/16ca5b11/">技巧: Git 多账户工作技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7fcc01c2/">技巧: macOs下Qt的Mysql驱动处理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e1b7f878/">技术: Qt 汇总篇</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/15783ed7/">技巧：Makefile相关</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ad67147c/">技巧: HEXO优雅操作</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aa213556/">技巧: macOS中替换rm命令</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ef21388e/">技术: 股票分析客户端分析与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/38fb8eb9/">技术: 网络编程部分汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a7d41a1/">技术: C++最终篇</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ba598705/">技术: Emacs环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3549e702/">技术: Deepin Linux环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1345f1a4/">技术: 网络吞吐量测试</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/65b929a8/">技术: 浅谈我经历的敏捷</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8804d39c/">技术: 网络开发常用工具</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6acc3344/">技术: Thrift</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8276c32/">技术: rapid-json</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17d1767e/">技术: Rapid Xml</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7d13442/">技术: Protocol buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/140bfd50/">技术: Gtest测试框架</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/247b42a4/">技术: 多线程调试问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d48acbe2/">技术: TDD 开发模式实践</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/47fb15b8/">技术: 一个HTTPd的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c62cfa29/">技术: C++网络库(轮子)大杂烩</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9d5b3554/">技术: Asio 异步IO库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e5af6e18/">技术: Boost库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3cd43f14/">技术: Unix Domain Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/87cd3741/">技术: 百万连接问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1d57da8b/">技术: C++ 实现线程池模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6b518c8a/">技术: 服务端网络模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e42d6398/">技术: UDP 模型网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/224e60da/">技术: TCP 模型网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df7a2188/">技术: TCP流解析(粘包和拆包问题)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1334152b/">技术: Epoll 模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8967f437/">技术: Linux 基础套接字模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/81fba862/">技术: Linux网络学习参考</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a4602dea/">技术: Linux网络IO模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cf64f3cd/">技术: Shell代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/33327382/">技术: 开源协议</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be94ecde/">技术: Git 代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1a10be5a/">技术: Python代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cc8315f3/">技术: 高质量Git工作</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3a357315/">技术: Python语言</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/82524a2d/">技术: Qt 网络编程案例汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a46fcd49/">技术: Qt 线程案例汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e3b79a82/">技巧: linux下查看二进制文件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5d0a2cfa/">技术: Qt 实践(汽车销量管理)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/77d8483b/">技巧: Qt 快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/75110831/">技术: JNI</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fdc9b2b9/">技术: C++编程之time问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6ff0a80/">技术: C++11 Lambda 再探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b84fe139/">技术: 对比 Linux 下并发库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/322ce852/">技术: C++11 特性补充</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/189d21c8/">技术: benchmark(lambda 和 bind)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/97d0104d/">技术: C++11 可调用对象function总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d12695b6/">技术: C++11 std::ref 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b43344a7/">技术: C++ 智能指针实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4ead806a/">技术: C++11 Bind 探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9ef88011/">技术: C++ RAII 相关技术总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bb36bf0d/">技术: C++11 Lambda 探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4b19001a/">技术: Linux Bin Utils</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/31dce1ea/">技术: C++ 智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/88802625/">技术: Linux 静态&动态库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ab21303c/">技术: C++11 并发库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bc67b8cb/">技术: 探究一下STL常用算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/640d4b5f/">技术: Linux 编程三大件儿</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/24da8a94/">技术: C++ 迭代器失效问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e53c44b8/">技术: C++ 标准库 STL</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f4144d45/">技术: C++非面向对象部分</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f8283c77/">技术: C++面向对象部分</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be09a73/">技术: 设计模式 C++ 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/956ee661/">技术: mysql-connector-cpp</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b0dbc55e/">技术: 带有移动语义的 C++ 字符串类</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f306f9f9/">技术: C++11 右值相关问题探讨</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e9705375/">技术: C++11 类型萃取</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d93a00e8/">技术: C++11 异常争论</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b7fe58b8/">技术: C++11 模板别名探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/72ae9d55/">技术: C++11 默认函数问题探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a8af70c7/">技术: C++11 auto和decltype总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c8bce253/">技术: Java中正则表达式支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/866a6247/">技术: Python中正则表达式的支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8ebc387/">技术: C++中正则表达式的支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/50c77f46/">技术: C语言中正则表达式的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aea53521/">技术: C++11 tuple 容器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/656a02b/">技术: C++11 hashtable 结构</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4bb5bf03/">技术: C++11 一致性初始化探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6f297fb/">技术: C++11 RangeFor探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70b6b9e7/">技术: C++11 explicit注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/919162f1/">技术: C++11 nullptr探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b744aae/">技术: C++11变长参数模板</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5f4ce2b/">技术: 探究 Linux 线程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1312cbe7/">技术: 探究 Linux 进程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1d2bfb39/">技术: Posix标准一览</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a00e5a90/">隐修者(里程碑)</a></li></ul>




    <script>
        
            yiliaConfig.fancybox = false;
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2018 &nbsp Merlin
            </div>
            <div class="footer-right">
                 blog&nbsp<b>version: </b> &nbsp<a href= "https://github.com/WizardMerlin/Gate#blog版本分支说明" >2.4</a>    <i class="fa fa-heart animated infinite pulse"></i>&nbsp高效流
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110654443-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "Do One Thing......" + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "Do It Well......" + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>