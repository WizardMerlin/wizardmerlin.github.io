<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Merlin" />



<meta name="description" content="学习 Golang 的时候写了 N 个demo，这里是对它们的温习和讲解。(可作为新手的练习指导)">
<meta name="keywords" content="golang,go">
<meta property="og:type" content="article">
<meta property="og:title" content="Golang: Golang 代码走廊">
<meta property="og:url" content="http://www.merlinblog.site/posts/d3fb236/index.html">
<meta property="og:site_name" content="梅林日志">
<meta property="og:description" content="学习 Golang 的时候写了 N 个demo，这里是对它们的温习和讲解。(可作为新手的练习指导)">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang6.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang8.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang7.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang9.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang11.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang10.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-04-golang12.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-04-golang13.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-06-golang14.jpg">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-08-golang15.png">
<meta property="og:updated_time" content="2018-04-12T06:55:17.641Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Golang: Golang 代码走廊">
<meta name="twitter:description" content="学习 Golang 的时候写了 N 个demo，这里是对它们的温习和讲解。(可作为新手的练习指导)">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang6.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="梅林日志" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/red/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>Golang: Golang 代码走廊 | 梅林日志</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/mine.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Merlin</a></h1>
        </hgroup>

        
        <p class="header-subtitle">云卷云舒，平常心态</p>
        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">[归档]</a></li>
                        
                            <li><a href="/works/">小作品</a></li>
                        
                            <li><a href="/tags/">[标签]</a></li>
                        
                            <li><a href="/about/">关于</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/WizardMerlin" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" href="https://www.douban.com/people/170414854/" title="豆瓣"></a>
                            
                                <a class="fa Email" href="mailto:&#119;&#105;&#122;&#97;&#114;&#100;&#109;&#101;&#114;&#108;&#105;&#110;&#57;&#52;&#53;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa QQ" href="tencent://message/?Menu=yes&uin=3076407405" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">极简.</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Merlin</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/mine.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Merlin</a></h1>
            </hgroup>
            
            <p class="header-subtitle">云卷云舒，平常心态</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">[归档]</a></li>
                
                    <li><a href="/works/">小作品</a></li>
                
                    <li><a href="/tags/">[标签]</a></li>
                
                    <li><a href="/about/">关于</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/WizardMerlin" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" target="_blank" href="https://www.douban.com/people/170414854/" title="豆瓣"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:&#119;&#105;&#122;&#97;&#114;&#100;&#109;&#101;&#114;&#108;&#105;&#110;&#57;&#52;&#53;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="tencent://message/?Menu=yes&uin=3076407405" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-golang-init-code" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/d3fb236/" class="article-date">
      <time datetime="2018-02-08T09:29:15.000Z" itemprop="datePublished">2018-02-08</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Golang: Golang 代码走廊
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/GoGolang专栏/">GoGolang专栏</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/go/">go</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/golang/">golang</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>学习 Golang 的时候写了 N 个demo，这里是对它们的温习和讲解。(可作为新手的练习指导)<br><a id="more"></a></p>
<p>这里其实是单独把 Go1.9 语言学习中写过的例子，全部搬到这里，当然是按逻辑整理的。</p>
<p>参考: <code>Go 圣经</code>, <code>go-by-examples</code> 等等。 后续有一篇<strong>代码荟萃</strong>摘取一些常见场景的代码精粹。</p>
<blockquote>
<p>已经完全分类完毕, 几乎涵盖 Go 的方方面面。（注意1.9版本有些内容和之前版本的Go是不同的）</p>
</blockquote>
<p><strong>关于练习</strong>:</p>
<blockquote>
<p>这里要求只有一个，把别人的代码看1-2遍，然后自己写，在不回头看。</p>
<blockquote>
<p>一旦中途回头看了，刚刚写过的全部删除，重头开始。(毕竟都是小例子)</p>
</blockquote>
</blockquote>
<p><strong>本文既是练习，也是知识点讲解</strong>，主要围绕下面的关键字:</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang6.jpg" alt="内置关键字"></p>
<blockquote>
<p>建议: 步步为营，一个知识点没有非常熟悉的时候，不要进到下一个知识点。(特别是 struct, method, interface这类有牵扯的内容)</p>
</blockquote>
<h2 id="Main函数"><a href="#Main函数" class="headerlink" title="Main函数"></a>Main函数</h2><ul>
<li>main函数既没有参数，也没有返回值 (命令行参数，另外有方法)</li>
<li>package名为 main 的才可以包含 main函数</li>
<li>一个可执行程序，必须要有一个 main 包</li>
<li>一般使用驼峰命令</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量定义(常量注释格式不对)</span></span><br><span class="line"><span class="keyword">const</span> PI = <span class="number">3.14</span></span><br><span class="line"><span class="comment">//类型声明</span></span><br><span class="line"><span class="keyword">type</span> type_name <span class="keyword">int</span></span><br><span class="line"><span class="comment">//结构声明</span></span><br><span class="line"><span class="keyword">type</span> struct_name <span class="keyword">struct</span>&#123;</span><br><span class="line">    <span class="comment">//定义成员</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口声明</span></span><br><span class="line"><span class="keyword">type</span> interface_name <span class="keyword">interface</span>&#123;</span><br><span class="line">    <span class="comment">//ur code here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(<span class="string">"你好世界, hello 中国"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="import别名"><a href="#import别名" class="headerlink" title="import别名"></a>import别名</h2><ul>
<li>import 的时候，可以使用别名 <code>import alias_name real_name</code>, 或者使用<code>.</code>代替(不建议, 容易混淆)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> std <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    std.Println(<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="可见性规则"><a href="#可见性规则" class="headerlink" title="可见性规则"></a>可见性规则</h2><blockquote>
<p>外部是否可见，是否能够调用，采用大小写约定</p>
</blockquote>
<ul>
<li>函数首字母小写即不可以被外部调用，大写意味着可以被外部调用(exported).</li>
<li>变量，常量，类型，接口，结构规则类似，首字母小写的话，外部不可见.</li>
<li>可见性是相对于包而言的，同一个包内，无隐私.</li>
</ul>
<p>所以看到，<strong>fmt的好多方法一定是首字母大写的</strong>。</p>
<h2 id="组定义"><a href="#组定义" class="headerlink" title="组定义"></a>组定义</h2><p>多个常量，变量，类型等，可以放在一个组里面，一次性定义。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PI     = <span class="number">3.14</span></span><br><span class="line">    const1 = <span class="string">"1"</span></span><br><span class="line">    const2 = <span class="number">2</span></span><br><span class="line">    const3 = <span class="number">3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//全局变量</span></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    name  = <span class="string">"bob"</span></span><br><span class="line">    name1 = <span class="string">"xp"</span></span><br><span class="line">    name2 = <span class="string">"xpbob"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>上面这些貌似，可以根据赋值自动推到出类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span>  <span class="comment">// var num int = 0</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span> <span class="comment">// var num int = 10</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>var组</code> 只能用于声明全局变量(函数体内则不能用这种方法)</li>
</ul>
<p>语法上就是: (<code>记着 var 开头就对了</code>)<br><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang8.jpg" alt=" "></p>
<p>一般类型也可以按组来定义:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> (</span><br><span class="line">    newType <span class="keyword">int</span></span><br><span class="line">    type1 <span class="keyword">float32</span></span><br><span class="line">    type2 <span class="keyword">string</span></span><br><span class="line">    type3 <span class="keyword">byte</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>之后就可以拿这些类型去定义变量了，例如<code>var aa newType</code>，一般用于单位转换。</p>
<p><strong>定义变量，var 关键字也可以省略</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num <span class="keyword">int</span> =<span class="number">10</span></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line">num := <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>第二种形式，省略掉了 var 关键字，并且类型也要由系统自动推断。</p>
<ul>
<li>一般而言，如果声明和使用都是一致的，那么就可以交给系统去推断<ul>
<li>并且，系统鼓励你省略类型</li>
</ul>
</li>
<li>声明时就赋值，那么直接采用最简写法即可</li>
<li>全部变量不能省略 var 关键字!</li>
</ul>
<p><strong>局部变量</strong>虽然不能用 <code>var()</code>, 但是可以并排写:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b, c, d <span class="keyword">int</span></span><br><span class="line">a, b, c, d = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//或者声明同时赋值</span></span><br><span class="line"><span class="keyword">var</span> a, b, c, d <span class="keyword">int</span> = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="comment">//等价于(省略类型的情况)</span></span><br><span class="line"><span class="keyword">var</span> a, b, c, d     = <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br><span class="line"><span class="comment">//等价于(省略 var )</span></span><br><span class="line">    a, b, c, d := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>对局部变量来说 : 是用来代替 var 的，但是全局变量不能有此特权</p>
<blockquote>
<p>:= 一般用于函数有多个返回值的时候，直接定义的同时接收数据</p>
</blockquote>
</blockquote>
<h2 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h2><p><strong>简单介绍整型</strong>:<br><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang7.jpg" alt=" "></p>
<blockquote>
<p>别名 byte, rune更多的在是在强调其作用情景。</p>
</blockquote>
<ul>
<li>当你用 byte 的时候，可能是用来处理字节相关的内容</li>
<li>当你用 rune 的时候，可能是用来处理 unicode 相关的字符</li>
</ul>
<p><strong>浮点型</strong>:</p>
<ul>
<li>float32/float64, 分别是4字节和8字节，精确到小数点后7/15位</li>
<li>double? 不存在的</li>
</ul>
<p><strong>复数类型</strong>:</p>
<ul>
<li>complex64/complex128, 分别占8/16字节</li>
</ul>
<p>math包可以检查数据的取值范围, 例如 <code>math.MinInt8</code> 打印出来 -128。</p>
<h2 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h2><ul>
<li>引用类型 : slice(可以认为切片是数组的封装), map, chan(协程通道)</li>
<li>接口类型 : interface</li>
<li>函数类型 : func (因为，函数可以赋值给变量)</li>
<li>其他    : array(可变数组类型), struct(结构类型), string(字符串类型)</li>
</ul>
<blockquote>
<p>map 可以简单的认为是一个 Hash 表， 但是其实现与其他语言有所不同；使用起来也有所不同。</p>
</blockquote>
<h2 id="零值"><a href="#零值" class="headerlink" title="零值"></a>零值</h2><p>零值并不等于空值，而是当变量被声明为某种类型后的<strong>默认值</strong>，通常情况下值类型的默认值为0，bool为false，string为空字符串.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//验证一下各种类型的零值</span></span><br><span class="line">    <span class="keyword">var</span> cnt <span class="keyword">int</span></span><br><span class="line">    fmt.Println(cnt) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> bb []<span class="keyword">byte</span></span><br><span class="line">    fmt.Println(bb) <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> intArr [<span class="number">3</span>]<span class="keyword">int</span>  <span class="comment">//不指定大小就是 slice</span></span><br><span class="line">    fmt.Println(intArr) <span class="comment">//[0,0,0]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> flag <span class="keyword">bool</span></span><br><span class="line">    fmt.Println(flag) <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>Go语言没有隐式转换，只有强制类型转换。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line">    b = <span class="number">1</span> <span class="comment">//ok</span></span><br><span class="line">    b = <span class="number">1.1</span> <span class="comment">//编译报错: constant 1.1 truncated to integer</span></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>所有类型间的转换，必须是显示的转换，并且发生在兼容的类型之间。</p>
<blockquote>
<p><code>&lt;value A&gt; [:]= &lt;type B&gt;(&lt;value B&gt;)</code></p>
</blockquote>
<p>举个例子: (int 和 rune转换)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a <span class="keyword">rune</span> = <span class="number">10</span></span><br><span class="line">    <span class="keyword">var</span> b <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//b = a //编译报错 : cannot use a (type rune) as type int in assignment</span></span><br><span class="line">    b = <span class="keyword">int</span>(a) <span class="comment">//强制类型转换</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>非bool 和 bool 之间不兼容！(数字和逻辑之间不兼容)</p>
</blockquote>
<p><strong>string 和 其他类型呢</strong>?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    a := <span class="number">65</span></span><br><span class="line">    str := <span class="keyword">string</span>(a)</span><br><span class="line"></span><br><span class="line">    fmt.Println(str)<span class="comment">//打印字符A, 而不是65</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可能它默认你需要的是这个数字表示的字符，其他类型和 string 转换借助 <code>strconv</code> 包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"strconv"</span></span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">65</span></span><br><span class="line">    str := strconv.Itoa(a)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//a = strconv.Atoi(b)</span></span><br><span class="line">    fmt.Println(str) <span class="comment">//65</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空白符号"><a href="#空白符号" class="headerlink" title="空白符号"></a>空白符号</h2><blockquote>
<p>一个下划线 <code>_</code> 用来赋值忽略</p>
</blockquote>
<p>例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    a, _, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    fmt.Println(a) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(c) <span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这么直白的看上去，似乎有点儿傻；但是一般用于<code>函数多返回值</code>的情景。</p>
<h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><blockquote>
<p>首先说一下，下面要讲解的常量&amp;枚举，<strong>应该使用大写</strong>！</p>
<blockquote>
<p>这里使用小写主要为了演示用。(同时，使用小写字母开头或者下划线开头，禁止其他包访问)</p>
</blockquote>
</blockquote>
<p>常量的值，在编译时就已经确定了。</p>
<ul>
<li>定义格式和变量类似，除了 const 关键字，能省略的都可以省略</li>
<li>可以使用 <code>const()</code> 组语法定义一组常量<ul>
<li>如果不指定的话，则输出默认赋值和上一行一样 (看下面的例子)，而不是零值</li>
<li>组内第一个常量的定义，表达式不能省略，必须初始化</li>
<li>给定了类型就要给出表达式(expression)不能用零值</li>
</ul>
</li>
<li>可以并排定义常量, 即仅用一个 const ，然后按顺序初始化</li>
<li>右侧必须是内置函数(编译时就能确定值)</li>
</ul>
<p>demo 如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量</span></span><br><span class="line"><span class="keyword">const</span> defalt_salary <span class="keyword">int</span> = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认常量</span></span><br><span class="line"><span class="keyword">const</span> default_age = <span class="number">20</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常量组</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    name = <span class="string">"bob"</span></span><br><span class="line">    age = <span class="number">22</span></span><br><span class="line">    salary = defalt_salary</span><br><span class="line">    married  <span class="comment">//如果不指定，则是上一行的表达式</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//多赋值</span></span><br><span class="line"><span class="keyword">const</span> a, b = <span class="number">1</span>, <span class="number">1.1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//套用上一行 + 多赋值</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    c, d = <span class="number">2</span>, <span class="string">"2,2"</span></span><br><span class="line">    e, f</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(married) <span class="comment">//输出 10000</span></span><br><span class="line">    fmt.Println(a) <span class="comment">// 1</span></span><br><span class="line">    fmt.Println(b) <span class="comment">// 1.1</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(e) <span class="comment">//2</span></span><br><span class="line">    fmt.Println(f) <span class="comment">//2.2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>常量一定要加 const 修饰</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">"xxxx"</span> <span class="comment">//把常量赋值给变量str</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//length := len(str) //ok</span></span><br><span class="line">    <span class="keyword">const</span> length = <span class="built_in">len</span>(str) <span class="comment">//编译报错 : const initializer len(str) is not a constant</span></span><br><span class="line">    fmt.Println(length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 <code>len(str)</code> 在编译时确定不了值。(实际上是因为 str 是变量，运行时才能确定内容)</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举借助 const(), 但是要借助<code>iota</code>常量计数器。</p>
<p>上面说了，const()中如果不赋值，那么就和上一行保持一样的赋值行为;<br>但是当你赋值为 iota 时，下面开始自动赋值， 核心规则如下:</p>
<ul>
<li>iota 从零开始计数 (记录组里的常量, 从组里第一个从常量开始记录)</li>
<li>同一组中每增加一个常量 iota 计数器加1 (反正它就在组里默默增加，而不是你每使用一次iota才增加计数)</li>
<li>遇到 const 关键字，计数器回复为0 (即开始定义下一个组的常量了)</li>
</ul>
<p>代码如下:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    a = <span class="string">"A"</span></span><br><span class="line">    b</span><br><span class="line">    c = <span class="literal">iota</span> <span class="comment">//c值为2,即取得计数器</span></span><br><span class="line">    d        <span class="comment">//d值为3</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line"></span><br><span class="line">    fmt.Println(a) <span class="comment">//A</span></span><br><span class="line">    fmt.Println(b) <span class="comment">//A</span></span><br><span class="line">    fmt.Println(c) <span class="comment">//2</span></span><br><span class="line">    fmt.Println(d) <span class="comment">//3</span></span><br><span class="line"></span><br><span class="line">    num := <span class="literal">iota</span> <span class="comment">//编译报错: undefined: iota</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>单独使用 <code>iota</code>, 编译报错；一定要用在 const() 组里</p>
</blockquote>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang9.jpg" alt="运算符"></p>
<p><code>^</code> 比较特殊，要看一下运算符左右有几个变量。</p>
<p>演示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    fmt.Println(!<span class="literal">true</span>) <span class="comment">//false</span></span><br><span class="line">    <span class="comment">//fmt.Println(!1) //编译报错: ! untyped number</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//^当一元运算符</span></span><br><span class="line">    fmt.Print(<span class="string">"^一元运算: "</span>)</span><br><span class="line">    fmt.Println(^<span class="number">1</span>) <span class="comment">//-2 结果比较奇怪, 用的比较少</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 位运算符 */</span></span><br><span class="line">    <span class="comment">//与运算符</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>&amp;<span class="number">0</span>) <span class="comment">//0</span></span><br><span class="line">    <span class="comment">//或运算</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>|<span class="number">0</span>) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//亦或</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>^<span class="number">0</span>) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(<span class="number">0</span>^<span class="number">1</span>) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>^<span class="number">1</span>) <span class="comment">//0</span></span><br><span class="line">    fmt.Println(<span class="number">0</span>^<span class="number">0</span>) <span class="comment">//0</span></span><br><span class="line">    <span class="comment">//fmt.Println(false^false); //编译报错:^ not defined on bool</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"-----special-----"</span>)</span><br><span class="line">    <span class="comment">//&amp;^ </span></span><br><span class="line">    <span class="comment">//主要看第二个操作数:</span></span><br><span class="line">    <span class="comment">//如果第二个操作数是0，那么结果和第一个操作数的位相同；</span></span><br><span class="line">    <span class="comment">//第二个操作数的位是1，那么结果一定是0</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>&amp;^<span class="number">0</span>) <span class="comment">//1</span></span><br><span class="line">    fmt.Println(<span class="number">0</span>&amp;^<span class="number">1</span>) <span class="comment">//0</span></span><br><span class="line">    fmt.Println(<span class="number">0</span>&amp;^<span class="number">0</span>) <span class="comment">//0</span></span><br><span class="line">    fmt.Println(<span class="number">0</span>&amp;^<span class="number">1</span>) <span class="comment">//0</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>&amp;^<span class="number">1</span>) <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"-----special-----"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//乘除，取余-略</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;&lt; 和 &gt;&gt;</span></span><br><span class="line">    fmt.Println(<span class="number">1</span>&lt;&lt;<span class="number">10</span>) <span class="comment">// 1024</span></span><br><span class="line">    fmt.Println(<span class="number">8</span>&gt;&gt;<span class="number">3</span>) <span class="comment">//1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑运算符 (带短路)</span></span><br><span class="line">    fmt.Println(<span class="literal">false</span> &amp;&amp; <span class="literal">true</span>)  <span class="comment">//false</span></span><br><span class="line">    fmt.Println(<span class="literal">true</span> &amp;&amp; <span class="literal">false</span>)  <span class="comment">//false</span></span><br><span class="line">    fmt.Println(<span class="literal">false</span> || <span class="literal">true</span>)  <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关于位移运算，这里有一个经典的应用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    _ = <span class="literal">iota</span></span><br><span class="line">    KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span> * <span class="literal">iota</span>) <span class="comment">//1024</span></span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">    EB</span><br><span class="line">    ZB</span><br><span class="line">    YB</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>或者下面的定义方式:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    B = <span class="number">1</span> &lt;&lt; (<span class="literal">iota</span> * <span class="number">10</span>)</span><br><span class="line">    KB</span><br><span class="line">    MB</span><br><span class="line">    GB</span><br><span class="line">    TB</span><br><span class="line">    PB</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    fmt.Println(B)</span><br><span class="line">    fmt.Println(KB)</span><br><span class="line">    fmt.Println(MB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递增递减"><a href="#递增递减" class="headerlink" title="递增递减"></a>递增递减</h2><blockquote>
<p>++ 和 – 作为语句而不是作为表达式</p>
</blockquote>
<ul>
<li>不能放在等号左边儿并且需要单独的一行；而表达式则可以放在等号右边</li>
<li>只能放在变量的右边，而不能在左边 (作为一个语句)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="comment">//b := a++ //编译报错: syntax error: unexpected ++ at end of statement</span></span><br><span class="line">    <span class="comment">//b := ++a //编译报错: syntax error:unexpected ++, expecting expression</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//++a //报错: unexpected ++, expecting &#125;, 不能放在变量的左边</span></span><br><span class="line">    a++ <span class="comment">//只能放在变量的右边</span></span><br><span class="line">    b := a</span><br><span class="line"></span><br><span class="line">    fmt.Println(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><p>这里指针运算比较滑稽，不支持 <code>-&gt;</code> 运算，而是统一采用 <code>.</code> 运算来操作。</p>
<p>基本用法还是类似:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//var a int = 1</span></span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="comment">//var b *int = &amp;a</span></span><br><span class="line">    b := &amp;a</span><br><span class="line"></span><br><span class="line">    fmt.Println(b); <span class="comment">//打印地址</span></span><br><span class="line">    fmt.Println(*b); <span class="comment">//打印值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认值是 nil, 而不是 NULL</span></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span></span><br><span class="line">    fmt.Println(p) <span class="comment">//&lt;nil&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有没有指针运算</strong>？</p>
<p>貌似也没有。</p>
<h2 id="if条件控制语句"><a href="#if条件控制语句" class="headerlink" title="if条件控制语句"></a>if条件控制语句</h2><p><strong>最大的区别</strong>:</p>
<ul>
<li>连括号都懒得写了; if 后面写一个空格再写 condition</li>
<li>condition 之前，支持一个初始化表达式(用分号阻隔)</li>
</ul>
<p>下面写一个例子:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//不带括号</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a 可以继续参加运算."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//支持一个初始化表达式, 注意是分号</span></span><br><span class="line">    <span class="keyword">if</span> b:=<span class="number">1</span>; a == b &#123;</span><br><span class="line">        fmt.Println(<span class="string">"a 和 b 相等."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//b是局部变量，出了上述作用于范围就嗝屁了</span></span><br><span class="line">    <span class="comment">//fmt.Println(b); //编译报错: undefined: b</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，局部变量还是会隐藏范围更大的变量。</p>
<h2 id="switch条件控制语句"><a href="#switch条件控制语句" class="headerlink" title="switch条件控制语句"></a>switch条件控制语句</h2><p><strong>switch 语句被增强了</strong>: (带有条件判断)</p>
<ul>
<li>switch 支持一个初始化表达式(可以是并行方式，即同时按顺序初始化多个，最右侧要写分号)</li>
<li>switch 后面可以不写值</li>
<li>case 可以是单一值，多值或者 condition条件</li>
<li>不用写 break 语句，执行完一个 case 会自动跳出去(跳出整个 switch)</li>
<li>如果想接着执行，那么要写 fallgroup</li>
</ul>
<p>大致就这三种形式:</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang11.jpg" alt="switch"></p>
<p>相关 demo 看下来</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    i := <span class="number">5</span></span><br><span class="line">    <span class="keyword">switch</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>&lt;=i &amp;&amp; i&lt;=<span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">"0-5"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>&lt;=i &amp;&amp; i&lt;=<span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">"6-10"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> i&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>:</span><br><span class="line">        fmt.Println(<span class="string">"0-5"</span>)</span><br><span class="line">    <span class="keyword">case</span> <span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>:</span><br><span class="line">        fmt.Println(<span class="string">"6-10"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> j <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> j, i=<span class="number">1</span>, <span class="number">1</span>; &#123;</span><br><span class="line">    <span class="keyword">case</span> i==j :</span><br><span class="line">        fmt.Println(<span class="string">"j==b"</span>);</span><br><span class="line">        <span class="keyword">fallthrough</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        fmt.Println(<span class="string">"fallthrough 继续执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>switch 中初始化的变量，同样是局部变量</p>
</blockquote>
<p>上面没有写经典的 switch。</p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><p>Go语言中只保留了一种循环, for 循环，但是却有3种形式, 非常强大。</p>
<blockquote>
<p>其实就是把 while 循环合并到 for 循环里面了</p>
</blockquote>
<ul>
<li>完全不带有条件的 (无限循环，在for内部满足条件break出去)</li>
<li>带有条件的 for (单个条件的就相当于 while 循环)</li>
<li>普通的for (3部分齐全)</li>
</ul>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-03-golang10.jpg" alt="for循环"></p>
<p><strong>1.无限循环，在for内部满足条件break出去</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    b := <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="number">2</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"b==2, 第一次循环"</span>);</span><br><span class="line">            b--</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> b ==<span class="number">1</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"b==1, 直接 continue 吧"</span>);</span><br><span class="line">            b--</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"b==0, 顺序执行下去算了"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> b==<span class="number">0</span> &#123;</span><br><span class="line">            fmt.Println(<span class="string">"已经执行到最后流程了，出去吧"</span>)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">//for</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，这种 for 就是: <code>for true {}</code>。</p>
<p><strong>长得像while的for循环</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//带有单个条件的 for 循环</span></span><br><span class="line"></span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> a &gt; <span class="number">0</span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"循环中..."</span>);</span><br><span class="line">        a--</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"循环结束了..."</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>完整的for循环</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sum <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">for</span> i :=<span class="number">1</span> ; i &lt;= <span class="number">100</span>; i++ &#123;</span><br><span class="line">        sum += i</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sum) <span class="comment">//5050</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结下来，非常灵活；需不需要条件，完全自己看着办。</p>
<p>还有一个 for each, 即 range for, 用于遍历 slice、map、数组、字符串等。</p>
<p>例如: 遍历数组</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//简单演示一下 range for</span></span><br><span class="line"></span><br><span class="line">    arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用 range 关键字，后面跟着容器的名字</span></span><br><span class="line">    <span class="comment">//可以把 range 当做一个多返回值的函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    for key, value := range oldMap &#123;</span></span><br><span class="line"><span class="comment">        newMap[key] = value</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line">    <span class="keyword">for</span> index,value := <span class="keyword">range</span> arr &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"index=%d, value=%d\n"</span>, index, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="跳转语句"><a href="#跳转语句" class="headerlink" title="跳转语句"></a>跳转语句</h2><blockquote>
<p>老三样: goto, break, continue</p>
</blockquote>
<ul>
<li>都可以配合标签 (跳出内层循环，可以连跳基层；但一定配合循环)</li>
<li>标签名区分带小写(严格匹配)</li>
<li>goto是调整执行位置，不一定非要用在循环中；但也要配置标签。</li>
</ul>
<p>但是 break, continue 还是原来的意思。</p>
<p>例子: 外层是死循环的，只跳出一层循环肯定不行.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">LABEL1:</span><br><span class="line">    <span class="keyword">for</span> &#123; <span class="comment">//外层是个死循环</span></span><br><span class="line">        <span class="keyword">for</span> i:=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">            <span class="keyword">if</span> i==<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">break</span> LABEL1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"跳出了与 LABEL 同级的循环"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>contine 的例子也是调到外层 label 同级的循环，但是会进行下一次的外层循环。<br><strong>contine外部循环应该是个有限循环</strong>.</p>
<blockquote>
<p>Label 标签一定要紧接 for 语句</p>
</blockquote>
<p>goto 语句比较难用，要慎用。(<strong>如果一定要用，那么请把goto的label放到goto后面，避免造成死循环</strong>)</p>
<p><em>个人建议,用最简单的break和continue吧</em>.</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>其实用的更多的应该是 slice .</p>
</blockquote>
<p>格式： <code>var &lt;varName&gt; [n]&lt;type&gt;</code>，其中 n &gt; 0。</p>
<p>数组必须在定义的时候指定长度，否则不称之为数组:</p>
<ul>
<li>数组长度也是类型的一部分，因此具有不同长度的数组为不同类型<ul>
<li>不同长度的数组其实不同类型，不能直接赋值(还是要遍历赋值)</li>
</ul>
</li>
<li>数组在Go中为值类型 (也就是说，基本都是值拷贝，不能改变原来的内容)</li>
<li>数组之间可以使用==或!=进行比较(系统已经实现这种运算)，但不可以使用&lt;或&gt;</li>
<li>可以使用new来创建数组，此方法返回一个指向数组的指针</li>
<li>Go支持多维数组</li>
<li>长度不知道，可以用 `…``代替，但是还是要指定(不指定长度就是 slice)</li>
</ul>
<p>简单的使用:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a [<span class="number">2</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">//var b [1]int //长度不同，不能相互赋值</span></span><br><span class="line">    <span class="keyword">var</span> b [<span class="number">2</span>]<span class="keyword">int</span> <span class="comment">//长度相同则可以</span></span><br><span class="line"></span><br><span class="line">    a = b <span class="comment">//长度不同，编译报错: cannot use b (type [1]int) as type [2]int in assignment</span></span><br><span class="line">    fmt.Println(a);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果不默认赋值，那么系统自动补零值</span></span><br><span class="line">    <span class="comment">//var aa int[3]</span></span><br><span class="line">    aa := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;</span><br><span class="line">    fmt.Println(aa)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//也可以按照索引指定(索引后面跟着冒号)</span></span><br><span class="line">    bb := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">3</span>:<span class="number">1</span>&#125; <span class="comment">//第4个元素为1，其他为0</span></span><br><span class="line">    fmt.Println(bb)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逐个指定</span></span><br><span class="line">    cc := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>:<span class="number">2</span>, <span class="number">2</span>:<span class="number">3</span>&#125;</span><br><span class="line">    fmt.Println(cc)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//...指定长度 (根据后面初始化的元素，确定长度)</span></span><br><span class="line">    <span class="comment">// 如果指定索引，那么也会根据索引来推断长度</span></span><br><span class="line">    words := [...]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br><span class="line">    <span class="keyword">for</span> _, word := <span class="keyword">range</span> words &#123;</span><br><span class="line">        fmt.Println(word)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>指针数组和数组指针问题。</p>
<p><strong>数组指针</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 数组指针 */</span></span><br><span class="line">    a := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>:<span class="number">1</span>, <span class="number">3</span>:<span class="number">1</span>&#125;</span><br><span class="line">    <span class="comment">//声明一个数组指针(写完数组类型，前面补一个 *号即可)</span></span><br><span class="line">    <span class="keyword">var</span> p *[<span class="number">10</span>]<span class="keyword">int</span></span><br><span class="line">    <span class="comment">//p = a //编译报错:cannot use a (type [10]int) as type *[10]int in assignment</span></span><br><span class="line">    p = &amp;a <span class="comment">//数组是值类型, 应该用取地址符号</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(p)</span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>指针数组</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* 指针数组：数组的元素都是地址 */</span></span><br><span class="line"></span><br><span class="line">    x, y := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">    <span class="comment">//先写好数组，然后把数组的元素类型改为 *int</span></span><br><span class="line">    array := [<span class="number">2</span>]*<span class="keyword">int</span> &#123;&amp;x, &amp;y&#125;</span><br><span class="line">    fmt.Println(array); <span class="comment">//这样遍历只能拿到地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _,value := <span class="keyword">range</span> array &#123;</span><br><span class="line">        fmt.Println(*value)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>数组是值类型，而不是引用类型，所以传递参数的时候，其实是进行拷贝的(而不是地址)</p>
</blockquote>
<p>如果要降低拷贝代价，请使用 slice 。</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-04-golang12.jpg" alt="数组是值类型"></p>
<p><strong>数组的比较也要求类型相同</strong>:(长度也作为数组类型的一部分)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    b := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br><span class="line">    c := [<span class="number">2</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    d := [<span class="number">1</span>]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(a==b) <span class="comment">//true</span></span><br><span class="line">    fmt.Println(a==c) <span class="comment">//false</span></span><br><span class="line">    <span class="comment">//fmt.Println(a==d) //不同类型的比较，编译报错</span></span><br><span class="line">    <span class="comment">//invalid operation: a == d (mismatched types [2]int and [1]int)</span></span><br><span class="line"></span><br><span class="line">    aa := [...]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">    bb := [...]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>&#125;</span><br><span class="line">    cc := [...]<span class="keyword">string</span>&#123;<span class="string">"hello"</span>, <span class="string">"world"</span>&#125;</span><br><span class="line"></span><br><span class="line">    fmt.Println(aa==bb) <span class="comment">//true</span></span><br><span class="line">    <span class="comment">//fmt.Println(aa==cc) //不同类型的比较，编译报错</span></span><br><span class="line">    <span class="comment">//invalid operation: aa == cc (mismatched types [1]string and [2]string)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通过下标操作数组</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr1 := [<span class="number">3</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    arr1[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(arr1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>多维数组</strong>:</p>
<p>多维数组一样可以使用下标运算, 索引指定等。<br>只有第一维可以用 … 指定长度(自动计算)，最好自己指定。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [...][<span class="number">3</span>]<span class="keyword">int</span> &#123;</span><br><span class="line">        &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">        &#123;<span class="number">1</span>&#125;&#125;</span><br><span class="line">    <span class="comment">//&#125;//编译报错</span></span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意最后一个<code>}</code> 必须在最后一个元素的同一行，否则编译报错</p>
</blockquote>
<p>其他关于数组的练习，可以写一个简单点写一个冒泡排序:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := [<span class="number">5</span>]<span class="keyword">int</span>&#123;<span class="number">2</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">5</span>&#125;</span><br><span class="line">    fmt.Println(arr)  <span class="comment">//排序之前</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//降序排序吧</span></span><br><span class="line">    leng := <span class="built_in">len</span>(arr)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; leng; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; leng; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> arr[i] &lt; arr[j] &#123;</span><br><span class="line">                <span class="comment">//交换 保证 当前的 arr[j]是最小</span></span><br><span class="line">                tmp := arr[i]</span><br><span class="line">                arr[i] = arr[j]</span><br><span class="line">                arr[j] = tmp</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">//inner for</span></span><br><span class="line">    &#125; <span class="comment">//outer for</span></span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h2><p>可以通过 new 关键字拿到相关类型的地址。</p>
<p>比如:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    p := <span class="built_in">new</span>([<span class="number">3</span>]<span class="keyword">int</span>)</span><br><span class="line">    fmt.Println(*p)</span><br><span class="line"></span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">4</span></span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="slice切片"><a href="#slice切片" class="headerlink" title="slice切片"></a>slice切片</h2><p>这是一个相对而言比较新的内容，其实也还好。</p>
<ul>
<li>变长数组的替代方案，可以指向数组的局部或者全部</li>
<li>可以用于指向一个已经存在的数组或者直接声明一个slice</li>
<li>形式上和数组不指定长度一样</li>
</ul>
<p>不太正式的使用方法，<strong>一般使用方法</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> sla []<span class="keyword">int</span> <span class="comment">//不指定长度即是 slice</span></span><br><span class="line">    fmt.Println(sla)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已经存在一个数组了, 用slice截取后面的元素</span></span><br><span class="line">    arr := [<span class="number">10</span>]<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;</span><br><span class="line">    fmt.Println(arr)</span><br><span class="line">    <span class="comment">//sli := arr[1] //取一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//sli := arr[5:10] //含头不含尾 index 5-9, index 10 不包含</span></span><br><span class="line">    <span class="comment">//等价于//sli := arr[5:len(arr)]</span></span><br><span class="line">    sli := arr[<span class="number">5</span>:] <span class="comment">//也是取 index 5-9, 直接取到末尾</span></span><br><span class="line">    fmt.Println(sli)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>取前5个元素的话 <code>arr[:5]</code>。</p>
<p><strong>正式使用</strong>方法:</p>
<blockquote>
<p><code>make([]T, len, cap)</code></p>
</blockquote>
<p>一般不使用new, 其中 len() 可以获取 len, cap()可以获取cap容量。<br><em>这里容量都是直接翻倍的，仅当不够用的时候</em>.</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//使用 make 方法</span></span><br><span class="line">    slice := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">10</span>, <span class="number">15</span>) <span class="comment">//指定长度为10，容量为15</span></span><br><span class="line">    fmt.Println(slice) <span class="comment">//打印整个 slice</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(slice), <span class="built_in">cap</span>(slice)) <span class="comment">//10, 15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以不指定容量(系统自动重分配)</li>
</ul>
<p><strong>Rslice</strong>: 简单说，就是截取现有的 slice，从一个 slice 中获得一个新的 slice。</p>
<ul>
<li>每一次取 slice 索引就又重新规划一次 (从0开始)。</li>
<li>新的 slice 可能长度有限，但是容量是截取的开始到原来 slice 的末尾(底层还是那个数组)</li>
<li>新的 slice 的最大索引不能超过原 slice 的 cap (如果按索引取值越界，会引发错误；但不会导致底层数组重新分配)</li>
<li>由于都共享底层数组，那么一个slice的改变可能会引起另外一个slice值改变</li>
</ul>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-04-golang13.jpg" alt="slice2array"></p>
<p>这里 cap 总归是 11， 但是 slice_a 从第三个开始取，所以它的最大容量就是 9。<br>并且，如果slice_b要从slice_a中开始取，那么索引应该从0重新排号。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    oldSlice := []<span class="keyword">byte</span>&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>,<span class="string">'e'</span>&#125; <span class="comment">//5个元素</span></span><br><span class="line">    sliceA := oldSlice[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">//取a, b ,c</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(sliceA))</span><br><span class="line">    sliceB := oldSlice[<span class="number">3</span>:<span class="number">5</span>] <span class="comment">//取 d,e</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(sliceB))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//sliceC 是在 sliceB 的基础上取</span></span><br><span class="line">    sliceC := sliceB[<span class="number">1</span>:] <span class="comment">//取e</span></span><br><span class="line">    fmt.Println(<span class="keyword">string</span>(sliceC))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看看 len 和 cap</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(oldSlice), <span class="built_in">cap</span>(oldSlice)) <span class="comment">//5 5</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(sliceA), <span class="built_in">cap</span>(sliceA)) <span class="comment">//3, 5</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(sliceB), <span class="built_in">cap</span>(sliceB)) <span class="comment">//2, 2</span></span><br><span class="line">    fmt.Println(<span class="built_in">len</span>(sliceC), <span class="built_in">cap</span>(sliceC)) <span class="comment">//1, 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>SliceAppend</strong>:</p>
<ul>
<li>使用 append 函数</li>
<li>可以在尾部追加元素</li>
<li>可以在尾部追加slice</li>
</ul>
<p>(追加完成了，如果没有超过cap，那么返回原来slice，否则返回重新分配的slice，同时拷贝元素)<br>(重新分配，一般是原来的 cap 翻倍)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">    <span class="comment">//用标准写法</span></span><br><span class="line">    s1 := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">    fmt.Printf(<span class="string">"%v, %p\n"</span>, s1, s1) <span class="comment">//查看地址</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始追加</span></span><br><span class="line">    s1 = <span class="built_in">append</span>(s1, <span class="number">1</span>, <span class="number">2</span>) <span class="comment">//现在长度为5已经超过了cap4,所以翻倍为8</span></span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(s1), <span class="built_in">len</span>(s1))</span><br><span class="line">    fmt.Printf(<span class="string">"%v, %p\n"</span>, s1, s1) <span class="comment">//查看地址(发现已经改变)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果重新分配过了，那么一个slice的修改不会影响原来的slice。(因为底层数组不再是同一个了)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    arr := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">    s1 := arr[<span class="number">0</span>:<span class="number">2</span>]</span><br><span class="line">    s2 := arr[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">    fmt.Println(s1) <span class="comment">//1, 2</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//2, 3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//s1和s2共享一个 2 元素，修改试试看(同时改变)</span></span><br><span class="line">    s2[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//1, 4</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//4, 5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看看s2的cap</span></span><br><span class="line">    fmt.Println(<span class="built_in">cap</span>(s2))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//但是在 s2 背后添加呢?</span></span><br><span class="line">    s2 = <span class="built_in">append</span>(s2, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//重新分配然后拷贝过去, 底层数组已经不一样了</span></span><br><span class="line">    fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在修改s2已经影响不了s1了 (底层数据结构不一样了)</span></span><br><span class="line">    s2[<span class="number">0</span>] = <span class="number">9</span></span><br><span class="line">    fmt.Println(s1) <span class="comment">//1, 4</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//9, 3, 2, 3,4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>copy()</strong>函数:</p>
<p>如果不想在一个 slice 尾部追加，那么可以用copy进行覆盖。</p>
<p>但是拷贝时注意类型一定要一致，并且长度不同，效果不同。</p>
<p>下面有个案例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    s1 := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;</span><br><span class="line">    s2 := []<span class="keyword">int</span>&#123;<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy(s1,s2) //s2拷贝到s1</span></span><br><span class="line">    <span class="comment">//fmt.Println(s1)  //s1 变成 5,6,7,4</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">copy</span>(s2, s1) <span class="comment">//s1拷贝到s2 (原来的 slice 长度保持不变, 所以只拷贝3个元素)</span></span><br><span class="line">    fmt.Println(s2) <span class="comment">//1,2,3</span></span><br><span class="line">    <span class="comment">//选择性拷贝</span></span><br><span class="line">    <span class="built_in">copy</span>(s2, s1[<span class="number">1</span>:]) <span class="comment">//2,3,4 拷贝到 s2 覆盖</span></span><br><span class="line">    fmt.Println(s2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完全拷贝？请直接赋值</span></span><br><span class="line">    s3 := s1</span><br><span class="line">    fmt.Println(s3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，长度不够的时候，以短的为准。（多余元素抛弃）source 和 target 都可以用索引截取.</p>
<p>如果要完全拷贝，可以用索引截取，但也可以直接 reslice，即赋值的方式。</p>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>这个 map, 类似其他语言的哈希表或者字典，就是 key-value。</p>
<ul>
<li>key 必须支持 <code>==</code> 和 <code>!=</code> 运算 （不能是函数，map, slice啥的）</li>
<li>value 没有类型限制(包括函数类型都行), value可以是空值</li>
<li>map和slice一样使用 make 创建(cap 可以省略)， 支持 <code>:=</code> 简写方式</li>
</ul>
<blockquote>
<p><code>make([keyType]valueType, cap)</code>  其中 cap 表示容量，可以省略(超出容量自己扩容)</p>
</blockquote>
<ul>
<li>len() 获取 map 的元素个数, 即 key 的个数。</li>
<li>delete() 删除某键值对</li>
<li>range for 进行迭代</li>
<li>存储的话，通过key，和数组赋值类似</li>
<li>多返回值, 第一个返回值就是 value, 第二返回值表明该key是否存在<ul>
<li>如果是空值，有可能该key本身不存在；或者存在，但存的是空值(所以有必要检查一下)</li>
</ul>
</li>
</ul>
<p>简单演示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//全写</span></span><br><span class="line">    <span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> <span class="comment">//定义</span></span><br><span class="line">    m1 = <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;&#125; <span class="comment">//初始化</span></span><br><span class="line">    fmt.Println(m1) <span class="comment">//map[]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//或者使用 make</span></span><br><span class="line">    <span class="keyword">var</span> m2 <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span> = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">3</span>) <span class="comment">//cap 可以省略</span></span><br><span class="line">    fmt.Println(m2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//make也可以简写 (系统也建议你简写)</span></span><br><span class="line">    m3 := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">    fmt.Println(m3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*添加元素*/</span></span><br><span class="line">    m1[<span class="number">1</span>] = <span class="string">"Ok"</span></span><br><span class="line">    fmt.Println(m1[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*覆盖, 重复添加的话，就直接覆盖了*/</span></span><br><span class="line">    m1[<span class="number">1</span>]=<span class="string">"Cancel"</span></span><br><span class="line">    fmt.Println(m1[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*删除, by key*/</span></span><br><span class="line">    <span class="built_in">delete</span>(m1, <span class="number">1</span>)</span><br><span class="line">    fmt.Println(m1[<span class="number">1</span>]) <span class="comment">//打印为空</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂的例子: (主要复杂在 value 类型上，这里是 map类型)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    complex_map := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>) <span class="comment">//value的类型是 map[int]string</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先取一下值，看看存不存在</span></span><br><span class="line">    str, ok := complex_map[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">        <span class="comment">//说明第一个key还没有插入，即没有值; 那就创建一下</span></span><br><span class="line">        complex_map[<span class="number">1</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>)</span><br><span class="line">        <span class="comment">//现在可以插入了</span></span><br><span class="line">        complex_map[<span class="number">1</span>][<span class="number">1</span>] = <span class="string">"Ok"</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取出来看看</span></span><br><span class="line">    str, ok = complex_map[<span class="number">1</span>][<span class="number">1</span>]</span><br><span class="line">    fmt.Println(str, ok)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历试试看: (对key, value副本修改不会影响原来的map)</p>
<p>3个元素的slice, 每个元素都是map，遍历试试看。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//操作副本不会影响原来的对象</span></span><br><span class="line">    sli := <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">3</span>, <span class="number">4</span>) <span class="comment">//长度为3, cap为4的slice</span></span><br><span class="line">    <span class="comment">//遍历slice进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> _,value := <span class="keyword">range</span> sli &#123;</span><br><span class="line">        value = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">        value[<span class="number">1</span>]=<span class="string">"OK"</span></span><br><span class="line">        fmt.Println(value)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sli) <span class="comment">//这里是空的，表明是对副本操作了。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接操作原始 sli</span></span><br><span class="line">    <span class="comment">//遍历slice进行初始化</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> sli &#123;</span><br><span class="line">        sli[i] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>, <span class="number">1</span>)</span><br><span class="line">        sli[i][<span class="number">1</span>]=<span class="string">"OK"</span></span><br><span class="line">        fmt.Println(sli[i])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sli)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>map的key排序</strong>:</p>
<p>map 遍历时拿出来 key 的顺序是不固定的(除非你以map[key]指定拿哪个元素)<br>借助 sort slice 可以对拿出来的 key 进行排序，从而间接对 map 排序了</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"sort"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m1 := <span class="keyword">map</span>[<span class="keyword">int</span>]<span class="keyword">string</span>&#123;<span class="number">1</span>:<span class="string">"a"</span>, <span class="number">2</span>:<span class="string">"b"</span>, <span class="number">3</span>:<span class="string">"c"</span>, <span class="number">4</span>:<span class="string">"d"</span>, <span class="number">5</span>:<span class="string">"e"</span>&#125; </span><br><span class="line">    <span class="comment">//初始化的时候貌似有序，但是遍历时发现是无序的</span></span><br><span class="line">    <span class="keyword">for</span> k,v := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        fmt.Println(k,v) <span class="comment">//多运行几次，发现是无序的</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//此时可以把 key 放入容器中，对 key 排序，从而拿到对 value 排序的目的</span></span><br><span class="line">    <span class="comment">//意思是，如果slice有序，那么map一定有序</span></span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    sli := <span class="built_in">make</span>([]<span class="keyword">int</span>, <span class="number">5</span>, <span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> k := <span class="keyword">range</span> m1 &#123;</span><br><span class="line">        sli[i] = k</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(sli)</span><br><span class="line">    sort.Ints(sli) <span class="comment">//排序 int 类型的容器</span></span><br><span class="line">    fmt.Println(sli)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>sort.Ints(slice)</code> 表示排序 int 型的 slice 。</li>
</ul>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul>
<li>函数不支持重载，默认参数; 当然也不能在函数里定义函数(不支持嵌套)</li>
<li>使用之前，不一定要声明</li>
<li>多返回值 (没有返回值的话，在返回值的地方可以不写; 单个返回值不需要小括号)</li>
<li>支持匿名函数/闭包</li>
<li>相同类型的参数, 返回值可以简写 <code>(a, b, c int)</code>, 可以用<strong>不定长变参</strong></li>
<li>命名返回值参数(相同类型简写的情况， return写明返回类的数据；否则直接写return)<ul>
<li>最好加上返回值的名称</li>
</ul>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a, b := f(<span class="number">1</span>)</span><br><span class="line">    fmt.Println(a, b)</span><br><span class="line"></span><br><span class="line">    c, d := f1()</span><br><span class="line">    fmt.Println(c,d)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(param1 <span class="keyword">int</span>)</span><span class="params">(result1, result2 <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    result1, result2 = param1, <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">//因为已经给返回值命名了，系统知道要返回的是result1, reuslt2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">()</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里返回值没有命名, 所以下面要指定</span></span><br><span class="line">    result1, result2 := <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> result1, result2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>为了代码可读，最好 return 后面加上返回值的名称</p>
</blockquote>
<p><strong>不定长变参</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//变参实际上是值拷贝</span></span><br><span class="line">    a, b, c := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">    f1(a, b, c)</span><br><span class="line">    fmt.Println(<span class="string">"外部: "</span>, a, b, c)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不定长变参函数 (必须作为最后一个参数, 编译器的要求)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(a ...<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//没有返回值，可以直接不写</span></span><br><span class="line">    fmt.Println(a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a ...<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//如果传递的是值，那么内部修改并不会影响外部的值</span></span><br><span class="line">    a[<span class="number">0</span>] = <span class="number">3</span></span><br><span class="line">    a[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">    a[<span class="number">2</span>] = <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"内部: "</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>值拷贝 &amp; 可变参数在参数列表最后</p>
</blockquote>
<p><strong>参数传递问题</strong>: (引用传递，值拷贝)</p>
<ul>
<li>这里把拷贝地址称为引用传递</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    b := &amp;a</span><br><span class="line">    c := []<span class="keyword">int</span>&#123;<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line"></span><br><span class="line">    f1(a)</span><br><span class="line">    fmt.Println(<span class="string">"外部a:"</span>, a)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    f2(b)</span><br><span class="line">    fmt.Println(<span class="string">"外部b:"</span>, *b) <span class="comment">//被内部修改</span></span><br><span class="line"></span><br><span class="line">    f3(c)</span><br><span class="line">    fmt.Println(<span class="string">"外部c:"</span>, c) <span class="comment">//被内部修改</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f1</span><span class="params">(a <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    a = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"内部a"</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(b *<span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    *b = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"内部b"</span>, *b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">(c []<span class="keyword">int</span>)</span></span> &#123; <span class="comment">//传递slice</span></span><br><span class="line">    c[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    c[<span class="number">1</span>] = <span class="number">0</span></span><br><span class="line">    fmt.Println(<span class="string">"内部c"</span>, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>函数作为类型</strong>: (一切皆类型)</p>
<blockquote>
<p>把函数作为类型赋值给变量</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A 函数调用了 AA 函数</span></span><br><span class="line">    A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := AA</span><br><span class="line">    a()  <span class="comment">//相当于函数调用 AA()</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">AA</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"调用AA"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>匿名函数</strong>: (就是定义的时候不给名字，其他一切如常)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//匿名函数的调用</span></span><br><span class="line">    a := <span class="function"><span class="keyword">func</span> <span class="params">()</span></span> &#123; <span class="comment">//这里相当于给匿名函数命名, a是函数类型</span></span><br><span class="line">        fmt.Println(<span class="string">"我是匿名函数"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    a()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>闭包</strong>:</p>
<blockquote>
<p>C语言返回给比人一个函数指针，这里闭包可以返回一个函数体&amp;代码块</p>
<blockquote>
<p>闭包可以捕获外部变量，跟 lambda 一样</p>
</blockquote>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//闭包返回一段代码块</span></span><br><span class="line">    codeBlock := closure(<span class="number">1</span>) <span class="comment">//返回类型 codeBlock 的类型是 func(int) int</span></span><br><span class="line">    result1 := codeBlock(<span class="number">0</span>)</span><br><span class="line">    result2 := codeBlock(<span class="number">2</span>)</span><br><span class="line">    fmt.Println(<span class="string">"result1 = "</span>, result1)</span><br><span class="line">    fmt.Println(<span class="string">"result2 = "</span>, result2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="comment">//closre(x)闭包返回 func(int) int 代码块</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">"x = "</span>, x)</span><br><span class="line">        fmt.Println(<span class="string">"y = "</span>, y)</span><br><span class="line">        <span class="keyword">return</span> x+y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>看闭包的返回类型即可知道封装的 code block 类型</li>
<li>闭包相对于匿名函数的好处是，拿到闭包的时候，它可以捕获外部的变量；</li>
<li>实际调用闭包封装的 code block 是才真正传入形参</li>
</ul>
<blockquote>
<p>仔细看，实际上经过闭包；原来的函数 closure 变成了另外一个函数调用</p>
<blockquote>
<p>给函数套个封装</p>
</blockquote>
</blockquote>
<p><strong>闭包捕获的是不是原始变量本身</strong>? 不是。<code>默认值拷贝</code></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">"main函数: x地址 = %p\n"</span>, &amp;x) <span class="comment">//0xc420012090</span></span><br><span class="line">    codeBlock := closure(x)</span><br><span class="line">    codeBlock(<span class="number">3.14</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//探究一下 闭包捕获的变量是不是原始变量? 看来默认值拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">float32</span>)</span><span class="title">float32</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"闭包内部: x地址 = %p\n"</span>, &amp;x) <span class="comment">//0xc420012098</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">float32</span>)</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Code Block内部: x地址 = %p\n"</span>, &amp;x) <span class="comment">//0xc420012098</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我试试按照指针来一波: (这回捕获的不再是值拷贝了)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">1</span></span><br><span class="line">    fmt.Printf(<span class="string">"main函数: x地址 = %p\n"</span>, &amp;x) <span class="comment">//0xc420012090</span></span><br><span class="line">    codeBlock := closure(&amp;x)</span><br><span class="line">    codeBlock(<span class="number">3.14</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//探究一下 闭包捕获的变量是不是原始变量? 看来默认值拷贝。</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closure</span><span class="params">(x *<span class="keyword">int</span>)</span> <span class="title">func</span><span class="params">(<span class="keyword">float32</span>)</span><span class="title">float32</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"闭包内部: x地址 = %p\n"</span>, x) <span class="comment">//0xc420012090</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">(y <span class="keyword">float32</span>)</span> <span class="title">float32</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"Code Block内部: x地址 = %p\n"</span>, x) <span class="comment">//0xc420012090</span></span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="defer关键字"><a href="#defer关键字" class="headerlink" title="defer关键字"></a>defer关键字</h2><p>有点儿 cpp raii按照block析构变量的意思。<strong>用的很少，但用起来也简单</strong>.</p>
<blockquote>
<p>在函数执行结束后，按照调用顺序的<strong>相反顺序</strong>逐个执行 defer 指定的内容.</p>
</blockquote>
<ul>
<li>先用 defer 定义的先入栈，后定义的后入栈；出栈则相反</li>
<li>即使函数发生严重错误也会执行；有点儿 finally 的意思</li>
<li>支持<strong>匿名函数</strong>调用 (也就是说可以给defer指定匿名函数)</li>
<li>defer本意是调用某个函数，所以指定匿名函数的之后，最后要加上<code>()</code></li>
</ul>
<p><strong>主要应用场景</strong>: (由于涉及到异常和错误，所以用好defer还是不错的)</p>
<ul>
<li>资源清理</li>
<li>文件关闭</li>
<li>解锁</li>
<li>记录事件</li>
</ul>
<p>简单的演示:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"执行 1"</span>)</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"执行 2"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"main函数执行"</span>)</span><br><span class="line">    A()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"执行 3"</span>)</span><br><span class="line">    fmt.Println(<span class="string">"子函数执行"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，确实是函数执行完毕之后，<strong>倒序</strong>执行 defer 定义的语句。</p>
<blockquote>
<p>defer 内容一定是主调函数完毕才去执行的</p>
</blockquote>
<p>特别是碰到匿名函数中引用了外部变量值时(默认还是值拷贝), 下面有三个案例，按顺序看:</p>
<p><strong>匿名函数</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    b := <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">(b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">        fmt.Printf(<span class="string">"defer b: %d, %p\n"</span>, b, &amp;b)</span><br><span class="line">        fmt.Printf(<span class="string">"defer a: %d, %p\n"</span>, a, &amp;a)</span><br><span class="line">    &#125;(b)</span><br><span class="line"></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    fmt.Printf(<span class="string">"outer a: %d, %p\n"</span>, a, &amp;a)</span><br><span class="line">    b = <span class="number">7</span></span><br><span class="line">    fmt.Printf(<span class="string">"outer b: %d, %p\n"</span>, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** a是直接拿，b是通过值拷贝参数传递</span></span><br><span class="line"><span class="comment">outer a: 3, 0xc420012090 //a 地址相同</span></span><br><span class="line"><span class="comment">outer b: 7, 0xc420012098 //b 地址不同</span></span><br><span class="line"><span class="comment">defer b: 6, 0xc4200120c0</span></span><br><span class="line"><span class="comment">defer a: 3, 0xc420012090</span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>先看b, <strong>匿名函数参数</strong>，默认还是值拷贝；所以地址不同，匿名函数内部拿到的也只是defer指定时的拷贝</li>
<li>在看a, <strong>匿名函数直接取</strong>，地址相同，值是 main 执行完毕时那个状态（用在for range时只能取到容器最后一个元素）</li>
</ul>
<p>有名函数，子函数的调用呢?</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> subFunc(b) <span class="comment">//0xc4200120b0</span></span><br><span class="line">    b = <span class="number">3</span></span><br><span class="line">    fmt.Printf(<span class="string">"outer b: %v, %p\n"</span>, b, &amp;b) <span class="comment">//0xc420012090</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subFunc</span><span class="params">(b <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    fmt.Printf(<span class="string">"defer b: %v, %p\n"</span>, b, &amp;b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果: (通过参数传递的，所以地址不同；defer时拿到的是一份拷贝)</span></span><br><span class="line"><span class="comment">outer b: 3, 0xc420012090</span></span><br><span class="line"><span class="comment">defer b: 2, 0xc4200120b0</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<ul>
<li>参数值传递, 拿到的是 defer 制定时的副本</li>
</ul>
<p><strong>但是内置函数有点奇葩</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    a = <span class="number">2</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Printf(<span class="string">"defer a: %v,%p\n"</span>, a, &amp;a) <span class="comment">//defer a: 2,0xc420012090</span></span><br><span class="line">    a = <span class="number">3</span></span><br><span class="line">    fmt.Printf(<span class="string">"outer a: %v,%p\n"</span>, a, &amp;a) <span class="comment">//outer a: 3,0xc420012090</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原则上:</p>
<ul>
<li>是同一个地址的话，应该取函数运行结束时的值(比如:匿名函数<strong>直接拿到&amp;使用</strong>的就是同一个地址，所以值是末尾执行完毕的值)</li>
<li>副本地址的话，就是defer指定时的副本(比如匿名函数的参数，子函数的参数;拿到的都是副本，所以地址不同且值也是当时的副本)</li>
<li>判断直接使用，简单的方法是语句块&amp;闭包里面找不到它的定义(此时初步可以认定就是从外部直接拿到的，是同一个地址)</li>
</ul>
<blockquote>
<p>但是<strong>Print系列函数虽然是子函数调用(含参数传递)，地址按原来的取，值则是拷贝</strong>。</p>
</blockquote>
<p>defer虽然看起来就像一个注册功能，但是真正运行的时候，根据不同代码有不同的表现。</p>
<p>这里有一个笔试题。</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-06-golang14.jpg" alt="笔试题"></p>
<h2 id="panic-recover模式"><a href="#panic-recover模式" class="headerlink" title="panic/recover模式"></a>panic/recover模式</h2><p>Go语言没有异常机制，但是通过 <code>panic/recover</code> 这种模式可以错误异常、错误。</p>
<blockquote>
<p>panic 可以在任何地方引发，但 recover只有在defer指定时有效</p>
</blockquote>
<p>下面引发一个 panic, recover试试。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//碰到 panic 后面基本就终止了</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"先声明"</span>)</span><br><span class="line">    A()</span><br><span class="line">    B()</span><br><span class="line">    C()</span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"后声明"</span>) <span class="comment">//后声明的没有执行</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"func B"</span>)</span><br><span class="line">    <span class="comment">//下面引发一个panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"发生严重错误了"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>panic 之后的代码一律不能执行，包括后面指定的 defer 代码</li>
<li>panic 之前注册的 defer 才能在引发异常之后执行</li>
</ul>
<blockquote>
<p>recover的注册代码要写在 panic 引发之前，最好在同一个调用栈里， 即哪个函数可能会引发，自己提前做好处理</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//碰到 panic 后面基本就终止了</span></span><br><span class="line">    <span class="keyword">defer</span> fmt.Println(<span class="string">"我只处理main函数内的异常"</span>)</span><br><span class="line">    A()</span><br><span class="line">    B()</span><br><span class="line">    C()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">A</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"func A"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">B</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"func B"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//引发问题前做好异常处理</span></span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> flag := <span class="built_in">recover</span>(); flag != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="comment">//表明确实引发了异常</span></span><br><span class="line">            fmt.Println(<span class="string">"函数B能引发了异常，我来恢复"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面引发一个panic</span></span><br><span class="line">    <span class="built_in">panic</span>(<span class="string">"发生严重错误了"</span>) <span class="comment">//制定了recover就不会panic了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">C</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"func C"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>通过 拿到 recover() 的返回值来判断是否引发了异常，然后进行处理</p>
</blockquote>
<p>有些错误就是很严重，没有 recover 的可能(不能修复，只能终止)，这个时候就需要panic.</p>
<h2 id="struct结构"><a href="#struct结构" class="headerlink" title="struct结构"></a>struct结构</h2><blockquote>
<p><code>type &lt;struct_name&gt; sturct{}</code></p>
</blockquote>
<p>花括号里面定义结构的字段、属性，它可以是一般类型，引用类型或者别的struct类型。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">struct</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ee := empty&#123;&#125;</span><br><span class="line">    fmt.Println(ee)</span><br><span class="line"></span><br><span class="line">    pp := person &#123;&#125;</span><br><span class="line">    fmt.Println(pp)</span><br><span class="line">    pp.name = <span class="string">"bob"</span></span><br><span class="line">    pp.age = <span class="number">20</span></span><br><span class="line">    fmt.Println(pp)</span><br><span class="line"></span><br><span class="line">    pp1 := person&#123;<span class="string">"bob"</span>,<span class="number">22</span>, <span class="comment">//直接字面值指定</span></span><br><span class="line">    &#125; <span class="comment">//字面值直接初始化(括号必须换行)</span></span><br><span class="line">    fmt.Println(pp1)</span><br><span class="line"></span><br><span class="line">    pp2 := person&#123; <span class="comment">//指定索引</span></span><br><span class="line">        name:<span class="string">"mike"</span>,</span><br><span class="line">        age:<span class="number">23</span>, <span class="comment">//直接字面量初始化</span></span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(pp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>直接字面量初始化</li>
<li>指定索引初始化</li>
</ul>
<p>但是上面有几个问题没有涉及到：</p>
<ul>
<li>嵌套 struct 类型怎么办？<ul>
<li>组合模型下要拿到父类的字段怎么办？</li>
<li>嵌套的结构有相同字段怎么办?</li>
</ul>
</li>
<li>指针传递问题？</li>
<li>匿名 struct ?<ul>
<li>嵌套匿名定义 (结构定义时匿名的，但字段是有名的，只能之后按字段赋值)</li>
<li>字段匿名</li>
</ul>
</li>
<li>struct只有属性么？方法呢？—这个单独再说(看下一节)</li>
</ul>
<p>先说简单的<strong>指针问题</strong> :</p>
<blockquote>
<p>struct的指针，直接拿，直接用</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//默认的传参数，都是值传递；不说</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//way1, 先构建一个 person 对象，然后取地址</span></span><br><span class="line">    p1 := person &#123;</span><br><span class="line">        name: <span class="string">"bob"</span>,</span><br><span class="line">        age: <span class="number">20</span>, <span class="comment">//不要忘记逗号</span></span><br><span class="line">    &#125;</span><br><span class="line">    setPerson(&amp;p1)</span><br><span class="line">    fmt.Println(<span class="string">"outer: "</span>, p1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//way2 -- 直接拿到struct的指针</span></span><br><span class="line">    p2 := &amp;person &#123;</span><br><span class="line">        name: <span class="string">"mike"</span>,</span><br><span class="line">        age:<span class="number">30</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    setPerson(p2)</span><br><span class="line">    fmt.Println(<span class="string">"outer: "</span>, *p2)<span class="comment">//这里p2是指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针也用 . 操作</span></span><br><span class="line">    p2.age = <span class="number">32</span></span><br><span class="line">    fmt.Println(<span class="string">"outer: "</span>, *p2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setPerson</span><span class="params">(p *person)</span></span>&#123;</span><br><span class="line">    p.age += <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"inner: "</span>, *p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>指针传递，裸指针，注意安全(智能指针也要注意)</li>
<li>指针传递一般比值传递性能要高，拷贝代价低</li>
</ul>
<blockquote>
<p>推荐直接取结构地址，用指针操作</p>
</blockquote>
<p><strong>匿名结构</strong>:</p>
<p>结构的字段没有定义的情况下，就想直接使用; 并且只用一次(只在本次拿到实例就完事儿了)</p>
<ul>
<li>定义结构的同时进行初始化</li>
<li>匿名就不需要 type 来给 struct{} 起别名了</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//定义的同时初始化(临时定义)</span></span><br><span class="line">    pp := &amp;<span class="keyword">struct</span> &#123;</span><br><span class="line">        name <span class="keyword">string</span></span><br><span class="line">        age <span class="keyword">int</span></span><br><span class="line">    &#125;&#123;</span><br><span class="line">        name: <span class="string">"bob"</span>,</span><br><span class="line">        age: <span class="number">12</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(*pp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>嵌套问题</strong>:</p>
<p>匿名结构也可以被嵌套:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    contact <span class="keyword">struct</span> &#123; <span class="comment">//这里contac是person的字段，该结构的实例，而该结构是没有名字的</span></span><br><span class="line">        city, dic <span class="keyword">string</span> <span class="comment">//同类型可以一起定义</span></span><br><span class="line">        <span class="comment">/* city string</span></span><br><span class="line"><span class="comment">        disc string */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pp := &amp; person&#123;&#125;</span><br><span class="line">    fmt.Println(*pp) <span class="comment">//&#123; 0 &#123; &#125;&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>定义完struct，之后按照index或者name进行初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">    contact <span class="keyword">struct</span> &#123; </span><br><span class="line">        city, dic <span class="keyword">string</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//way1: 定义之后再指定初始化</span></span><br><span class="line">    pp1 := &amp; person&#123;name:<span class="string">"joe"</span>, age:<span class="number">19</span>&#125;</span><br><span class="line">    fmt.Println(*pp1) <span class="comment">//&#123;joe 19 &#123; &#125;&#125;</span></span><br><span class="line">    pp1.contact.city = <span class="string">"上海"</span></span><br><span class="line">    pp1.contact.dic = <span class="string">"黄浦区"</span></span><br><span class="line">    fmt.Println(*pp1)</span><br><span class="line"></span><br><span class="line">    fmt.Println(<span class="string">"--------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//way2: 定义的时候就指定好---失败了</span></span><br><span class="line"><span class="comment">/*  pp2 := &amp;person &#123;</span></span><br><span class="line"><span class="comment">        name: "mike",</span></span><br><span class="line"><span class="comment">        age: 20,</span></span><br><span class="line"><span class="comment">        contact : &#123;</span></span><br><span class="line"><span class="comment">            city: "上海", dic: "黄浦区",</span></span><br><span class="line"><span class="comment">        &#125;,</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//way2: 定义的时候就制定好，全部直接字面量，不用字段指定---失败了</span></span><br><span class="line"><span class="comment">/* 	pp2 := &amp;person &#123;"mike", 20, &#123;"上海", "黄浦区"&#125;&#125; // missing type in composite literal</span></span><br><span class="line"><span class="comment">    fmt.Println(*pp2) */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，如果在结构里定义了匿名结构，初始化只能在外部进行。(编译器能力有限, 识别不了你的花样)</p>
<p>如果是嵌入的有名结构，则可以定义实例的时候就指明:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> human <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> student <span class="keyword">struct</span> &#123;</span><br><span class="line">    human</span><br><span class="line">    stuNo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> teacher <span class="keyword">struct</span> &#123;</span><br><span class="line">    human</span><br><span class="line">    teaNo <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义就初始化--直接字面量(这也解释了为啥内部匿名嵌套定义不能这么初始化)</span></span><br><span class="line">    ss := student&#123;human&#123;<span class="string">"bob"</span>,<span class="number">10</span>&#125;, <span class="number">1</span>&#125; <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(ss)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定制就初始化--按照字段指定</span></span><br><span class="line">    ss2 := student &#123;</span><br><span class="line">        human:  human&#123;</span><br><span class="line">                    name: <span class="string">"bob"</span>,</span><br><span class="line">                    age: <span class="number">10</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">        stuNo: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(ss2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>按照字段指定的时候，内部嵌套struct类型被当做了字段用于声明</li>
<li>嵌入结构的字段，可以直接拿下来使用 (如果没有二义性问题，即从两个嵌入结构拿到同样的字段的情况)</li>
<li>本层字段会隐藏嵌入结构的同名字段，如果要用要明确指定嵌入结构(名称冲突)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//操作嵌入式结构的字段</span></span><br><span class="line">ss2.human.age = <span class="number">11</span></span><br><span class="line">fmt.Println(ss2)</span><br><span class="line"></span><br><span class="line"><span class="comment">//相当于把嵌入结构字段----不推荐这样，容易引起歧义</span></span><br><span class="line">ss2.age = <span class="number">12</span></span><br><span class="line">fmt.Println(ss2)</span><br></pre></td></tr></table></figure>
<p>嵌套的结构有相同的字段:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> C2 <span class="keyword">struct</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    cc1 := C1&#123;&#125; <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(cc1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译报错</span></span><br><span class="line">    <span class="comment">//fmt.Println(cc1.name) //ambiguous selector cc1.name</span></span><br><span class="line">    fmt.Println(cc1.A.name) <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">    cc2 := C2&#123;&#125; <span class="comment">//ok</span></span><br><span class="line">    fmt.Println(cc2)</span><br><span class="line">    fmt.Println(cc2.name) <span class="comment">//ok</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>最高级别如果不存在某个字段，那么找内部嵌入的strut的字段</li>
</ul>
<p><strong>匿名字段</strong>:</p>
<ul>
<li>定义的时候按顺序初始化</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">string</span></span><br><span class="line">    <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//way1 按顺序初始化</span></span><br><span class="line">    pp := &amp;person &#123;<span class="string">"mike"</span>, <span class="number">20</span>&#125;</span><br><span class="line">    <span class="comment">//pp := &amp;person &#123;20, "mike"&#125;//编译报错</span></span><br><span class="line">    fmt.Println(*pp)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//way2 ???</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按规矩做事情，还是不要搞匿名字段比较好。</p>
<p>struct实例的<strong>比较运算</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pp0 := person &#123;</span><br><span class="line">        name: <span class="string">"bob"</span>,</span><br><span class="line">        age:<span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    pp1 := person &#123;</span><br><span class="line">        name: <span class="string">"bob"</span>,</span><br><span class="line">        age:<span class="number">20</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(<span class="string">"pp0 == pp1, "</span>, pp0 == pp1) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    pp1.age += <span class="number">1</span></span><br><span class="line">    fmt.Println(<span class="string">"pp0 == pp1, "</span>, pp0 == pp1) <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bb0 := person1 &#123;"bob", 20&#125;</span></span><br><span class="line">    <span class="comment">//fmt.Println("bb0 == pp0, ", bb0 == pp0)</span></span><br><span class="line">    <span class="comment">//编译报错:mismatched types person1 and person</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>相同类型结构才可以比较</li>
</ul>
<h2 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h2><p>给 struct 或者其他类型添加方法，其实就是给方法指定默认的 receiver。</p>
<p><strong>指定该方法的所属对象</strong>？并不是，看下面的结论。</p>
<blockquote>
<p>个人猜想，方法指定 receiver 应该是调用的时候默认传入 this 指针。(猜想错了)</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pp := person&#123;<span class="string">"bob"</span>, <span class="number">10</span>&#125;</span><br><span class="line">    fmt.Println(<span class="string">"old: pp"</span>, pp)</span><br><span class="line"></span><br><span class="line">    pp.printPerson1()</span><br><span class="line">    fmt.Println(<span class="string">"outer print1: pp"</span>, pp) <span class="comment">//内部改变，但外部没有变</span></span><br><span class="line"></span><br><span class="line">    pp.printPerons2()</span><br><span class="line">    fmt.Println(<span class="string">"outer print2: pp"</span>, pp)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指定 receiver</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span> <span class="title">printPerson1</span><span class="params">()</span></span> &#123; <span class="comment">//默认按值拷贝</span></span><br><span class="line">    p.age ++</span><br><span class="line">    fmt.Println(<span class="string">"inner print1"</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span> <span class="title">printPerons2</span><span class="params">()</span></span> &#123; <span class="comment">//指定传递 person 对象的指针</span></span><br><span class="line">    p.age ++</span><br><span class="line">    fmt.Println(<span class="string">"inner print2"</span>, p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 输出结果</span></span><br><span class="line"><span class="comment">old: pp &#123;bob 10&#125;</span></span><br><span class="line"><span class="comment">inner print1 bob 11</span></span><br><span class="line"><span class="comment">outer print1: pp &#123;bob 10&#125;</span></span><br><span class="line"><span class="comment">inner print2 bob 11</span></span><br><span class="line"><span class="comment">outer print2: pp &#123;bob 11&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果指定 receiver 是值方式，那么就是对象属性的拷贝</li>
<li>如果指定 receiver 是指针方式，那么就是引用原来的对象</li>
</ul>
<blockquote>
<p>实际上指定的 receiver 是函数的第一个参数(所以可以通过函数的方式调用)</p>
</blockquote>
<p><strong>Go方法，没有重载，没有泛型，所以针对不同的类型，要针对不同receiver分别声明</strong>.</p>
<p>(如果你想根据参数不同来弄个重载，肯定报错，例子略)</p>
<ul>
<li>有些类型不能直接指定方法，但是通过给类型别名指定方法，则可以间接为原来的类型指定方法</li>
<li>内置类型不能直接指定，因为这里的int类型不是本包定义的；这里的指定放大只适用于本包定义的类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名，然后给别名指定方法</span></span><br><span class="line"><span class="keyword">type</span> XX <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x XX</span><br><span class="line">    x.printInt()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给 XX 指定方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *XX)</span><span class="title">printInt</span><span class="params">()</span></span> &#123;</span><br><span class="line">    *p = *p + <span class="number">1</span> <span class="comment">//因为 X 就是 int</span></span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般基本类型或者不能直接指定方法的类型，都要<strong>借助类型别名</strong>。(相当于绕过语法限制)</p>
<ul>
<li>类型别名指定的方法只能通过别名的实例调用，而不能被原来的类型实例直接调用</li>
<li>类型别名和原来的类型混合计算的时候，要把原来的类型<strong>强转成类型别名的类型</strong></li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类型别名，然后给别名指定方法</span></span><br><span class="line"><span class="keyword">type</span> XX <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x XX</span><br><span class="line">    x.setInt(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给 XX 指定方法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *XX)</span><span class="title">setInt</span><span class="params">(num <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//*p += num //编译报错 // mismatched types XX and int</span></span><br><span class="line"><span class="comment">/* 	tmp := XX(num)</span></span><br><span class="line"><span class="comment">    *p += tmp  */</span></span><br><span class="line">    *p += XX(num)</span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上指定的 receiver 是函数的第一个参数，<strong>所以可以通过函数的方式调用</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> XX <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x XX</span><br><span class="line">    <span class="comment">//x.printInt()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过 method express调用</span></span><br><span class="line">    (*XX).printInt(&amp;x) <span class="comment">//传入实例的指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给 XX 指定方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *XX)</span><span class="title">printInt</span><span class="params">()</span></span> &#123;</span><br><span class="line">    *p = *p + <span class="number">1</span> <span class="comment">//因为 X 就是 int</span></span><br><span class="line">    fmt.Println(*p)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过函数调用 Vs 通过函数的方式调用，建议还是用实例调用吧。</p>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><blockquote>
<p>无侵入式设计的接口</p>
</blockquote>
<p>早有耳闻<code>无侵入式</code>的接口，也就是说，不需要改变原来类、结构、或者任何类型的任何部分，就可以说它具有某些接口的feature。</p>
<p><strong>在定义结构的时候根本不需要声明什么关键字说它实现了某个接口，只需要在给它指定方法的时候，指定某个接口的方法即可</strong>。(必须为某个类型<strong>指定</strong>某个接口内的全部<strong>方法</strong>后，放能说这个类型实现了这个接口)</p>
<blockquote>
<p>简单说: 为类型指定接口里的方法即可。(structural typing)</p>
</blockquote>
<ul>
<li>接口只有方法声明，没有实现</li>
<li>接口没有数据字段</li>
</ul>
<p>(下面代码有一个注意事项: <strong>如果USB接口里有一个方法 name()，它会和 PCWire 的字段重名，导致编译报错</strong>)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="keyword">string</span> <span class="comment">//定义一个方法，参数为空，返回string类型</span></span><br><span class="line">    connect()</span><br><span class="line">    disconnect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个结构，PC数据线，实现了USB接口</span></span><br><span class="line"><span class="keyword">type</span> PCWire <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> usb USB</span><br><span class="line">    usb = PCWire&#123;<span class="string">"PC 数据线"</span>&#125; <span class="comment">//usb的运行时类型是 struct PCWire</span></span><br><span class="line">    <span class="comment">//usb.name undefined (type USB has no field or method name)</span></span><br><span class="line">    <span class="comment">//usb.name = "PC 数据线"//应该在上一步赋值的时候指定</span></span><br><span class="line">    str := usb.getName()</span><br><span class="line">    fmt.Println(str) <span class="comment">//PC 数据线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一般的用法，不用定义接口实例，直接指定实现接口的类型实例</span></span><br><span class="line">    usb2 := PCWire&#123;<span class="string">"劣质 PC 数据线"</span>&#125;</span><br><span class="line">    usb2.connect()</span><br><span class="line">    usb2.disconnect()</span><br><span class="line"></span><br><span class="line">    usb3 := PCWire&#123;<span class="string">"高级 PC 数据线"</span>&#125;</span><br><span class="line">    (*PCWire).connect(&amp;usb3)</span><br><span class="line">    (*PCWire).disconnect(&amp;usb3)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了usb意味着三个方法都要实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//receiver 可以指定对象或者指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wire.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">connect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(wire.name + <span class="string">"已经连接 USB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">disconnect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(wire.name + <span class="string">"已经断开USB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以仔细看 <code>usb2 := PCWire{&quot;劣质 PC 数据线&quot;}</code>, 根本没有定义接口，<strong>直接用的struct实例</strong>(如果它实现了某接口，那么直接用相关的方法即可，不用废话)。接口不用声明，直接使用。其实这里是包容性原则:</p>
<blockquote>
<p>抽象层级高的可以包容抽象层级低的事物</p>
</blockquote>
<p>当然也可以有这种操作: (把接口当做接收实例的形参)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来一个形参方法，接收 USB 实例 (面向接口编程)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureInterface</span><span class="params">(usb USB)</span></span> &#123;</span><br><span class="line">    fmt.Println(<span class="string">"正常调用该方法，说明传入的实参是 usb 的实例"</span>)</span><br><span class="line">    fmt.Println(usb.getName()) <span class="comment">//直接 usb.name 不行，usb没有这个字段</span></span><br><span class="line">    <span class="comment">//fmt.Println(PCWire(usb).name) //强制类型转换？</span></span><br><span class="line">    <span class="comment">//编译报错:cannot convert usb (type USB) to type PCWire: need type assertion</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类或者具体类型不能向抽象类型转换，不兼容。(抽象包容具体是ok的)</li>
</ul>
<blockquote>
<p>不能强制类型转换，但是我就是想从实例那儿拿到字段怎么办？判断一下运行时类型 <strong>type assertion</strong>.</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//来一个形参方法，接收 USB 实例 (面向接口编程)</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">ensureInterface</span><span class="params">(usb USB)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//fmt.Println(PCWire(usb).name) //强制类型转换，报错</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pcWire,ok := usb.(PCWire); ok == <span class="literal">true</span> &#123;</span><br><span class="line">        <span class="comment">//如果 usb 确实是 PCWire 的实例</span></span><br><span class="line">        fmt.Println(<span class="string">"Disconnected: "</span>, pcWire.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>usb.(PCWire) 可以拿到相关的类型的实例，不过最好检查一下这个方法是否运行成功(可能拿到的是nil)</li>
<li>type assertion: <code>实例.(类型)</code> 类型检查了。</li>
</ul>
<p><strong>全兼容的接口</strong>: 一个接口里面啥方法也不定义。那么等于说它能兼容所有的对象(所有对象都会实现这些空方法)</p>
<p><code>usb USB</code>可以兼容所有实现该 USB 接口的实例，如果形参是 <code>empty interface{}</code> 那么这货就可以包容所有的类型啦</p>
<p><code>fmt.Println</code> 就是这么定义的。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Println</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span> <span class="params">(n <span class="keyword">int</span>, err error)</span></span></span><br></pre></td></tr></table></figure>
<p>空接口 <code>interface{}</code> 其实就可以把它当成一个类型来用，通常也可以 type empty interface {}``，然后用 empty 即可。</p>
<p>其次，接口可以和<strong>嵌套</strong>结合:</p>
<blockquote>
<p>为什么嵌入？代替面向对象的 <code>继承</code> 呗。</p>
</blockquote>
<ul>
<li>接口可以内嵌接口 (相当于把公共方法提取到公共接口里)</li>
<li>接口可以嵌入到其他类型中，比如 struct (意思是说，我有这样的实例作为字段)</li>
</ul>
<p><strong>内嵌定义</strong>:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义通用接口标准, 就一个连接方法，是个接口都能连接。</span></span><br><span class="line"><span class="keyword">type</span> Standard <span class="keyword">interface</span> &#123;</span><br><span class="line">    connect()</span><br><span class="line">    disconnect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其他具体接口本来应该继承它获取连接方法，但这里采用内嵌&amp;组合</span></span><br><span class="line"><span class="keyword">type</span> USB2 <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="keyword">string</span></span><br><span class="line">    <span class="comment">/*connect()</span></span><br><span class="line"><span class="comment">    disconnect()*/</span></span><br><span class="line">    Standard  <span class="comment">//这就是内嵌定义了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> USB3 <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="keyword">string</span></span><br><span class="line">    highwayTransport()</span><br><span class="line">    Standard <span class="comment">//内嵌标准接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于相关类型，实现具体接口，直接实现即可。</p>
<blockquote>
<p>本质上还是会把内嵌接口下放，所以如果是多个内嵌，也会存在二义性问题</p>
</blockquote>
<p>运行试试: (在上一个案例上抽取 Standard 接口)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="keyword">string</span> <span class="comment">//定义一个方法，参数为空，返回string类型</span></span><br><span class="line">    <span class="comment">/*抽取到 Standard 接口</span></span><br><span class="line"><span class="comment">    connect()</span></span><br><span class="line"><span class="comment">    disconnect() */</span></span><br><span class="line">    Standard</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Standard <span class="keyword">interface</span> &#123;</span><br><span class="line">    connect()</span><br><span class="line">    disconnect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PCWire <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> usb USB</span><br><span class="line">    usb = PCWire&#123;<span class="string">"PC 数据线"</span>&#125; <span class="comment">//usb的运行时类型是 struct PCWire</span></span><br><span class="line">    str := usb.getName()</span><br><span class="line">    fmt.Println(str) <span class="comment">//PC 数据线</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一般的用法，不用定义接口实例，直接指定实现接口的类型实例</span></span><br><span class="line">    usb2 := PCWire&#123;<span class="string">"劣质 PC 数据线"</span>&#125;</span><br><span class="line">    usb2.connect()</span><br><span class="line">    usb2.disconnect()</span><br><span class="line"></span><br><span class="line">    usb3 := PCWire&#123;<span class="string">"高级 PC 数据线"</span>&#125;</span><br><span class="line">    (*PCWire).connect(&amp;usb3)</span><br><span class="line">    (*PCWire).disconnect(&amp;usb3)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实现了usb意味着三个方法都要实现</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//receiver 可以指定对象或者指针</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> wire.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">connect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(wire.name + <span class="string">"已经连接 USB"</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">disconnect</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(wire.name + <span class="string">"已经断开USB"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果两个内嵌的接口有同样的方法呢？–不能处理。</p>
<p><img src="http://omotkhw3y.bkt.clouddn.com/2018-02-08-golang15.png" alt="共有方法问题"></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> A <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="keyword">string</span></span><br><span class="line">    xxx()</span><br><span class="line">    yyy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> B <span class="keyword">interface</span> &#123;</span><br><span class="line">    getName() <span class="keyword">string</span> <span class="comment">//返回值不能做作为区分</span></span><br><span class="line">    zzz()</span><br><span class="line">    ssss()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*duplicate method getName*/</span></span><br><span class="line"><span class="keyword">type</span> C1 <span class="keyword">interface</span> &#123;</span><br><span class="line">    A</span><br><span class="line">    B</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> CC1 <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//var c C1</span></span><br><span class="line">    c := CC1&#123;<span class="string">"ccc"</span>&#125;</span><br><span class="line">    fmt.Println(c.getName()) <span class="comment">//编译报错:ambiguous selector c.getName</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c CC1)</span> <span class="title">getName</span><span class="params">()</span> <span class="title">string</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> c.name</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* type C2 interface &#123;</span></span><br><span class="line"><span class="comment">    A</span></span><br><span class="line"><span class="comment">    B</span></span><br><span class="line"><span class="comment">    name() string</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>和同为Golang的朋友讨论了一下，初步结论，go的设计团队没有在语言层面上解决这个问题，只能做一些检查。</p>
<p>还有一个问题:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usb := PCWire&#123;<span class="string">"数据线"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>其实这里拿到的实例 usb 是按值拷贝的，即通过 usb 修改的字段其实是修改的副本，而接口里面初始化的那份则保持不变。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> USB <span class="keyword">interface</span> &#123;</span><br><span class="line">    printName()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> PCWire <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//var wire USB</span></span><br><span class="line">    <span class="comment">//接口 = 对象, 此处就发生了拷贝，即 wire 其实 struct PCWire 实例的副本</span></span><br><span class="line">    wire := PCWire&#123;<span class="string">"电脑数据线"</span>&#125;</span><br><span class="line">    <span class="keyword">var</span> usb USB <span class="comment">//接口内部保存着对于实例的引用，所以拿到该部分引用(原始对象)</span></span><br><span class="line">    usb = USB(wire) <span class="comment">//抽象接口可以兼容，拿到接口所存储的实例的指针</span></span><br><span class="line"></span><br><span class="line">    wire.printName() <span class="comment">//副本打印 "电脑数据线"</span></span><br><span class="line">    usb.printName() <span class="comment">//接口拿到的打印 "电脑数据线"</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改 wire 这个副本的内容</span></span><br><span class="line">    wire.name = <span class="string">"数据线(改)"</span></span><br><span class="line">    <span class="comment">//当然通过 usb.name 修改肯定不行啦，接口没有这个字段</span></span><br><span class="line"></span><br><span class="line">    wire.printName() <span class="comment">//副本的改变了: 数据线(改)</span></span><br><span class="line">    usb.printName()  <span class="comment">//接口内存储的指针则没有变: 电脑数据线</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(wire PCWire)</span> <span class="title">printName</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(wire.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">电脑数据线</span></span><br><span class="line"><span class="comment">电脑数据线</span></span><br><span class="line"><span class="comment">数据线(改)</span></span><br><span class="line"><span class="comment">电脑数据线</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>接口对象如果指向某个对象，即使该对象是一个空指针，那么该接口对象也不空。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">interface</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> noempty <span class="keyword">interface</span> &#123;</span><br><span class="line">    hello()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> em empty</span><br><span class="line">    fmt.Println(em == <span class="literal">nil</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> no noempty</span><br><span class="line">    fmt.Println(no == <span class="literal">nil</span>) <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> p *<span class="keyword">int</span> = <span class="literal">nil</span></span><br><span class="line">    em = p <span class="comment">//只要接口收纳了对象, 它就不为空</span></span><br><span class="line">    fmt.Println(em == <span class="literal">nil</span>) <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接口对象为空的条件: 接口没有容纳对象。(即接口内部没有指向对象)</li>
</ul>
<h2 id="type-switch"><a href="#type-switch" class="headerlink" title="type_switch"></a>type_switch</h2><p>如果判断一个实例的运行时类型，即到底是实现该接口的哪个实例？</p>
<p>上面给了一个方法, type asserting 检查中的一种:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> instance, ok := usb.(PCWire); ok &#123;</span><br><span class="line">    <span class="comment">//说明 usb 确实是 PCWire的实例</span></span><br><span class="line">    fmt.Println(instance.name); <span class="comment">//可以直接拿到 instance 实例。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是 现在有 N 个 struct都实现了这个 USB接口，那么这种<strong>ok pattern</strong>肯定是行不通的。</p>
<p>就引入了 <code>type switch</code> 更加高效的判断:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> v := usb.(<span class="keyword">type</span>) &#123; <span class="comment">//注意这里写入的是type关键字</span></span><br><span class="line">    <span class="keyword">case</span> PCWire: <span class="comment">/* ur code here */</span></span><br><span class="line">    <span class="keyword">case</span> PhoneWire: <span class="comment">/* ur code here */</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 ok pattern 类似， <code>usb.(type)</code>拿到的 v 就是运行时实例的类型，让它和case去匹配即可。</p>
<p>也可以各个 case 写成 <code>PCWire == usb.(type)</code>，写 type 关键字而不是具体的类型可以让系统去确定。<br>两种写法没有本质的区别，但是上面那种用局部变量 v 更加简洁。</p>
<blockquote>
<p>最后接口这里，我建议从抽象-具体的角度去理解；</p>
</blockquote>
<p>(从超集，子集的角度也行，不过不直观？)</p>
<p>不管是 <code>ok pattern</code> 还是 <code>type switch</code>都表明，其实Go的接口完全可以<code>面向接口编程</code>，即<strong>支持运行时多态</strong>, 形参只管写接口类型即可。(这种动多态不借助继承，而直接用的接口方法实现达到目的, 有点点儿 Java 的意思)</p>
<p>强烈建议阅读<strong>《我为什么不喜欢Go语言式的接口》</strong>，这里槽点多多；请接着往下看。</p>
<h2 id="方法集问题"><a href="#方法集问题" class="headerlink" title="方法集问题"></a>方法集问题</h2><blockquote>
<p>事实证明 1.9 版本的 Go 已经可以处理好 receiver 的自动转换问题了.</p>
</blockquote>
<p>以前说结构的时候，说过这样的问题:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">instance := person&#123;<span class="string">"bob"</span>, <span class="number">20</span>&#125; <span class="comment">//拿到副本</span></span><br><span class="line">ptr := &amp;person&#123;<span class="string">"bob"</span>, <span class="number">20</span>&#125; <span class="comment">//直接拿到指针</span></span><br></pre></td></tr></table></figure>
<p>那么之后通过 <code>instance</code> 和 <code>ptr</code> 都可以去访问字段，或者访问方法，直接用就好了。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//访问字段</span></span><br><span class="line">instance.name = <span class="string">"xxx"</span></span><br><span class="line">ptr.name = <span class="string">"xxx"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问方法</span></span><br><span class="line">instance.printName()</span><br><span class="line">ptr.printName()</span><br></pre></td></tr></table></figure>
<p>这里<code>printName()</code>方法会根据传入的是副本对象还是指针，做自动的转换。(无论 printName方法的 receiver 是 <code>p *person</code>，还是<code>p person</code>, 都能自动转换并处理)</p>
<p>但是如果通过接口调用，即把相关实例赋值给接口对象，通过接口调用接口的方法，那么这个时候，不会做自动转换。</p>
<ul>
<li>如果这个接口方法的 receiver 是指针，那么只能通过指针对象调用</li>
<li>如果这个接口方法的 receiver 是值对象，那么可以通过指针或者值调用</li>
</ul>
<p>下面是一个综合案例:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//证明一下 receiver 不能自动转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    pp0 := person&#123;<span class="string">"bob"</span>,<span class="number">20</span>&#125;</span><br><span class="line">    pp1 := &amp;person&#123;<span class="string">"bob"</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问自动，自动转换 ok</span></span><br><span class="line">    pp0.age++</span><br><span class="line">    pp1.age++</span><br><span class="line"></span><br><span class="line">    <span class="comment">//访问方法自动转换 ok ( 调用 printPerson2() 把 printPerson1() 注释掉 )</span></span><br><span class="line"><span class="comment">/* 	pp0.printPerson2()</span></span><br><span class="line"><span class="comment">    pp1.printPerson2() */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//调用 printPerson1() 把 printPerson2() 注释掉</span></span><br><span class="line">    pp0.printPerson1()</span><br><span class="line">    pp1.printPerson1()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span><span class="title">printPerson1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* func (p *person)printPerson2() &#123;</span></span><br><span class="line"><span class="comment">    fmt.Println(p.name, p.age)</span></span><br><span class="line"><span class="comment">&#125; */</span></span><br></pre></td></tr></table></figure>
<p>上面充分证明了:</p>
<ul>
<li>对于结构来的方法的receiver，字段等，指针/实例可以完成自动转换 (但是传指针和值效果不一样)</li>
</ul>
<p>然后，<strong>如果是 interface 的方法，指针和实例之间是不能相互转换的</strong>？（1.4版本的Go不行，1.9版本的可以么？验证一下）</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">//证明一下 receiver 不能自动转换</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> <span class="built_in">print</span> <span class="keyword">interface</span> &#123;</span><br><span class="line">    printPerson1()</span><br><span class="line">    printPerson2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span> &#123;</span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">//这里pp0,pp1分别是接口类型副本，指针</span></span><br><span class="line">    pp0 := person&#123;<span class="string">"bob"</span>,<span class="number">20</span>&#125;</span><br><span class="line">    pp1 := &amp;person&#123;<span class="string">"bob"</span>, <span class="number">20</span>&#125;</span><br><span class="line"></span><br><span class="line">    pp0.printPerson1()</span><br><span class="line">    pp0.printPerson2()</span><br><span class="line"></span><br><span class="line">    pp1.printPerson1()</span><br><span class="line">    pp1.printPerson2()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//该接口方法，实例和指针均可调用，自动转换ok</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p person)</span><span class="title">printPerson1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name, p.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//该接口方法，只能指针调用，实例调用失败----事实证明可以！！！</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *person)</span><span class="title">printPerson2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(p.name, p.age)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>事实证明，不管是接口方法还是实例方法(普通的结构成员方法)，receiver都可以完成自动转换</p>
</blockquote>
<h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>貌似最早接触反射的时候，是在Java里面根据配置文件里面配置的 domain 类生成 pojo 对象容纳数据。</p>
<p><strong>不过一般是写框架的人用反射比较多, 应用产品开发人员，业务开发人员用的少</strong>。</p>
<blockquote>
<p>作为内省的一种手段，反射提供了 <code>抽象-&gt;具体</code> 的实现，并且和编译类型无关。</p>
</blockquote>
<p>Golang 里面，反射主要是 Typeof 和 Valueof，但是注意一下<strong>反射出来的原类型</strong>和<strong>真实的原类型</strong>可能是一样的，但是由于反射中API的设计，一般知道是某个原始类型，但是调用的时候也要去写”从值、实例得到反射类型”的代码。<em>这里代码开始不好理解，得反复写</em>.</p>
<p>简单代码: 从实例获取它的运行时类型，并反射出属性，方法</p>
<p>首先注意一下：<strong>外部包能够反射的，一般都是能够 expoted 的字段和方法；如果都是小写开头，会得到这样的错误</strong>:</p>
<blockquote>
<p>cannot return value obtained from unexported field or method</p>
</blockquote>
<p>例如下面的代码:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(usr User)</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(usr.name, usr.id, usr.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    uu := User &#123;<span class="number">1</span>,<span class="string">"bob"</span>,<span class="number">20</span>&#125;</span><br><span class="line">    uu.info(uu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//info 方法内部用到了反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(usr User)</span><span class="title">info</span><span class="params">(obj empty)</span></span> &#123;</span><br><span class="line">    <span class="comment">//拿到类型</span></span><br><span class="line">    t := reflect.TypeOf(obj) <span class="comment">// t 是 Type接口的实例副本</span></span><br><span class="line">    fmt.Println(<span class="string">"Type:"</span>, t.Name()) <span class="comment">//结构类型是有方法的，所以可以调用 Name()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到值</span></span><br><span class="line">    v := reflect.ValueOf(obj) <span class="comment">//这里拿到的结构 (而不是字段)</span></span><br><span class="line">    <span class="comment">//字段循环取 (字段的类型、名字可以通过 t 获取；但是 value 只能通过 v 获取)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        <span class="comment">//拿到字段的名称，类型 (通过t)</span></span><br><span class="line">        field := t.Field(i) <span class="comment">//拿到字段对象 (可以查看字段的类型，名称；但是拿不到值)</span></span><br><span class="line">        fmt.Print(field.Name,<span class="string">" "</span>, field.Type,<span class="string">" "</span>) <span class="comment">//字段没有方法，直接用属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到字段的值</span></span><br><span class="line">        val := v.Field(i).Interface() <span class="comment">//拿到 v当前值</span></span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>OK, 我现在把字段方法的定义全部改成大写开头，但是！<strong>info方法的实现全部不用改~</strong></p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> empty <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(usr User)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Printf(usr.Name, usr.Id, usr.Age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    uu := User &#123;<span class="number">1</span>,<span class="string">"bob"</span>,<span class="number">20</span>&#125;</span><br><span class="line">    uu.Info(uu)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//info 方法内部用到了反射</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(usr User)</span><span class="title">Info</span><span class="params">(obj empty)</span></span> &#123;</span><br><span class="line">    <span class="comment">//拿到类型</span></span><br><span class="line">    t := reflect.TypeOf(obj) <span class="comment">// t 是 Type接口的实例副本</span></span><br><span class="line">    fmt.Println(<span class="string">"Type:"</span>, t.Name()) <span class="comment">//结构类型是有方法的，所以可以调用 Name()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到值</span></span><br><span class="line">    v := reflect.ValueOf(obj) <span class="comment">//这里拿到的结构 (而不是字段)</span></span><br><span class="line">    <span class="comment">//字段循环取 (字段的类型、名字可以通过 t 获取；但是 value 只能通过 v 获取)</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumField(); i++ &#123;</span><br><span class="line">        <span class="comment">//拿到字段的名称，类型 (通过t)</span></span><br><span class="line">        field := t.Field(i) <span class="comment">//拿到字段对象 (可以查看字段的类型，名称；但是拿不到值)</span></span><br><span class="line">        fmt.Print(field.Name,<span class="string">" "</span>, field.Type,<span class="string">" "</span>) <span class="comment">//字段没有方法，直接用属性</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//拿到字段的值</span></span><br><span class="line">        val := v.Field(i).Interface() <span class="comment">//拿到 v当前值</span></span><br><span class="line">        fmt.Println(val)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Type: User</span></span><br><span class="line"><span class="comment">Id int 1</span></span><br><span class="line"><span class="comment">Name string bob</span></span><br><span class="line"><span class="comment">Age int 20</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>也就是说，反射的代码，代码中根本不涉及原始代码的任何字符；也就不会因为原始类型修改，导致反射的代码编译不过。反射就好像是站在了<strong>编译器</strong>的角度去理解程序，而不是我们的角度(上帝视角)。</p>
<p>还有一段代码可以补充在后面，调用相关的方法:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用 obj 的方法 (可能有多个方法，所以也是循环)</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; t.NumMethod(); i++ &#123;</span><br><span class="line">    m := t.Method(i)</span><br><span class="line">    fmt.Printf(<span class="string">"%s: %v\n"</span>, m.Name, m.Type) <span class="comment">//Type表示方法的签名 //Print: func(main.User)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到的是 receiver 就是函数的第一个参数。</p>
<p>关于入参，如果传进来的是指针则不太好办，一般用 kind 做一下检查</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(usr User)</span><span class="title">Info</span><span class="params">(obj empty)</span></span> &#123;</span><br><span class="line">    <span class="comment">//拿到类型</span></span><br><span class="line">    t := reflect.TypeOf(obj) <span class="comment">// t 是 Type接口的实例副本</span></span><br><span class="line">    fmt.Println(<span class="string">"Type:"</span>, t.Name()) <span class="comment">//结构类型是有方法的，所以可以调用 Name()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> kind := t.Kind(); kind != reflect.Struct &#123;</span><br><span class="line">        fmt.Println(<span class="string">"传入反射函数的参数不是实例类型，您是不是传入了指针？"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*下面代码，获取类型，值部分一样*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果有嵌入(匿名的和有名的)字段怎么办？</li>
<li>怎么样调用结构的方法(有参数的和无参数的)</li>
</ul>
<p><strong>嵌入结构</strong>: (嵌入结构当做外层结构的一个字段来解析)</p>
<ul>
<li>操作类型信息</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">    User <span class="comment">//只写了类型, 相当于匿名字段</span></span><br><span class="line">    title <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    m := Manager&#123;User&#123;<span class="number">1</span>, <span class="string">"bob"</span>, <span class="number">30</span>&#125;, <span class="string">"manager"</span>&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射代码 - 对类型操作</span></span><br><span class="line">    typeManger := reflect.TypeOf(m)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Field 拿到完整的匿名结构</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, typeManger.Field(<span class="number">0</span>)) </span><br><span class="line">    fmt.Printf(<span class="string">"%#v\n"</span>, typeManger.Field(<span class="number">0</span>)) <span class="comment">//输出完整结构信息</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//FieldByIndex 拿到匿名结构内的所有字段, 以 slice 索引的形式</span></span><br><span class="line">    <span class="comment">//直接拿到 manager, 相当于 Field(0)</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, typeManger.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>&#125;))</span><br><span class="line">    <span class="comment">//取得 user.id </span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, typeManger.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">0</span>&#125;)) <span class="comment">//直接传递的 slice 要指定两级索引值</span></span><br><span class="line">    <span class="comment">//相对于 Manager 而言 User 是第0个，相对于 User 而言 Id 是第0个。</span></span><br><span class="line">    <span class="comment">//取得 user.name</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, typeManger.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取得 manager.title</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, typeManger.FieldByIndex([]<span class="keyword">int</span>&#123;<span class="number">1</span>&#125;))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//FieldByName, 同样用于取得 manager.title</span></span><br><span class="line">    titleName,_ := typeManger.FieldByName(<span class="string">"title"</span>) <span class="comment">//字段名字如果输入错误, 返回为空</span></span><br><span class="line">    fmt.Printf(<span class="string">"%v\n"</span>, titleName)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结起来就是: <strong>操作类型，先拿到反射对象，然后从反射对象入手找Field.</strong></p>
<ul>
<li>操作字段值</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"reflect"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    x := <span class="number">99</span></span><br><span class="line">    fmt.Println(x)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先获得值得反射对象</span></span><br><span class="line">    val := reflect.ValueOf(&amp;x) <span class="comment">//必须传递指针，因为下面要修改原值</span></span><br><span class="line">    val.Elem().SetInt(<span class="number">100</span>)</span><br><span class="line">    <span class="comment">//btw: Elem returns the value that the interface v contains</span></span><br><span class="line"></span><br><span class="line">    fmt.Println(x)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂一点的，操作结构的字段，也是类似的:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span> </span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    Id <span class="keyword">int</span></span><br><span class="line">    Name <span class="keyword">string</span></span><br><span class="line">    Age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := &amp;User&#123;<span class="number">0</span>, <span class="string">"bob"</span>, <span class="number">20</span>&#125;</span><br><span class="line">    fmt.Println(*u)</span><br><span class="line"></span><br><span class="line">    Modify(u) <span class="comment">//传入指针</span></span><br><span class="line">    fmt.Println(*u)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Modify</span><span class="params">(o <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先拿到反射对象 reflect.Value 类型</span></span><br><span class="line">    valObj := reflect.ValueOf(o) </span><br><span class="line">    <span class="comment">//var val Value  //没必要这么定义，valObj本身类型就是 Value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入空接口一定要检查入参</span></span><br><span class="line">    <span class="keyword">if</span> valObj.Kind() != reflect.Ptr || !valObj.Elem().CanSet() &#123;</span><br><span class="line">        fmt.Println(<span class="string">"传入不是指针或者不能改修原结构, 下面操作无法完成，直接退出"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        valObj = valObj.Elem() <span class="comment">//类型都是 Value 可以直接赋值</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*  if age := valObj.FieldByName("Age"); age.Kind() ==reflect.Int &#123;</span></span><br><span class="line"><span class="comment">        age.SetInt(21)</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    age := valObj.FieldByName(<span class="string">"Age"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!age.IsValid()) &#123; <span class="comment">//没有找到返回的是 []Value&#123;&#125;</span></span><br><span class="line">        fmt.Println(<span class="string">"没有找到相关的字段"</span>)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125; <span class="comment">//实际上没有找到字段去设置也是不成功的</span></span><br><span class="line">    <span class="keyword">if</span> age.Kind() == reflect.Int &#123;</span><br><span class="line">        age.SetInt(<span class="number">22</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>调用结构的方法</strong>: (方法必须是 Exported 的)</p>
<p>调用结构的方法，不必要去分辨方法的类型(即原型或者说签名)，直接拿到方法的 Value 进行调用即可。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"reflect"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">    id <span class="keyword">int</span></span><br><span class="line">    name <span class="keyword">string</span></span><br><span class="line">    age <span class="keyword">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//给它添加一个方法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u *User)</span> <span class="title">SetUserAge</span><span class="params">(age <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//fmt.Println("param age = ", age)</span></span><br><span class="line">    u.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(u User)</span> <span class="title">Print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    fmt.Println(u.name, <span class="string">" : "</span>, u.age)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    u := &amp;User&#123;<span class="number">1</span>, <span class="string">"bob"</span>, <span class="number">20</span>&#125;</span><br><span class="line">    fmt.Println(u.age) <span class="comment">//20</span></span><br><span class="line">    u.SetUserAge(<span class="number">21</span>)</span><br><span class="line">    fmt.Println(u.age) <span class="comment">//21 正常调用 ok</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//反射调用 (先拿到反射 Value 对象)</span></span><br><span class="line">    valObj := reflect.ValueOf(u) <span class="comment">//传入的是指针</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*应该做一些检查*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到方法</span></span><br><span class="line">    m := valObj.MethodByName(<span class="string">"SetUserAge"</span>)</span><br><span class="line">    <span class="comment">//设置参数</span></span><br><span class="line">    args := []reflect.Value&#123;reflect.ValueOf(<span class="number">22</span>)&#125; <span class="comment">//int类型的 Value</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//传入参数，反射调用</span></span><br><span class="line">    m.Call(args)</span><br><span class="line">    fmt.Println(u.age) <span class="comment">//22</span></span><br><span class="line"></span><br><span class="line">    m1 := valObj.MethodByName(<span class="string">"Print"</span>)</span><br><span class="line">    m1.Call([]reflect.Value&#123;&#125;) <span class="comment">//无参数调用</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>调用方法时，方法需要的参数，也是 reflect.Value 类型， 即<code>[]Value{}</code>成员要是 Value 类型的</li>
<li>无参数，多参数时，反射调用类似</li>
<li>正规的做法，也要判断方法是否可以被调用，传入的参数是否是指针等</li>
</ul>
<blockquote>
<p>方法也好，字段也好，在反射操作中，一定分开处理 Type 和 Value</p>
</blockquote>
<p>(<strong>因为语言的设计者在设计 API 的时候就是这么设计的</strong>)</p>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/posts/d3fb236/">Golang: Golang 代码走廊</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Merlin</a></p>
        <p><span>发布时间:</span>2018-02-08, 17:29:15</p>
        <p><span>最后更新:</span>2018-04-12, 14:55:17</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/posts/d3fb236/" title="Golang: Golang 代码走廊">http://www.merlinblog.site/posts/d3fb236/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.merlinblog.site/posts/d3fb236/　　作者: Merlin" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/posts/85a160b/">
                    技巧: Numbers(一)
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/posts/16ca5b11/">
                    技巧: Git 多账户工作技巧
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Main函数"><span class="toc-number">1.</span> <span class="toc-text">Main函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import别名"><span class="toc-number">2.</span> <span class="toc-text">import别名</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可见性规则"><span class="toc-number">3.</span> <span class="toc-text">可见性规则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#组定义"><span class="toc-number">4.</span> <span class="toc-text">组定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基本类型"><span class="toc-number">5.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他类型"><span class="toc-number">6.</span> <span class="toc-text">其他类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#零值"><span class="toc-number">7.</span> <span class="toc-text">零值</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式转换"><span class="toc-number">8.</span> <span class="toc-text">隐式转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型转换"><span class="toc-number">9.</span> <span class="toc-text">类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#空白符号"><span class="toc-number">10.</span> <span class="toc-text">空白符号</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常量"><span class="toc-number">11.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举"><span class="toc-number">12.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#运算符"><span class="toc-number">13.</span> <span class="toc-text">运算符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#递增递减"><span class="toc-number">14.</span> <span class="toc-text">递增递减</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#指针"><span class="toc-number">15.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#if条件控制语句"><span class="toc-number">16.</span> <span class="toc-text">if条件控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#switch条件控制语句"><span class="toc-number">17.</span> <span class="toc-text">switch条件控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#循环语句"><span class="toc-number">18.</span> <span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#跳转语句"><span class="toc-number">19.</span> <span class="toc-text">跳转语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">20.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new关键字"><span class="toc-number">21.</span> <span class="toc-text">new关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slice切片"><span class="toc-number">22.</span> <span class="toc-text">slice切片</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">23.</span> <span class="toc-text">map</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">24.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#defer关键字"><span class="toc-number">25.</span> <span class="toc-text">defer关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#panic-recover模式"><span class="toc-number">26.</span> <span class="toc-text">panic/recover模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#struct结构"><span class="toc-number">27.</span> <span class="toc-text">struct结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型方法"><span class="toc-number">28.</span> <span class="toc-text">类型方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#接口"><span class="toc-number">29.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#type-switch"><span class="toc-number">30.</span> <span class="toc-text">type_switch</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#方法集问题"><span class="toc-number">31.</span> <span class="toc-text">方法集问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">32.</span> <span class="toc-text">反射</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/posts/85a160b/" title="上一篇: 技巧: Numbers(一)">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/posts/16ca5b11/" title="下一篇: 技巧: Git 多账户工作技巧">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/7ef0bd11/">技巧: iOS 工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e2300e0/">Golang: 并发聊天室综合案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/74edbb6d/">Golang: TCP 文件传输案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a8342f6/">Golang: TCP 简单并发服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aa0a3cc6/">技巧: B站视频下载脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8180668e/">技巧: 多用户共享 Parralles 虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/55b0329b/">Golang: 值类型&引用类型坑(12)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ac5ecee9/">Golang: 函数类型实现接口封装问题(11)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/eecafb73/">Golang: struct打印输出问题(10)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8f54ef0c/">Golang: string和byte slie字节问题(9)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8a7f81db/">Golang: time计算问题(8)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d4333ec1/">Golang: chan定义问题(7)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aec4de55/">Golang: defer 时机问题(6)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e9bf7e00/">Golang: make和new坑(5)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e0c9893e/">Golang: import和package坑(4)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4ff88030/">Golang: runtime.Gosched 问题(3)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/690caed4/">Golang: HTML Template案例(xml新闻解析+并发改进)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4620296/">Golang: JSON 小案例(读配置文件)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/777e9274/">Golang: JSON 综合案例(天气预报)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/21f718fc/">Golang: RESTful 小案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ad1d8b3/">Golang: 泛型容器的安全问题 (2)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e9ef6fe/">Android: APK細粒度的權限管理設計</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3fde375b/">Golang: 内嵌真的不是继承 (1)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/558a5d81/">Android: 密碼學基礎</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2ff459d4/">Android: 彙編語言基礎</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ede42ab6/">Golang: 注意空接口运行时类型 (0)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bd0987da/">Android: 音频框架&驱动解析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6c3c68b0/">Gcc: Gcc优化指南(5. 功成身退-总结)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/466242ae/">Gcc: Gcc优化指南(4. Gcc & G++ & 相关工具)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/425935e0/">Gcc: Gcc优化指南(3. Gcc Optimize-核心)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5cd24f32/">Gcc: Gcc优化指南(2. Gcc Options)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11ea881a/">Gcc: Gcc优化指南(1. Common Problmes of Path & Libs)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e58a5cc/">量化: 数学和量化研究(0. 总起)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6805cb0/">Gcc: Gcc优化指南(0. Basic Skills)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/78268fe4/">Golang: 标准库解决方案(8.总结-功成身退)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e3c9a06b/">Golang: 标准库解决方案(7.Concurrency)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bb600d10/">Golang: 标准库解决方案(6.REST & JSON API)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2f5310cf/">Golang: 标准库解决方案(5.Web Server & Client)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/40bd3fcc/">Golang: 标准库解决方案(4.Math/Time/Archives/Images)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fedfbade/">Golang: 标准库解决方案(3.处理BuildTools,IO,Error)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/42e1a67a/">Golang: 标准库解决方案(2.处理Strings,Bytes,Runes)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/461f0c5f/">Golang: 标准库解决方案(1.听两位大师讲标准库)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/dbbca7df/">Golang: WebGoGoGo(0.Web编程的方方面面)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/187d6c5a/">Golang: WebGoGoGo(0.概述Web编程)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/94df7563/">Golang: Here We Go(5.孰能生巧-Oreilly大师讲解&再练习)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/53a29a57/">Golang: RobPike谈 并发Vs并行</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9b9dc4cb/">Golang: One Video Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9d17f938/">Golang: 标准库解决方案(0.总起)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e5c13927/">Golang: Think in Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/514585e8/">Golang: Here We Go(4.功成身退-资料&面试题)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4f07614d/">Golang: Here We Go(3.登堂入室-全部语法&大量练习)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/872df2cf/">Golang: Here We Go(2.常用命令&代码结构&语法大纲)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/51cffabe/">Golang: Here We Go(1.安装&&脚本)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d740c2ec/">Golang: Here We Go(0.Google工程师介绍)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/590c21ce/">V-skills 专栏指南</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df51d2c/">技巧: Hexo 置顶问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4111adcd/">技巧: WordPress 迁移&备份技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d61966e4/">略懂: Nginx 折腾</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/12cc604a/">技巧: WordPress upload 最终解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/173f9602/">技术: 深耕 Docker 生态圈(十一){Docker 实践}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5ac3e07f/">技巧: Wordpress 网页(h5) mp4 兼容问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/65a942dd/">技术: 深耕 Docker 生态圈(十一){Docker 三剑客}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a30c0f5f/">技术: 深耕 Docker 生态圈(十){私有仓库配置}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c73a742c/">技术: 深耕 Docker 生态圈(九){Docker 数据管理}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/19c3a85f/">技术: 深耕 Docker 生态圈(八){Docker 网络部分}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b3512db9/">技术: 深耕 Docker 生态圈(七){Docker 的底层实现}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cd70a238/">技术: 深耕 Docker 生态圈(六){Dockerfile 文法}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/36bc3b47/">技术: 深耕 Docker 生态圈(五){自己构建的镜像为何这么大}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cb3fb6f1/">技术: 深耕 Docker 生态圈(四){镜像存储在哪}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e0391b88/">技术: 深耕 Docker 生态圈(三){Docker 指令}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8abfca36/">技术: 深耕 Docker 生态圈(二){配置 Docker }</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70ca69ad/">技术: 深耕 Docker 生态圈(一){总起:安装环境}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9724f8c0/">传送门(Gate)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/683530b4/">略懂: Docker 镜像与容器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ab11b0d1/">略懂: 软件架构模式</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e1b58964/">技术: Sqlite 主键自增(Python接口)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/121fc86a/">技巧: 迁移博客到 VPS (借助hook)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/337aa775/">略懂: 我所认识的 Nodejs</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f8bb990d/">技巧: iOS 原生客户端配置 Gmail</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ecd9f8c2/">略懂: 前端相关的缓存技术</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9b49ffe2/">Golang: 深入探究 Golang 并发</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5009ef69/">技巧: macOS 录屏保存为 gif 格式</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/85a160b/">技巧: Numbers(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d3fb236/">Golang: Golang 代码走廊</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/16ca5b11/">技巧: Git 多账户工作技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7fcc01c2/">技巧: macOs下Qt的Mysql驱动处理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e1b7f878/">技术: Qt 汇总篇</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/15783ed7/">技巧：Makefile相关</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ad67147c/">技巧: HEXO优雅操作</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aa213556/">技巧: macOS中替换rm命令</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ef21388e/">技术: 股票分析客户端分析与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/38fb8eb9/">技术: 网络编程部分汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a7d41a1/">技术: C++最终篇</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ba598705/">技术: Emacs环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3549e702/">技术: Deepin Linux环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1345f1a4/">技术: 网络吞吐量测试</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/65b929a8/">技术: 浅谈我经历的敏捷</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8804d39c/">技术: 网络开发常用工具</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6acc3344/">技术: Thrift</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8276c32/">技术: rapid-json</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17d1767e/">技术: Rapid Xml</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7d13442/">技术: Protocol buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/140bfd50/">技术: Gtest测试框架</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/247b42a4/">技术: 多线程调试问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d48acbe2/">技术: TDD 开发模式实践</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/47fb15b8/">技术: 一个HTTPd的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c62cfa29/">技术: C++网络库(轮子)大杂烩</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9d5b3554/">技术: Asio 异步IO库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e5af6e18/">技术: Boost库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3cd43f14/">技术: Unix Domain Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/87cd3741/">技术: 百万连接问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1d57da8b/">技术: C++ 实现线程池模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6b518c8a/">技术: 服务端网络模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e42d6398/">技术: UDP 模型网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/224e60da/">技术: TCP 模型网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df7a2188/">技术: TCP流解析(粘包和拆包问题)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1334152b/">技术: Epoll 模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8967f437/">技术: Linux 基础套接字模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/81fba862/">技术: Linux网络学习参考</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a4602dea/">技术: Linux网络IO模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cf64f3cd/">技术: Shell代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/33327382/">技术: 开源协议</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be94ecde/">技术: Git 代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1a10be5a/">技术: Python代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cc8315f3/">技术: 高质量Git工作</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3a357315/">技术: Python语言</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/82524a2d/">技术: Qt 网络编程案例汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a46fcd49/">技术: Qt 线程案例汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e3b79a82/">技巧: linux下查看二进制文件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5d0a2cfa/">技术: Qt 实践(汽车销量管理)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/77d8483b/">技巧: Qt 快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/75110831/">技术: JNI</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fdc9b2b9/">技术: C++编程之time问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6ff0a80/">技术: C++11 Lambda 再探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b84fe139/">技术: 对比 Linux 下并发库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/322ce852/">技术: C++11 特性补充</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/189d21c8/">技术: benchmark(lambda 和 bind)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/97d0104d/">技术: C++11 可调用对象function总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d12695b6/">技术: C++11 std::ref 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b43344a7/">技术: C++ 智能指针实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4ead806a/">技术: C++11 Bind 探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9ef88011/">技术: C++ RAII 相关技术总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bb36bf0d/">技术: C++11 Lambda 探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4b19001a/">技术: Linux Bin Utils</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/31dce1ea/">技术: C++ 智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/88802625/">技术: Linux 静态&动态库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ab21303c/">技术: C++11 并发库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bc67b8cb/">技术: 探究一下STL常用算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/640d4b5f/">技术: Linux 编程三大件儿</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/24da8a94/">技术: C++ 迭代器失效问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e53c44b8/">技术: C++ 标准库 STL</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f4144d45/">技术: C++非面向对象部分</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f8283c77/">技术: C++面向对象部分</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be09a73/">技术: 设计模式 C++ 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/956ee661/">技术: mysql-connector-cpp</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b0dbc55e/">技术: 带有移动语义的 C++ 字符串类</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f306f9f9/">技术: C++11 右值相关问题探讨</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e9705375/">技术: C++11 类型萃取</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d93a00e8/">技术: C++11 异常争论</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b7fe58b8/">技术: C++11 模板别名探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/72ae9d55/">技术: C++11 默认函数问题探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a8af70c7/">技术: C++11 auto和decltype总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c8bce253/">技术: Java中正则表达式支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/866a6247/">技术: Python中正则表达式的支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8ebc387/">技术: C++中正则表达式的支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/50c77f46/">技术: C语言中正则表达式的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aea53521/">技术: C++11 tuple 容器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/656a02b/">技术: C++11 hashtable 结构</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4bb5bf03/">技术: C++11 一致性初始化探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6f297fb/">技术: C++11 RangeFor探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70b6b9e7/">技术: C++11 explicit注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/919162f1/">技术: C++11 nullptr探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b744aae/">技术: C++11变长参数模板</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5f4ce2b/">技术: 探究 Linux 线程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1312cbe7/">技术: 探究 Linux 进程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1d2bfb39/">技术: Posix标准一览</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a00e5a90/">隐修者(里程碑)</a></li></ul>




    <script>
        
            yiliaConfig.fancybox = false;
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2018 &nbsp Merlin
            </div>
            <div class="footer-right">
                 blog&nbsp<b>version: </b> &nbsp<a href= "https://github.com/WizardMerlin/Gate#blog版本分支说明" >2.4</a>    <i class="fa fa-heart animated infinite pulse"></i>&nbsp高效流
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110654443-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "Do One Thing......" + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "Do It Well......" + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>