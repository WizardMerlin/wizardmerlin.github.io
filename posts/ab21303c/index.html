<!DOCTYPE html>
<html lang="zh-Hans">
<head>

    <!--[if lt IE 9]>
        <style>body {display: none; background: none !important} </style>
        <meta http-equiv="Refresh" Content="0; url=//outdatedbrowser.com/" />
    <![endif]-->

<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="format-detection" content="telephone=no" />
<meta name="author" content="Merlin" />



<meta name="description" content="techniques of thread in c++, not just only in posix linux">
<meta name="keywords" content="cpp,boost,thread">
<meta property="og:type" content="article">
<meta property="og:title" content="技术: C++11 并发库">
<meta property="og:url" content="http://www.merlinblog.site/posts/ab21303c/index.html">
<meta property="og:site_name" content="梅林日志">
<meta property="og:description" content="techniques of thread in c++, not just only in posix linux">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://omotkhw3y.bkt.clouddn.com/cpp_thread.jpg">
<meta property="og:updated_time" content="2018-04-12T06:55:17.622Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="技术: C++11 并发库">
<meta name="twitter:description" content="techniques of thread in c++, not just only in posix linux">
<meta name="twitter:image" content="http://omotkhw3y.bkt.clouddn.com/cpp_thread.jpg">

<link rel="apple-touch-icon" href= "/apple-touch-icon.png">


    <link rel="alternate" href="/atom.xml" title="梅林日志" type="application/atom+xml">



    <link rel="shortcut icon" href="/favicon.gif">



    <link href="//cdn.bootcss.com/animate.css/3.5.1/animate.min.css" rel="stylesheet">



    <link href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.css" rel="stylesheet">



    <script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
    <link href="//cdn.bootcss.com/pace/1.0.2/themes/red/pace-theme-minimal.css" rel="stylesheet">


<link rel="stylesheet" href="/css/style.css">



<link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">


<title>技术: C++11 并发库 | 梅林日志</title>

<script src="//cdn.bootcss.com/jquery/2.2.4/jquery.min.js"></script>
<script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

<script>
    var yiliaConfig = {
        fancybox: true,
        animate: true,
        isHome: false,
        isPost: true,
        isArchive: false,
        isTag: false,
        isCategory: false,
        fancybox_js: "//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.min.js",
        scrollreveal: "//cdn.bootcss.com/scrollReveal.js/3.1.4/scrollreveal.min.js",
        search: false
    }
</script>


    <script>
        yiliaConfig.jquery_ui = [true, "//cdn.bootcss.com/jqueryui/1.10.4/jquery-ui.min.js", "//cdn.bootcss.com/jqueryui/1.10.4/css/jquery-ui.min.css"];
    </script>



    <script> yiliaConfig.rootUrl = "\/";</script>






</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
    <header id="header" class="inner">
        <a href="/" class="profilepic">
            <img src="/img/mine.png" class="animated zoomIn">
        </a>
        <hgroup>
          <h1 class="header-author"><a href="/">Merlin</a></h1>
        </hgroup>

        
        <p class="header-subtitle">云卷云舒，平常心态</p>
        

        


        

        <div id="switch-area" class="switch-area">
            <div class="switch-wrap">
                <section class="switch-part switch-part1">
                    <nav class="header-menu">
                        <ul>
                        
                            <li><a href="/">主页</a></li>
                        
                            <li><a href="/archives/">[归档]</a></li>
                        
                            <li><a href="/works/">小作品</a></li>
                        
                            <li><a href="/tags/">[标签]</a></li>
                        
                            <li><a href="/about/">关于</a></li>
                        
                        </ul>
                    </nav>
                    <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" href="https://github.com/WizardMerlin" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" href="https://www.douban.com/people/170414854/" title="豆瓣"></a>
                            
                                <a class="fa Email" href="mailto:&#119;&#105;&#122;&#97;&#114;&#100;&#109;&#101;&#114;&#108;&#105;&#110;&#57;&#52;&#53;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa QQ" href="tencent://message/?Menu=yes&uin=3076407405" title="QQ"></a>
                            
                        </ul>
                    </nav>
                </section>
                
                
                
                
                <section class="switch-part switch-part3">
                    <div id="js-friends">
                    
                      <a class="main-nav-link switch-friends-link" href="https://hexo.io">Hexo</a>
                    
                    </div>
                </section>
                

                
                
                <section class="switch-part switch-part4">
                
                    <div id="js-aboutme">极简.</div>
                </section>
                
            </div>
        </div>
    </header>                
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
      <div class="overlay">
          <div class="slider-trigger"></div>
          <h1 class="header-author js-mobile-header hide"><a href="/" title="回到主页">Merlin</a></h1>
      </div>
    <div class="intrude-less">
        <header id="header" class="inner">
            <a href="/" class="profilepic">
                <img src="/img/mine.png" class="animated zoomIn">
            </a>
            <hgroup>
              <h1 class="header-author"><a href="/" title="回到主页">Merlin</a></h1>
            </hgroup>
            
            <p class="header-subtitle">云卷云舒，平常心态</p>
            
            <nav class="header-menu">
                <ul>
                
                    <li><a href="/">主页</a></li>
                
                    <li><a href="/archives/">[归档]</a></li>
                
                    <li><a href="/works/">小作品</a></li>
                
                    <li><a href="/tags/">[标签]</a></li>
                
                    <li><a href="/about/">关于</a></li>
                
                <div class="clearfix"></div>
                </ul>
            </nav>
            <nav class="header-nav">
                        <ul class="social">
                            
                                <a class="fa GitHub" target="_blank" href="https://github.com/WizardMerlin" title="GitHub"></a>
                            
                                <a class="fa 豆瓣" target="_blank" href="https://www.douban.com/people/170414854/" title="豆瓣"></a>
                            
                                <a class="fa Email" target="_blank" href="mailto:&#119;&#105;&#122;&#97;&#114;&#100;&#109;&#101;&#114;&#108;&#105;&#110;&#57;&#52;&#53;&#64;&#103;&#109;&#97;&#105;&#108;&#46;&#99;&#111;&#109;" title="Email"></a>
                            
                                <a class="fa QQ" target="_blank" href="tencent://message/?Menu=yes&uin=3076407405" title="QQ"></a>
                            
                        </ul>
            </nav>
        </header>                
    </div>
    <link class="menu-list" tags="标签" friends="友情链接" about="关于我"/>
</nav>
      <div class="body-wrap"><article id="post-cpp-thread" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/posts/ab21303c/" class="article-date">
      <time datetime="2016-06-29T14:33:11.000Z" itemprop="datePublished">2016-06-29</time>
</a>


    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      技术: C++11 并发库
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
    <div class="article-category tagcloud">
    <a class="article-category-link" href="/categories/技术/">技术</a>
    </div>


        
    <div class="article-tag tagcloud">
        <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/boost/">boost</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/cpp/">cpp</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/thread/">thread</a></li></ul>
    </div>

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
          
        <p>techniques of thread in c++, not just only in posix linux<br><a id="more"></a></p>
<p>如果不看 Futures 库, 整个 C++ 并发库, 就跟 pthread 没有啥区别. 如果加上Futures库, 整个和Boost又没有太多差别. 总之, 整个C++并发库貌似都是在炒冷饭的样子, 不是移植boost, 就是封装底层线程库(例如pthread), 没办法还是仔细说说吧.</p>
<p>关于Pthread, 可以参考我的博文:  <a href="http://www.merlinblog.site/2017/03/19/linux-pthread.html">posix-thread</a><br>关于Boost, 可以参考我的博文: <a href="http://www.merlinblog.site/2017/06/21/boost.html">Boost总结</a></p>
<blockquote>
<p>本文会花非常大的力气总结 C++11 并发库</p>
</blockquote>
<h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>C+11中的实现基本和Boost一致, 只不过命名空间不一样以及涉及的头文件不一样:</p>
<ul>
<li>atomic</li>
<li>mutex</li>
<li>thread</li>
<li>condition_variable</li>
<li>future</li>
</ul>
<p>并且相关效率也不一样, 一般认为: lock, atomic, spinlock三者的效率相当, 但是mutex效率低. (这也是你看到为啥和libevent相比, 不管是asio还是多线程框架, 基本讨不到偏移, 可能就是因为mutex的关系).</p>
<p><code>《C++ Concurrency In Action》</code> 真本书非常推荐, 如果没有时间看完一本书, 那么直接看我说精华, 也不错.</p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>首先c++, 或者boost 为了我们方便的使用线程, 做了很多封装, 什么gud之类的, 反而影响了我们对于线程范畴内最本质内容的理解:</p>
<ul>
<li>线程的控制(创建，销毁/分离)</li>
<li>线程的同步(信号量(PV)，互斥量，竞争/冒险条件，文件锁，屏障)</li>
<li>线程的属性</li>
<li>线程的调试(多线程其实是不好调试的)</li>
</ul>
<hr>
<p>根据 <a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">Cppreference</a> 的说法, C++11并发库包含以下内容:</p>
<ul>
<li>atomic<br>该头文主要声明了两个类, std::atomic 和 std::atomic_flag，另外还声明了一套 C 风格的原子类型和与 C 兼容的原子操作的函数.<br>这个和boost是一致的, 不适用锁就能同步的原子操作</li>
<li>thread<br>该头文件主要声明了 std::thread 类, 另外 <code>std::this_thread</code> 命名空间也在该头文件中.</li>
<li>mutex<br>该头文件主要声明了与互斥量(mutex)相关的类，包括 std::mutex 系列类，std::lock_guard, std::unique_lock, 以及其他的类型和函数</li>
<li>condition_variable<br>该头文件主要声明了与条件变量相关的类，包括 std::condition_variable 和 std::condition_variable_any</li>
<li>future<br>该头文件主要声明了 <code>std::promise</code>, <code>std::package_task</code> 两个 Provider 类，以及 <code>std::future</code> 和 <code>std::shared_future</code> 两个 Future 类<br>另外还有一些与之相关的类型和函数，<code>std::async()</code> 函数就声明在此头文件中</li>
</ul>
<p>其中最后一个future由于涉及到了异步任务, 相当于对于线程的封装(async). 异步任务可以参考我的文章 <a href="http://www.merlinblog.site/2017/08/11/Asio.html">Asio</a></p>
<p>讲真, 从pthread切换过来, 没有感觉到幸福可能是因为pthread api用熟悉了, 但是不得不说c++并发库, 使得并发编程变得简单了.</p>
<p>直接上手一个demo:<br><img src="http://omotkhw3y.bkt.clouddn.com/cpp_thread.jpg" alt=""></p>
<p>可以看到老奸巨猾的c++11, 还是只给出了标准, 具体的实现, 要依赖系统平台的库.</p>
<p>也就是说, linux平台, 我们完全可以认为, c++ 并发库给出了统一的操作API, 实际上是封装了pthread操作(具体封装过程可以参考具体的头文件, 比如创建线程这个, 其实就是根据_type参数判断对应pthread_create()的哪种调用).</p>
<p>虽然只是封装, 但是, 确实精简了太多! 例如我要给线程执行函数传参, 看看下面是不是够简单的:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n1 = <span class="number">500</span>;</span><br><span class="line">    <span class="keyword">int</span> n2 = <span class="number">600</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">([&amp;](<span class="keyword">int</span> addNum)</span></span>&#123;</span><br><span class="line">        n1 += addNum;</span><br><span class="line">        n2 += addNum;</span><br><span class="line">    &#125;,<span class="number">500</span>);</span><br><span class="line">    t.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n1 &lt;&lt; <span class="string">' '</span> &lt;&lt; n2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始细说</p>
<hr>
<h2 id="Threads库"><a href="#Threads库" class="headerlink" title="Threads库"></a>Threads库</h2><p>定义在 <code>thread</code> 头文件下, 该库就两大块儿</p>
<ul>
<li>thread类</li>
<li>this_thread命名空间</li>
</ul>
<h3 id="thread类"><a href="#thread类" class="headerlink" title="thread类"></a>thread类</h3><p>主要说说他的构造器, 赋值函数(移动函数)等成员函数的使用.</p>
<p>构造器:</p>
<ul>
<li><p>默认构造函数，创建一个空的 thread 执行对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread() <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化构造函数，创建一个 thread对象，该 thread对象可被 joinable，新产生的线程会调用 fn 函数，该函数的参数由 args 给出</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Fn</span>, <span class="title">class</span>... <span class="title">Args</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">explicit</span> <span class="title">thread</span> (<span class="title">Fn</span>&amp;&amp; <span class="title">fn</span>, <span class="title">Args</span>&amp;&amp;... <span class="title">args</span>);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝构造函数(被禁用)，意味着 thread 不可被拷贝构造</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread (<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>move 构造函数，move 构造函数，调用成功之后 x 不代表任何 thread 执行对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread (thread&amp;&amp; x) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>参考代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; n &lt;&lt; <span class="string">" executing\n"</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>&amp; n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread 2 executing\n"</span>;</span><br><span class="line">        ++n;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::milliseconds(<span class="number">10</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">std</span>::thread t1; <span class="comment">// t1 is not a thread</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(f1, n + <span class="number">1</span>)</span></span>; <span class="comment">// pass by value</span></span><br><span class="line">    std::thread t3(f2, std::ref(n)); // pass by reference</span><br><span class="line">    std::thread t4(std::move(t3)); // t4 is now running f2(). t3 is no longer a thread</span><br><span class="line">    t2.join();</span><br><span class="line">    t4.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Final value of n is "</span> &lt;&lt; n &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>移动赋值函数</p>
<ul>
<li><p>move 赋值操作，如果当前对象不可 joinable，传递一个右值引用(rhs)给 move 赋值操作；如果当前对象可被 joinable，则调用 terminate() .</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (thread&amp;&amp; rhs) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>拷贝赋值操作被禁用，thread 对象不可被拷贝</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> thread&amp;) = <span class="keyword">delete</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其他成员函数:</p>
<ul>
<li><p>bool joinable() const noexcept; 检查某个线程是否可以被joinable (正在运行的可以被joinable)<br>代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread t;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"before starting, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    t = <span class="built_in">std</span>::thread(foo);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after starting, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    t.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after joining, joinable: "</span> &lt;&lt; t.joinable() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 运行结果:</span></span><br><span class="line"><span class="comment">before starting, joinable: 0</span></span><br><span class="line"><span class="comment">after starting, joinable: 1</span></span><br><span class="line"><span class="comment">after joining, joinable: 0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p><code>最好把joinable理解成正在运行</code> , 后面说成员数join的时候, 还会用到.</p>
</li>
<li>std::thread::id get_id() const noexcept; 获取线程id</li>
<li><p>native_handle_type native_handle(); 返回一个线程handler, 用于实时调度<br>由于系统对于实时调度的支持不同, 所以下面的代码不一定成功.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::mutex iomutex;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">    sched_param sch;</span><br><span class="line">    <span class="keyword">int</span> policy; </span><br><span class="line">    pthread_getschedparam(pthread_self(), &amp;policy, &amp;sch);</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(iomutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Thread "</span> &lt;&lt; num &lt;&lt; <span class="string">" is executing at priority "</span></span><br><span class="line">              &lt;&lt; sch.sched_priority &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1(f, 1), t2(f, 2);</span><br><span class="line"> </span><br><span class="line">    sched_param sch;</span><br><span class="line">    <span class="keyword">int</span> policy; </span><br><span class="line">    pthread_getschedparam(t1.native_handle(), &amp;policy, &amp;sch);</span><br><span class="line">    sch.sched_priority = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">if</span> (pthread_setschedparam(t1.native_handle(), SCHED_FIFO, &amp;sch)) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to setschedparam: "</span> &lt;&lt; <span class="built_in">std</span>::strerror(errno) &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    t1.join(); t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>static unsigned int hardware_concurrency() noexcept; 返回并发数的参考</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//注意这是个静态方法</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> n = <span class="built_in">std</span>::thread::hardware_concurrency();</span><br><span class="line">     <span class="comment">//结果和你的逻辑处理器processor个数保持一致, cat /proc/cpuinfo </span></span><br><span class="line">      <span class="comment">//每个processor 启动一个硬件线程</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="string">" concurrent threads are supported.\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>void join(); 阻塞等待回收其他线程; 只有本线程 <code>joinable is false</code> , 即当前不在运行, 才可以回收其他线程, 否则出现自己等待回收自己, 那就是死锁了.</p>
</li>
<li><p>void detach(); 主要是设置分离的线程自己调用detach方法, 必须当前线程在运行, 即joinable才可以.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">independentThread</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting concurrent thread.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting concurrent thread.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">threadCaller</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Starting thread caller.\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t</span><span class="params">(independentThread)</span></span>;</span><br><span class="line">    t.detach();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Exiting thread caller.\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    threadCaller();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>void swap( thread&amp; other ) noexcept; 交换线程对象所绑定的具体线程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(bar)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::swap(t1, t2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after std::swap(t1, t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    t1.swap(t2);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"after t1.swap(t2):"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 1 id: "</span> &lt;&lt; t1.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread 2 id: "</span> &lt;&lt; t2.get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*运行结果*/</span></span><br><span class="line">thread <span class="number">1</span> id: <span class="number">1892</span></span><br><span class="line">thread <span class="number">2</span> id: <span class="number">2584</span></span><br><span class="line">after <span class="built_in">std</span>::swap(t1, t2):</span><br><span class="line">thread <span class="number">1</span> id: <span class="number">2584</span></span><br><span class="line">thread <span class="number">2</span> id: <span class="number">1892</span></span><br><span class="line">after t1.swap(t2):</span><br><span class="line">thread <span class="number">1</span> id: <span class="number">1892</span></span><br><span class="line">thread <span class="number">2</span> id: <span class="number">2584</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="this-thread"><a href="#this-thread" class="headerlink" title="this_thread"></a>this_thread</h3><p>这个命名空间下, 主要说几个函数:</p>
<ul>
<li><p>yield : void yield() noexcept; 让出cpu, 让其他线程执行.<br>是否阻塞让出cpu和操作系统的实现有关, 也就是说这只是个建议. For example, a first-in-first-out realtime scheduler (SCHED_FIFO in Linux) would suspend the current thread and put it on the back of the queue of the same-priority threads that are ready to run (and if there are no other threads at the same priority, yield has no effect). 样例代码可以看下面:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// "busy sleep" while suggesting that other threads run </span></span><br><span class="line"><span class="comment">// for a small amount of time</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">little_sleep</span><span class="params">(<span class="built_in">std</span>::chrono::microseconds us)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="keyword">auto</span> end = start + us;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//使用的时候注意加上命名空间</span></span><br><span class="line">        <span class="built_in">std</span>::this_thread::yield();</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">std</span>::chrono::high_resolution_clock::now() &lt; end);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line"> </span><br><span class="line">    little_sleep(<span class="built_in">std</span>::chrono::microseconds(<span class="number">100</span>));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> elapsed = <span class="built_in">std</span>::chrono::high_resolution_clock::now() - start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waited for "</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::chrono::duration_cast&lt;<span class="built_in">std</span>::chrono::microseconds&gt;(elapsed).count()</span><br><span class="line">              &lt;&lt; <span class="string">" microseconds\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>get_id : std::thread::id get_id() noexcept; 获取当前线程的id, 类型为 std::thread::id</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::mutex g_display_mutex;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread::id this_id = <span class="built_in">std</span>::this_thread::get_id();</span><br><span class="line"> </span><br><span class="line">    g_display_mutex.lock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread "</span> &lt;&lt; this_id &lt;&lt; <span class="string">" sleeping...\n"</span>;</span><br><span class="line">    g_display_mutex.unlock();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(foo)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(foo)</span></span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sleep_for: 主动睡眠放弃cpu一定时间, 之后自动醒来.(由系统调度), 代码原型如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Rep</span>, <span class="title">class</span> <span class="title">Period</span> &gt; //<span class="title">Rep</span>数字计数单位, <span class="title">Period</span>时间单位</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sleep_for</span>( <span class="title">const</span> <span class="title">std</span>:</span>:chrono::duration&lt;Rep, Period&gt;&amp; sleep_duration );</span><br></pre></td></tr></table></figure>
<p>基本使用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello waiter"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">2</span>s);</span><br><span class="line">    <span class="keyword">auto</span> end = <span class="built_in">std</span>::chrono::high_resolution_clock::now();</span><br><span class="line">    <span class="comment">// 注意持续的时间可以使用std::chrono::duration并提供单位</span></span><br><span class="line">    <span class="built_in">std</span>::chrono::duration&lt;<span class="keyword">double</span>, <span class="built_in">std</span>::milli&gt; elapsed = end-start;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waited "</span> &lt;&lt; elapsed.count() &lt;&lt; <span class="string">" ms\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>sleep_until 睡眠到某个时间点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Clock</span>, <span class="title">class</span> <span class="title">Duration</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">sleep_until</span>( <span class="title">const</span> <span class="title">std</span>:</span>:chrono::time_point&lt;Clock,Duration&gt;&amp; sleep_time );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>std::this_thread下的这几个函数还是经常用到的:</p>
<ul>
<li>yield</li>
<li>get_id</li>
<li>sleep_for</li>
<li>sleep_until</li>
</ul>
<h2 id="Mutex库"><a href="#Mutex库" class="headerlink" title="Mutex库"></a>Mutex库</h2><p>On Linux, it uses pthreads underlying. So it can be thought of pthreads wrapped in C++ style objects. 但是讲到mutex锁, 它提供了一种全新的使用方式.<br>mutex库, 主要是围绕 mutex 以及 lock 展开 (当然也包括它们的变形和封装体). 此外把call_once相关的内容也放入了头文件 <code>mutex</code> 这里.</p>
<p>先看下, 以前再Boost是怎么用的:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;boost/thread.hpp&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> globalVariable;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Reader(<span class="keyword">int</span> waitTime) &#123; _waitTime = waitTime;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Reader Api: "</span> &lt;&lt; globalVariable &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        usleep(_waitTime);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _waitTime;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    Writer(<span class="keyword">int</span> variable, <span class="keyword">int</span> waitTime)</span><br><span class="line">    &#123;</span><br><span class="line">      _writerVariable = variable;</span><br><span class="line">      _waitTime = waitTime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        usleep(_waitTime);</span><br><span class="line">        <span class="comment">// Take lock and modify the global variable</span></span><br><span class="line">        boost::mutex::<span class="function">scoped_lock <span class="title">lock</span><span class="params">(_writerMutex)</span></span>;</span><br><span class="line">        globalVariable = _writerVariable;</span><br><span class="line">        _writerVariable++;</span><br><span class="line">        <span class="comment">// since we have used scoped lock, </span></span><br><span class="line">        <span class="comment">// it automatically unlocks on going out of scope</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _writerVariable;</span><br><span class="line">    <span class="keyword">int</span> _waitTime;</span><br><span class="line">    <span class="keyword">static</span> boost::mutex _writerMutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">boost::mutex</span><br><span class="line">Writer::_writerMutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">Reader <span class="title">reads</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">  <span class="function">Writer <span class="title">writes1</span><span class="params">(<span class="number">100</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line">  <span class="function">Writer <span class="title">writes2</span><span class="params">(<span class="number">200</span>, <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  boost::<span class="function">thread <span class="title">readerThread</span><span class="params">(reads)</span></span>;</span><br><span class="line">  boost::<span class="function">thread <span class="title">writerThread1</span><span class="params">(writes1)</span></span>;</span><br><span class="line">  usleep(<span class="number">100</span>);</span><br><span class="line">  boost::<span class="function">thread <span class="title">writerThread2</span><span class="params">(writes2)</span></span>;</span><br><span class="line"></span><br><span class="line">  readerThread.join();</span><br><span class="line">  writerThread1.join();</span><br><span class="line">  writerThread2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -o boost_mutex boost_mutex.cpp -lboost_thread -lboost_system</span><br><span class="line">$ ./boost_mutex</span><br><span class="line">Reader Api: <span class="number">100</span></span><br><span class="line">Reader Api: <span class="number">100</span></span><br><span class="line">Reader Api: <span class="number">200</span></span><br><span class="line">Reader Api: <span class="number">103</span></span><br><span class="line">Reader Api: <span class="number">104</span></span><br><span class="line">Reader Api: <span class="number">204</span></span><br><span class="line">Reader Api: <span class="number">205</span></span><br><span class="line">Reader Api: <span class="number">206</span></span><br><span class="line">Reader Api: <span class="number">207</span></span><br></pre></td></tr></table></figure></p>
<p>但是加锁和解锁的过程, 用了一个 <code>boost::mutex::scoped_lock lock(_writerMutex);</code> 相当简单.</p>
<p>boost thread就说这么多, 下面接着说c++的mutex库.</p>
<h3 id="mutex"><a href="#mutex" class="headerlink" title="mutex"></a>mutex</h3><p>首先要说的是, 在C++线程库, 很少有, 手动加锁然后解锁的这种传统流程(当然也可以这么做), 一般是使用手动加锁, 自动解锁的形式, 即 一般使用的是 <code>lock_guard</code>, <code>unique_lock</code> 等包装类, 但是包装类也需要Mutex作为锁的基本. 所以还是要介绍一下 mutex 锁: </p>
<ul>
<li>mutex 基本的排它锁(类)</li>
<li>timed_mutex  定时 Mutex (类)</li>
<li>recursive_mutex  递归锁(可以重复上锁)</li>
<li>recursive_timed_mutex 定时递归锁</li>
</ul>
<p>当然也有共享锁:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;mutex&gt;</span><br><span class="line">shared_timed_mutex :	provides shared mutual exclusion facility  (C++14)</span><br><span class="line">shared_mutex :          provides shared mutual exclusion facility  (C++17)</span><br></pre></td></tr></table></figure></p>
<p>基本锁 mutex 类, 仅提供了传统的流程方法:</p>
<ul>
<li>lock : locks the mutex, blocks if the mutex is not available </li>
<li>try_lock : tries to lock the mutex, returns if the mutex is not available </li>
<li>unlock : unlocks the mutex </li>
</ul>
<p>以try_lock为例, 案例如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;chrono&gt;</span><br><span class="line">#include &lt;mutex&gt;</span><br><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;iostream&gt; // std::cout</span><br><span class="line"> </span><br><span class="line">std::chrono::milliseconds interval(100);</span><br><span class="line"> </span><br><span class="line">std::mutex mutex;</span><br><span class="line">int job_shared = 0; //两个线程要修改的(共享)量</span><br><span class="line"> </span><br><span class="line">int job_exclusive = 0; // 两个线程要修改的量, 但不提供mutex保护</span><br><span class="line"> </span><br><span class="line">// this thread can modify both &apos;job_shared&apos; and &apos;job_exclusive&apos;</span><br><span class="line">void job_1() </span><br><span class="line">&#123;</span><br><span class="line">    std::this_thread::sleep_for(interval); // let &apos;job_2&apos; take a lock</span><br><span class="line"> </span><br><span class="line">    while (true) &#123;  //使用 try_lock 离不开循环</span><br><span class="line">        // try to lock mutex to modify &apos;job_shared&apos;</span><br><span class="line">        if (mutex.try_lock()) &#123;</span><br><span class="line">            std::cout &lt;&lt; &quot;job shared (&quot; &lt;&lt; job_shared &lt;&lt; &quot;)\n&quot;;</span><br><span class="line">            mutex.unlock(); //能加上锁, 自然用完要解锁</span><br><span class="line">            return;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // can&apos;t get lock to modify &apos;job_shared&apos;</span><br><span class="line">            // but there is some other work to do</span><br><span class="line">            ++job_exclusive;</span><br><span class="line">            std::cout &lt;&lt; &quot;job exclusive (&quot; &lt;&lt; job_exclusive &lt;&lt; &quot;)\n&quot;;</span><br><span class="line">            std::this_thread::sleep_for(interval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">// this thread can modify only &apos;job_shared&apos;</span><br><span class="line">void job_2() </span><br><span class="line">&#123;</span><br><span class="line">    mutex.lock();</span><br><span class="line">    std::this_thread::sleep_for(5 * interval);</span><br><span class="line">    ++job_shared;</span><br><span class="line">    mutex.unlock();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">    std::thread thread_1(job_1);</span><br><span class="line">    std::thread thread_2(job_2);</span><br><span class="line"> </span><br><span class="line">    thread_1.join();</span><br><span class="line">    thread_2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他额锁, 定时锁和递归锁(重复锁), 主要方法和mutex类相似, 但是稍稍做了改进, 比如定时锁, 如果一直拿不到锁, 这个线程要不要这么傻等着? 要等多久? 要等到某个时刻? 而递归锁则是为同一个线程反复加锁提供了方便, 里三层外三层, 只要是同一个线程, 可以多次对同一个锁进行加锁(解锁次数也要匹配, 不然会报错std::system_error), 但是如果别的线程已经拿到了锁, 别说加三层, 一层也加不了, 所以递归锁方便的是本线程自己; 和其他线程的互斥性不变.</p>
<p>定时锁多了两个方法:</p>
<ul>
<li>try_lock_for (public member function)<br>tries to lock the mutex, returns if the mutex has been unavailable for the specified timeout duration </li>
<li>try_lock_until<br>tries to lock the mutex, returns if the mutex has been unavailable until specified time point has been reached </li>
</ul>
<p>(注意它们的返回值, 成功返回true, 失败返回false; 如果已经有所了, 还在try_lock, 那么其行为是未定义的, 看具体的平台具体怎么实现吧)<br>例如, try_lock_for: Tries to lock the mutex. Blocks until specified timeout_duration has elapsed or the lock is acquired, whichever comes first. On successful lock acquisition returns true, otherwise returns false.</p>
<p>给一个写的不是太好的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// control access to std::cout (非核心逻辑)</span></span><br><span class="line"><span class="built_in">std</span>::mutex cout_mutex; </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面开辟的线程集合, 都在抢这个锁进行ostringstreams输出</span></span><br><span class="line"><span class="built_in">std</span>::timed_mutex mutex; </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">job</span><span class="params">(<span class="keyword">int</span> id)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> Ms = <span class="built_in">std</span>::chrono::milliseconds;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">ostringstream</span> stream;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mutex.try_lock_for(Ms(<span class="number">100</span>))) &#123;</span><br><span class="line">            stream &lt;&lt; <span class="string">"success "</span>;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(Ms(<span class="number">100</span>));</span><br><span class="line">            mutex.unlock();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            stream &lt;&lt; <span class="string">"failed "</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(Ms(<span class="number">100</span>));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(cout_mutex);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"["</span> &lt;&lt; id &lt;&lt; <span class="string">"] "</span> &lt;&lt; stream.str() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//线程集合</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">        threads.emplace_back(job, i);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i: threads) &#123;</span><br><span class="line">        i.join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次强调一下:</p>
<blockquote>
<p>一般很少会用一个Mutex自己去调用成员方法加锁的, 更多的使用全局加锁方法(针对多个锁, 同时或者顺序加锁) 或者 加锁的包装类比如lock_guard或者unique_lock等</p>
</blockquote>
<h3 id="全局加锁算法"><a href="#全局加锁算法" class="headerlink" title="全局加锁算法"></a>全局加锁算法</h3><p>本来上面的 mutex 类自身已经提供了lock 和 try_lock方法, 这里又针对不同锁(单个或者多个, 是否需要顺序加锁)提供了通用方法: (其实是对mutex.lock, unlock等的封装)</p>
<ul>
<li><p>std::lock 阻塞加锁<br>locks specified mutexes, blocks if any are unavailable </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Lockable1</span>, <span class="title">class</span> <span class="title">Lockable2</span>, <span class="title">class</span>... <span class="title">LockableN</span> &gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">lock</span>( <span class="title">Lockable1</span>&amp; <span class="title">lock1</span>, <span class="title">Lockable2</span>&amp; <span class="title">lock2</span>, <span class="title">LockableN</span>&amp;... <span class="title">lockn</span> );</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>std::try_lock 异步加锁<br>attempts to obtain ownership of mutexes via repeated calls to try_lock </p>
</li>
</ul>
<p>这些加锁方法其实是去调用每种lockable对象, 即mutex自身的方法, 然后加锁, 并且不会死锁, 原因如下:</p>
<blockquote>
<p>Locks the given Lockable objects lock1, lock2, …, lockn using a deadlock avoidance algorithm to avoid deadlock. The objects are locked by an unspecified series of calls to lock, try_lock, unlock. If a call to lock or unlock results in an exception, unlock is called for any locked objects before rethrowing.</p>
</blockquote>
<p>简单解释就是, 好比你要连续加两个锁, 现在加完第一个锁, 正要加第二锁的时候, 被强占了cpu, 导致了第二所没有获取, 之后造成了死锁; 如果想要连续一次性加几个锁, 就要这个方法就对了.</p>
<p>但是通用加锁算法, 只提供了加锁, 没有提供解锁方法, 所以, 一般要配合 <code>lock_guard</code> 或者 <code>unique_lock</code> 这类加锁封装类(其实就是把锁作为资源, 用raii手法封装起来)来使用, 下面给出一个案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line">    Employee(<span class="built_in">std</span>::<span class="built_in">string</span> id) : id(id) &#123;&#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> id;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; lunch_partners;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> ret = <span class="string">"Employee "</span> + id + <span class="string">" has lunch partners: "</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">const</span> <span class="keyword">auto</span>&amp; partner : lunch_partners )</span><br><span class="line">            ret += partner + <span class="string">" "</span>;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_mail</span><span class="params">(Employee &amp;, Employee &amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// simulate a time-consuming messaging operation</span></span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 线程执行方法</span></span><br><span class="line"><span class="comment">// 某个Employee往自己的 lunch_partners 列表中添加人员的时候, 不允许其他线程同时操作.</span></span><br><span class="line"><span class="comment">// assign_lunch_partners 把相关的双方互相添加联系, 所以两个Employee都要加锁</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">assign_lunch_partner</span><span class="params">(Employee &amp;e1, Employee &amp;e2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">/* 非核心逻辑</span></span><br><span class="line"><span class="comment">   static std::mutex io_mutex;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">   </span></span><br><span class="line"><span class="comment">   // 确保cout过程不被其他线程打断, 可以连续输出</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        std::lock_guard&lt;std::mutex&gt; lk(io_mutex);</span></span><br><span class="line"><span class="comment">        std::cout &lt;&lt; e1.id &lt;&lt; " and " &lt;&lt; e2.id &lt;&lt; " are waiting for locks" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="comment">// use std::lock to acquire two locks without worrying about </span></span><br><span class="line">    <span class="comment">// other calls to assign_lunch_partner deadlocking us</span></span><br><span class="line">    &#123;</span><br><span class="line">	<span class="comment">//不用检查返回值, 因为加不上锁, 它就一直傻等</span></span><br><span class="line">        <span class="built_in">std</span>::lock(e1.m, e2.m);</span><br><span class="line">			<span class="comment">//adopt_lock表示已经加锁了, 调用lock_guard时不必再去加锁了</span></span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk1(e1.m, <span class="built_in">std</span>::adopt_lock); </span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk2(e2.m, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">				    </span><br><span class="line"></span><br><span class="line">					</span><br><span class="line"><span class="comment">// Equivalent code (if unique_locks are needed, e.g. for condition variables)</span></span><br><span class="line"><span class="comment">//        std::unique_lock&lt;std::mutex&gt; lk1(e1.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//        std::unique_lock&lt;std::mutex&gt; lk2(e2.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//        std::lock(lk1, lk2);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*  非核心逻辑</span></span><br><span class="line"><span class="comment">	//同样确保输出过程不被打断</span></span><br><span class="line"><span class="comment">        &#123;</span></span><br><span class="line"><span class="comment">            std::lock_guard&lt;std::mutex&gt; lk(io_mutex);</span></span><br><span class="line"><span class="comment">            std::cout &lt;&lt; e1.id &lt;&lt; " and " &lt;&lt; e2.id &lt;&lt; " got locks" &lt;&lt; std::endl;</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">		</span></span><br><span class="line"><span class="comment">*/</span>			</span><br><span class="line">        e1.lunch_partners.push_back(e2.id);</span><br><span class="line">        e2.lunch_partners.push_back(e1.id);</span><br><span class="line">    &#125;</span><br><span class="line">    send_mail(e1, e2);</span><br><span class="line">    send_mail(e2, e1);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Employee alice("alice"), bob("bob"), christina("christina"), dave("dave");</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// assign in parallel threads because mailing users about lunch assignments</span></span><br><span class="line">    <span class="comment">// takes a long time</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(alice), <span class="built_in">std</span>::ref(bob));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(christina), <span class="built_in">std</span>::ref(bob));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(christina), <span class="built_in">std</span>::ref(alice));</span><br><span class="line">    threads.emplace_back(assign_lunch_partner, <span class="built_in">std</span>::ref(dave), <span class="built_in">std</span>::ref(bob));</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;thread : threads) thread.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; alice.output() &lt;&lt; <span class="string">'\n'</span>  &lt;&lt; bob.output() &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; christina.output() &lt;&lt; <span class="string">'\n'</span> &lt;&lt; dave.output() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但是如果不用封装类, lock_guard或者unique_lock, 就应该让每个lockable对象分别自己解锁. </p>
<p>std::try_lock也是类似的, 只不过相当于std::lock, 它是非阻塞的, 所以注意检查它的 <code>返回值</code> :(拿不到锁, 它又不会傻等)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Lockable1</span>, <span class="title">class</span> <span class="title">Lockable2</span>, <span class="title">class</span>... <span class="title">LockableN</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">int</span> <span class="title">try_lock</span>( <span class="title">Lockable1</span>&amp; <span class="title">lock1</span>, <span class="title">Lockable2</span>&amp; <span class="title">lock2</span>, <span class="title">LockableN</span>&amp;... <span class="title">lockn</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>按你给定的顺序加锁, 全部成功, 返回-1; 如果哪一个失败就返回哪一个的索引(参数的索引从0开始, 即0-based). 通常仅当所有的加锁成功, 即返回-1的时候才停止try_lock尝试.</p>
<p>可以看下面的代码: (多个锁的 try_lock 实验)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/*一个锁保护一个变量, 两个线程, 分别增加foo_count, bar_count*/</span></span><br><span class="line">    <span class="keyword">int</span> foo_count = <span class="number">0</span>; <span class="built_in">std</span>::mutex foo_count_mutex;</span><br><span class="line">    <span class="keyword">int</span> bar_count = <span class="number">0</span>; <span class="built_in">std</span>::mutex bar_count_mutex;</span><br><span class="line">    <span class="keyword">int</span> overall_count = <span class="number">0</span>; <span class="comment">//上面两个锁都拿到才修改总数</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//主线程, 即main函数所在线程控制是否结束 done 标志, 多余的锁, 见下面分析</span></span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>; <span class="comment">//std::mutex done_mutex;</span></span><br><span class="line">    </span><br><span class="line"> </span><br><span class="line"> <span class="comment">//线程执行函数(用来修改 foo_count, bar_count)</span></span><br><span class="line">    <span class="keyword">auto</span> increment = [](<span class="keyword">int</span> &amp;counter, <span class="built_in">std</span>::mutex &amp;m,  <span class="keyword">const</span> <span class="keyword">char</span> *desc) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(m);</span><br><span class="line">            ++counter;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; desc &lt;&lt; <span class="string">": "</span> &lt;&lt; counter &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">            lock.unlock();</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    std::thread increment_foo(increment, std::ref(foo_count), </span><br><span class="line">        <span class="built_in">std</span>::ref(foo_count_mutex), <span class="string">"foo"</span>);</span><br><span class="line">    std::thread increment_bar(increment, std::ref(bar_count), </span><br><span class="line">        <span class="built_in">std</span>::ref(bar_count_mutex), <span class="string">"bar"</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">update_overall</span><span class="params">([&amp;]()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">//本线程和main线程共同受到done标志的相应, 只是本线程只是检查, 并不修改.</span></span><br><span class="line">						  <span class="comment">// 所以下面弄什么 done_mutex其实是多余</span></span><br><span class="line">        <span class="comment">//done_mutex.lock();</span></span><br><span class="line">		</span><br><span class="line">        <span class="keyword">while</span> (!done) &#123;</span><br><span class="line">            <span class="comment">//done_mutex.unlock();</span></span><br><span class="line">            <span class="keyword">int</span> result = <span class="built_in">std</span>::try_lock(foo_count_mutex, bar_count_mutex);</span><br><span class="line">            <span class="keyword">if</span> (result == <span class="number">-1</span>) &#123; <span class="comment">//两个锁我都拿到才修改overall_count</span></span><br><span class="line">                overall_count += foo_count + bar_count;</span><br><span class="line">                foo_count = <span class="number">0</span>;</span><br><span class="line">                bar_count = <span class="number">0</span>;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"overall: "</span> &lt;&lt; overall_count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">                foo_count_mutex.unlock();</span><br><span class="line">                bar_count_mutex.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>));</span><br><span class="line">            <span class="comment">//done_mutex.lock();</span></span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="comment">//done_mutex.unlock();</span></span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    increment_foo.join(); <span class="comment">//foo_count 增加到10完毕, 回收线程</span></span><br><span class="line">    increment_bar.join(); <span class="comment">//bar_count 增加到10完毕, 回收线程</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//done_mutex.lock();</span></span><br><span class="line">    done = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//done_mutex.unlock();</span></span><br><span class="line">    </span><br><span class="line">    update_overall.join();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done processing\n"</span></span><br><span class="line">              &lt;&lt; <span class="string">"foo: "</span> &lt;&lt; foo_count &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"bar: "</span> &lt;&lt; bar_count &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">              &lt;&lt; <span class="string">"overall: "</span> &lt;&lt; overall_count &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="lock类结构"><a href="#lock类结构" class="headerlink" title="lock类结构"></a>lock类结构</h3><p>BasicLockable 类型的对象只需满足两种操作，lock 和 unlock，<br>Lockable 类型，在 BasicLockable 类型的基础上新增了 try_lock 操作，因此一个满足 Lockable 的对象应支持三种操作：lock，unlock 和 try_lock；<br>TimedLockable 类型，在 Lockable 类型的基础上又新增了 try_lock_for 和 try_lock_until 2种操作，因此一个满足 TimedLockable 的对象应支持五种操作：lock, unlock, try_lock, try_lock_for, try_lock_until</p>
<h3 id="lock包装类"><a href="#lock包装类" class="headerlink" title="lock包装类"></a>lock包装类</h3><p>C++11中单个锁的包装类, 构造的时候m.lock, 析构的时候自动m.unlock (其实就是把锁作为资源, 用raii手法封装起来):</p>
<ul>
<li><code>std::lock_guard</code> 方便线程对互斥量上锁(RAII 手法)的包装类<br>implements a strictly scope-based mutex ownership wrapper </li>
<li><code>std::unique_lock</code> 方便线程对互斥量上锁, 但提供了更好的上锁和解锁控制的包装类<br>implements movable mutex ownership wrapper </li>
</ul>
<p>(严格来说 std::unique_lock应该归类为BasicLockable类型, 即和mutex归为一类) </p>
<p>C++14和C++17中的包装类:</p>
<ul>
<li>shared_lock<br>implements movable shared mutex ownership wrapper </li>
<li>scoped_lock<br>deadlock-avoiding RAII wrapper for multiple mutexes </li>
</ul>
<p>(主要使用 <code>lock_guard</code> 和 <code>unique_lock</code>, 如果是boost, 那么几个就随便用了) </p>
<p>以lock_guard为例:</p>
<ul>
<li>explicit lock_guard( mutex_type&amp; m );</li>
<li>lock_guard( mutex_type&amp; m, std::adopt_lock_t t ); //adopt_lock_t类型表示加锁策略</li>
<li>lock_guard( const lock_guard&amp; ) = delete; //不允许lock_guard间相互赋值</li>
</ul>
<p>(移动构造/移动拷贝也没有)</p>
<p>如果这个线程还再运行, 并且拥有 mutx m, 那么调用<code>lock_guard()</code>就会尝试去拿锁(拿不到阻塞等待). 但是下面的情况是危险的:</p>
<ul>
<li>不是递归mutex, 却要用lock_guard取重复加锁</li>
<li>当前线程不存在了(停止或者被停止运行了), 还想调用lock_guard()</li>
<li>当前线程不拥有该mutex变量</li>
</ul>
<p>(该方法会抛出异常, 一般是m.lock()产生的)</p>
<p>简单的使用案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">int</span> g_i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::mutex g_i_mutex;  <span class="comment">// protects g_i</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">safe_increment</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock(g_i_mutex);</span><br><span class="line">    ++g_i;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// g_i_mutex is automatically released when lock</span></span><br><span class="line">    <span class="comment">// goes out of scope</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t1</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t2</span><span class="params">(safe_increment)</span></span>;</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; __func__ &lt;&lt; <span class="string">": "</span> &lt;&lt; g_i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>lock_guard 只是简单的包装, 它简化了mutex加锁和解锁的过程(但是不维护和管理锁的生命周期), 更加强大的是, std::unique_lock, shared_lock, scoped_lock; C++11中只支持到了unique_lock.</p>
<p>下面说说 unique_lock()</p>
<p>unique_lock 是对 mutex 集合的封装, 新创建的 unique_lock 对象负责传入的 Mutex 对象的上锁和解锁操作, 并且是独占方式. unique_lock支持:</p>
<ul>
<li>延迟加锁(先声明锁, 之后真正用的时候在加锁, 比如使用std::lock())</li>
<li>time-constrained attempts at locking (定义异步加锁)</li>
<li>recursive locking</li>
<li>transfer of lock ownership (但是不支持拷贝, 只支持移动)</li>
<li>use with condition variables</li>
</ul>
<p>和 lock_guard 一样, std::unique_lock 对象也能保证在其自身析构时它所管理的 Mutex 对象能够被正确地解锁(即使没有显式地调用 unlock 函数). 这也是一种简单而又安全的上锁和解锁方式, 尤其是在程序抛出异常后先前已被上锁的 Mutex 对象可以正确进行解锁操作, 极大地简化了程序员编写与 Mutex 相关的异常处理代码. (unique_lock 对象同样也不负责管理 Mutex 对象的生命周期)</p>
<p>下面是延迟锁定的简单使用案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Box</span> &#123;</span></span><br><span class="line">    explicit Box(int num) : num_things&#123;num&#125; &#123;&#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> num_things;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Box &amp;from, Box &amp;to, <span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// don't actually take the locks yet</span></span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock1(from.m, <span class="built_in">std</span>::defer_lock);</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock2(to.m, <span class="built_in">std</span>::defer_lock);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// lock both unique_locks without deadlock</span></span><br><span class="line">    <span class="built_in">std</span>::lock(lock1, lock2);</span><br><span class="line"> </span><br><span class="line">    from.num_things -= num;</span><br><span class="line">    to.num_things += num;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 'from.m' and 'to.m' mutexes unlocked in 'unique_lock' dtors</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Box <span class="title">acc1</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">Box <span class="title">acc2</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    std::thread t1(transfer, std::ref(acc1), std::ref(acc2), 10);</span><br><span class="line">    std::thread t2(transfer, std::ref(acc2), std::ref(acc1), 5);</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>但 unique_lock 给程序员提供了更多的自由, unique_lock 作为一个TimedLockable对象, 支持5种主要操作: lock, unlock, try_lock, try_lock_for, try_lock_until. 主要构造器, 大致上如下:</p>
<ul>
<li>unique_lock() noexcept; //默认构造器</li>
<li>explicit unique_lock(mutex_type&amp; m);  //对应basic mutex, 即含有lock和unlock操作</li>
<li>unique_lock(mutex_type&amp; m, try_to_lock_t tag);  //在上面的基础上增加了try_lock方法</li>
<li>unique_lock(mutex_type&amp; m, defer_lock_t tag) noexcept;  //延迟绑定mutex</li>
<li>unique_lock(mutex_type&amp; m, adopt_lock_t tag);  //中途收养已经加锁的mutex</li>
<li>template <class rep,="" class="" period=""><br>unique_lock(mutex_type&amp; m, const chrono::duration<rep,period>&amp; rel_time);  //带有计时器的mutex的封装, 相当于lock_for</rep,period></class></li>
<li>template <class clock,="" class="" duration=""><br>unique_lock(mutex_type&amp; m, const chrono::time_point<clock,duration>&amp; abs_time);  //相当于lock_until</clock,duration></class></li>
<li>unique_lock(const unique_lock&amp;) = delete;   //禁止拷贝</li>
<li>unique_lock(unique_lock&amp;&amp; x);   //移动转移所有权<br>如果被赋值的对象之前已经获得了它所管理的 Mutex 对象的锁(即已经上锁), 则在移动赋值(move assignment)之前会调用 unlock 函数释放它所占有的锁<br>主要是用在, 创建 unique_lock 的时候不指定 mutex 的情况.<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck;         <span class="comment">// default-constructed</span></span><br><span class="line">lck = <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt;(mtx);  <span class="comment">// move-assigned</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>其他成员函数, 根据 <a href="http://en.cppreference.com/w/cpp/thread/unique_lock" target="_blank" rel="noopener">参考手册</a> 的分类, 应该如下:</p>
<ul>
<li>锁操作类<ul>
<li>lock</li>
<li>try_lock, try_lock_for, try_lock_until</li>
<li>unlock</li>
</ul>
</li>
<li>所有权类<ul>
<li>swap 交换 unique_lock 所关联的 mutex</li>
<li>release 释放所有权(返回指向它所管理的 Mutex 对象的指针并释放所有权)</li>
</ul>
</li>
<li>判别类(只读)<ul>
<li>owns_lock(返回当前 std::unique_lock 对象是否获得了锁, 不仅仅是检查是否关联了 mutex ), 已经加锁则返回true</li>
<li>operator bool (和上面作用一样, 用于判断条件语句中直接使用对象进行判断)</li>
<li>mutex  直接返回相关联的 mutex 的指针</li>
</ul>
</li>
</ul>
<p>但是注意, 如果你要后面自己调用锁操作相关的成员方法, 主要是指加锁操作, (不手动调用unlock, 在作用域结束的时候也会自动调用), 那么初始化 unique_lock的时候, 必须制定为延迟绑定:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">//std::unique_lock&lt;std::mutex&gt; lck (mtx,std::defer_lock);</span><br><span class="line"></span><br><span class="line">//线程执行方法</span><br><span class="line">void print_thread_id (int id) &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck (mtx,std::defer_lock);</span><br><span class="line">  // critical section (exclusive access to std::cout signaled by locking lck):</span><br><span class="line">  lck.lock();</span><br><span class="line">  std::cout &lt;&lt; &quot;thread #&quot; &lt;&lt; id &lt;&lt; &apos;\n&apos;;</span><br><span class="line">  lck.unlock(); //不手动调用也会自动调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//线程执行方法</span><br><span class="line">void print_star () &#123;</span><br><span class="line">  std::unique_lock&lt;std::mutex&gt; lck(mtx,std::defer_lock);</span><br><span class="line">  // print &apos;*&apos; if successfully locked, &apos;x&apos; otherwise: </span><br><span class="line">  if (lck.try_lock())</span><br><span class="line">    std::cout &lt;&lt; &apos;*&apos;;</span><br><span class="line">  else                    </span><br><span class="line">    std::cout &lt;&lt; &apos;x&apos;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//线程执行方法</span><br><span class="line">void fireworks () &#123;</span><br><span class="line">  std::unique_lock&lt;std::timed_mutex&gt; lck(mtx, std::defer_lock);</span><br><span class="line">  // waiting to get a lock: each thread prints &quot;-&quot; every 200ms:</span><br><span class="line">  while (!lck.try_lock_for(std::chrono::milliseconds(200))) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;-&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  // got a lock! - wait for 1s, then this thread prints &quot;*&quot;</span><br><span class="line">  std::this_thread::sleep_for(std::chrono::milliseconds(1000));</span><br><span class="line">  std::cout &lt;&lt; &quot;*\n&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然, 如果你使用 <code>std::try_to_lock</code> 这种参数, 那么初始化的时候, 就会尝试加锁了:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;         // std::vector</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;          // std::mutex, std::unique_lock, std::try_to_lock</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx;           <span class="comment">// mutex for critical section</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_star</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lck(mtx,<span class="built_in">std</span>::try_to_lock);</span><br><span class="line">  <span class="comment">// print '*' if successfully locked, 'x' otherwise: </span></span><br><span class="line">  <span class="keyword">if</span> (lck.owns_lock()) <span class="comment">// 等价于 if(lck)</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'*'</span>;</span><br><span class="line">  <span class="keyword">else</span>                    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">'x'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; ++i)</span><br><span class="line">    threads.emplace_back(<span class="built_in">std</span>::thread(print_star));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; x: threads) x.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>仔细一看, unique_lock 比 lock_guard 灵活不少, 但是lock_guard设计目的明显而又简单.</p>
<h3 id="lock-t"><a href="#lock-t" class="headerlink" title="lock_t"></a>lock_t</h3><p>上面说 std::lock_guard, std::scoped_lock, std::unique_lock, and std::shared_lock 的时候, 已经涉及到这个结构体了, 代表上锁的策略( tag type used to specify locking strategy). </p>
<p>它们的用法不同:</p>
<ul>
<li>defer_lock_t    do not acquire ownership of the mutex (延后获取, 真正加锁的时候才获取所有权; 构造只是声明以后的联系)</li>
<li>try_to_lock_t    try to acquire ownership of the mutex without blocking</li>
<li>adopt_lock_t    assume the calling thread already has ownership of the mutex</li>
</ul>
<p>它们都可以作为参数传入给 unique_lock 或 lock_guard 的构造函数, 但是具体意义是不同的.</p>
<p>一个案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bank_account</span> &#123;</span></span><br><span class="line">    explicit bank_account(int balance) : balance(balance) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> balance;</span><br><span class="line">    <span class="built_in">std</span>::mutex m;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">transfer</span><span class="params">(bank_account &amp;from, bank_account &amp;to, <span class="keyword">int</span> amount)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// lock both mutexes without deadlock</span></span><br><span class="line">    <span class="built_in">std</span>::lock(from.m, to.m);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// make sure both already-locked mutexes are unlocked at the end of scope</span></span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock1(from.m, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line">    <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lock2(to.m, <span class="built_in">std</span>::adopt_lock);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//  上面的代码等价于(equivalent approach): //derfer_lock表明自己手动加锁</span></span><br><span class="line"><span class="comment">//    std::unique_lock&lt;std::mutex&gt; lock1(from.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//    std::unique_lock&lt;std::mutex&gt; lock2(to.m, std::defer_lock);</span></span><br><span class="line"><span class="comment">//    std::lock(lock1, lock2);</span></span><br><span class="line"> </span><br><span class="line">    from.balance -= amount;</span><br><span class="line">    to.balance += amount;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">bank_account <span class="title">my_account</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line">    <span class="function">bank_account <span class="title">your_account</span><span class="params">(<span class="number">50</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    std::thread t1(transfer, std::ref(my_account), std::ref(your_account), 10);</span><br><span class="line">    std::thread t2(transfer, std::ref(your_account), std::ref(my_account), 5);</span><br><span class="line"> </span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="call-once"><a href="#call-once" class="headerlink" title="call_once"></a>call_once</h3><p>在pthreads中是这样用的<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_once_t</span> once_control = PTHREAD_ONCE_INIT;</span><br><span class="line">int pthread_once(pthread_once_t *once_control, void (*init_routine) (void));</span><br></pre></td></tr></table></figure></p>
<p>为了确保某些变量只在多线程环境中初始化一次, 要求 <code>once_control</code> 初始化指定的值, 而全部的这个flag是由库维护的保证了其互斥性. (c++中也可以用aotomic进行代替)</p>
<p>在C++这个并发库中, 类似的使用 <code>std::call_once</code> 来解决:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt; <span class="class"><span class="keyword">class</span> <span class="title">Function</span>, <span class="title">class</span>... <span class="title">Args</span> &gt;  </span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">call_once</span> ( <span class="title">std</span>:</span>:once_flag&amp; flag, Function&amp;&amp; f, Args&amp;&amp; args... );</span><br></pre></td></tr></table></figure>
<p>注意这个函数时会抛出异常的(当f运行出错时): std::system_error if any condition prevents calls to call_once from executing as specified any exception thrown by f .<br>按照c++标准的介绍, 应该是如果第一次调用没有成功的话，那么第二次还会继续调用，一次类推直到调用成功为止。(实际上, 根据不同的实现, 表现结果也有一点儿差别)</p>
<p>简单的使用案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; staticData;  </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; initializeStaticData ()  </span><br><span class="line">&#123;  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; vec;  </span><br><span class="line">    vec.push_back (<span class="string">"initialize"</span>);  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> vec;  <span class="comment">//值拷贝</span></span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">std</span>::once_flag oc;  </span><br><span class="line">    <span class="built_in">std</span>::call_once(oc, [] &#123; staticData = initializeStaticData ();&#125;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在本例中是系统自动初始化它(实际上onc_flag类的内部状态在调用call_once时采取设置, 不用担心), 并且注意std::once_flag is neither copyable nor movable.</p>
<p>但是上面的案例是不规范的, 说过的, 它是会抛出异常的, 下面看一个可能抛出异常的案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::once_flag flag1, flag2;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">simple_do_once</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::call_once(flag1, []()&#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Simple example: called once\n"</span>; &#125;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">may_throw_function</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (do_throw) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"throw: call_once will retry\n"</span>; <span class="comment">// this may appear more than once</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Didn't throw, call_once will not attempt again\n"</span>; <span class="comment">// guaranteed once</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_once</span><span class="params">(<span class="keyword">bool</span> do_throw)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"pid = "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//可能抛出异常</span></span><br><span class="line">    <span class="built_in">std</span>::call_once(flag2, may_throw_function, do_throw);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">    <span class="comment">//do nothing</span></span><br><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"unlock yes ?"</span>  &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//可惜只执行一次</span></span><br><span class="line">    <span class="comment">// std::thread st1(simple_do_once);</span></span><br><span class="line">    <span class="comment">// std::thread st2(simple_do_once);</span></span><br><span class="line">    <span class="comment">// std::thread st3(simple_do_once);</span></span><br><span class="line">    <span class="comment">// std::thread st4(simple_do_once);</span></span><br><span class="line">    <span class="comment">// st1.join();</span></span><br><span class="line">    <span class="comment">// st2.join();</span></span><br><span class="line">    <span class="comment">// st3.join();</span></span><br><span class="line">    <span class="comment">// st4.join();</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">//std::thread t1(do_once, true);</span></span><br><span class="line">    <span class="comment">//std::thread t2(do_once, true);	</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t3</span><span class="params">(do_once, <span class="literal">false</span>)</span></span>; <span class="comment">//直到不再抛出异常, 才算执行了一次</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">t4</span><span class="params">(do_once, <span class="literal">true</span>)</span></span>;</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>本质上来说, 异常和线程pthread的库在内核的futex同步机制上(内核互斥对象处理上), 貌似没有做的很好; 所以如果你不注释掉相应的行<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//std::thread t1(do_once, true);</span></span><br><span class="line">   <span class="comment">//std::thread t2(do_once, true);</span></span><br></pre></td></tr></table></figure></p>
<p>就可能产生死锁, 运行类似下面的结果:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pid = pid = 140252808775424</span><br><span class="line">pid = 140252800382720</span><br><span class="line">throw: call_once will retry</span><br><span class="line">140252817168128</span><br><span class="line">unlock yes ?</span><br><span class="line">pid = 140252791990016</span><br></pre></td></tr></table></figure></p>
<p>查看线程堆栈, 发现3个线程在等待内核的互斥对象:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Thread 4 (Thread 0x7fe23bfff700 (LWP 8588)):</span><br><span class="line">#0  0x00007fe2452006ef in futex_wait (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/unix/sysv/linux/futex-internal.h:61</span><br><span class="line">#1  futex_wait_simple (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/nptl/futex-internal.h:135</span><br><span class="line">#2  __pthread_once_slow (once_control=0xcb536311d8 &lt;flag2&gt;, init_routine=0x7fe244f293c0 &lt;__once_proxy&gt;) at pthread_once.c:105</span><br><span class="line">0x000000cb5342e3b1 in do_once (do_throw=true) at callonce.cpp:26</span><br><span class="line"></span><br><span class="line">Thread 3 (Thread 0x7fe243514700 (LWP 8587)):</span><br><span class="line">#0  0x00007fe2452006ef in futex_wait (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/unix/sysv/linux/futex-internal.h:61</span><br><span class="line">#1  futex_wait_simple (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/nptl/futex-internal.h:135</span><br><span class="line">#2  __pthread_once_slow (once_control=0xcb536311d8 &lt;flag2&gt;, init_routine=0x7fe244f293c0 &lt;__once_proxy&gt;) at pthread_once.c:105</span><br><span class="line">0x000000cb5342e3b1 in do_once (do_throw=false) at callonce.cpp:26</span><br><span class="line"></span><br><span class="line">Thread 2 (Thread 0x7fe243d65700 (LWP 8586)):</span><br><span class="line">#0  0x00007fe2452006ef in futex_wait (private=0, expected=1, futex_word=0xcb536311d8 &lt;flag2&gt;) at ../sysdeps/unix/sysv/linux/futex-internal.h:61</span><br><span class="line">#1  fusimple (private=0, expected=1, rnal.h:135</span><br><span class="line">#2  __nce_slow (once_control=0xcb5363thread_once.c:105</span><br><span class="line">0x342e3b1 in do_once (do_throw=true) at callonce.cpp:26</span><br><span class="line"></span><br><span class="line">//还有一个已经跑完的,但是没有释放锁的线程</span><br><span class="line">Threadd 0x7fe245605740 (LWP 8584)):</span><br><span class="line">#0  0x51fa67d in pthread_join (threadid=140609777456896, thread_return=0x0) at pthread_join.c:90</span><br><span class="line">#1  0x4f2a397 in std::thread::join() () from /usr/lib/x86_64-linux-gnu/libstdc++.so.6</span><br><span class="line">#2  0x342e48b in main () at callonce.cpp:51</span><br></pre></td></tr></table></figure></p>
<p>但是如果 <code>t3</code> 最先执行, 那么最好不过了, 可以直接运行结束, 而不会产生死锁(你多运行几次)<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">= pid = 139844931725056</span><br><span class="line">Didn&apos;t throw, call_once will not attempt again</span><br><span class="line">139844923332352</span><br><span class="line">pid = 139844940117760</span><br><span class="line">pid = 139844948510464</span><br></pre></td></tr></table></figure></p>
<p>如果你涉及到异常, call_once可以很好的用于初始化(拿到一个实例)一次, 例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span> &#123;</span>  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    <span class="keyword">mutable</span> <span class="built_in">std</span>::once_flag initDataFlag;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">initData</span> <span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;  </span><br><span class="line">        _data = <span class="string">"init"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> _data;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">std</span>::<span class="function"><span class="built_in">string</span>&amp; <span class="title">getData</span> <span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="built_in">std</span>::call_once (initDataFlag, &amp;X::initData, <span class="keyword">this</span>);  </span><br><span class="line">        <span class="keyword">return</span> _data;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果返回相关实例的话, 这就是一个单例啊.</p>
<h2 id="condition-variable库"><a href="#condition-variable库" class="headerlink" title="condition_variable库"></a>condition_variable库</h2><p>该库的头文件如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt; condition_variable &gt;</span><br></pre></td></tr></table></figure></p>
<p>这个里面主要包括2个类和1个函数:</p>
<ul>
<li>condition_variable 类</li>
<li>condition_variable_any 类</li>
<li>notify_all_at_thread_exit 函数</li>
</ul>
<p>额外的还有一个枚举类型 <code>cv_status</code></p>
<p>配合mutex或者mutex的包装类使用, 个人感觉比 pthreads 要简单一些.</p>
<p>与 std::condition_variable 类似, 只不过 std::condition_variable_any 的 wait 函数可以接受任何 lockable 参数(它就是一个类模板), 而 std::condition_variable 只能接受 std::unique_lock<std::mutex> 类型的参数, 除此以外, 和 std::condition_variable 几乎完全一样.  下面重点说 <code>std::condition_variable</code> .</std::mutex></p>
<p>看下api, 大致也就和pthreads的 <code>pthread_cond_*()</code> 用法类似, 可能名字不太一样.</p>
<p>大致把成员函数分类一下：</p>
<ul>
<li>wait系列 (条件不满足&amp;拿不到锁, 等待)<ul>
<li>wait</li>
<li>wait_until</li>
<li>wait_for</li>
</ul>
</li>
<li>notify系列<ul>
<li>notify_one</li>
<li>notify_all</li>
</ul>
</li>
<li>构造系列 (条件变量和锁绑定, 相互复制没有意义)<ul>
<li>condition_variable();</li>
<li>condition_variable(const condition_variable&amp;) = delete;</li>
</ul>
</li>
</ul>
<p>为什么条件变量要初始化要绑锁？<br>因为给下属放权很重要，cv判断条件是否满足从而决定是否竞争锁，这期间cv需要有主动放锁和主动加锁的权利.</p>
<p>std::condition_variable 对象通常使用 std::unique_lock<std::mutex> 来等待, 等待前先加锁. 等待时, 如果条件不满足, wait 会原子性地解锁并把线程挂起.</std::mutex></p>
<p>好吧, 我强调一下:</p>
<blockquote>
<p>与条件变量搭配使用的锁必须是 unique_lock, 不能用 lock_guard.</p>
</blockquote>
<p>直接看一下案例代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;                // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;                // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;                // std::mutex, std::unique_lock</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;    // std::condition_variable</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::mutex mtx; <span class="comment">// 全局互斥锁.</span></span><br><span class="line"><span class="built_in">std</span>::condition_variable cv; <span class="comment">// 全局条件变量.</span></span><br><span class="line"><span class="keyword">bool</span> ready = <span class="literal">false</span>; <span class="comment">// 全局标志位.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_print_id</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">    <span class="keyword">while</span> (!ready) &#123;</span><br><span class="line">    	  <span class="comment">// 条件不满足, 放锁, 等待重新加锁</span></span><br><span class="line">	     <span class="comment">// 该线程执行阻塞在这条语句</span></span><br><span class="line">        cv.wait(lck); </span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//被别的线程唤醒并抢到了锁</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread "</span> &lt;&lt; id &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::thread threads[<span class="number">10</span>];</span><br><span class="line">    <span class="comment">// spawn 10 threads:</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">        threads[i] = <span class="built_in">std</span>::thread(do_print_id, i);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"10 threads ready to race...\n"</span>;</span><br><span class="line">    </span><br><span class="line">    &#123;</span><br><span class="line">	<span class="built_in">std</span>::unique_lock &lt;<span class="built_in">std</span>::mutex&gt; lck(mtx);</span><br><span class="line">	ready = <span class="literal">true</span>; <span class="comment">// 设置全局标志位为 true.</span></span><br><span class="line">	cv.notify_all(); <span class="comment">// 唤醒所有线程.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cv.notify_one(); //请先通知再放锁			       </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp; th:threads) &#123;</span><br><span class="line">        th.join();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至于先放锁，再通知别人，还是先通知别人再放锁， 再pthread里面讨论过， 不在多说.<br>一般只有两个线程， 才会用到 <code>notify_one</code> , 因为”通知”非彼即此.</p>
<p>(即使接到通知了也不一定能抢到锁, 还是要看操作系统的调度策略, 比如优先级高的先来之类的)</p>
<p>下面说说 wait 系列的函数.</p>
<ul>
<li>void wait (unique_lock<mutex>&amp; lck); //无条件放锁阻塞等待</mutex></li>
<li>template <class predicate=""><br>void wait (unique_lock<mutex>&amp; lck, Predicate pred); //自带预判条件</mutex></class></li>
</ul>
<p>它俩的区别是？ 第二种情况设置了前置条件, 它相当于:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (!pred()) &#123;</span><br><span class="line">    cv.wait(lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意 pred 是一个为此函数, 例如lambda表达式之类的 <code>[]{return i == 1;}</code> , 当然你也可以把它写成函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">equalsOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> i == <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面有一个简单的案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">std</span>::condition_variable cv;</span><br><span class="line"><span class="built_in">std</span>::mutex cv_m; <span class="comment">// This mutex is used for three purposes:</span></span><br><span class="line">                 <span class="comment">// 1) to synchronize accesses to i</span></span><br><span class="line">                 <span class="comment">// 2) to synchronize accesses to std::cerr</span></span><br><span class="line">                 <span class="comment">// 3) for the condition variable cv</span></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">waits</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lk(cv_m);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Waiting... \n"</span>;</span><br><span class="line">    cv.wait(lk, []&#123;<span class="keyword">return</span> i == <span class="number">1</span>;&#125;);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"...finished waiting. i == 1\n"</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signals</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(cv_m);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Notifying...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_all();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line"> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::lock_guard&lt;<span class="built_in">std</span>::mutex&gt; lk(cv_m);</span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"Notifying again...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cv.notify_all();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    std::thread t1(waits), t2(waits), t3(waits), t4(signals);</span><br><span class="line">    t1.join(); </span><br><span class="line">    t2.join(); </span><br><span class="line">    t3.join();</span><br><span class="line">    t4.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>todo</p>
<h2 id="Futures库"><a href="#Futures库" class="headerlink" title="Futures库"></a>Futures库</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>当时学习 boost 的时候, 这一篇是直接一带而过的, 因为平常都没有怎么用到这个库.这个库和异步任务(简单理解成单独封装&amp;运行在独立线程中的任务)有关, 和线程间传递数据(当然包括共享数据–即同步)有关. Futures本身又是指期货, 未来交易的一种约定&amp;协议.  </p>
<p>怎么样理解这个库呢? Wiki上面给了很好的解释:</p>
<blockquote>
<p>In computer science, future, promise, delay, and deferred refer to constructs used for synchronizing program execution in some concurrent programming languages. They describe an object that acts as a proxy for a result that is initially unknown, usually because the computation of its value is yet incomplete.</p>
</blockquote>
<p>联系实际编程实体, 其实就很好理解了: 线程本身运行是互不干扰的, 虽然它们可以互相的共享一些资源. 那么两个独立运行的实体, 怎么通信交流呢? 就通过约定或者协议来了, 交流呢就通过promise对象来, 约定我这个线程的执行结果存储在一个叫做 futures的实体里, 另外的线程体执行体, 你们要结果先同步等待着(这个同步可能被封装起来, 你看不到它们显示的在wait或者被mutex挡住), 之后有了值就去取(而不是在那傻等) 所以这个过程是异步过程(可能有个线程在同步等待, 比如主线程).</p>
<p>并且这种约定, 通常是运行之前就要约定好, 我这个线程里面跑的是个什么任务(package_task), 我运行期来之后, 别的线程要交流就通过 promise (我给promise写值), 这个代理对象, 我没有给它值之前, 别的需要从这个对象获取值的其他线程就同步等待, 而且只能通过与promise关联的futures获取, 之后我这个线程运行的任务结束了, 有需要结果, 但是又在运行中不能傻等在那儿等结果的线程, 可以异步的从futures得到结果(当然我结束了给一个回调通知也是可以的?).</p>
<p>如何匹配future/promise对呢？ (建立相关的关联) 一个在我的线程, 另一个在别的啥线程中么？<br>既然 future 和 promise 可以被到处移动(不是拷贝), 那么可能性就挺多的.<br>最普遍的情况是父子线程配对形式, 父线程用future获取子线程promise返回的值. 在这种情况下, 使用async()是很优雅的方法.</p>
<p>如果还是没有听明白, 直接看代码吧, 这段代码是这么个意思:</p>
<blockquote>
<p>一个double数组求和的任务, 我(主线程) 分别交给两个子线程去求和(一个求前半个数组的和, 一个求后半个数组的和), 之后分别返回后, 我主线程在完成最后的求和工作.</p>
</blockquote>
<p>大致代码如下: (同步&amp;协作)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">accumulate_all</span><span class="params">(<span class="built_in">vector</span>&amp; v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// package the tasks: </span></span><br><span class="line">	<span class="comment">//用accumulate算法计算 doubles 数据的和</span></span><br><span class="line">	<span class="comment">//注意 task 内部已经处理好了写入promise的操作</span></span><br><span class="line">	packaged_task pt0&#123;<span class="built_in">std</span>::accumulate&#125;;</span><br><span class="line">	packaged_task pt1&#123;<span class="built_in">std</span>::accumulate&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> f0 = pt0.get_future(); <span class="comment">// get hold of the futures</span></span><br><span class="line">	<span class="keyword">auto</span> f1 = pt1.get_future();</span><br><span class="line"></span><br><span class="line">	<span class="comment">//把任务分解到两个线程; 分别完成后, 在主线程完成最终求和计算</span></span><br><span class="line">	pt0(&amp;v[<span class="number">0</span>],&amp;v[v.size()/<span class="number">2</span>],<span class="number">0</span>); <span class="comment">// start the threads</span></span><br><span class="line">	pt1(&amp;[v.size()/<span class="number">2</span>],&amp;v[size()],<span class="number">0</span>); <span class="comment">// packageed_task 封装了线程</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> f0.get()+f1.get(); <span class="comment">// get the results</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>packaged_task</code> 提供了启动任务的简单方法(但是并没有单独开辟线程, 还是在本线程内执行的). 特别是它处理好了 future 和 promise 的关联关系, 同时提供了包装代码(就是put方法)以保证返回值/异常可以放到 promise 中.</p>
<p>总结:<br>C++11并发库提供了 future 和 promise 来简化任务线程间的传值(返回值)操作; 同时为启动任务提供了packaged_task以方便的封装(也可以通过 std::packaged_task 拿到future, 获取future_status, 但是想put或者set还是需要promise).</p>
<p>其中的关键点是允许2个任务间使用无(显式)锁的方式进行值传递(标准库帮你高效的封装好了). </p>
<p>async()基本实现思路: 当一个任务需要另外一个线程(启动它的线程)返回值时, 它把这个值放到promise中. 之后这个返回值会出现在和此 promise 关联的 future 中. 于是另外线程就能读到返回值, 从futures中读取(当然你最好先判断一下 futures_status 为 ready 状态). </p>
<h3 id="provider"><a href="#provider" class="headerlink" title="provider"></a>provider</h3><p>该部分主要说:</p>
<ul>
<li>std::promise</li>
<li>std::package_task</li>
</ul>
<p>以及 provider 相关的函数 std::async() 和 std::launch.</p>
<p>下面先说 promise.</p>
<p>promise的主要目的是提供一个”put”(也能”get”)操作以和 future 的 get() 对应, 在 promise 对象构造时可以和一个共享状态（通常是std::future）相关联, 并可以在相关联的共享状态(std::future)上保存一个类型为 T 的值. promise 对象是异步 Provider，它可以在某一时刻设置共享状态的值. 可以通过 get_future 来获取与该 promise 对象相关联的 future 对象, 并且用到其set方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::future&lt;T&gt; get_future();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据声明时promise的参数不同, 有不同的setter</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">( <span class="keyword">const</span> R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">( R&amp;&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">( R&amp; value )</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_value</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>promise为future传递的结果类型有2种: (set_xxx)</p>
<ul>
<li>传一个普通值 (set_value, set_value_at_thread_exit)</li>
<li>抛出一个异常 (set_exception, set_exception_at_thread_exit)</li>
</ul>
<p>基本用法不同:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  X res;</span><br><span class="line">  <span class="comment">// compute a value for res</span></span><br><span class="line">  p.set_value(res);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (...) &#123; <span class="comment">// oops: couldn't compute res</span></span><br><span class="line">  p.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于 get_future:<br>返回的 future 对象可以访问由 promise 对象设置在共享状态上的值或者某个异常对象。只能从 promise 共享状态获取一个 future 对象。如果关联了 future 的promise不设置值或者异常, 那么 promise对象在析构时会自动地设置一个 future_error 异常(broken_promise). 设置promise的值&amp;异常，此后 promise 的共享状态标志变为 ready.</p>
<p>下面有一个简单的例子: (主线程通过promise设置值, 让其他线程通过相关联的future去获取值)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;     // std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;         // std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int</span><span class="params">(<span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt;&amp; fut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = fut.get(); <span class="comment">// 获取共享状态的值.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>; <span class="comment">// 打印 value: 10.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; prom; <span class="comment">// 生成一个 std::promise&lt;int&gt; 对象.</span></span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future(); <span class="comment">// 和 future 关联.</span></span><br><span class="line">    std::thread t(print_int, std::ref(fut)); // 将 future 交给另外一个线程t.</span><br><span class="line">    prom.set_value(<span class="number">10</span>); <span class="comment">// 设置共享状态的值, 此处和线程t保持同步.</span></span><br><span class="line">    t.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置异常的具体例子: (线程1从终端接收一个整数, 线程2将该整数打印出来, 如果线程1接收一个非整数, 则为 promise 设置一个异常(failbit), 线程2 在std::future::get 是抛出该异常)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cin, std::cout, std::ios</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;     // std::ref</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;         // std::promise, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;      // std::exception, std::current_exception</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_int</span><span class="params">(<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt;&amp; prom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Please, enter an integer value: "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span>.exceptions (<span class="built_in">std</span>::ios::failbit);   <span class="comment">// throw on failbit</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; x;                         <span class="comment">// sets failbit if input is not int</span></span><br><span class="line">        prom.set_value(x);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp;) &#123; <span class="comment">//cin拿到的不是整数时</span></span><br><span class="line">        prom.set_exception(<span class="built_in">std</span>::current_exception());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_int</span><span class="params">(<span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt;&amp; fut)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> x = fut.get();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"[exception caught: "</span> &lt;&lt; e.what() &lt;&lt; <span class="string">"]\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; prom;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future();</span><br><span class="line"></span><br><span class="line">    std::thread th1(get_int, std::ref(prom));</span><br><span class="line">    std::thread th2(print_int, std::ref(fut));</span><br><span class="line"></span><br><span class="line">    th1.join();</span><br><span class="line">    th2.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>那么 <code>void set_value()</code>  是怎么回事?<br>如果不设置值的话(虽然还是会自动设置一个异常, 然后promise的状态还是ready状态), 那就起到通知(notify)等待从future拿到值的线程, 例如下面的例子:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;thread&gt;</span><br><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;cctype&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;iterator&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;sstream&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::istringstream iss_numbers&#123;&quot;3 4 1 42 23 -23 93 2 -289 93&quot;&#125;;</span><br><span class="line">    std::istringstream iss_letters&#123;&quot; a 23 b,e a2 k k?a;si,ksa c&quot;&#125;;</span><br><span class="line"></span><br><span class="line">    //其他线程把上面流的内容放入 这些容器中</span><br><span class="line">    std::vector&lt;int&gt; numbers;</span><br><span class="line">    std::vector&lt;char&gt; letters;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    std::promise&lt;void&gt; numbers_promise, letters_promise;</span><br><span class="line"> </span><br><span class="line">    //主线程纯碎只是要获取其他线程是否完成的状态</span><br><span class="line">    auto numbers_ready = numbers_promise.get_future();</span><br><span class="line">    auto letter_ready = letters_promise.get_future();</span><br><span class="line"></span><br><span class="line">    //子线程用xxx_promise只是传递ready状态</span><br><span class="line">    std::thread value_reader([&amp;]</span><br><span class="line">    &#123;</span><br><span class="line">        // I/O operations.</span><br><span class="line">        std::copy(std::istream_iterator&lt;int&gt;&#123;iss_numbers&#125;,</span><br><span class="line">                  std::istream_iterator&lt;int&gt;&#123;&#125;,</span><br><span class="line">                  std::back_inserter(numbers));</span><br><span class="line"> </span><br><span class="line">        //Notify for numbers.</span><br><span class="line">        numbers_promise.set_value(); //仅仅是只是传递ready状态</span><br><span class="line"> </span><br><span class="line">        std::copy_if(std::istreambuf_iterator&lt;char&gt;&#123;iss_letters&#125;,</span><br><span class="line">                     std::istreambuf_iterator&lt;char&gt;&#123;&#125;,</span><br><span class="line">                     std::back_inserter(letters),</span><br><span class="line">                     ::isalpha);</span><br><span class="line"> </span><br><span class="line">        //Notify for letters.</span><br><span class="line">        letters_promise.set_value();</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    //主线程numbers future 阻塞wait</span><br><span class="line">    numbers_ready.wait();</span><br><span class="line">    //numbers容器被填充完毕了</span><br><span class="line">    std::sort(numbers.begin(), numbers.end());</span><br><span class="line"> </span><br><span class="line">/*  //非核心逻辑</span><br><span class="line">    if (letter_ready.wait_for(std::chrono::seconds(1)) ==</span><br><span class="line">            std::future_status::timeout)</span><br><span class="line">    &#123;</span><br><span class="line">        //output the numbers while letters are being obtained.</span><br><span class="line">        for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; &apos; &apos;;</span><br><span class="line">        numbers.clear(); //Numbers were already printed.</span><br><span class="line">    &#125;</span><br><span class="line">*/    </span><br><span class="line"></span><br><span class="line">    //阻塞等待</span><br><span class="line">    letter_ready.wait();</span><br><span class="line">    std::sort(letters.begin(), letters.end());</span><br><span class="line"> </span><br><span class="line">    //If numbers were already printed, it does nothing.</span><br><span class="line">    for (int num : numbers) std::cout &lt;&lt; num &lt;&lt; &apos; &apos;;</span><br><span class="line">    std::cout &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">    for (char let : letters) std::cout &lt;&lt; let &lt;&lt; &apos; &apos;;</span><br><span class="line">    std::cout &lt;&lt; &apos;\n&apos;;</span><br><span class="line"> </span><br><span class="line">    value_reader.join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>set_xxx_at_thread_exit</code> 这类比较特殊, 拥有promise的线程, 真正set是在线程结束的时候才去set(延后设置), 可想而知, 对方等待的线程会一直等待结果.(但是重复调用set会报错). The state is made ready when the current thread exits, after all variables with thread-local storage duration have been destroyed. 下面有个简单的例子:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::chrono_literals;</span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f = p.get_future();</span><br><span class="line">    <span class="built_in">std</span>::thread([&amp;p] &#123;</span><br><span class="line">          <span class="built_in">std</span>::this_thread::sleep_for(<span class="number">1</span>s);</span><br><span class="line">          p.set_value_at_thread_exit(<span class="number">9</span>);</span><br><span class="line">    &#125;).detach();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waiting..."</span> &lt;&lt; <span class="built_in">std</span>::flush;</span><br><span class="line">    f.wait();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done!\nResult is: "</span> &lt;&lt; f.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>补充说明一下其构造方法中也是禁用了拷贝构造函数的, 只保留了移动构造:</p>
<ul>
<li>promise();  //默认构造函数，初始化一个空的共享状态。</li>
<li>template <class alloc=""> promise<br>(allocator_arg_t aa, const Alloc&amp; alloc); //和默认类似, 但是可以自定指定分配器</class></li>
<li>promise (const promise&amp;) = delete; //禁止拷贝构造</li>
<li>promise (promise&amp;&amp; x) noexcept; //移动构造</li>
</ul>
<p>移动构造就是为了转移所有权, 例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;         // std::thread</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;         // std::promise, std::future</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; prom; <span class="comment">//下面接收不同的promise实例的所有权</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_global_promise</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut = prom.get_future();</span><br><span class="line">    <span class="keyword">int</span> x = fut.get();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value: "</span> &lt;&lt; x &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th1</span><span class="params">(print_global_promise)</span></span>;</span><br><span class="line">    prom.set_value(<span class="number">10</span>);</span><br><span class="line">    th1.join();</span><br><span class="line"></span><br><span class="line">    prom = <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt;();    <span class="comment">// prom 被move赋值为一个新的 promise 对象.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="function">thread <span class="title">th2</span> <span class="params">(print_global_promise)</span></span>;</span><br><span class="line">    prom.set_value (<span class="number">20</span>);</span><br><span class="line">    th2.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面记录一下 std::packaged_task</p>
<p>std::packaged_task 与 std::function 类似，只不过 std::packaged_task 将其包装的可调用对象的执行结果传递给一个 std::future 对象(该对象通常在另外一个线程中获取 std::packaged_task 任务的执行结果). 也就是说 std::packaged_task 包含了两个最基本要素:</p>
<ul>
<li>被包装的任务(stored task)，任务(task)是一个可调用的对象，如函数指针、成员函数指针或者函数对象</li>
<li>共享状态(shared state)，用于保存任务的返回值，可以通过 std::future 对象来达到异步访问共享状态的效果</li>
</ul>
<p>std::packaged_task 对象是异步 Provider, 它在某一时刻通过调用被包装的任务来设置共享状态的值. </p>
<p>通俗的说, 它和 std::function (function, lambda, bind , functor)一样, 可以作为一个可调用对象容器. 但不同的是它多了两样重要功能, 一是异步调用, 二是它保存返回值或者异常(别的线程是可以通过std::future对象获取到的)</p>
<p>std::packaged_task 的 <code>operator()</code> 函数 和 thread对象包装一个方法有什么不同:</p>
<blockquote>
<p>A successful call to operator() synchronizes with a call to any member function of a std::future</p>
</blockquote>
<p>实际上, 你可以像上面说promise的时候一样, 直接绕过 packaged_task, 而采用普通的启动线程的方式, 还是可以从promise关联的future中拿到结果. </p>
<p>但是直接执行调用:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// unique function to avoid disambiguating the std::pow overload set</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(x,y); &#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_lambda</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id : "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(a, b); </span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    task(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_lambda:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_bind</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id : "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>()&gt; task(<span class="built_in">std</span>::bind(f, <span class="number">2</span>, <span class="number">11</span>));</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    task();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_bind:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">task_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"thread id : "</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(f);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line"> </span><br><span class="line">    std::thread task_td(std::move(task), 2, 10);</span><br><span class="line">    task_td.join();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task_thread:\t"</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main thread id : "</span> </span><br><span class="line">    &lt;&lt; <span class="built_in">std</span>::this_thread::get_id() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    task_lambda();</span><br><span class="line">    task_bind();</span><br><span class="line">    task_thread();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">main thread id : 140384054449984</span><br><span class="line">thread id : 139700016576320</span><br><span class="line">task_lambda:	512</span><br><span class="line">thread id : 139700016576320</span><br><span class="line">task_bind:  2048</span><br><span class="line">thread id : 139700016576320</span><br><span class="line">task_thread:	1024</span><br></pre></td></tr></table></figure></p>
<p>是的, 可以看到其实没有开辟新的线程, 仅仅是进行了调用, 要想在另外的线程执行, 还是要借助 thread:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;     // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;       // std::packaged_task, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;       // std::chrono::seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;       // std::thread, std::this_thread::sleep_for</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// count down taking a second for each value:</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countdown</span> <span class="params">(<span class="keyword">int</span> from, <span class="keyword">int</span> to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=from; i!=to; --i) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Finished!\n"</span>;</span><br><span class="line">    <span class="keyword">return</span> from - to;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task(countdown); <span class="comment">// 设置 packaged_task</span></span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; ret = task.get_future(); <span class="comment">// 获得与 packaged_task 共享状态相关联的 future 对象.</span></span><br><span class="line"></span><br><span class="line">    std::thread th(std::move(task), 10, 0);   //创建一个新线程完成计数任务.</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> value = ret.get();                    <span class="comment">// 等待任务完成并获取结果.</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"The countdown lasted for "</span> &lt;&lt; value &lt;&lt; <span class="string">" seconds.\n"</span>;</span><br><span class="line"></span><br><span class="line">    th.join();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>用 packaged_task 直接拿到future, 而不是借助promise才能拿到;</p>
</blockquote>
<p>(packaged_task 和 promise 同为 provide 类, 但是要设置值, 还是需要 promise 类对象)</p>
<p>实际上调用传参上面也有一点儿区别: 参考 <a href="http://www.cplusplus.com/reference/future/packaged_task/operator_func/" target="_blank" rel="noopener">cplusplus网站</a></p>
<ul>
<li>If the stored task is a function pointer or a function object, it is called forwarding the arguments to the call.</li>
<li>If the stored task is a pointer to a non-static member function, it is called using the first argument as the object on which the member is called (this may either be an object, a reference, or a pointer to it), and the remaining arguments are forwarded as arguments for the member function.</li>
<li>If it is a pointer to a non-static data member, it should be called with a single argument, and the function stores in the shared state a reference to that member of its argument (the argument may either be an object, a reference, or a pointer to it).</li>
</ul>
<p>翻译一下就是:</p>
<ul>
<li>如果被包装的任务是函数指针或者函数对象，调用 std::packaged_task::operator() 只是将参数传递给被包装的对象。</li>
<li>如果被包装的任务是指向类的非静态成员函数的指针，那么 std::packaged_task::operator() 的第一个参数应该指定为成员函数被调用的那个对象，剩余的参数作为该成员函数的参数。</li>
<li>如果被包装的任务是指向类的非静态成员变量，那么 std::packaged_task::operator() 只允许单个参数。</li>
</ul>
<p>(其实和 std::function 类似)</p>
<p>关于 packaged_task 执行结果中, 还有两个重要的方法:</p>
<ul>
<li><code>reset()</code> :  resets the state abandoning any stored results of previous executions </li>
<li><code>make_ready_at_thread_exit</code> : executes the function ensuring that the result is ready only once the current thread exits </li>
</ul>
<p>案例如下:<br>(看到所在线程退出后, future 才进入ready状态)<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">worker</span><span class="params">(<span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt;&amp; output)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">void</span>(<span class="keyword">bool</span>&amp;)&gt; my_task&#123; [](<span class="keyword">bool</span>&amp; done) &#123; done=<span class="literal">true</span>; &#125; &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> result = my_task.get_future();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line"> </span><br><span class="line">    my_task.make_ready_at_thread_exit(done); <span class="comment">// execute task right away</span></span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"worker: done = "</span> &lt;&lt; <span class="built_in">std</span>::boolalpha &lt;&lt; done &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"worker: result is not ready yet"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    output = <span class="built_in">std</span>::move(result);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">void</span>&gt; result;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::thread&#123;worker, <span class="built_in">std</span>::ref(result)&#125;.join();</span><br><span class="line">    <span class="comment">//检查 future的状态 :  std::future_status 类型</span></span><br><span class="line">    <span class="keyword">auto</span> status = result.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::ready)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"main: result is ready"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>而 reset 则是重置状态和存储的值, 实现方式其实是检查包装的任务:<br>即<code>*this = packaged_task(std::move(f))</code>, 使用案例如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::packaged_task&lt;<span class="keyword">int</span>(<span class="keyword">int</span>,<span class="keyword">int</span>)&gt; task([](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">pow</span>(a, b);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; result = task.get_future();</span><br><span class="line">    task(<span class="number">2</span>, <span class="number">9</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2^9 = "</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line"> </span><br><span class="line">    task.reset();</span><br><span class="line">    result = task.get_future();</span><br><span class="line">    std::thread task_td(std::move(task), 2, 10);</span><br><span class="line">    task_td.join();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"2^10 = "</span> &lt;&lt; result.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其他需要注意的是, packaged_task 是禁止了拷贝语义, 只有移动语义, 所以简单多用 std::move 进行再次包装:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">packaged_task&amp; <span class="keyword">operator</span>=( <span class="keyword">const</span> packaged_task&amp; ) = <span class="keyword">delete</span>;</span><br><span class="line">packaged_task&amp; <span class="keyword">operator</span>=( packaged_task&amp;&amp; rhs ) <span class="keyword">noexcept</span>;</span><br></pre></td></tr></table></figure></p>
<p>移动之后, 原来的 packaged_task 对象也讲失去 state和包装的方法, 此时需要用<code>valid</code>成员方法检测有效性:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>成员方法 和 <code>std::swap</code> 作用一样, 都是 交换 staes 和包装的方法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void swap( packaged_task&amp; other ) noexcept;</span><br><span class="line"></span><br><span class="line">template&lt; class Function, class... Args &gt;</span><br><span class="line">void swap( packaged_task&lt;Function(Args...)&gt; &amp;lhs, </span><br><span class="line">           packaged_task&lt;Function(Args...)&gt; &amp;rhs ) noexcept;</span><br></pre></td></tr></table></figure></p>
<p>最后 packaged_task 只是封装了任务, 并没有说是不是同一线程执行, 或者另外的线程单独执行; 如果要想另外的线程单独执行, 其他线程异步获取结果, 可以再用一个封装, std::async.  (std:async 通常配合 <code>std::launch</code> 枚举一起使用)</p>
<p>btw: std::async 和 std::launch 都定义在 future 头文件中.</p>
<h3 id="future"><a href="#future" class="headerlink" title="future"></a>future</h3><p>该部分主要涉及:</p>
<ul>
<li>std::future</li>
<li>std::shared_future</li>
</ul>
<p>future 对象可以异步返回(拿到)共享状态的值, 或者在必要的情况下阻塞调用者(即拿到并使用future的线程)并等待共享状态标志变为 ready, 然后才能获取共享状态的值.</p>
<p>标准库中提供了3种future：</p>
<ul>
<li>普通future</li>
<li>shared_future(用于复杂场合)</li>
<li>atomic_future (暂时不说)</li>
</ul>
<p>其实普通 future 它已经完全够用了.</p>
<p>如果我们有一个future f，通过get()可以获得它的值:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if necessary wait for the value to get computed</span></span><br><span class="line">X v = f.get();</span><br></pre></td></tr></table></figure></p>
<p>如果它的返回值还没有到达，调用线程会进行阻塞等待. 等待超时怎么办? get()会抛出异常的(从标准库或等待的线程那个线程中抛出).<br>如果我们不需要等待返回值(非阻塞方式)，可以简单询问一下future，看返回值是否已经到达：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//换成while的话, 就是直接返回, 然后进行下一次询问</span><br><span class="line">if (f.wait_for(0))</span><br><span class="line">&#123;</span><br><span class="line"> // there is a value to get()</span><br><span class="line"> // do something</span><br><span class="line">&#125; else</span><br><span class="line">&#123;</span><br><span class="line"> // do something else</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般从构造函数拿到的future都是无效的, 除非接收了有效future对象的所有权(即 move 拿到的别人的).<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">future() noexcept; //默认构造</span><br><span class="line">future (future&amp;&amp; x) noexcept;</span><br><span class="line">future (const future&amp;) = delete;// 禁用拷贝语义</span><br><span class="line"></span><br><span class="line">//实例:</span><br><span class="line">std::future&lt;int&gt; fut;           // 默认构造函数</span><br><span class="line">fut = std::async(do_some_task);   // move-赋值操作。</span><br></pre></td></tr></table></figure></p>
<p>一般可以从三种途径获取:</p>
<ul>
<li>provider<ul>
<li>promise 的成员函数 get_future , 但是一般promise都是共享的(全局的), 两个线程都可见</li>
<li>packaged_task  的成员函数 get_future , 因为启动 task的线程(姑且称为父线程), 它是拥有task的实例的, 这个线程想拿到异步调用的结果, 就完全可以从task对象要future对象.</li>
</ul>
</li>
<li>std::async 函数的返回值(这个就是对标准异步任务流程的封装, 可以简单理解成跑在别的线程里面的 packaged_task , 所以也是可以拿到future对象的)</li>
</ul>
<p>如果不是默认构造&amp;上面三种途径接收的到的(move), 那么在调用 <code>get</code> 或者 <code>share</code> 之前, 最好检查一下, 用<code>valid</code> 成员函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果这个future有保存shared status, </span></span><br><span class="line"><span class="comment">//那么就返回true, 表示可以用(get(), share())</span></span><br><span class="line"><span class="comment">//否则返回false</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">valid</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>还有一个重要原因要检查 <code>valid</code>, 可能是 <code>share</code>, 即 <code>std::future::share()</code> :<br>返回一个 std::shared_future 对象(本文后续内容将介绍 std::shared_future), 调用该函数之后, 该 std::future 对象本身已经不和任何共享状态相关联, 因此该 std::future 的状态不再是 valid 的了, <code>valid() == false</code></p>
<p>那为什么需要 shared_future ? 因为原来的 <code>std::future</code> 当你get一次共享状态(status)值或者存储的异常之后, 它就失效了, 再解引用或者参考它的值的行为是未定义的, 通俗说, 就是你调用两次 std::future的get方法试试看, 行为未定义, 但是shared_future则不同, 看下面的代码:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;         // std::async, </span></span></span><br><span class="line">						<span class="comment">//std::future, std::shared_future</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_get_value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">10</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; fut = <span class="built_in">std</span>::async(do_get_value);</span><br><span class="line">    <span class="built_in">std</span>::shared_future&lt;<span class="keyword">int</span>&gt; shared_fut = fut.share();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 共享的 future 对象可以被多次访问.</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"value: "</span> &lt;&lt; shared_fut.get() &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//10</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"its double: "</span> &lt;&lt; shared_fut.get()*<span class="number">2</span> &lt;&lt; <span class="string">'\n'</span>; <span class="comment">//10</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以啊, 没事儿还是要在使用之前检查一下future对象, 看看究竟还能不能再调用<code>get</code>或者<code>share</code>方法:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;       // std::cout</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;         // std::async, std::future</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;        // std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_get_value</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">11</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span> <span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 由默认构造函数创建的 std::future 对象,</span></span><br><span class="line">    <span class="comment">// 初始化时该 std::future 对象处于为 invalid 状态.</span></span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; foo, bar;</span><br><span class="line">    foo = <span class="built_in">std</span>::async(do_get_value); <span class="comment">// move 赋值, foo 变为 valid.</span></span><br><span class="line">    bar = <span class="built_in">std</span>::move(foo); <span class="comment">// move 赋值, bar 变为 valid, 而 move 赋值以后 foo 变为 invalid.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (foo.valid())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo's value: "</span> &lt;&lt; foo.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"foo is not valid\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (bar.valid())</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar's value: "</span> &lt;&lt; bar.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bar is not valid\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>再次强调 : 在一个有效的 future 对象上调用 get 会阻塞当前的调用者(get函数内高效的封装了std::future::wait, 而wait是Blocks until the result becomes available.), 直到 Provider 设置了共享状态的值或异常(此时共享状态的标志变为 ready), std::future::get 将返回异步任务的值或异常(如果发生了异常).</p>
<p>不想一直阻塞等怎么办? 那就像上面一样, 用wait_for()异步询问(其实是, 我先等指定的时间, 时间到了, 我就询问, 不管有没有我都返回), 例如:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; future = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []()&#123; </span><br><span class="line">        <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">3</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;  </span><br><span class="line">    &#125;); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting...\n"</span>;</span><br><span class="line">    <span class="built_in">std</span>::future_status status;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        status = future.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deferred\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"timeout\n"</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ready!\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (status != <span class="built_in">std</span>::future_status::ready); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"result is "</span> &lt;&lt; future.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">waiting...</span><br><span class="line">timeout</span><br><span class="line">timeout</span><br><span class="line">ready!</span><br><span class="line">result is 8</span><br></pre></td></tr></table></figure></p>
<p>而如果你用的是 <code>wait</code> , 那么就会阻塞等待结果(get函数封装了wait(), 当然如果get的时候调用已经完成, 可以拿到结果, 那么就不用阻塞了), 看下面:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f1 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []()&#123;</span><br><span class="line">        <span class="keyword">return</span> fib(<span class="number">20</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f2 = <span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, []()&#123;</span><br><span class="line">        <span class="keyword">return</span> fib(<span class="number">25</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"waiting...\n"</span>;</span><br><span class="line">    f1.wait();</span><br><span class="line">    f2.wait();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f1: "</span> &lt;&lt; f1.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f2: "</span> &lt;&lt; f2.get() &lt;&lt; <span class="string">'\n'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">waiting...</span><br><span class="line">f1: 6765</span><br><span class="line">f2: 75025</span><br></pre></td></tr></table></figure></p>
<p>还有一个 wait_until呢? 它也不像 wait 那样一直傻等, 它等具体制定的时间到了, 就停止等待. 如果具体时间到之前, 结果就拿到了那最好(提前就返回了), 如果没有, 那么你就只能去判断他的返回值了, 和 wait_for 一样, 是判断 <code>std::future_status</code> , 即:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deferred\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"timeout\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ready!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>具体含义是:</p>
<ul>
<li>future_status::deferred    The function to calculate the result has not been started yet</li>
<li>future_status::ready        The result is ready</li>
<li>future_status::timeout    The timeout has expired</li>
</ul>
<p>下面有个例子: (仅等待2秒, 让执行1秒的拿到结果, 执行5秒的超时而返回)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::chrono::system_clock::time_point two_seconds_passed</span><br><span class="line">        = <span class="built_in">std</span>::chrono::system_clock::now() + <span class="built_in">std</span>::chrono::seconds(<span class="number">2</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Make a future that that takes 1 second to completed</span></span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p1;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f_completes = p1.get_future();</span><br><span class="line">    <span class="built_in">std</span>::thread([](<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p1)</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>)); </span><br><span class="line">                    p1.set_value_at_thread_exit(<span class="number">9</span>); </span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="built_in">std</span>::move(p1)</span><br><span class="line">    ).detach();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Make a future that that takes 5 seconds to completed</span></span><br><span class="line">    <span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p2;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">int</span>&gt; f_times_out = p2.get_future();</span><br><span class="line">    <span class="built_in">std</span>::thread([](<span class="built_in">std</span>::promise&lt;<span class="keyword">int</span>&gt; p2)</span><br><span class="line">                &#123; </span><br><span class="line">                    <span class="built_in">std</span>::this_thread::sleep_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">5</span>)); </span><br><span class="line">                    p2.set_value_at_thread_exit(<span class="number">8</span>); </span><br><span class="line">                &#125;, </span><br><span class="line">                <span class="built_in">std</span>::move(p2)</span><br><span class="line">    ).detach();</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Waiting for 2 seconds..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::future_status::ready == f_completes.wait_until(two_seconds_passed))</span><br><span class="line">        &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f_completes: "</span> &lt;&lt; f_completes.get() &lt;&lt; <span class="string">"\n"</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f_completes did not complete!\n"</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">std</span>::future_status::ready == f_times_out.wait_until(two_seconds_passed))</span><br><span class="line">        &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f_times_out: "</span> &lt;&lt; f_times_out.get() &lt;&lt; <span class="string">"\n"</span>; &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        &#123; <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f_times_out did not complete!\n"</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Done!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Waiting <span class="keyword">for</span> <span class="number">2</span> seconds...</span><br><span class="line">f_completes: <span class="number">9</span></span><br><span class="line">f_times_out did <span class="keyword">not</span> complete!</span><br><span class="line">Done!</span><br></pre></td></tr></table></figure></p>
<p>补上说一下 <code>shared_future</code> :<br>std::shared_future 与 std::future 类似，但是 std::shared_future 可以拷贝、多个 std::shared_future 可以共享某个共享状态的最终结果(即共享状态的某个值或者异常, 表现为重复调用 get方法). shared_future 可以通过某个 std::future 对象隐式转换(参见 std::shared_future 的构造函数 <code>shared_future (future&lt;T&gt;&amp;&amp; x) noexcept;</code>), 或者通过 std::future::share() 显示转换，无论哪种转换，被转换的那个 std::future 对象都会变为 not-valid.</p>
<p>它的构造函数如下:</p>
<ul>
<li>shared_future() noexcept;  //default</li>
<li>shared_future (const shared_future&amp; x); //copy</li>
<li>shared_future (shared_future&amp;&amp; x) noexcept; //move</li>
<li>shared_future (future<t>&amp;&amp; x) noexcept; //move from future – 相当于隐式转换</t></li>
</ul>
<h3 id="辅助工具"><a href="#辅助工具" class="headerlink" title="辅助工具"></a>辅助工具</h3><p>这部分有异常, 枚举, 还有辅助函数, 主要涉及</p>
<ul>
<li>async 异步调用函数</li>
<li>launch 异步调用函数的启动策略</li>
<li>future_status 枚举</li>
<li>future_errors 异常枚举<br>std::future_error 继承子 C++ 标准异常体系中的 logic_error</li>
</ul>
<p>按顺序说说.</p>
<p>async 和 launch:<br>async的函数原型如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//没有指定policy (默认async策略)</span><br><span class="line">template &lt;class Fn, class... Args&gt;</span><br><span class="line">future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;</span><br><span class="line">    async(Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br><span class="line">    </span><br><span class="line">//指定policy才运行</span><br><span class="line">template &lt;class Fn, class... Args&gt;</span><br><span class="line">future&lt;typename result_of&lt;Fn(Args...)&gt;::type&gt;</span><br><span class="line">    async(launch policy, Fn&amp;&amp; fn, Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure></p>
<p>std::async() 的 fn 和 args 参数用来指定异步任务及其参数, launch指定了 async的启动policy, 枚举定义如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">launch</span> :</span> <span class="comment">/* unspecified */</span> &#123;</span><br><span class="line">    async =    <span class="comment">/* unspecified */</span>,</span><br><span class="line">    deferred = <span class="comment">/* unspecified */</span>,</span><br><span class="line">    <span class="comment">/* implementation-defined */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>policy 参数可以是launch::async，launch::deferred，以及两者的按位或( | ).</p>
<p>下面看一个案例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">ThreadTask</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()</span><br><span class="line">        &lt;&lt; <span class="string">" start computing..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        ret += <span class="built_in">std</span>::<span class="built_in">sin</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()</span><br><span class="line">        &lt;&lt; <span class="string">" finished computing..."</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">" main thread id :"</span></span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::this_thread::get_id()</span><br><span class="line">              &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">std</span>::future&lt;<span class="keyword">double</span>&gt; f(<span class="built_in">std</span>::async(<span class="built_in">std</span>::launch::async, ThreadTask, <span class="number">100000000</span>));</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">    <span class="keyword">while</span>(f.wait_until(<span class="built_in">std</span>::chrono::system_clock::now() + <span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))</span><br><span class="line">            != <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task is running...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">while</span>(f.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))</span><br><span class="line">            != <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task is running...\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; f.get() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> EXIT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> main thread id :140714198243136</span><br><span class="line">140714176349952 start computing...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">140714176349952 finished computing...</span><br><span class="line">1.71365</span><br></pre></td></tr></table></figure></p>
<p>但是上面那个案例, 如果你把策略指定城 <code>std::launch::deferred</code> 那就完蛋了, 因为 <code>std::launch::deferred</code> 策略会延迟到下面这个循环<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(f.wait_for(<span class="built_in">std</span>::chrono::seconds(<span class="number">1</span>))</span><br><span class="line">		!= <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">		<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"task is running...\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>的后面的 <code>f.get()</code> 语句是才去执行异步线程内的任务, 也就是说 main 线程这个循环永远出不去, 运行结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ing...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">task is running...</span><br><span class="line">//下面死循环了</span><br></pre></td></tr></table></figure></p>
<p>使用 <code>std::launch::deferred</code> 策略, 就直接 <code>get</code>不要 wait_for 或者 wait_until 去包装函数是否执行完毕了.</p>
<p>下面说说, staus 封装函数(task)的返回状态.</p>
<p>上面已经说了 future_status 的含义了, 再重复一下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::deferred) &#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"deferred\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::timeout) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"timeout\n"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (status == <span class="built_in">std</span>::future_status::ready) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ready!\n"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体含义是:</p>
<ul>
<li>future_status::deferred    The function to calculate the result has not been started yet (    共享状态包含一个 deferred 函数, 即函数延迟执行)</li>
<li>future_status::ready        The result is ready (共享状态的标志已经变为 ready，即 Provider 在共享状态上设置了值或者异常)</li>
<li>future_status::timeout    The timeout has expired (超时，即在规定的时间内共享状态的标志没有变为 ready)</li>
</ul>
<p>一般用future_status做逻辑判断, 但是错误处理就要依靠errc, error等类的枚举了. </p>
<p>下面还有三个和错误相关的内容:</p>
<p>future_errc (enum): identifies the future error codes </p>
<ul>
<li>broken_promise    取值0      与该 std::future 共享状态相关联的 std::promise 对象在设置值或者异常之前一被销毁</li>
<li>future_already_retrieved     取值1        与该 std::future 对象相关联的共享状态的值已经被当前 Provider 获取了，即调用了 std::future::get 函数</li>
<li>promise_already_satisfied    取值2        std::promise 对象已经对共享状态设置了某一值或者异常</li>
<li>no_state               取值3        无共享状态</li>
</ul>
<p>当操作promise或者future出错的时候, 会抛出异常, 用future_error类进行捕获.</p>
<p>future_error (class): reports an error related to futures or promises<br>这就是个异常类(其父类是logic_error), 可以通过其成员方法<code>code</code> 以及 <code>what</code> 获取异常详情.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;future&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::future&lt;int&gt; empty;</span><br><span class="line">    try &#123;</span><br><span class="line">        int n = empty.get(); // The behavior is undefined, but</span><br><span class="line">                             // some implementations throw std::future_error</span><br><span class="line">    &#125; catch (const std::future_error&amp; e) &#123;</span><br><span class="line">        std::cout &lt;&lt; &quot;Caught a future_error with code \&quot;&quot; &lt;&lt; e.code()</span><br><span class="line">                  &lt;&lt; &quot;\&quot;\nMessage: \&quot;&quot; &lt;&lt; e.what() &lt;&lt; &quot;\&quot;\n&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<hr>
<p>整理&amp;上传 ING.</p>
<h2 id="其他主题"><a href="#其他主题" class="headerlink" title="其他主题"></a>其他主题</h2><p>很显然在c++11的时候, 并发库并没有完全支持boost线程库的内容, 而是有选择性的部分摘取, 下面提一下并发库中没有涉及到的内容:</p>
<ul>
<li>shared_mutex<br>读写锁(rwlock)<br>pthreads库倒是为读写锁专门开辟了API, Boost也是(shared_mutex), 但是C++标准貌似到C++17才会引入, 请参考我的文章 <a href="http://www.merlinblog.site/2017/06/21/boost.html">boost</a></li>
<li>atomic<br>原子操作, 也应该算作 <code>无锁编程</code> 领域, 因为我用的不是很多, 所以没有谈, 可以参考我的文章 <a href="http://www.merlinblog.site/2017/06/21/boost.html">boost</a></li>
<li>thread_group<br>c++11的标准库直接省略了..<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">boost::thread_group threads;	</span><br><span class="line">threads.create_thread(boost::bind(Worker, boost::ref(counter)));</span><br><span class="line">threads.create_thread(boost::bind(Worker, boost::ref(counter)));</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>*</p>
<h1 id="尾巴"><a href="#尾巴" class="headerlink" title="尾巴"></a>尾巴</h1><p>花了很大的经历, C++11并发支持库也就说的差不多了. 但是用熟悉了这些API是远远不够的, 有时间还是需要看看真正的大师是怎么在理解和处理线程. 这方面的好书并不多, 但是单独花一本书的内容去讲解并发&amp;线程的, 通常都还不错.</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol>
<li><a href="">《C++并发编程实战》</a></li>
<li><a href="http://www.merlinblog.site/2017/06/21/boost.html">我的博文boost</a></li>
<li><a href="http://www.boost.org/doc/libs/1_49_0/doc/html/thread.html" target="_blank" rel="noopener">boost线程库</a></li>
<li><a href="http://en.cppreference.com/w/cpp/thread" target="_blank" rel="noopener">cppreference</a></li>
<li><a href="http://www.cplusplus.com/reference/multithreading/" target="_blank" rel="noopener">cplusplus</a></li>
</ol>

      
    </div>
    
  </div>
  
    
    <div class="copyright">
        <p><span>本文标题:</span><a href="/posts/ab21303c/">技术: C++11 并发库</a></p>
        <p><span>文章作者:</span><a href="/" title="回到主页">Merlin</a></p>
        <p><span>发布时间:</span>2016-06-29, 22:33:11</p>
        <p><span>最后更新:</span>2018-04-12, 14:55:17</p>
        <p>
            <span>原始链接:</span><a class="post-url" href="/posts/ab21303c/" title="技术: C++11 并发库">http://www.merlinblog.site/posts/ab21303c/</a>
            <span class="copy-path" data-clipboard-text="原文: http://www.merlinblog.site/posts/ab21303c/　　作者: Merlin" title="点击复制文章链接"><i class="fa fa-clipboard"></i></span>
            <script> var clipboard = new Clipboard('.copy-path'); </script>
        </p>
        <p>
            <span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" title="CC BY-NC-SA 4.0 International" target = "_blank">"署名-非商用-相同方式共享 4.0"</a> 转载请保留原文链接及作者。
        </p>
    </div>



    <nav id="article-nav">
        
            <div id="article-nav-newer" class="article-nav-title">
                <a href="/posts/88802625/">
                    技术: Linux 静态&amp;动态库
                </a>
            </div>
        
        
            <div id="article-nav-older" class="article-nav-title">
                <a href="/posts/bc67b8cb/">
                    技术: 探究一下STL常用算法
                </a>
            </div>
        
    </nav>

  
</article>

    <div id="toc" class="toc-article">
        <strong class="toc-title">文章目录</strong>
        
            <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#引子"><span class="toc-number">1.</span> <span class="toc-text">引子</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#正文"><span class="toc-number">2.</span> <span class="toc-text">正文</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#简介"><span class="toc-number">2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Threads库"><span class="toc-number">2.2.</span> <span class="toc-text">Threads库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#thread类"><span class="toc-number">2.2.1.</span> <span class="toc-text">thread类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this-thread"><span class="toc-number">2.2.2.</span> <span class="toc-text">this_thread</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mutex库"><span class="toc-number">2.3.</span> <span class="toc-text">Mutex库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mutex"><span class="toc-number">2.3.1.</span> <span class="toc-text">mutex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全局加锁算法"><span class="toc-number">2.3.2.</span> <span class="toc-text">全局加锁算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock类结构"><span class="toc-number">2.3.3.</span> <span class="toc-text">lock类结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock包装类"><span class="toc-number">2.3.4.</span> <span class="toc-text">lock包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#lock-t"><span class="toc-number">2.3.5.</span> <span class="toc-text">lock_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#call-once"><span class="toc-number">2.3.6.</span> <span class="toc-text">call_once</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#condition-variable库"><span class="toc-number">2.4.</span> <span class="toc-text">condition_variable库</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Futures库"><span class="toc-number">2.5.</span> <span class="toc-text">Futures库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">2.5.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#provider"><span class="toc-number">2.5.2.</span> <span class="toc-text">provider</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#future"><span class="toc-number">2.5.3.</span> <span class="toc-text">future</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#辅助工具"><span class="toc-number">2.5.4.</span> <span class="toc-text">辅助工具</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#其他主题"><span class="toc-number">2.6.</span> <span class="toc-text">其他主题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#尾巴"><span class="toc-number">3.</span> <span class="toc-text">尾巴</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#参考资料"><span class="toc-number">4.</span> <span class="toc-text">参考资料</span></a></li></ol>
        
    </div>
    <style>
        .left-col .switch-btn,
        .left-col .switch-area {
            display: none;
        }
        .toc-level-3 i,
        .toc-level-3 ol {
            display: none !important;
        }
    </style>

    <input type="button" id="tocButton" value="隐藏目录"  title="点击按钮隐藏或者显示文章目录">

    <script>
        yiliaConfig.toc = ["隐藏目录", "显示目录", !!"false"];
    </script>





    




    <div class="scroll" id="post-nav-button">
        
            <a href="/posts/88802625/" title="上一篇: 技术: Linux 静态&amp;动态库">
                <i class="fa fa-angle-left"></i>
            </a>
        

        <a title="文章列表"><i class="fa fa-bars"></i><i class="fa fa-times"></i></a>

        
            <a href="/posts/bc67b8cb/" title="下一篇: 技术: 探究一下STL常用算法">
                <i class="fa fa-angle-right"></i>
            </a>
        
    </div>

    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/posts/7ef0bd11/">技巧: iOS 工作流</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e2300e0/">Golang: 并发聊天室综合案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/74edbb6d/">Golang: TCP 文件传输案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a8342f6/">Golang: TCP 简单并发服务器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aa0a3cc6/">技巧: B站视频下载脚本</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8180668e/">技巧: 多用户共享 Parralles 虚拟机</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/55b0329b/">Golang: 值类型&引用类型坑(12)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ac5ecee9/">Golang: 函数类型实现接口封装问题(11)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/eecafb73/">Golang: struct打印输出问题(10)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8f54ef0c/">Golang: string和byte slie字节问题(9)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8a7f81db/">Golang: time计算问题(8)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d4333ec1/">Golang: chan定义问题(7)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aec4de55/">Golang: defer 时机问题(6)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e9bf7e00/">Golang: make和new坑(5)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e0c9893e/">Golang: import和package坑(4)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4ff88030/">Golang: runtime.Gosched 问题(3)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/690caed4/">Golang: HTML Template案例(xml新闻解析+并发改进)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4620296/">Golang: JSON 小案例(读配置文件)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/777e9274/">Golang: JSON 综合案例(天气预报)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/21f718fc/">Golang: RESTful 小案例</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ad1d8b3/">Golang: 泛型容器的安全问题 (2)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e9ef6fe/">Android: APK細粒度的權限管理設計</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3fde375b/">Golang: 内嵌真的不是继承 (1)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/558a5d81/">Android: 密碼學基礎</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2ff459d4/">Android: 彙編語言基礎</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ede42ab6/">Golang: 注意空接口运行时类型 (0)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bd0987da/">Android: 音频框架&驱动解析</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6c3c68b0/">Gcc: Gcc优化指南(5. 功成身退-总结)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/466242ae/">Gcc: Gcc优化指南(4. Gcc & G++ & 相关工具)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/425935e0/">Gcc: Gcc优化指南(3. Gcc Optimize-核心)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5cd24f32/">Gcc: Gcc优化指南(2. Gcc Options)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/11ea881a/">Gcc: Gcc优化指南(1. Common Problmes of Path & Libs)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1e58a5cc/">量化: 数学和量化研究(0. 总起)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6805cb0/">Gcc: Gcc优化指南(0. Basic Skills)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/78268fe4/">Golang: 标准库解决方案(8.总结-功成身退)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e3c9a06b/">Golang: 标准库解决方案(7.Concurrency)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bb600d10/">Golang: 标准库解决方案(6.REST & JSON API)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/2f5310cf/">Golang: 标准库解决方案(5.Web Server & Client)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/40bd3fcc/">Golang: 标准库解决方案(4.Math/Time/Archives/Images)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fedfbade/">Golang: 标准库解决方案(3.处理BuildTools,IO,Error)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/42e1a67a/">Golang: 标准库解决方案(2.处理Strings,Bytes,Runes)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/461f0c5f/">Golang: 标准库解决方案(1.听两位大师讲标准库)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/dbbca7df/">Golang: WebGoGoGo(0.Web编程的方方面面)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/187d6c5a/">Golang: WebGoGoGo(0.概述Web编程)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/94df7563/">Golang: Here We Go(5.孰能生巧-Oreilly大师讲解&再练习)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/53a29a57/">Golang: RobPike谈 并发Vs并行</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9b9dc4cb/">Golang: One Video Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9d17f938/">Golang: 标准库解决方案(0.总起)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e5c13927/">Golang: Think in Golang</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/514585e8/">Golang: Here We Go(4.功成身退-资料&面试题)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4f07614d/">Golang: Here We Go(3.登堂入室-全部语法&大量练习)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/872df2cf/">Golang: Here We Go(2.常用命令&代码结构&语法大纲)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/51cffabe/">Golang: Here We Go(1.安装&&脚本)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d740c2ec/">Golang: Here We Go(0.Google工程师介绍)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/590c21ce/">V-skills 专栏指南</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df51d2c/">技巧: Hexo 置顶问题解决</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4111adcd/">技巧: WordPress 迁移&备份技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d61966e4/">略懂: Nginx 折腾</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/12cc604a/">技巧: WordPress upload 最终解决方案</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/173f9602/">技术: 深耕 Docker 生态圈(十一){Docker 实践}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5ac3e07f/">技巧: Wordpress 网页(h5) mp4 兼容问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/65a942dd/">技术: 深耕 Docker 生态圈(十一){Docker 三剑客}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a30c0f5f/">技术: 深耕 Docker 生态圈(十){私有仓库配置}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c73a742c/">技术: 深耕 Docker 生态圈(九){Docker 数据管理}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/19c3a85f/">技术: 深耕 Docker 生态圈(八){Docker 网络部分}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b3512db9/">技术: 深耕 Docker 生态圈(七){Docker 的底层实现}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cd70a238/">技术: 深耕 Docker 生态圈(六){Dockerfile 文法}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/36bc3b47/">技术: 深耕 Docker 生态圈(五){自己构建的镜像为何这么大}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cb3fb6f1/">技术: 深耕 Docker 生态圈(四){镜像存储在哪}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e0391b88/">技术: 深耕 Docker 生态圈(三){Docker 指令}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8abfca36/">技术: 深耕 Docker 生态圈(二){配置 Docker }</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70ca69ad/">技术: 深耕 Docker 生态圈(一){总起:安装环境}</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9724f8c0/">传送门(Gate)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/683530b4/">略懂: Docker 镜像与容器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ab11b0d1/">略懂: 软件架构模式</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e1b58964/">技术: Sqlite 主键自增(Python接口)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/121fc86a/">技巧: 迁移博客到 VPS (借助hook)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/337aa775/">略懂: 我所认识的 Nodejs</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f8bb990d/">技巧: iOS 原生客户端配置 Gmail</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ecd9f8c2/">略懂: 前端相关的缓存技术</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9b49ffe2/">Golang: 深入探究 Golang 并发</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5009ef69/">技巧: macOS 录屏保存为 gif 格式</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/85a160b/">技巧: Numbers(一)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d3fb236/">Golang: Golang 代码走廊</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/16ca5b11/">技巧: Git 多账户工作技巧</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7fcc01c2/">技巧: macOs下Qt的Mysql驱动处理</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e1b7f878/">技术: Qt 汇总篇</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/15783ed7/">技巧：Makefile相关</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ad67147c/">技巧: HEXO优雅操作</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aa213556/">技巧: macOS中替换rm命令</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ef21388e/">技术: 股票分析客户端分析与实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/38fb8eb9/">技术: 网络编程部分汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a7d41a1/">技术: C++最终篇</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ba598705/">技术: Emacs环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3549e702/">技术: Deepin Linux环境配置</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1345f1a4/">技术: 网络吞吐量测试</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/65b929a8/">技术: 浅谈我经历的敏捷</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8804d39c/">技术: 网络开发常用工具</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6acc3344/">技术: Thrift</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8276c32/">技术: rapid-json</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/17d1767e/">技术: Rapid Xml</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/7d13442/">技术: Protocol buffer</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/140bfd50/">技术: Gtest测试框架</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/247b42a4/">技术: 多线程调试问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d48acbe2/">技术: TDD 开发模式实践</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/47fb15b8/">技术: 一个HTTPd的简单实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c62cfa29/">技术: C++网络库(轮子)大杂烩</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9d5b3554/">技术: Asio 异步IO库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e5af6e18/">技术: Boost库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3cd43f14/">技术: Unix Domain Socket</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/87cd3741/">技术: 百万连接问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1d57da8b/">技术: C++ 实现线程池模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/6b518c8a/">技术: 服务端网络模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e42d6398/">技术: UDP 模型网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/224e60da/">技术: TCP 模型网络编程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/df7a2188/">技术: TCP流解析(粘包和拆包问题)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1334152b/">技术: Epoll 模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8967f437/">技术: Linux 基础套接字模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/81fba862/">技术: Linux网络学习参考</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a4602dea/">技术: Linux网络IO模型</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cf64f3cd/">技术: Shell代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/33327382/">技术: 开源协议</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be94ecde/">技术: Git 代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1a10be5a/">技术: Python代码规范</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/cc8315f3/">技术: 高质量Git工作</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/3a357315/">技术: Python语言</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/82524a2d/">技术: Qt 网络编程案例汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a46fcd49/">技术: Qt 线程案例汇总</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e3b79a82/">技巧: linux下查看二进制文件</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5d0a2cfa/">技术: Qt 实践(汽车销量管理)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/77d8483b/">技巧: Qt 快捷键</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/75110831/">技术: JNI</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/fdc9b2b9/">技术: C++编程之time问题总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6ff0a80/">技术: C++11 Lambda 再探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b84fe139/">技术: 对比 Linux 下并发库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/322ce852/">技术: C++11 特性补充</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/189d21c8/">技术: benchmark(lambda 和 bind)</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/97d0104d/">技术: C++11 可调用对象function总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d12695b6/">技术: C++11 std::ref 总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b43344a7/">技术: C++ 智能指针实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4ead806a/">技术: C++11 Bind 探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/9ef88011/">技术: C++ RAII 相关技术总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bb36bf0d/">技术: C++11 Lambda 探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4b19001a/">技术: Linux Bin Utils</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/31dce1ea/">技术: C++ 智能指针</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/88802625/">技术: Linux 静态&动态库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/ab21303c/">技术: C++11 并发库</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/bc67b8cb/">技术: 探究一下STL常用算法</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/640d4b5f/">技术: Linux 编程三大件儿</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/24da8a94/">技术: C++ 迭代器失效问题</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e53c44b8/">技术: C++ 标准库 STL</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f4144d45/">技术: C++非面向对象部分</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f8283c77/">技术: C++面向对象部分</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/be09a73/">技术: 设计模式 C++ 实现</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/956ee661/">技术: mysql-connector-cpp</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b0dbc55e/">技术: 带有移动语义的 C++ 字符串类</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/f306f9f9/">技术: C++11 右值相关问题探讨</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e9705375/">技术: C++11 类型萃取</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/d93a00e8/">技术: C++11 异常争论</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b7fe58b8/">技术: C++11 模板别名探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/72ae9d55/">技术: C++11 默认函数问题探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a8af70c7/">技术: C++11 auto和decltype总结</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/c8bce253/">技术: Java中正则表达式支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/866a6247/">技术: Python中正则表达式的支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/8ebc387/">技术: C++中正则表达式的支持</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/50c77f46/">技术: C语言中正则表达式的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/aea53521/">技术: C++11 tuple 容器</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/656a02b/">技术: C++11 hashtable 结构</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/4bb5bf03/">技术: C++11 一致性初始化探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/e6f297fb/">技术: C++11 RangeFor探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/70b6b9e7/">技术: C++11 explicit注意事项</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/919162f1/">技术: C++11 nullptr探究</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/b744aae/">技术: C++11变长参数模板</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/5f4ce2b/">技术: 探究 Linux 线程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1312cbe7/">技术: 探究 Linux 进程</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/1d2bfb39/">技术: Posix标准一览</a></li><li class="post-list-item"><a class="post-list-link" href="/posts/a00e5a90/">隐修者(里程碑)</a></li></ul>




    <script>
        
            yiliaConfig.fancybox = false;
        
    </script>
</div>
      <footer id="footer">
    <div class="outer">
        <div id="footer-info">
            <div class="footer-left">
                <i class="fa fa-copyright"></i> 
                2015-2018 &nbsp Merlin
            </div>
            <div class="footer-right">
                 blog&nbsp<b>version: </b> &nbsp<a href= "https://github.com/WizardMerlin/Gate#blog版本分支说明" >2.4</a>    <i class="fa fa-heart animated infinite pulse"></i>&nbsp高效流
            </div>
        </div>
        
            <div class="visit">
                
                    <span id="busuanzi_container_site_pv" style='display:none'>
                        <span id="site-visit" title="本站到访数"><i class="fa fa-user" aria-hidden="true"></i><span id="busuanzi_value_site_uv"></span>
                        </span>
                    </span>
                
                
                    <span>| </span>
                
                
                    <span id="busuanzi_container_page_pv" style='display:none'>
                        <span id="page-visit"  title="本页阅读量"><i class="fa fa-eye animated infinite pulse" aria-hidden="true"></i><span id="busuanzi_value_page_pv"></span>
                        </span>
                    </span>
                
            </div>
        
    </div>
</footer>
    </div>
    
    <script src="/js/GithubRepoWidget.js"></script>

<script data-main="/js/main.js" src="//cdn.bootcss.com/require.js/2.2.0/require.min.js"></script>

    <script>
        $(document).ready(function() {
            var iPad = window.navigator.userAgent.indexOf('iPad');
            if (iPad > -1 || $(".left-col").css("display") === "none") {
                var bgColorList = ["#9db3f4", "#414141", "#e5a859", "#f5dfc6", "#c084a0", "#847e72", "#cd8390", "#996731"];
                var bgColor = Math.ceil(Math.random() * (bgColorList.length - 1));
                $("body").css({"background-color": bgColorList[bgColor], "background-size": "cover"});
            }
            else {
                var backgroundnum = 1;
                var backgroundimg = "url(/background/bg-x.jpg)".replace(/x/gi, Math.ceil(Math.random() * backgroundnum));
                $("body").css({"background": backgroundimg, "background-attachment": "fixed", "background-size": "cover"});
            }
        })
    </script>



<!-- Google Analytics -->
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-110654443-1', 'auto');
ga('send', 'pageview');

</script>
<!-- End Google Analytics -->



<div class="scroll" id="scroll">
    <a href="#" title="返回顶部"><i class="fa fa-arrow-up"></i></a>
    <a href="#comments" onclick="load$hide();" title="查看评论"><i class="fa fa-comments-o"></i></a>
    <a href="#footer" title="转到底部"><i class="fa fa-arrow-down"></i></a>
</div>
<script>
    // Open in New Window
    
        var oOpenInNew = {
             github: ".github-widget a", 
            
            
            
            
            
             archives: ".archive-article-title", 
             miniArchives: "a.post-list-link", 
            
             friends: "#js-friends a", 
             socail: ".social a" 
        }
        for (var x in oOpenInNew) {
            $(oOpenInNew[x]).attr("target", "_blank");
        }
    
</script>

    <script>
        var originTitle = document.title;
        var titleTime;
        document.addEventListener("visibilitychange", function() {
            if (document.hidden) {
                document.title = "Do One Thing......" + originTitle;
                clearTimeout(titleTime);
            }
            else {
                document.title = "Do It Well......" + originTitle;
                titleTime = setTimeout(function() {
                    document.title = originTitle;
                }, 2000);
            }
        })
    </script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>
  </div>
</body>
</html>